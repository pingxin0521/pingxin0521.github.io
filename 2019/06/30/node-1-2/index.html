<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Node.JS 深入 | 平心de小屋</title><meta name="keywords" content="Node.JS,后端"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Node.js 常用工具util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。">
<meta property="og:type" content="article">
<meta property="og:title" content="Node.JS 深入">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/06/30/node-1-2/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="Node.js 常用工具util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg">
<meta property="article:published_time" content="2019-06-30T10:18:59.000Z">
<meta property="article:modified_time" content="2021-05-09T07:21:19.480Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="Node.JS">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/06/30/node-1-2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Node.JS 深入',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-09 15:21:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Node.JS 深入</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-06-30T10:18:59.000Z" title="发表于 2019-06-30 18:18:59">2019-06-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-09T07:21:19.480Z" title="更新于 2021-05-09 15:21:19">2021-05-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/Node-JS/">Node.JS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Node.JS 深入"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="Node-js-常用工具"><a href="#Node-js-常用工具" class="headerlink" title="Node.js 常用工具"></a>Node.js 常用工具</h4><p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。</p>
<span id="more"></span>

<h5 id="util-inherits"><a href="#util-inherits" class="headerlink" title="util.inherits"></a>util.inherits</h5><p><strong>util.inherits(constructor, superConstructor)</strong> 是一个实现对象间原型继承的函数。</p>
<p>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有提供对象继承的语言级别特性，而是通过原型复制来实现的。</p>
<p>在这里我们只介绍 util.inherits 的用法，示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;name&#x27;</span>;</span><br><span class="line">        <span class="built_in">this</span>.base = <span class="number">1995</span>;</span><br><span class="line">        <span class="built_in">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;hello &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;sub&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">util.inherits(sub, Base);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baseObj = <span class="keyword">new</span> Base();</span><br><span class="line"><span class="built_in">console</span>.log(baseObj);</span><br><span class="line">baseObj.showName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subObj = <span class="keyword">new</span> sub();</span><br><span class="line"><span class="built_in">console</span>.log(subObj);</span><br><span class="line"><span class="built_in">console</span>.log(subObj.name);</span><br><span class="line">subObj.showName();</span><br></pre></td></tr></table></figure>

<p>我们定义了一个基础对象 Base 和一个继承自 Base 的 Sub，Base 有三个在构造函数内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承。运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base &#123; name: &#x27;name&#x27;, base: 1995, sayHello: [Function] &#125;</span><br><span class="line">name</span><br><span class="line">sub &#123; name: &#x27;sub&#x27; &#125;</span><br><span class="line">sub</span><br><span class="line">sub</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。</p>
<h5 id="util-inspect"><a href="#util-inspect" class="headerlink" title="util.inspect"></a>util.inspect</h5><p><strong>util.inspect(object,[showHidden],[depth],[colors])</strong> 是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。</p>
<p>showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。</p>
<p>depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。</p>
<p>特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了 toString 方法也不会调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var util = require(&#x27;util&#x27;); </span><br><span class="line">function Person() &#123; </span><br><span class="line">    this.name = &#x27;byvoid&#x27;; </span><br><span class="line">    this.toString = function() &#123; </span><br><span class="line">    return this.name; </span><br><span class="line">    &#125;; </span><br><span class="line">&#125; </span><br><span class="line">var obj = new Person(); </span><br><span class="line">console.log(util.inspect(obj)); </span><br><span class="line">console.log(util.inspect(obj, true)); </span><br></pre></td></tr></table></figure>

<p>运行结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person &#123; name: &#x27;byvoid&#x27;, toString: [Function] &#125;</span><br><span class="line">Person &#123;</span><br><span class="line">  name: &#x27;byvoid&#x27;,</span><br><span class="line">  toString:</span><br><span class="line">   &#123; [Function]</span><br><span class="line">     [length]: 0,</span><br><span class="line">     [name]: &#x27;&#x27;,</span><br><span class="line">     [arguments]: null,</span><br><span class="line">     [caller]: null,</span><br><span class="line">     [prototype]: &#123; [constructor]: [Circular] &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>更多详情可以访问 <a target="_blank" rel="noopener" href="http://nodejs.cn/api/util.html">http://nodejs.cn/api/util.html</a> 了解详细内容。</p>
<h4 id="Node-js-文件系统"><a href="#Node-js-文件系统" class="headerlink" title="Node.js 文件系统"></a>Node.js 文件系统</h4><p>Node.js 提供一组类似 UNIX（POSIX）标准的文件操作API。 Node 导入文件系统模块(fs)语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>异步和同步</strong></p>
<p>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。</p>
<p>异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。</p>
<p>建议大家使用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。</p>
<p>创建 input.txt 文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">平心地址：https://hanyunpeng0521.github.io</span><br><span class="line">文件读取实例</span><br></pre></td></tr></table></figure>

<p>创建 file.js 文件, 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">// 异步读取</span><br><span class="line">fs.readFile(&#x27;input.txt&#x27;, function (err, data) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;异步读取: &quot; + data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 同步读取</span><br><span class="line">var data = fs.readFileSync(&#x27;input.txt&#x27;);</span><br><span class="line">console.log(&quot;同步读取: &quot; + data.toString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;程序执行完毕。&quot;);</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">平心地址：https://hanyunpeng0521.github.io</span><br><span class="line">文件读取实例</span><br><span class="line"></span><br><span class="line">程序执行完毕。</span><br><span class="line">平心地址：https://hanyunpeng0521.github.io</span><br><span class="line">文件读取实例</span><br></pre></td></tr></table></figure>

<p>接下来，让我们来具体了解下 Node.js 文件系统的方法。</p>
<p><strong>打开文件</strong></p>
<p>以下为在异步模式下打开文件的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.open(path, flags[, mode], callback)</span><br></pre></td></tr></table></figure>

<p>参数使用说明如下：</p>
<ul>
<li><strong>path</strong> - 文件的路径。</li>
<li><strong>flags</strong> - 文件打开的行为。具体值详见下文。</li>
<li><strong>mode</strong> - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。</li>
<li><strong>callback</strong> - 回调函数，带有两个参数如：callback(err, fd)。</li>
</ul>
<p>flags 参数可以是以下值：</p>
<table>
<thead>
<tr>
<th align="left">Flag</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="left">以读取模式打开文件。如果文件不存在抛出异常。</td>
</tr>
<tr>
<td align="left">r+</td>
<td align="left">以读写模式打开文件。如果文件不存在抛出异常。</td>
</tr>
<tr>
<td align="left">rs</td>
<td align="left">以同步的方式读取文件。</td>
</tr>
<tr>
<td align="left">rs+</td>
<td align="left">以同步的方式读取和写入文件。</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">以写入模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td align="left">wx</td>
<td align="left">类似 ‘w’，但是如果文件路径存在，则文件写入失败。</td>
</tr>
<tr>
<td align="left">w+</td>
<td align="left">以读写模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td align="left">wx+</td>
<td align="left">类似 ‘w+’， 但是如果文件路径存在，则文件读写失败。</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">以追加模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td align="left">ax</td>
<td align="left">类似 ‘a’， 但是如果文件路径存在，则文件追加失败。</td>
</tr>
<tr>
<td align="left">a+</td>
<td align="left">以读取追加模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td align="left">ax+</td>
<td align="left">类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。</td>
</tr>
</tbody></table>
<p>接下来我们创建 file.js 文件，并打开 input.txt 文件进行读写，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">// 异步打开文件</span><br><span class="line">console.log(&quot;准备打开文件！&quot;);</span><br><span class="line">fs.open(&#x27;input.txt&#x27;, &#x27;r+&#x27;, function(err, fd) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">  console.log(&quot;文件打开成功！&quot;);     </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备打开文件！</span><br><span class="line">文件打开成功！</span><br></pre></td></tr></table></figure>

<p><strong>获取文件信息</strong></p>
<p>以下为通过异步模式获取文件信息的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.stat(path, callback)</span><br></pre></td></tr></table></figure>

<p>参数使用说明如下：</p>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，带有两个参数如：(err, stats), <strong>stats</strong> 是 fs.Stats 对象。</li>
</ul>
<p>fs.stat(path)执行后，会将stats类的实例返回给其回调函数。可以通过stats类中的提供方法判断文件的相关属性。例如判断是否为文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">fs.stat(&#x27;/Users/liuht/code/itbilu/demo/fs.js&#x27;, function (err, stats) &#123;</span><br><span class="line">    console.log(stats.isFile());         //true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>stats类中的方法有：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">stats.isFile()</td>
<td align="left">如果是文件返回 true，否则返回 false。</td>
</tr>
<tr>
<td align="left">stats.isDirectory()</td>
<td align="left">如果是目录返回 true，否则返回 false。</td>
</tr>
<tr>
<td align="left">stats.isBlockDevice()</td>
<td align="left">如果是块设备返回 true，否则返回 false。</td>
</tr>
<tr>
<td align="left">stats.isCharacterDevice()</td>
<td align="left">如果是字符设备返回 true，否则返回 false。</td>
</tr>
<tr>
<td align="left">stats.isSymbolicLink()</td>
<td align="left">如果是软链接返回 true，否则返回 false。</td>
</tr>
<tr>
<td align="left">stats.isFIFO()</td>
<td align="left">如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。</td>
</tr>
<tr>
<td align="left">stats.isSocket()</td>
<td align="left">如果是 Socket 返回 true，否则返回 false。</td>
</tr>
</tbody></table>
<p>接下来我们创建 file.js 文件，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备打开文件！&quot;);</span><br><span class="line">fs.stat(&#x27;input.txt&#x27;, function (err, stats) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(stats);</span><br><span class="line">   console.log(&quot;读取文件信息成功！&quot;);</span><br><span class="line">   </span><br><span class="line">   // 检测文件类型</span><br><span class="line">   console.log(&quot;是否为文件(isFile) ? &quot; + stats.isFile());</span><br><span class="line">   console.log(&quot;是否为目录(isDirectory) ? &quot; + stats.isDirectory());    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备打开文件！</span><br><span class="line">&#123; dev: 16777220,</span><br><span class="line">  mode: 33188,</span><br><span class="line">  nlink: 1,</span><br><span class="line">  uid: 501,</span><br><span class="line">  gid: 20,</span><br><span class="line">  rdev: 0,</span><br><span class="line">  blksize: 4096,</span><br><span class="line">  ino: 40333161,</span><br><span class="line">  size: 61,</span><br><span class="line">  blocks: 8,</span><br><span class="line">  atime: Mon Sep 07 2015 17:43:55 GMT+0800 (CST),</span><br><span class="line">  mtime: Mon Sep 07 2015 17:22:35 GMT+0800 (CST),</span><br><span class="line">  ctime: Mon Sep 07 2015 17:22:35 GMT+0800 (CST) &#125;</span><br><span class="line">读取文件信息成功！</span><br><span class="line">是否为文件(isFile) ? true</span><br><span class="line">是否为目录(isDirectory) ? false</span><br></pre></td></tr></table></figure>

<p><strong>写入文件</strong></p>
<p>以下为异步模式下写入文件的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(file, data[, options], callback)</span><br></pre></td></tr></table></figure>

<p>writeFile 直接打开文件默认是 <strong>w</strong> 模式，所以如果文件存在，该方法写入的内容会覆盖旧的文件内容。</p>
<p>参数使用说明如下：</p>
<ul>
<li><strong>file</strong> - 文件名或文件描述符。</li>
<li><strong>data</strong> - 要写入文件的数据，可以是 String(字符串) 或 Buffer(缓冲) 对象。</li>
<li><strong>options</strong> - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 ‘w’</li>
<li><strong>callback</strong> - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。</li>
</ul>
<p>接下来我们创建 file.js 文件，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备写入文件&quot;);</span><br><span class="line">fs.writeFile(&#x27;input.txt&#x27;, &#x27;我是通 过fs.writeFile 写入文件的内容&#x27;,  function(err) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;数据写入成功！&quot;);</span><br><span class="line">   console.log(&quot;--------我是分割线-------------&quot;)</span><br><span class="line">   console.log(&quot;读取写入的数据！&quot;);</span><br><span class="line">   fs.readFile(&#x27;input.txt&#x27;, function (err, data) &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">         return console.error(err);</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&quot;异步读取文件数据: &quot; + data.toString());</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备写入文件</span><br><span class="line">数据写入成功！</span><br><span class="line">--------我是分割线-------------</span><br><span class="line">读取写入的数据！</span><br><span class="line">异步读取文件数据: 我是通 过fs.writeFile 写入文件的内容</span><br></pre></td></tr></table></figure>

<p><strong>读取文件</strong></p>
<p>以下为异步模式下读取文件的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.read(fd, buffer, offset, length, position, callback)</span><br></pre></td></tr></table></figure>

<p>该方法使用了文件描述符来读取文件。</p>
<p>参数使用说明如下：</p>
<ul>
<li><strong>fd</strong> - 通过 fs.open() 方法返回的文件描述符。</li>
<li><strong>buffer</strong> - 数据写入的缓冲区。</li>
<li><strong>offset</strong> - 缓冲区写入的写入偏移量。</li>
<li><strong>length</strong> - 要从文件中读取的字节数。</li>
<li><strong>position</strong> - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。</li>
<li><strong>callback</strong> - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。</li>
</ul>
<p>input.txt 文件内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平心地址：https://hanyunpeng0521.github.io</span><br></pre></td></tr></table></figure>

<p>接下来我们创建 file.js 文件，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var buf = new Buffer.alloc(1024);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备打开已存在的文件！&quot;);</span><br><span class="line">fs.open(&#x27;input.txt&#x27;, &#x27;r+&#x27;, function(err, fd) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;文件打开成功！&quot;);</span><br><span class="line">   console.log(&quot;准备读取文件：&quot;);</span><br><span class="line">   fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123;</span><br><span class="line">      if (err)&#123;</span><br><span class="line">         console.log(err);</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(bytes + &quot;  字节被读取&quot;);</span><br><span class="line">      </span><br><span class="line">      // 仅输出读取的字节</span><br><span class="line">      if(bytes &gt; 0)&#123;</span><br><span class="line">         console.log(buf.slice(0, bytes).toString());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备打开已存在的文件！</span><br><span class="line">文件打开成功！</span><br><span class="line">准备读取文件：</span><br><span class="line">66  字节被读取</span><br><span class="line">平心地址：https://hanyunpeng0521.github.io</span><br></pre></td></tr></table></figure>

<p><strong>关闭文件</strong></p>
<p>以下为异步模式下关闭文件的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.close(fd, callback)</span><br></pre></td></tr></table></figure>

<p>该方法使用了文件描述符来读取文件。</p>
<p>参数使用说明如下：</p>
<ul>
<li><strong>fd</strong> - 通过 fs.open() 方法返回的文件描述符。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<p>input.txt 文件内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平心地址：https://hanyunpeng0521.github.io</span><br></pre></td></tr></table></figure>

<p>接下来我们创建 file.js 文件，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var buf = new Buffer.alloc(1024);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备打开文件！&quot;);</span><br><span class="line">fs.open(&#x27;input.txt&#x27;, &#x27;r+&#x27;, function(err, fd) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;文件打开成功！&quot;);</span><br><span class="line">   console.log(&quot;准备读取文件！&quot;);</span><br><span class="line">   fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123;</span><br><span class="line">      if (err)&#123;</span><br><span class="line">         console.log(err);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 仅输出读取的字节</span><br><span class="line">      if(bytes &gt; 0)&#123;</span><br><span class="line">         console.log(buf.slice(0, bytes).toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 关闭文件</span><br><span class="line">      fs.close(fd, function(err)&#123;</span><br><span class="line">         if (err)&#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">         &#125; </span><br><span class="line">         console.log(&quot;文件关闭成功&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备打开文件！</span><br><span class="line">文件打开成功！</span><br><span class="line">准备读取文件！</span><br><span class="line">平心地址：https://hanyunpeng0521.github.io</span><br><span class="line">文件关闭成功</span><br></pre></td></tr></table></figure>

<p><strong>截取文件</strong></p>
<p>以下为异步模式下截取文件的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.ftruncate(fd, len, callback)</span><br></pre></td></tr></table></figure>

<p>该方法使用了文件描述符来读取文件。</p>
<p>参数使用说明如下：</p>
<ul>
<li><strong>fd</strong> - 通过 fs.open() 方法返回的文件描述符。</li>
<li><strong>len</strong> - 文件内容截取的长度。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<p>input.txt 文件内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平心地址：https://hanyunpeng0521.github.io</span><br></pre></td></tr></table></figure>

<p>接下来我们创建 file.js 文件，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var buf = new Buffer.alloc(1024);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备打开文件！&quot;);</span><br><span class="line">fs.open(&#x27;input.txt&#x27;, &#x27;r+&#x27;, function(err, fd) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;文件打开成功！&quot;);</span><br><span class="line">   console.log(&quot;截取10字节内的文件内容，超出部分将被去除。&quot;);</span><br><span class="line">   </span><br><span class="line">   // 截取文件</span><br><span class="line">   fs.ftruncate(fd, 10, function(err)&#123;</span><br><span class="line">      if (err)&#123;</span><br><span class="line">         console.log(err);</span><br><span class="line">      &#125; </span><br><span class="line">      console.log(&quot;文件截取成功。&quot;);</span><br><span class="line">      console.log(&quot;读取相同的文件&quot;); </span><br><span class="line">      fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123;</span><br><span class="line">         if (err)&#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // 仅输出读取的字节</span><br><span class="line">         if(bytes &gt; 0)&#123;</span><br><span class="line">            console.log(buf.slice(0, bytes).toString());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // 关闭文件</span><br><span class="line">         fs.close(fd, function(err)&#123;</span><br><span class="line">            if (err)&#123;</span><br><span class="line">               console.log(err);</span><br><span class="line">            &#125; </span><br><span class="line">            console.log(&quot;文件关闭成功！&quot;);</span><br><span class="line">         &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备打开文件！</span><br><span class="line">文件打开成功！</span><br><span class="line">截取10字节内的文件内容，超出部分将被去除。</span><br><span class="line">文件截取成功。</span><br><span class="line">读取相同的文件</span><br><span class="line">...</span><br><span class="line">文件关闭成功</span><br></pre></td></tr></table></figure>

<p><strong>删除文件</strong></p>
<p>以下为删除文件的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.unlink(path, callback)</span><br></pre></td></tr></table></figure>

<p>参数使用说明如下：</p>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<p>input.txt 文件内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平心地址：https://hanyunpeng0521.github.io</span><br></pre></td></tr></table></figure>

<p>接下来我们创建 file.js 文件，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备删除文件！&quot;);</span><br><span class="line">fs.unlink(&#x27;input.txt&#x27;, function(err) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;文件删除成功！&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备删除文件！</span><br><span class="line">文件删除成功！</span><br></pre></td></tr></table></figure>

<p>再去查看 input.txt 文件，发现已经不存在了。</p>
<p><strong>创建目录</strong></p>
<p>以下为创建目录的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.mkdir(path[, options], callback)</span><br></pre></td></tr></table></figure>

<p>参数使用说明如下：</p>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li>options 参数可以是：<ul>
<li><strong>recursive</strong> - 是否以递归的方式创建目录，默认为 false。</li>
<li><strong>mode</strong> - 设置目录权限，默认为 0777。</li>
</ul>
</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<p>接下来我们创建 file.js 文件，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">// tmp 目录必须存在</span><br><span class="line">console.log(&quot;创建目录 /tmp/test/&quot;);</span><br><span class="line">fs.mkdir(&quot;/tmp/test/&quot;,function(err)&#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;目录创建成功。&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">创建目录 /tmp/test/</span><br><span class="line">目录创建成功。</span><br></pre></td></tr></table></figure>

<p>可以添加 recursive: true 参数，不管创建的目录 /tmp 和 /tmp/a 是否存在：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.mkdir(&#x27;/tmp/a/apple&#x27;, &#123; recursive: true &#125;, (err) =&gt; &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>读取目录</strong></p>
<p>以下为读取目录的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readdir(path, callback)</span><br></pre></td></tr></table></figure>

<p>参数使用说明如下：</p>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。</li>
</ul>
<p>接下来我们创建 file.js 文件，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;查看 /tmp 目录&quot;);</span><br><span class="line">fs.readdir(&quot;/tmp/&quot;,function(err, files)&#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   files.forEach( function (file)&#123;</span><br><span class="line">       console.log( file );</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">查看 /tmp 目录</span><br><span class="line">input.out</span><br><span class="line">output.out</span><br><span class="line">test</span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure>

<p><strong>删除目录</strong></p>
<p>以下为删除目录的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.rmdir(path, callback)</span><br></pre></td></tr></table></figure>

<p>参数使用说明如下：</p>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<p>接下来我们创建 file.js 文件，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">// 执行前创建一个空的 /tmp/test 目录</span><br><span class="line">console.log(&quot;准备删除目录 /tmp/test&quot;);</span><br><span class="line">fs.rmdir(&quot;/tmp/test&quot;,function(err)&#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;读取 /tmp 目录&quot;);</span><br><span class="line">   fs.readdir(&quot;/tmp/&quot;,function(err, files)&#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">          return console.error(err);</span><br><span class="line">      &#125;</span><br><span class="line">      files.forEach( function (file)&#123;</span><br><span class="line">          console.log( file );</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备删除目录 /tmp/test</span><br><span class="line">读取 /tmp 目录</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>以下为 Node.js 文件模块相同的方法列表：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>fs.rename(oldPath, newPath, callback)</strong> 异步 rename().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>fs.ftruncate(fd, len, callback)</strong> 异步 ftruncate().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>fs.ftruncateSync(fd, len)</strong> 同步 ftruncate()</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>fs.truncate(path, len, callback)</strong> 异步 truncate().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>fs.truncateSync(path, len)</strong> 同步 truncate()</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>fs.chown(path, uid, gid, callback)</strong> 异步 chown().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>fs.chownSync(path, uid, gid)</strong> 同步 chown()</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>fs.fchown(fd, uid, gid, callback)</strong> 异步 fchown().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>fs.fchownSync(fd, uid, gid)</strong> 同步 fchown()</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>fs.lchown(path, uid, gid, callback)</strong> 异步 lchown().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>fs.lchownSync(path, uid, gid)</strong> 同步 lchown()</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>fs.chmod(path, mode, callback)</strong> 异步 chmod().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>fs.chmodSync(path, mode)</strong> 同步 chmod().</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><strong>fs.fchmod(fd, mode, callback)</strong> 异步 fchmod().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><strong>fs.fchmodSync(fd, mode)</strong> 同步 fchmod().</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><strong>fs.lchmod(path, mode, callback)</strong> 异步 lchmod().回调函数没有参数，但可能抛出异常。Only available on Mac OS X.</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><strong>fs.lchmodSync(path, mode)</strong> 同步 lchmod().</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><strong>fs.stat(path, callback)</strong> 异步 stat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><strong>fs.lstat(path, callback)</strong> 异步 lstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><strong>fs.fstat(fd, callback)</strong> 异步 fstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><strong>fs.statSync(path)</strong> 同步 stat(). 返回 fs.Stats 的实例。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><strong>fs.lstatSync(path)</strong> 同步 lstat(). 返回 fs.Stats 的实例。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><strong>fs.fstatSync(fd)</strong> 同步 fstat(). 返回 fs.Stats 的实例。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><strong>fs.link(srcpath, dstpath, callback)</strong> 异步 link().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><strong>fs.linkSync(srcpath, dstpath)</strong> 同步 link().</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left"><strong>fs.symlink(srcpath, dstpath[, type], callback)</strong> 异步 symlink().回调函数没有参数，但可能抛出异常。 type 参数可以设置为 ‘dir’, ‘file’, 或 ‘junction’ (默认为 ‘file’) 。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><strong>fs.symlinkSync(srcpath, dstpath[, type])</strong> 同步 symlink().</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left"><strong>fs.readlink(path, callback)</strong> 异步 readlink(). 回调函数有两个参数 err, linkString。</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left"><strong>fs.realpath(path[, cache], callback)</strong> 异步 realpath(). 回调函数有两个参数 err, resolvedPath。</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left"><strong>fs.realpathSync(path[, cache])</strong> 同步 realpath()。返回绝对路径。</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left"><strong>fs.unlink(path, callback)</strong> 异步 unlink().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td align="left">32</td>
<td align="left"><strong>fs.unlinkSync(path)</strong> 同步 unlink().</td>
</tr>
<tr>
<td align="left">33</td>
<td align="left"><strong>fs.rmdir(path, callback)</strong> 异步 rmdir().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td align="left">34</td>
<td align="left"><strong>fs.rmdirSync(path)</strong> 同步 rmdir().</td>
</tr>
<tr>
<td align="left">35</td>
<td align="left"><strong>fs.mkdir(path[, mode], callback)</strong> S异步 mkdir(2).回调函数没有参数，但可能抛出异常。 访问权限默认为 0777。</td>
</tr>
<tr>
<td align="left">36</td>
<td align="left"><strong>fs.mkdirSync(path[, mode])</strong> 同步 mkdir().</td>
</tr>
<tr>
<td align="left">37</td>
<td align="left"><strong>fs.readdir(path, callback)</strong> 异步 readdir(3). 读取目录的内容。</td>
</tr>
<tr>
<td align="left">38</td>
<td align="left"><strong>fs.readdirSync(path)</strong> 同步 readdir().返回文件数组列表。</td>
</tr>
<tr>
<td align="left">39</td>
<td align="left"><strong>fs.close(fd, callback)</strong> 异步 close().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td align="left">40</td>
<td align="left"><strong>fs.closeSync(fd)</strong> 同步 close().</td>
</tr>
<tr>
<td align="left">41</td>
<td align="left"><strong>fs.open(path, flags[, mode], callback)</strong> 异步打开文件。</td>
</tr>
<tr>
<td align="left">42</td>
<td align="left"><strong>fs.openSync(path, flags[, mode])</strong> 同步 version of fs.open().</td>
</tr>
<tr>
<td align="left">43</td>
<td align="left"><strong>fs.utimes(path, atime, mtime, callback)</strong></td>
</tr>
<tr>
<td align="left">44</td>
<td align="left"><strong>fs.utimesSync(path, atime, mtime)</strong> 修改文件时间戳，文件通过指定的文件路径。</td>
</tr>
<tr>
<td align="left">45</td>
<td align="left"><strong>fs.futimes(fd, atime, mtime, callback)</strong></td>
</tr>
<tr>
<td align="left">46</td>
<td align="left"><strong>fs.futimesSync(fd, atime, mtime)</strong> 修改文件时间戳，通过文件描述符指定。</td>
</tr>
<tr>
<td align="left">47</td>
<td align="left"><strong>fs.fsync(fd, callback)</strong> 异步 fsync.回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td align="left">48</td>
<td align="left"><strong>fs.fsyncSync(fd)</strong> 同步 fsync.</td>
</tr>
<tr>
<td align="left">49</td>
<td align="left"><strong>fs.write(fd, buffer, offset, length[, position], callback)</strong> 将缓冲区内容写入到通过文件描述符指定的文件。</td>
</tr>
<tr>
<td align="left">50</td>
<td align="left"><strong>fs.write(fd, data[, position[, encoding]], callback)</strong> 通过文件描述符 fd 写入文件内容。</td>
</tr>
<tr>
<td align="left">51</td>
<td align="left"><strong>fs.writeSync(fd, buffer, offset, length[, position])</strong> 同步版的 fs.write()。</td>
</tr>
<tr>
<td align="left">52</td>
<td align="left"><strong>fs.writeSync(fd, data[, position[, encoding]])</strong> 同步版的 fs.write().</td>
</tr>
<tr>
<td align="left">53</td>
<td align="left"><strong>fs.read(fd, buffer, offset, length, position, callback)</strong> 通过文件描述符 fd 读取文件内容。</td>
</tr>
<tr>
<td align="left">54</td>
<td align="left"><strong>fs.readSync(fd, buffer, offset, length, position)</strong> 同步版的 fs.read.</td>
</tr>
<tr>
<td align="left">55</td>
<td align="left"><strong>fs.readFile(filename[, options], callback)</strong> 异步读取文件内容。</td>
</tr>
<tr>
<td align="left">56</td>
<td align="left"><strong>fs.readFileSync(filename[, options])</strong></td>
</tr>
<tr>
<td align="left">57</td>
<td align="left"><strong>fs.writeFile(filename, data[, options], callback)</strong> 异步写入文件内容。</td>
</tr>
<tr>
<td align="left">58</td>
<td align="left"><strong>fs.writeFileSync(filename, data[, options])</strong> 同步版的 fs.writeFile。</td>
</tr>
<tr>
<td align="left">59</td>
<td align="left"><strong>fs.appendFile(filename, data[, options], callback)</strong> 异步追加文件内容。</td>
</tr>
<tr>
<td align="left">60</td>
<td align="left"><strong>fs.appendFileSync(filename, data[, options])</strong> The 同步 version of fs.appendFile.</td>
</tr>
<tr>
<td align="left">61</td>
<td align="left"><strong>fs.watchFile(filename[, options], listener)</strong> 查看文件的修改。</td>
</tr>
<tr>
<td align="left">62</td>
<td align="left"><strong>fs.unwatchFile(filename[, listener])</strong> 停止查看 filename 的修改。</td>
</tr>
<tr>
<td align="left">63</td>
<td align="left"><code>fs.watch(filename[, options][, listener]) 查看 filename 的修改，filename 可以是文件或目录。返回 fs.FSWatcher 对象。</code></td>
</tr>
<tr>
<td align="left">64</td>
<td align="left"><strong>fs.exists(path, callback)</strong> 检测给定的路径是否存在。</td>
</tr>
<tr>
<td align="left">65</td>
<td align="left"><strong>fs.existsSync(path)</strong> 同步版的 fs.exists.</td>
</tr>
<tr>
<td align="left">66</td>
<td align="left"><strong>fs.access(path[, mode], callback)</strong> 测试指定路径用户权限。</td>
</tr>
<tr>
<td align="left">67</td>
<td align="left"><strong>fs.accessSync(path[, mode])</strong> 同步版的 fs.access。</td>
</tr>
<tr>
<td align="left">68</td>
<td align="left"><strong>fs.createReadStream(path[, options])</strong> 返回ReadStream 对象。</td>
</tr>
<tr>
<td align="left">69</td>
<td align="left"><strong>fs.createWriteStream(path[, options])</strong> 返回 WriteStream 对象。</td>
</tr>
<tr>
<td align="left">70</td>
<td align="left"><strong>fs.symlink(srcpath, dstpath[, type], callback)</strong> 异步 symlink().回调函数没有参数，但可能抛出异常。</td>
</tr>
</tbody></table>
<p>更多内容，请查看官网文件模块描述：<a target="_blank" rel="noopener" href="http://nodejs.cn/api/fs.html">File System</a>。</p>
<h4 id="Node-js-GET-POST请求"><a href="#Node-js-GET-POST请求" class="headerlink" title="Node.js GET/POST请求"></a>Node.js GET/POST请求</h4><p>在很多场景中，我们的服务器都需要跟用户的浏览器打交道，如表单提交。</p>
<p>表单提交到服务器一般都使用 GET/POST 请求。</p>
<h5 id="获取GET请求内容"><a href="#获取GET请求内容" class="headerlink" title="获取GET请求内容"></a>获取GET请求内容</h5><p>由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。</p>
<p>node.js 中 url 模块中的 parse 函数提供了这个功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain; charset=utf-8&#x27;</span>&#125;);</span><br><span class="line">    res.end(util.inspect(url.parse(req.url, <span class="literal">true</span>)));</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>在浏览器中访问 <a target="_blank" rel="noopener" href="http://localhost:3000/user?name=%E5%B9%B3%E5%BF%83&amp;url=https://hanyunpeng0521.github.io">http://localhost:3000/user?name=平心&amp;url=https://hanyunpeng0521.github.io</a> 然后查看返回结果</p>
<h5 id="获取-URL-的参数"><a href="#获取-URL-的参数" class="headerlink" title="获取 URL 的参数"></a>获取 URL 的参数</h5><p>我们可以使用 url.parse 方法来解析 URL 中的参数，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html; charset=utf8&#x27;</span>&#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 解析 url 参数</span></span><br><span class="line">    <span class="keyword">var</span> params = url.parse(req.url, <span class="literal">true</span>).query;</span><br><span class="line">    res.write(<span class="string">&quot;网站名：&quot;</span> + params.name);</span><br><span class="line">    res.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    res.write(<span class="string">&quot;网站 URL：&quot;</span> + params.url);</span><br><span class="line">    res.end();</span><br><span class="line"> </span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>在浏览器中访问 <a target="_blank" rel="noopener" href="http://localhost:3000/user?name=%E5%B9%B3%E5%BF%83&amp;url=https://hanyunpeng0521.github.io">http://localhost:3000/user?name=平心&amp;url=https://hanyunpeng0521.github.io</a> 然后查看返回结果</p>
<h5 id="获取-POST-请求内容"><a href="#获取-POST-请求内容" class="headerlink" title="获取 POST 请求内容"></a>获取 POST 请求内容</h5><p>POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。</p>
<p>比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所以 node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 定义了一个post变量，用于暂存请求体的信息</span></span><br><span class="line">    <span class="keyword">var</span> post = <span class="string">&#x27;&#x27;</span>;     </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中</span></span><br><span class="line">    req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;    </span><br><span class="line">        post += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。</span></span><br><span class="line">    req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">        post = querystring.parse(post);</span><br><span class="line">        res.end(util.inspect(post));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>以下实例表单通过 POST 提交并输出数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> postHTML = </span><br><span class="line">  <span class="string">&#x27;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;示例&lt;/title&gt;&lt;/head&gt;&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;&lt;body&gt;&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;&lt;form method=&quot;post&quot;&gt;&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;网站名： &lt;input name=&quot;name&quot;&gt;&lt;br&gt;&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;网站 URL： &lt;input name=&quot;url&quot;&gt;&lt;br&gt;&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;&lt;input type=&quot;submit&quot;&gt;&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;&lt;/form&gt;&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;&lt;/body&gt;&lt;/html&gt;&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> body = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    body += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    body = querystring.parse(body);</span><br><span class="line">    <span class="comment">// 设置响应头部信息及编码</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html; charset=utf8&#x27;</span>&#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(body.name &amp;&amp; body.url) &#123; <span class="comment">// 输出提交的数据</span></span><br><span class="line">        res.write(<span class="string">&quot;网站名：&quot;</span> + body.name);</span><br><span class="line">        res.write(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">        res.write(<span class="string">&quot;网站 URL：&quot;</span> + body.url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 输出表单</span></span><br><span class="line">        res.write(postHTML);</span><br><span class="line">    &#125;</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Node-js-工具模块"><a href="#Node-js-工具模块" class="headerlink" title="Node.js 工具模块"></a>Node.js 工具模块</h4><h5 id="OS-模块"><a href="#OS-模块" class="headerlink" title="OS 模块"></a>OS 模块</h5><p>Node.js os 模块提供了一些基本的系统操作函数。我们可以通过以下方式引入该模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var os = require(&quot;os&quot;)</span><br></pre></td></tr></table></figure>

<p>方法</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>os.tmpdir()</strong> 返回操作系统的默认临时文件夹。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>os.endianness()</strong> 返回 CPU 的字节序，可能的是 “BE” 或 “LE”。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>os.hostname()</strong> 返回操作系统的主机名。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>os.type()</strong> 返回操作系统名</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>os.platform()</strong> 返回编译时的操作系统名</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>os.arch()</strong> 返回操作系统 CPU 架构，可能的值有 “x64”、”arm” 和 “ia32”。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>os.release()</strong> 返回操作系统的发行版本。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>os.uptime()</strong> 返回操作系统运行的时间，以秒为单位。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>os.loadavg()</strong> 返回一个包含 1、5、15 分钟平均负载的数组。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>os.totalmem()</strong> 返回系统内存总量，单位为字节。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>os.freemem()</strong> 返回操作系统空闲内存量，单位是字节。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>os.cpus()</strong> 返回一个对象数组，包含所安装的每个 CPU/内核的信息：型号、速度（单位 MHz）、时间（一个包含 user、nice、sys、idle 和 irq 所使用 CPU/内核毫秒数的对象）。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>os.networkInterfaces()</strong> 获得网络接口列表。</td>
</tr>
</tbody></table>
<p>属性</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">属性 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>os.EOL</strong> 定义了操作系统的行尾符的常量。</td>
</tr>
</tbody></table>
<p>创建 main.js 文件，代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> os = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CPU 的字节序</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;endianness : &#x27;</span> + os.endianness());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作系统名</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;type : &#x27;</span> + os.type());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作系统名</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;platform : &#x27;</span> + os.platform());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统内存总量</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;total memory : &#x27;</span> + os.totalmem() + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作系统空闲内存量</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;free memory : &#x27;</span> + os.freemem() + <span class="string">&quot; bytes.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js </span><br><span class="line">endianness : LE</span><br><span class="line">type : Linux</span><br><span class="line">platform : linux</span><br><span class="line">total memory : 8250183680 bytes.</span><br><span class="line">free memory : 339279872 bytes.</span><br></pre></td></tr></table></figure>

<h5 id="Node-js-Path-模块"><a href="#Node-js-Path-模块" class="headerlink" title="Node.js Path 模块"></a>Node.js Path 模块</h5><p>Node.js path 模块提供了一些用于处理文件路径的小工具，我们可以通过以下方式引入该模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&quot;path&quot;)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>path.normalize(p)</strong> 规范化路径，注意’..’ 和 ‘.’。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><code>path.join([path1][, path2][, ...]) 用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是&quot;/&quot;，Windows系统是&quot;\&quot;。</code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>path.resolve([from …], to)</strong> 将 <strong>to</strong> 参数解析为绝对路径，给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径。 例如，给定的路径片段的序列为：/foo、/bar、baz，则调用 path.resolve(‘/foo’, ‘/bar’, ‘baz’) 会返回 /bar/baz。<code>path.resolve(&#39;/foo/bar&#39;, &#39;./baz&#39;); // 返回: &#39;/foo/bar/baz&#39;  path.resolve(&#39;/foo/bar&#39;, &#39;/tmp/file/&#39;); // 返回: &#39;/tmp/file&#39;  path.resolve(&#39;wwwroot&#39;, &#39;static_files/png/&#39;, &#39;../gif/image.gif&#39;); // 如果当前工作目录为 /home/myself/node， // 则返回 &#39;/home/myself/node/wwwroot/static_files/gif/image.gif&#39;</code></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>path.isAbsolute(path)</strong> 判断参数 <strong>path</strong> 是否是绝对路径。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>path.relative(from, to)</strong> 用于将绝对路径转为相对路径，返回从 from 到 to 的相对路径（基于当前工作目录）。在 Linux 上：<code>path.relative(&#39;/data/orandea/test/aaa&#39;, &#39;/data/orandea/impl/bbb&#39;); // 返回: &#39;../../impl/bbb&#39;</code>在 Windows 上：<code>path.relative(&#39;C:\\orandea\\test\\aaa&#39;, &#39;C:\\orandea\\impl\\bbb&#39;); // 返回: &#39;..\\..\\impl\\bbb&#39;</code></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>path.dirname(p)</strong> 返回路径中代表文件夹的部分，同 Unix 的dirname 命令类似。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>path.basename(p[, ext])</strong> 返回路径中的最后一部分。同 Unix 命令 bashname 类似。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>path.extname(p)</strong> 返回路径中文件的后缀名，即路径中最后一个’.’之后的部分。如果一个路径中并不包含’.’或该路径只包含一个’.’ 且这个’.’为路径的第一个字符，则此命令返回空字符串。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>path.parse(pathString)</strong> 返回路径字符串的对象。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>path.format(pathObject)</strong> 从对象中返回路径字符串，和 path.parse 相反。</td>
</tr>
</tbody></table>
<p>属性</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">属性 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>path.sep</strong> 平台的文件路径分隔符，’\‘ 或 ‘/‘。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>path.delimiter</strong> 平台的分隔符, ; or ‘:’.</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>path.posix</strong> 提供上述 path 的方法，不过总是以 posix 兼容的方式交互。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>path.win32</strong> 提供上述 path 的方法，不过总是以 win32 兼容的方式交互。</td>
</tr>
</tbody></table>
<p>创建 main.js 文件，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&quot;path&quot;);</span><br><span class="line"></span><br><span class="line">// 格式化路径</span><br><span class="line">console.log(&#x27;normalization : &#x27; + path.normalize(&#x27;/test/test1//2slashes/1slash/tab/..&#x27;));</span><br><span class="line"></span><br><span class="line">// 连接路径</span><br><span class="line">console.log(&#x27;joint path : &#x27; + path.join(&#x27;/test&#x27;, &#x27;test1&#x27;, &#x27;2slashes/1slash&#x27;, &#x27;tab&#x27;, &#x27;..&#x27;));</span><br><span class="line"></span><br><span class="line">// 转换为绝对路径</span><br><span class="line">console.log(&#x27;resolve : &#x27; + path.resolve(&#x27;main.js&#x27;));</span><br><span class="line"></span><br><span class="line">// 路径中文件的后缀名</span><br><span class="line">console.log(&#x27;ext name : &#x27; + path.extname(&#x27;main.js&#x27;));</span><br></pre></td></tr></table></figure>

<h5 id="Net-模块"><a href="#Net-模块" class="headerlink" title="Net 模块"></a>Net 模块</h5><p>Node.js Net 模块提供了一些用于底层的网络通信的小工具，包含了创建服务器/客户端的方法，我们可以通过以下方式引入该模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var net = require(&quot;net&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>方法</strong></p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><code>net.createServer([options][, connectionListener]) 创建一个 TCP 服务器。参数 connectionListener 自动给 &#39;connection&#39; 事件创建监听器。</code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>net.connect(options[, connectionListener])</strong> 返回一个新的 ‘net.Socket’，并连接到指定的地址和端口。 当 socket 建立的时候，将会触发 ‘connect’ 事件。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>net.createConnection(options[, connectionListener])</strong> 创建一个到端口 port 和 主机 host的 TCP 连接。 host 默认为 ‘localhost’。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><code>net.connect(port[, host][, connectListener]) 创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 &#39;localhost&#39;。参数 connectListener 将会作为监听器添加到 &#39;connect&#39; 事件。返回 &#39;net.Socket&#39;。</code></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><code>net.createConnection(port[, host][, connectListener]) 创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 &#39;localhost&#39;。参数 connectListener 将会作为监听器添加到 &#39;connect&#39; 事件。返回 &#39;net.Socket&#39;。</code></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>net.connect(path[, connectListener])</strong> 创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件上。返回 ‘net.Socket’。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>net.createConnection(path[, connectListener])</strong> 创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>net.isIP(input)</strong> 检测输入的是否为 IP 地址。 IPV4 返回 4， IPV6 返回 6，其他情况返回 0。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>net.isIPv4(input)</strong> 如果输入的地址为 IPV4， 返回 true，否则返回 false。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>net.isIPv6(input)</strong> 如果输入的地址为 IPV6， 返回 true，否则返回 false。</td>
</tr>
</tbody></table>
<h5 id="net-Server"><a href="#net-Server" class="headerlink" title="net.Server"></a>net.Server</h5><p>net.Server通常用于创建一个 TCP 或本地服务器。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><code>server.listen(port[, host][, backlog][, callback]) 监听指定端口 port 和 主机 host ac连接。 默认情况下 host 接受任何 IPv4 地址(INADDR_ANY)的直接连接。端口 port 为 0 时，则会分配一个随机端口。</code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>server.listen(path[, callback])</strong> 通过指定 path 的连接，启动一个本地 socket 服务器。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>server.listen(handle[, callback])</strong> 通过指定句柄连接。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>server.listen(options[, callback])</strong> options 的属性：端口 port, 主机 host, 和 backlog, 以及可选参数 callback 函数, 他们在一起调用server.listen(port, [host], [backlog], [callback])。还有，参数 path 可以用来指定 UNIX socket。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>server.close([callback])</strong> 服务器停止接收新的连接，保持现有连接。这是异步函数，当所有连接结束的时候服务器会关闭，并会触发 ‘close’ 事件。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>server.address()</strong> 操作系统返回绑定的地址，协议族名和服务器端口。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>server.unref()</strong> 如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>server.ref()</strong> 与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>server.getConnections(callback)</strong> 异步获取服务器当前活跃连接的数量。当 socket 发送给子进程后才有效；回调函数有 2 个参数 err 和 count。</td>
</tr>
</tbody></table>
<p><strong>事件</strong></p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">事件 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>listening</strong> 当服务器调用 server.listen 绑定后会触发。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>connection</strong> 当新连接创建后会被触发。socket 是 net.Socket实例。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>close</strong> 服务器关闭时会触发。注意，如果存在连接，这个事件不会被触发直到所有的连接关闭。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>error</strong> 发生错误时触发。’close’ 事件将被下列事件直接调用。</td>
</tr>
</tbody></table>
<h5 id="net-Socket"><a href="#net-Socket" class="headerlink" title="net.Socket"></a>net.Socket</h5><p>net.Socket 对象是 TCP 或 UNIX Socket 的抽象。net.Socket 实例实现了一个双工流接口。 他们可以在用户创建客户端(使用 connect())时使用, 或者由 Node 创建它们，并通过 connection 服务器事件传递给用户。</p>
<p><strong>事件</strong></p>
<p>net.Socket 事件有：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">事件 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>lookup</strong> 在解析域名后，但在连接前，触发这个事件。对 UNIX sokcet 不适用。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>connect</strong> 成功建立 socket 连接时触发。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>data</strong> 当接收到数据时触发。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>end</strong> 当 socket 另一端发送 FIN 包时，触发该事件。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>timeout</strong> 当 socket 空闲超时时触发，仅是表明 socket 已经空闲。用户必须手动关闭连接。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>drain</strong> 当写缓存为空得时候触发。可用来控制上传。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>error</strong> 错误发生时触发。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>close</strong> 当 socket 完全关闭时触发。参数 had_error 是布尔值，它表示是否因为传输错误导致 socket 关闭。</td>
</tr>
</tbody></table>
<p><strong>属性</strong></p>
<p>net.Socket 提供了很多有用的属性，便于控制 socket 交互：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">属性 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>socket.bufferSize</strong> 该属性显示了要写入缓冲区的字节数。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>socket.remoteAddress</strong> 远程的 IP 地址字符串，例如：’74.125.127.100’ or ‘2001:4860:a005::68’。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>socket.remoteFamily</strong> 远程IP协议族字符串，比如 ‘IPv4’ or ‘IPv6’。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>socket.remotePort</strong> 远程端口，数字表示，例如：80 or 21。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>socket.localAddress</strong> 网络连接绑定的本地接口 远程客户端正在连接的本地 IP 地址，字符串表示。例如，如果你在监听’0.0.0.0’而客户端连接在’192.168.1.1’，这个值就会是 ‘192.168.1.1’。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>socket.localPort</strong> 本地端口地址，数字表示。例如：80 or 21。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>socket.bytesRead</strong> 接收到得字节数。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>socket.bytesWritten</strong> 发送的字节数。</td>
</tr>
</tbody></table>
<p><strong>方法</strong></p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>new net.Socket([options])</strong> 构造一个新的 socket 对象。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><code>socket.connect(port[, host][, connectListener]) 指定端口 port 和 主机 host，创建 socket 连接 。参数 host 默认为 localhost。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。</code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>socket.connect(path[, connectListener])</strong> 打开指定路径的 unix socket。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>socket.setEncoding([encoding])</strong> 设置编码</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><code>socket.write(data[, encoding][, callback]) 在 socket 上发送数据。第二个参数指定了字符串的编码，默认是 UTF8 编码。</code></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><code>socket.end([data][, encoding]) 半关闭 socket。例如，它发送一个 FIN 包。可能服务器仍在发送数据。</code></td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>socket.destroy()</strong> 确保没有 I/O 活动在这个套接字上。只有在错误发生情况下才需要。（处理错误等等）。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>socket.pause()</strong> 暂停读取数据。就是说，不会再触发 data 事件。对于控制上传非常有用。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>socket.resume()</strong> 调用 pause() 后想恢复读取数据。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>socket.setTimeout(timeout[, callback])</strong> socket 闲置时间超过 timeout 毫秒后 ，将 socket 设置为超时。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>socket.setNoDelay([noDelay])</strong> 禁用纳格（Nagle）算法。默认情况下 TCP 连接使用纳格算法，在发送前他们会缓冲数据。将 noDelay 设置为 true 将会在调用 socket.write() 时立即发送数据。noDelay 默认值为 true。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><code>socket.setKeepAlive([enable][, initialDelay]) 禁用/启用长连接功能，并在发送第一个在闲置 socket 上的长连接 probe 之前，可选地设定初始延时。默认为 false。 设定 initialDelay （毫秒），来设定收到的最后一个数据包和第一个长连接probe之间的延时。将 initialDelay 设为0，将会保留默认（或者之前）的值。默认值为0.</code></td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>socket.address()</strong> 操作系统返回绑定的地址，协议族名和服务器端口。返回的对象有 3 个属性，比如{ port: 12346, family: ‘IPv4’, address: ‘127.0.0.1’ }。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><strong>socket.unref()</strong> 如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。如果服务器已被 unref，则再次调用 unref 并不会产生影响。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><strong>socket.ref()</strong> 与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<p>创建 server.js 文件，代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">connection</span>) </span>&#123; </span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;client connected&#x27;</span>);</span><br><span class="line">   connection.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;客户端关闭连接&#x27;</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   connection.write(<span class="string">&#x27;Hello World!\r\n&#x27;</span>);</span><br><span class="line">   connection.pipe(connection);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;server is listening&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行以上服务端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node server.js</span><br><span class="line">server is listening   # 服务已创建并监听 8080 端口</span><br></pre></td></tr></table></figure>

<p>新开一个窗口，创建 client.js 文件，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var net = require(&#x27;net&#x27;);</span><br><span class="line">var client = net.connect(&#123;port: 8080&#125;, function() &#123;</span><br><span class="line">   console.log(&#x27;连接到服务器！&#x27;);  </span><br><span class="line">&#125;);</span><br><span class="line">client.on(&#x27;data&#x27;, function(data) &#123;</span><br><span class="line">   console.log(data.toString());</span><br><span class="line">   client.end();</span><br><span class="line">&#125;);</span><br><span class="line">client.on(&#x27;end&#x27;, function() &#123; </span><br><span class="line">   console.log(&#x27;断开与服务器的连接&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行以上客户端的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">连接到服务器！</span><br><span class="line">Hello World!</span><br><span class="line"></span><br><span class="line">断开与服务器的连接</span><br></pre></td></tr></table></figure>

<h5 id="DNS-模块"><a href="#DNS-模块" class="headerlink" title="DNS 模块"></a>DNS 模块</h5><p>Node.js <strong>DNS</strong> 模块用于解析域名。引入 DNS 模块语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var dns = require(&quot;dns&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>方法</strong></p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>dns.lookup(hostname[, options], callback)</strong> 将域名（比如 ‘runoob.com’）解析为第一条找到的记录 A （IPV4）或 AAAA(IPV6)。参数 options可以是一个对象或整数。如果没有提供 options，IP v4 和 v6 地址都可以。如果 options 是整数，则必须是 4 或 6。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>dns.lookupService(address, port, callback)</strong> 使用 getnameinfo 解析传入的地址和端口为域名和服务。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>dns.resolve(hostname[, rrtype], callback)</strong> 将一个域名（如 ‘runoob.com’）解析为一个 rrtype 指定记录类型的数组。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>dns.resolve4(hostname, callback)</strong> 和 dns.resolve() 类似, 仅能查询 IPv4 (A 记录）。 addresses IPv4 地址数组 (比如，[‘74.125.79.104’, ‘74.125.79.105’, ‘74.125.79.106’]）。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>dns.resolve6(hostname, callback)</strong> 和 dns.resolve4() 类似， 仅能查询 IPv6( AAAA 查询）</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>dns.resolveMx(hostname, callback)</strong> 和 dns.resolve() 类似, 仅能查询邮件交换(MX 记录)。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>dns.resolveTxt(hostname, callback)</strong> 和 dns.resolve() 类似, 仅能进行文本查询 (TXT 记录）。 addresses 是 2-d 文本记录数组。(比如，[ [‘v=spf1 ip4:0.0.0.0 ‘, ‘~all’ ] ]）。 每个子数组包含一条记录的 TXT 块。根据使用情况可以连接在一起，也可单独使用。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>dns.resolveSrv(hostname, callback)</strong> 和 dns.resolve() 类似, 仅能进行服务记录查询 (SRV 记录）。 addresses 是 hostname可用的 SRV 记录数组。 SRV 记录属性有优先级（priority），权重（weight）, 端口（port）, 和名字（name） (比如，[{‘priority’: 10, ‘weight’: 5, ‘port’: 21223, ‘name’: ‘service.example.com’}, …]）。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>dns.resolveSoa(hostname, callback)</strong> 和 dns.resolve() 类似, 仅能查询权威记录(SOA 记录）。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>dns.resolveNs(hostname, callback)</strong> 和 dns.resolve() 类似, 仅能进行域名服务器记录查询(NS 记录）。 addresses 是域名服务器记录数组（hostname 可以使用） (比如, [‘ns1.example.com’, ‘ns2.example.com’]）。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>dns.resolveCname(hostname, callback)</strong> 和 dns.resolve() 类似, 仅能进行别名记录查询 (CNAME记录)。addresses 是对 hostname 可用的别名记录数组 (比如，, [‘bar.example.com’]）。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>dns.reverse(ip, callback)</strong> 反向解析 IP 地址，指向该 IP 地址的域名数组。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>dns.getServers()</strong> 返回一个用于当前解析的 IP 地址数组的字符串。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><strong>dns.setServers(servers)</strong> 指定一组 IP 地址作为解析服务器。</td>
</tr>
</tbody></table>
<p><strong>rrtypes</strong></p>
<p>以下列出了 dns.resolve() 方法中有效的 rrtypes值:</p>
<ul>
<li><code>&#39;A&#39;</code> IPV4 地址, 默认</li>
<li><code>&#39;AAAA&#39;</code> IPV6 地址</li>
<li><code>&#39;MX&#39;</code> 邮件交换记录</li>
<li><code>&#39;TXT&#39;</code> text 记录</li>
<li><code>&#39;SRV&#39;</code> SRV 记录</li>
<li><code>&#39;PTR&#39;</code> 用来反向 IP 查找</li>
<li><code>&#39;NS&#39;</code> 域名服务器记录</li>
<li><code>&#39;CNAME&#39;</code> 别名记录</li>
<li><code>&#39;SOA&#39;</code> 授权记录的初始值</li>
</ul>
<p><strong>错误码</strong></p>
<p>每次 DNS 查询都可能返回以下错误码：</p>
<ul>
<li><code>dns.NODATA</code>: 无数据响应。</li>
<li><code>dns.FORMERR</code>: 查询格式错误。</li>
<li><code>dns.SERVFAIL</code>: 常规失败。</li>
<li><code>dns.NOTFOUND</code>: 没有找到域名。</li>
<li><code>dns.NOTIMP</code>: 未实现请求的操作。</li>
<li><code>dns.REFUSED</code>: 拒绝查询。</li>
<li><code>dns.BADQUERY</code>: 查询格式错误。</li>
<li><code>dns.BADNAME</code>: 域名格式错误。</li>
<li><code>dns.BADFAMILY</code>: 地址协议不支持。</li>
<li><code>dns.BADRESP</code>: 回复格式错误。</li>
<li><code>dns.CONNREFUSED</code>: 无法连接到 DNS 服务器。</li>
<li><code>dns.TIMEOUT</code>: 连接 DNS 服务器超时。</li>
<li><code>dns.EOF</code>: 文件末端。</li>
<li><code>dns.FILE</code>: 读文件错误。</li>
<li><code>dns.NOMEM</code>: 内存溢出。</li>
<li><code>dns.DESTRUCTION</code>: 通道被摧毁。</li>
<li><code>dns.BADSTR</code>: 字符串格式错误。</li>
<li><code>dns.BADFLAGS</code>: 非法标识符。</li>
<li><code>dns.NONAME</code>: 所给主机不是数字。</li>
<li><code>dns.BADHINTS</code>: 非法HINTS标识符。</li>
<li><code>dns.NOTINITIALIZED</code>: c c-ares 库尚未初始化。</li>
<li><code>dns.LOADIPHLPAPI</code>: 加载 iphlpapi.dll 出错。</li>
<li><code>dns.ADDRGETNETWORKPARAMS</code>: 无法找到 GetNetworkParams 函数。</li>
<li><code>dns.CANCELLED</code>: 取消 DNS 查询。</li>
</ul>
<p><strong>实例</strong></p>
<p>创建 main.js 文件，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var dns = require(&#x27;dns&#x27;);</span><br><span class="line"></span><br><span class="line">dns.lookup(&#x27;www.github.com&#x27;, function onLookup(err, address, family) &#123;</span><br><span class="line">   console.log(&#x27;ip 地址:&#x27;, address);</span><br><span class="line">   dns.reverse(address, function (err, hostnames) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">      console.log(err.stack);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   console.log(&#x27;反向解析 &#x27; + address + &#x27;: &#x27; + JSON.stringify(hostnames));</span><br><span class="line">&#125;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行以上代码，结果如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">address: 192.30.252.130</span><br><span class="line">reverse for 192.30.252.130: [&quot;github.com&quot;]</span><br></pre></td></tr></table></figure>

<h5 id="Domain-模块"><a href="#Domain-模块" class="headerlink" title="Domain 模块"></a>Domain 模块</h5><p>Node.js <strong>Domain(域)</strong> 简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的异常。引入 Domain 模块 语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var domain = require(&quot;domain&quot;)</span><br></pre></td></tr></table></figure>

<p>domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出，与process.on(‘uncaughtException’)不同。</p>
<p>Domain 模块可分为隐式绑定和显式绑定：</p>
<ul>
<li>隐式绑定: 把在domain上下文中定义的变量，自动绑定到domain对象</li>
<li>显式绑定: 把不是在domain上下文中定义的变量，以代码的方式绑定到domain对象</li>
</ul>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>domain.run(function)</strong> 在域的上下文运行提供的函数，隐式的绑定了所有的事件分发器，计时器和底层请求。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>domain.add(emitter)</strong> 显式的增加事件</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>domain.remove(emitter)</strong> 删除事件。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>domain.bind(callback)</strong> 返回的函数是一个对于所提供的回调函数的包装函数。当调用这个返回的函数时，所有被抛出的错误都会被导向到这个域的 error 事件。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>domain.intercept(callback)</strong> 和 domain.bind(callback) 类似。除了捕捉被抛出的错误外，它还会拦截 Error 对象作为参数传递到这个函数。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>domain.enter()</strong> 进入一个异步调用的上下文，绑定到domain。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>domain.exit()</strong> 退出当前的domain，切换到不同的链的异步调用的上下文中。对应domain.enter()。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>domain.dispose()</strong> 释放一个domain对象，让node进程回收这部分资源。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>domain.create()</strong> 返回一个domain对象。</td>
</tr>
</tbody></table>
<p><strong>属性</strong></p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">属性 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>domain.members</strong> 已加入domain对象的域定时器和事件发射器的数组。</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<p>创建 main.js 文件，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">var EventEmitter = require(&quot;events&quot;).EventEmitter;</span><br><span class="line">var domain = require(&quot;domain&quot;);</span><br><span class="line"></span><br><span class="line">var emitter1 = new EventEmitter();</span><br><span class="line"></span><br><span class="line">// 创建域</span><br><span class="line">var domain1 = domain.create();</span><br><span class="line"></span><br><span class="line">domain1.on(&#x27;error&#x27;, function(err)&#123;</span><br><span class="line">   console.log(&quot;domain1 处理这个错误 (&quot;+err.message+&quot;)&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 显式绑定</span><br><span class="line">domain1.add(emitter1);</span><br><span class="line"></span><br><span class="line">emitter1.on(&#x27;error&#x27;,function(err)&#123;</span><br><span class="line">   console.log(&quot;监听器处理此错误 (&quot;+err.message+&quot;)&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter1.emit(&#x27;error&#x27;,new Error(&#x27;通过监听器来处理&#x27;));</span><br><span class="line"></span><br><span class="line">emitter1.removeAllListeners(&#x27;error&#x27;);</span><br><span class="line"></span><br><span class="line">emitter1.emit(&#x27;error&#x27;,new Error(&#x27;通过 domain1 处理&#x27;));</span><br><span class="line"></span><br><span class="line">var domain2 = domain.create();</span><br><span class="line"></span><br><span class="line">domain2.on(&#x27;error&#x27;, function(err)&#123;</span><br><span class="line">   console.log(&quot;domain2 处理这个错误 (&quot;+err.message+&quot;)&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 隐式绑定</span><br><span class="line">domain2.run(function()&#123;</span><br><span class="line">   var emitter2 = new EventEmitter();</span><br><span class="line">   emitter2.emit(&#x27;error&#x27;,new Error(&#x27;通过 domain2 处理&#x27;));   </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">domain1.remove(emitter1);</span><br><span class="line">emitter1.emit(&#x27;error&#x27;, new Error(&#x27;转换为异常，系统将崩溃!&#x27;));</span><br></pre></td></tr></table></figure>

<p>执行以上代码，结果如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">监听器处理此错误 (通过监听器来处理)</span><br><span class="line">domain1 处理这个错误 (通过 domain1 处理)</span><br><span class="line">domain2 处理这个错误 (通过 domain2 处理)</span><br><span class="line"></span><br><span class="line">events.js:72</span><br><span class="line">        throw er; // Unhandled &#x27;error&#x27; event</span><br><span class="line">              ^</span><br><span class="line">Error: 转换为异常，系统将崩溃!</span><br><span class="line">    at Object.&lt;anonymous&gt; (/www/node/main.js:40:24)</span><br><span class="line">    at Module._compile (module.js:456:26)</span><br><span class="line">    at Object.Module._extensions..js (module.js:474:10)</span><br><span class="line">    at Module.load (module.js:356:32)</span><br><span class="line">    at Function.Module._load (module.js:312:12)</span><br><span class="line">    at Function.Module.runMain (module.js:497:10)</span><br><span class="line">    at startup (node.js:119:16)</span><br><span class="line">    at node.js:929:3</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/06/30/node-1-2/">https://pingxin0521.gitee.io/2019/06/30/node-1-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Node-JS/">Node.JS</a><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/">后端</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/06/30/Java-SpringBoot-1-4-0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring boot 数据访问</div></div></a></div><div class="next-post pull-right"><a href="/2019/06/30/Java-SpringBoot-1-3-3/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring boot 健康检查、审计、统计和监控</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/06/07/node-1-0/" title="Node.JS 入门"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-04-01</div><div class="title">Node.JS 入门</div></div></a></div><div><a href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-05-09</div><div class="title">Node.JS web开发前置知识</div></div></a></div><div><a href="/2019/07/01/node-2-2/" title="Node.JS 再深入 -- http"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-05-09</div><div class="title">Node.JS 再深入 -- http</div></div></a></div><div><a href="/2019/06/07/node-1-1/" title="Node.JS 入门"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-04-01</div><div class="title">Node.JS 入门</div></div></a></div><div><a href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-05-10</div><div class="title">Koa -- 基于Node.js平台的下一代Web开发框架</div></div></a></div><div><a href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-05-16</div><div class="title">Egg.js -- 为企业级框架和应用而生</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-js-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">1.</span> <span class="toc-text">Node.js 常用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#util-inherits"><span class="toc-number">1.1.</span> <span class="toc-text">util.inherits</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#util-inspect"><span class="toc-number">1.2.</span> <span class="toc-text">util.inspect</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-js-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">Node.js 文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-js-GET-POST%E8%AF%B7%E6%B1%82"><span class="toc-number">3.</span> <span class="toc-text">Node.js GET&#x2F;POST请求</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96GET%E8%AF%B7%E6%B1%82%E5%86%85%E5%AE%B9"><span class="toc-number">3.1.</span> <span class="toc-text">获取GET请求内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-URL-%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">获取 URL 的参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-POST-%E8%AF%B7%E6%B1%82%E5%86%85%E5%AE%B9"><span class="toc-number">3.3.</span> <span class="toc-text">获取 POST 请求内容</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-js-%E5%B7%A5%E5%85%B7%E6%A8%A1%E5%9D%97"><span class="toc-number">4.</span> <span class="toc-text">Node.js 工具模块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#OS-%E6%A8%A1%E5%9D%97"><span class="toc-number">4.1.</span> <span class="toc-text">OS 模块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Node-js-Path-%E6%A8%A1%E5%9D%97"><span class="toc-number">4.2.</span> <span class="toc-text">Node.js Path 模块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Net-%E6%A8%A1%E5%9D%97"><span class="toc-number">4.3.</span> <span class="toc-text">Net 模块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#net-Server"><span class="toc-number">4.4.</span> <span class="toc-text">net.Server</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#net-Socket"><span class="toc-number">4.5.</span> <span class="toc-text">net.Socket</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DNS-%E6%A8%A1%E5%9D%97"><span class="toc-number">4.6.</span> <span class="toc-text">DNS 模块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Domain-%E6%A8%A1%E5%9D%97"><span class="toc-number">4.7.</span> <span class="toc-text">Domain 模块</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
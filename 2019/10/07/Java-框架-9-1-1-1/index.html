<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Spring Security 入门 | 平心de小屋</title><meta name="keywords" content="Java,框架"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基本概念什么是认证系统为什么要认证? 认证是为了保护系统的隐私数据与资源,用户的身份合法方可访问该系统的资源。 认证 :用户认证就是判断一个用户的身份是否合法的过程,用户去访问系统资源时系统要求验证用户的身份信息,身份合法方可继续访问,不合法则拒绝访问。常见的用户身份认证方式有:用户名密码登录,二维码登录,手机短信登录,指纹认证等方式。">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Security 入门">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/10/07/Java-%E6%A1%86%E6%9E%B6-9-1-1-1/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="基本概念什么是认证系统为什么要认证? 认证是为了保护系统的隐私数据与资源,用户的身份合法方可访问该系统的资源。 认证 :用户认证就是判断一个用户的身份是否合法的过程,用户去访问系统资源时系统要求验证用户的身份信息,身份合法方可继续访问,不合法则拒绝访问。常见的用户身份认证方式有:用户名密码登录,二维码登录,手机短信登录,指纹认证等方式。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg">
<meta property="article:published_time" content="2019-10-07T08:18:59.000Z">
<meta property="article:modified_time" content="2019-12-30T12:06:16.852Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="框架">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/10/07/Java-%E6%A1%86%E6%9E%B6-9-1-1-1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring Security 入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2019-12-30 20:06:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring Security 入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-10-07T08:18:59.000Z" title="发表于 2019-10-07 16:18:59">2019-10-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-12-30T12:06:16.852Z" title="更新于 2019-12-30 20:06:16">2019-12-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E6%A1%86%E6%9E%B6/">框架</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring Security 入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="什么是认证"><a href="#什么是认证" class="headerlink" title="什么是认证"></a>什么是认证</h5><p>系统为什么要认证?</p>
<p>认证是为了保护系统的隐私数据与资源,用户的身份合法方可访问该系统的资源。</p>
<p><strong>认证</strong> :用户认证就是判断一个用户的身份是否合法的过程,用户去访问系统资源时系统要求验证用户的身份信息,身份合法方可继续访问,不合法则拒绝访问。常见的用户身份认证方式有:用户名密码登录,二维码登录,手机短信登录,指纹认证等方式。</p>
<span id="more"></span>

<h5 id="什么是会话"><a href="#什么是会话" class="headerlink" title="什么是会话"></a>什么是会话</h5><p>用户认证通过后,为了避免用户的每次操作都进行认证可将用户的信息保证在会话中。会话就是系统为了保持当前用户的登录状态所提供的机制,常见的有基于session方式、基于token方式等。</p>
<p>基于session的认证方式如下图:</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/18/QHR14f.png" alt="QHR14f.png"></p>
<p>它的交互流程是,用户认证成功后,在服务端生成用户相关的数据保存在session(当前会话)中,发给客户端的sesssion_id 存放到 cookie 中,这样用户客户端请求时带上 session_id 就可以验证服务器端是否存在 session 数据,以此完成用户的合法校验,当用户退出系统或session过期销毁时,客户端的session_id也就无效了。</p>
<p>基于token方式如下图:</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/18/QHR0U0.png" alt="QHR0U0.png"></p>
<p>它的交互流程是,用户认证成功后,服务端生成一个token发给客户端,客户端可以放到 cookie 或 localStorage<br>等存储中,每次请求时带上 token,服务端收到token通过验证后即可确认用户身份。</p>
<p><strong>区别</strong>：基于session的认证方式由Servlet规范定制,服务端要存储session信息需要占用内存资源,客户端需要支持cookie;基于token的方式则一般不需要服务端存储token,并且不限制客户端的存储方式。如今移动互联网时代更多类型的客户端需要接入系统,系统多是采用前后端分离的架构进行实现,所以基于token的方式更适合，如JWT认证。</p>
<h5 id="什么是授权"><a href="#什么是授权" class="headerlink" title="什么是授权"></a>什么是授权</h5><p>微信登录成功后用户即可使用微信的功能,比如,发红包、发朋友圈、添加好友等,没有绑定银行卡的用户是无法发送红包的,绑定银行卡的用户才可以发红包,发红包功能、发朋友圈功能都是微信的资源即功能资源,用户拥有发红包功能的权限才可以正常使用发送红包功能,拥有发朋友圈功能的权限才可以使用发朋友圈功能,这个根据用户的权限来控制用户使用资源的过程就是授权。</p>
<p>为什么要授权?</p>
<p>认证是为了保证用户身份的合法性,授权则是为了更细粒度的对隐私数据进行划分,授权是在认证通过后发生的,<br>控制不同的用户能够访问不同的资源。</p>
<p><strong>授权</strong>: 授权是用户认证通过根据用户的权限来控制用户访问资源的过程,拥有资源的访问权限则正常访问,没有权限则拒绝访问。</p>
<h5 id="授权的数据模型"><a href="#授权的数据模型" class="headerlink" title="授权的数据模型"></a>授权的数据模型</h5><p>如何进行授权即如何对用户访问资源进行控制,首先需要学习授权相关的数据模型。</p>
<p>授权可简单理解为Who对What(which)进行How操作,包括如下:</p>
<ul>
<li><p>Who,即主体(Subject),主体一般是指用户,也可以是程序,需要访问系统中的资源。</p>
</li>
<li><p>What,即资源(Resource),如系统菜单、页面、按钮、代码方法、系统商品信息、系统订单信息等。系统菜单、页面、按钮、代码方法都属于系统功能资源,对于web系统每个功能资源通常对应一个URL;系统商品信息、系统订单信息都属于实体资源(数据资源),实体资源由资源类型和资源实例组成,比如商品信息为资源类型,商品编号 为001的商品为资源实例。 </p>
</li>
<li><p>How,权限/许可(Permission),规定了用户对资源的操作许可,权限离开资源没有意义,如用户查询权限、用户添加权限、某个代码方法的调用权限、编号为001的用户的修改权限等,通过权限可知用户对哪些资源都有哪些操作许可。</p>
</li>
</ul>
<p>主体、资源、权限关系如下图:</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/18/QHWVI0.png" alt="QHWVI0.png"></p>
<p>主体、资源、权限相关的数据模型如下:</p>
<ul>
<li><p>主体(用户id、账号、密码、…)</p>
</li>
<li><p>资源(资源id、资源名称、访问地址、…)</p>
</li>
<li><p>权限(权限id、权限标识、权限名称、资源id、…)</p>
</li>
<li><p>角色(角色id、角色名称、…)</p>
</li>
<li><p>角色和权限关系(角色 id、权限id、…)</p>
</li>
<li><p>主体(用户)和角色关系(用户id、角色id、…)</p>
</li>
</ul>
<p>主体(用户)、资源、权限关系如下图:</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/18/QHWMM4.png" alt="QHWMM4.png"></p>
<p>通常企业开发中将资源和权限表合并为一张权限表,如下:</p>
<ul>
<li>资源(资源id、资源名称、访问地址、…)</li>
<li>权限(权限id、权限标识、权限名称、资源id、…)</li>
</ul>
<p>合并为:</p>
<ul>
<li>权限(权限id、权限标识、权限名称、资源名称、资源访问地址、…)</li>
</ul>
<p>修改后数据模型之间的关系如下图:</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/18/QHWGIx.png" alt="QHWGIx.png"></p>
<h5 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h5><p>如何实现授权?业界通常基于RBAC实现授权。</p>
<p><strong>基于角色的访问控制</strong></p>
<p>RBAC基于角色的访问控制(Role-Based Access Control)是按角色进行授权,比如:主体的角色为总经理可以查询企业运营报表,查询员工工资信息等,访问控制流程如下:</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/18/QHWdQe.png" alt="QHWdQe.png"></p>
<p>根据上图中的判断逻辑,授权代码可表示如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(主体.hasRole(&quot;总经理角色id&quot;))&#123;</span><br><span class="line">查询工资</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上图中查询工资所需要的角色变化为总经理和部门经理,此时就需要修改判断逻辑为“判断用户的角色是否是总经理或部门经理”,修改代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(主体.hasRole(&quot;总经理角色id&quot;) ||</span><br><span class="line">主体.hasRole(&quot;部门经理角色id&quot;))&#123;</span><br><span class="line">查询工资</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上边的例子发现,当需要修改角色的权限时就需要修改授权的相关代码,系统可扩展性差。</p>
<p><strong>基于资源的访问控制</strong></p>
<p>RBAC基于资源的访问控制(Resource-Based Access Control)是按资源(或权限)进行授权,比如:用户必须具有查询工资权限才可以查询员工工资信息等,访问控制流程如下:</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/18/QHfklD.png" alt="QHfklD.png"></p>
<p>根据上图中的判断,授权代码可以表示为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(主体.hasPermission(&quot;查询工资权限标识&quot;))&#123;</span><br><span class="line">查询工资</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点:系统设计时定义好查询工资的权限标识,即使查询工资所需要的角色变化为总经理和部门经理也不需要修改<br>授权代码,系统可扩展性强。</p>
<h4 id="基于Session的认证方式"><a href="#基于Session的认证方式" class="headerlink" title="基于Session的认证方式"></a>基于Session的认证方式</h4><p><strong>认证流程</strong></p>
<p>基于Session认证方式的流程是,用户认证成功后,在服务端生成用户相关的数据保存在session(当前会话),而发给客户端的 sesssion_id 存放到 cookie 中,这样用客户端请求时带上 session_id 就可以验证服务器端是否存在<br>session 数据,以此完成用户的合法校验。当用户退出系统或session过期销毁时,客户端的session_id也就无效了。</p>
<p>下图是session认证方式的流程图:</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/home/hyp/.config/Typora/typora-user-images/image-20191218221229380.png" alt="image-20191218221229380"></p>
<p>基于Session的认证机制由Servlet规范定制,Servlet容器已实现,用户通过HttpSession的操作方法即可实现,如下是HttpSession相关的操作API。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/18/QHf41O.png" alt="QHf41O.png"></p>
<p>代码参考：<a target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521/learn-sercurity/tree/master/security-springmvc">https://github.com/hanyunpeng0521/learn-sercurity/tree/master/security-springmvc</a></p>
<p>运行项目：<code>mvn clean tomcat7:run</code></p>
<p>浏览器访问：<a target="_blank" rel="noopener" href="http://localhost:8080/security-springmvc">http://localhost:8080/security-springmvc</a></p>
<p>未登录情况下,/r/r1与/r/r2均提示 “请先登录”。</p>
<p>张三登录情况下,由于张三有p1权限,因此可以访问/r/r1,张三没有p2权限,访问/r/r2时提示 “权限不足 “。</p>
<p>李四登录情况下,由于李四有p2权限,因此可以访问/r/r2,李四没有p1权限,访问/r/r1时提示 “权限不足 “。</p>
<p>测试结果全部符合预期结果。</p>
<h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><p>一个能够为基于Spring的企业应用系统提供声明式的安全訪问控制解决方式的安全框架（简单说是对访问权限进行控制嘛），应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。</p>
<p>用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。</p>
<p>用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。   </p>
<p>spring security的主要核心功能为 认证和授权，所有的架构也是基于这两个核心功能去实现的。</p>
<p>spring security的项目：<a target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521/learn-sercurity/tree/master/security-spring-security">https://github.com/hanyunpeng0521/learn-sercurity/tree/master/security-spring-security</a></p>
<p>spring boot+spring security项目：<a target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521/learn-sercurity/tree/master/security-spring-boot">https://github.com/hanyunpeng0521/learn-sercurity/tree/master/security-spring-boot</a></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Spring Security所解决的问题就是<strong>安全访问控制</strong>,而安全访问控制功能其实就是对所有进入系统的请求进行拦截,校验每个请求是否能够访问它所期望的资源。根据前边知识的学习,可以通过Filter或AOP等技术来实现,Spring Security对Web资源的保护是靠Filter实现的,所以从这个Filter来入手,逐步深入Spring Security原理。</p>
<p>当初始化Spring Security时,会创建一个名为 <strong>SpringSecurityFilterChain</strong> 的Servlet过滤器,类型为org.springframework.security.web.FilterChainProxy,它实现了javax.servlet.Filter,因此外部的请求会经过此类,下图是Spring Security过虑器链结构图:</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/19/QqFEy8.png" alt="QqFEy8.png"></p>
<p>FilterChainProxy 是一个代理,真正起作用的是FilterChainProxy中SecurityFilterChain所包含的各个Filter,同时这些Filter作为Bean被Spring管理,它们是Spring Security核心,各有各的职责,但他们并不直接处理用户的认<br>证,也不直接处理用户的授权,而是把它们交给了认证管理器(AuthenticationManager)和决策管理器(AccessDecisionManager)进行处理,下图是FilterChainProxy相关类的UML图示。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/12/19/d6BwiLSQX2WxDOF.png" alt="UTOOLS1576733298633.png"></p>
<p>spring Security功能的实现主要是由一系列过滤器链相互配合完成。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/12/19/YW4H8pihzyQFAEU.png" alt="UTOOLS1576733329015.png"></p>
<p>下面介绍过滤器链中主要的几个过滤器及其作用:</p>
<ul>
<li>SecurityContextPersistenceFilter 这个Filter是整个拦截过程的入口和出口(也就是第一个和最后一个拦截器),会在请求开始时从配置好的 SecurityContextRepository 中获取 SecurityContext,然后把它设置给SecurityContextHolder。在请求完成后将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好的 SecurityContextRepository,同时清除 securityContextHolder 所持有的 SecurityContext;</li>
<li>UsernamePasswordAuthenticationFilter 用于处理来自表单提交的认证。该表单必须提供对应的用户名和密码,其内部还有登录成功或失败后进行处理的 AuthenticationSuccessHandler 和AuthenticationFailureHandler,这些都可以根据需求做相关改变;</li>
<li>FilterSecurityInterceptor 是用于保护web资源的,使用AccessDecisionManager对当前用户进行授权访问,前面已经详细介绍过了;</li>
<li>ExceptionTranslationFilter 能够捕获来自 FilterChain 所有的异常,并进行处理。但是它只会处理两类异常:AuthenticationException 和 AccessDeniedException,其它的异常它会继续抛出。</li>
</ul>
<h5 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h5><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/12/19/1tbQRFcLy37elMI.png" alt="UTOOLS1576733427247.png"></p>
<p>让我们仔细分析认证过程:</p>
<ol>
<li><p>用户提交用户名、密码被SecurityFilterChain中的 UsernamePasswordAuthenticationFilter 过滤器获取到,封装为请求Authentication,通常情况下是UsernamePasswordAuthenticationToken这个实现类。</p>
</li>
<li><p>然后过滤器将Authentication提交至认证管理器(AuthenticationManager)进行认证</p>
</li>
<li><p>认证成功后, AuthenticationManager 身份管理器返回一个被填充满了信息的(包括上面提到的权限信息,身份信息,细节信息,但密码通常会被移除) Authentication 实例。</p>
</li>
<li><p>SecurityContextHolder 安全上下文容器将第3步填充了信息的 Authentication ,通过<code>SecurityContextHolder.getContext().setAuthentication(...)</code>方法,设置到其中。</p>
</li>
</ol>
<p>  可以看出AuthenticationManager接口(认证管理器)是认证相关的核心接口,也是发起认证的出发点,它的实现类为ProviderManager。而Spring Security支持多种认证方式,因此ProviderManager维护着一个<code>List&lt;AuthenticationProvider&gt;</code> 列表,存放多种认证方式,最终实际的认证工作是由AuthenticationProvider完成的。</p>
<p>  咱们知道web表单的对应的AuthenticationProvider实现类为DaoAuthenticationProvider,它的内部又维护着一个UserDetailsService负责UserDetails的获取。最终AuthenticationProvider将UserDetails填充至Authentication。</p>
<p>  认证核心组件的大体关系如下:</p>
<p>  <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/12/19/QwsxdNb62G7ktiu.png" alt="UTOOLS1576733517982.png"></p>
<p><strong>AuthenticationProvider</strong></p>
<p>通过前面的Spring Security认证流程我们得知,认证管理器(AuthenticationManager)委托AuthenticationProvider完成认证工作。</p>
<p>AuthenticationProvider是一个接口,定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>authenticate()方法定义了认证的实现过程,它的参数是一个Authentication,里面包含了登录用户所提交的用<br>户、密码等。而返回值也是一个Authentication,这个Authentication则是在认证成功后,将用户的权限及其他信息重新组装后生成。</p>
<p>Spring Security中维护着一个 List&lt;AuthenticationProvider&gt; 列表,存放多种认证方式,不同的认证方式使用不同的AuthenticationProvider。如使用用户名密码登录时,使用AuthenticationProvider1,短信登录时使用<br>AuthenticationProvider2等等这样的例子很多。</p>
<p>每个AuthenticationProvider需要实现supports()方法来表明自己支持的认证方式,如我们使用表单方式认证,<br>在提交请求时Spring Security会生成UsernamePasswordAuthenticationToken,它是一个Authentication,里面<br>封装着用户提交的用户名、密码信息。而对应的,哪个AuthenticationProvider来处理它?</p>
<p>我们在DaoAuthenticationProvider的基类AbstractUserDetailsAuthenticationProvider发现以下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (UsernamePasswordAuthenticationToken.class</span><br><span class="line">			.isAssignableFrom(authentication));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是说当web表单提交用户名密码时,Spring Security由DaoAuthenticationProvider处理。</p>
<p>最后,我们来看一下 Authentication(认证信息)的结构,它是一个接口,我们之前提到的UsernamePasswordAuthenticationToken就是它的实现之一:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Authentication是spring security包中的接口,直接继承自Principal类,</span></span><br><span class="line"><span class="comment">//而Principal是位于 java.security包中的。</span></span><br><span class="line"><span class="comment">//它是表示着一个抽象主体身份,任何主体都有一个名称,因此包含一个getName()方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authentication</span> <span class="keyword">extends</span> <span class="title">Principal</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//权限信息列表,默认是GrantedAuthority接口的一些实现类,通常是代表权限信息的一系列字符串。</span></span><br><span class="line">	Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line">    <span class="comment">//凭证信息,用户输入的密码字符串,在认证过后通常会被移除,用于保障安全。</span></span><br><span class="line">	<span class="function">Object <span class="title">getCredentials</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//细节信息,web应用中的实现接口通常为 WebAuthenticationDetails,它记录了访问者的ip地址和sessionId的值。</span></span><br><span class="line">	<span class="function">Object <span class="title">getDetails</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//身份信息,大部分情况下返回的是UserDetails接口的实现类,UserDetails代表用户的详细信息,那从Authentication中取出来的UserDetails就是当前登录用户信息,它也是框架中的常用接口之一。</span></span><br><span class="line">	<span class="function">Object <span class="title">getPrincipal</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>UserDetailsService</strong></p>
<p>现在咱们现在知道DaoAuthenticationProvider处理了web表单的认证逻辑,认证成功后既得到一个Authentication(UsernamePasswordAuthenticationToken实现),里面包含了身份信息(Principal)。这个身份信息就是一个 Object ,大多数情况下它可以被强转为UserDetails对象。</p>
<p>DaoAuthenticationProvider中包含了一个UserDetailsService实例,它负责根据用户名提取用户信息UserDetails(包含密码),而后DaoAuthenticationProvider会去对比UserDetailsService提取的用户密码与用户提交的密码是否匹配作为认证成功的关键依据,因此可以通过将自定义的 UserDetailsService 公开为spring bean来定义自定义身份验证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">	<span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多人把 DaoAuthenticationProvider和UserDetailsService的职责搞混淆,其实UserDetailsService只负责从特定的地方(通常是数据库)加载用户信息,仅此而已。而DaoAuthenticationProvider的职责更大,它完成完整的认证流程,同时会把UserDetails填充至Authentication。</p>
<p>上面一直提到UserDetails是用户信息,咱们看一下它的真面目:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它和Authentication接口很类似,比如它们都拥有username,authorities。Authentication的getCredentials()与UserDetails中的getPassword()需要被区分对待,前者是用户提交的密码凭证,后者是用户实际存储的密码,认证其实就是对这两者的比对。Authentication中的getAuthorities()实际是由UserDetails的getAuthorities()传递而形成的。还记得Authentication接口中的getDetails()方法吗?其中的UserDetails用户详细信息便是经过了AuthenticationProvider认证之后被填充的。</p>
<p>通过实现UserDetailsService和UserDetails,我们可以完成对用户信息获取方式以及用户信息字段的扩展。Spring Security提供的InMemoryUserDetailsManager(内存认证),JdbcUserDetailsManager(jdbc认证)就是UserDetailsService的实现类,主要区别无非就是从内存还是从数据库加载用户。</p>
<p>自定义UserDetailsService:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDataUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">//登录账号</span></span><br><span class="line">        System.out.println(<span class="string">&quot;username=&quot;</span> + username);</span><br><span class="line"><span class="comment">//根据账号去数据库查询...</span></span><br><span class="line"><span class="comment">//这里暂时使用静态数据</span></span><br><span class="line">        UserDetails userDetails =</span><br><span class="line">                User.withUsername(username).password(<span class="string">&quot;123&quot;</span>).authorities(<span class="string">&quot;p1&quot;</span>).build();</span><br><span class="line">        <span class="keyword">return</span> userDetails;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>屏蔽安全配置类中 UserDetailsService的定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public UserDetailsService userDetailsService() &#123;</span></span><br><span class="line"><span class="comment">//        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();</span></span><br><span class="line"><span class="comment">//        manager.createUser(User.withUsername(&quot;zhangsan&quot;).password(&quot;123&quot;).authorities(&quot;p1&quot;).build());</span></span><br><span class="line"><span class="comment">//        manager.createUser(User.withUsername(&quot;lisi&quot;).password(&quot;456&quot;).authorities(&quot;p2&quot;).build());</span></span><br><span class="line"><span class="comment">//        return manager;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br></pre></td></tr></table></figure>

<p>重启工程,请求认证,SpringDataUserDetailsService的loadUserByUsername方法被调用 ,查询用户信息。</p>
<h5 id="PasswordEncoder"><a href="#PasswordEncoder" class="headerlink" title="PasswordEncoder"></a>PasswordEncoder</h5><p>DaoAuthenticationProvider认证处理器通过UserDetailsService获取到UserDetails后,它是如何与请求Authentication中的密码做对比呢?</p>
<p>在这里Spring Security为了适应多种多样的加密类型,又做了抽象,DaoAuthenticationProvider通过PasswordEncoder接口的matches方法进行密码的对比,而具体的密码对比细节取决于实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PasswordEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">encode</span><span class="params">(CharSequence rawPassword)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">upgradeEncoding</span><span class="params">(String encodedPassword)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而Spring Security提供很多内置的PasswordEncoder,能够开箱即用,使用某种PasswordEncoder只需要进行如下声明即可,如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> NoOpPasswordEncoder.getInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NoOpPasswordEncoder采用字符串匹配方法,不对密码进行加密比较处理,密码比较流程如下:</p>
<ol>
<li>用户输入密码(明文 )</li>
<li>DaoAuthenticationProvider获取UserDetails(其中存储了用户的正确密码)</li>
<li>DaoAuthenticationProvider使用PasswordEncoder对输入的密码和正确的密码进行校验,密码一致则校验通<br>过,否则校验失败。</li>
</ol>
<p>NoOpPasswordEncoder 的校验规则拿 输入的密码和UserDetails中的正确密码进行字符串比较,字符串内容一致则校验通过,否则校验失败。</p>
<p>实际项目中推荐使用BCryptPasswordEncoder, Pbkdf2PasswordEncoder, SCryptPasswordEncoder等,感兴趣的大家可以看看这些PasswordEncoder的具体实现。</p>
<p><strong>spring security 5</strong></p>
<p>在最新的 Spring Security 5发布版本中, 出于安全性的考虑调整了PasswordEncoder的实现与使用策略.</p>
<ol>
<li><p>以前常用的实现 StandardPasswordEncoder, MessageDigestPasswordEncoder, StandardPasswordEncoder 不再推荐使用, 全加上了@Deprecated ,并有具体的说明，推荐使用BCryptPasswordEncoder, Pbkdf2PasswordEncoder, SCryptPasswordEncoder等</p>
</li>
<li><p>增加 PasswordEncoderFactories 类提供一个静态方法 createDelegatingPasswordEncoder()方法, 使用委托方式创建PasswordEncoder的实现，在此方法的实现中,实际上使用了 BCryptPasswordEncoder 作为默认的实现(我想, 这也是Spring Security团队推荐使用的吧).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org/springframework/security/crypto/factory/PasswordEncoderFactories.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PasswordEncoder <span class="title">createDelegatingPasswordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String encodingId = <span class="string">&quot;bcrypt&quot;</span>;</span><br><span class="line">	Map&lt;String, PasswordEncoder&gt; encoders = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	encoders.put(encodingId, <span class="keyword">new</span> BCryptPasswordEncoder());</span><br><span class="line">	encoders.put(<span class="string">&quot;ldap&quot;</span>, <span class="keyword">new</span> org.springframework.security.crypto.password.LdapShaPasswordEncoder());</span><br><span class="line">	encoders.put(<span class="string">&quot;MD4&quot;</span>, <span class="keyword">new</span> org.springframework.security.crypto.password.Md4PasswordEncoder());</span><br><span class="line">	encoders.put(<span class="string">&quot;MD5&quot;</span>, <span class="keyword">new</span> org.springframework.security.crypto.password.MessageDigestPasswordEncoder(<span class="string">&quot;MD5&quot;</span>));</span><br><span class="line">	encoders.put(<span class="string">&quot;noop&quot;</span>, org.springframework.security.crypto.password.NoOpPasswordEncoder.getInstance());</span><br><span class="line">	encoders.put(<span class="string">&quot;pbkdf2&quot;</span>, <span class="keyword">new</span> Pbkdf2PasswordEncoder());</span><br><span class="line">	encoders.put(<span class="string">&quot;scrypt&quot;</span>, <span class="keyword">new</span> SCryptPasswordEncoder());</span><br><span class="line">	encoders.put(<span class="string">&quot;SHA-1&quot;</span>, <span class="keyword">new</span> org.springframework.security.crypto.password.MessageDigestPasswordEncoder(<span class="string">&quot;SHA-1&quot;</span>));</span><br><span class="line">	encoders.put(<span class="string">&quot;SHA-256&quot;</span>, <span class="keyword">new</span> org.springframework.security.crypto.password.MessageDigestPasswordEncoder(<span class="string">&quot;SHA-256&quot;</span>));</span><br><span class="line">	encoders.put(<span class="string">&quot;sha256&quot;</span>, <span class="keyword">new</span> org.springframework.security.crypto.password.StandardPasswordEncoder());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DelegatingPasswordEncoder(encodingId, encoders);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>关于加密salt(盐值)的变化. 在之前的使用中, 一般在使用时自己指定salt值,一个配置示例如下:</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/12/19/I5qGjog2bSrlfV1.png" alt="UTOOLS1576737719093.png"></p>
<p>而在新的使用中, salt的实现 将由各具体实现类去处理(如使用随机生成的值)</p>
</li>
</ol>
<p>BCrypt 密码散列函数的概念介绍可以看一下维基百科或百度百科的内容 （因为只是使用，暂时不需要对算法的了解和实现）</p>
<blockquote>
<p>维基百科：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Bcrypt">BCrypt</a></p>
</blockquote>
<blockquote>
<p>百度百科：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Bcrypt">BCrypt</a></p>
</blockquote>
<p>加密/解密 与 Hash 这两个概念不能混淆，比如：SHA 系列是 Hash 算法，不是加密算法，加密意味着可以解密，但是 Hash 是不可逆的（无法通过 Hash 值还原得到密码，只能比对 Hash 值看看是否相等）。</p>
<p>目前很大一部分存在安全问题的系统一般仅仅使用密码的 MD5 值进行保存，可以通过 MD5 查询库去匹配对大部分的密码（可以直接从彩虹表里反推出来），而且 MD5 计算 Hash 值碰撞容易构造，安全性大大降低。MD5 加盐在本地计算速度也是很快，也是密码短也是极其容易破解；更好的选择是 SHA-256、BCrypt 等等等</p>
<p><strong>使用</strong></p>
<p>使用BCryptPasswordEncoder:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在安全配置类中定义</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>修改SpringDataUserDetailsService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDataUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;username=&quot;</span> + s);</span><br><span class="line">        UserDetails user = User</span><br><span class="line">                .builder()</span><br><span class="line">                .username(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line"><span class="comment">//                .password(&quot;123&quot;)</span></span><br><span class="line">                .password(<span class="string">&quot;$2a$10$1b5mIkehqv5c4KRrX9bUj.A4Y2hug3IGCnMCL5i4RpQrYV12xNKye&quot;</span>)</span><br><span class="line">                .authorities(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<p>如果是使用 BCryptPasswordEncoder 调用 encode() 方法编码输入密码的话，其实这个编码后的“密码”并不是我们平时输入的真正密码，而是密码加盐后的通过单向 Hash 算法（BCrypt）得到值。</p>
<p>这里面细心的同学可能会发现一些问题：</p>
<ul>
<li>同一个密码计算 Hash 不应该是一样的吗？每次使用 BCryptPasswordEncoder 编码同一个密码都是不一样的？</li>
<li>BCryptPasswordEncoder 编码同一个密码后结果都不一样，怎么进行匹配？</li>
</ul>
<p>下面通过源码简单说一下这个匹配的流程：<br><code>matches(CharSequence rawPassword, String encodedPassword)</code> 方法根据两个参数都可以知道</p>
<ul>
<li>第一个参数是原密码</li>
<li>第二个参数就是用 PasswordEncoder 调用 <code>encode(CharSequence rawPassword)</code> 编码过后保存在数据库的密码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org/springframework/security/crypto/bcrypt/BCryptPasswordEncoder.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (encodedPassword == <span class="keyword">null</span> || encodedPassword.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Empty encoded password&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!BCRYPT_PATTERN.matcher(encodedPassword).matches()) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Encoded password does not look like BCrypt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> BCrypt.checkpw(rawPassword.toString(), encodedPassword);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码解读：首先判断是否数据库保存的“密码”（后面简称：“密码”）是否为空或者 <code>null</code> ，在通过正则表达式匹配“密码”是否符合格式，最后通过 <code>BCrypt</code> 的 <code>checkpw(String plaintext, String hashed)</code> 方法进行密码匹配</p>
<p>再详细看看 <code>BCrypt</code> 的 <code>checkpw(String plaintext, String hashed)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org/springframework/security/crypto/bcrypt/BCrypt.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkpw</span><span class="params">(String plaintext, String hashed)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> equalsNoEarlyReturn(hashed, hashpw(plaintext, hashed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二个参数 hashed 表明其实数据库查询出来的“密码”也就是 Hash 值；<code>equalsNoEarlyReturn(hashed, hashpw(plaintext, hashed))</code> 代码中通过调用 hashpw 计算输入密码的 Hash 值（参数分别是输入的密码和保存在数据库的“密码”）</p>
<p>再继续看 <code>hashpw</code> 里面的部分代码（内容过长，省略部分代码，看看代码中的中文注释）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org/springframework/security/crypto/bcrypt/BCrypt.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hashpw</span><span class="params">(String password, String salt)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">	BCrypt B;</span><br><span class="line">	String real_salt;</span><br><span class="line">	<span class="keyword">byte</span> passwordb[], saltb[], hashed[];</span><br><span class="line">	<span class="keyword">char</span> minor = (<span class="keyword">char</span>) <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> rounds, off = <span class="number">0</span>;</span><br><span class="line">	StringBuilder rs = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (salt == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;salt cannot be null&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> saltLength = salt.length();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (saltLength &lt; <span class="number">28</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid salt&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (salt.charAt(<span class="number">0</span>) != <span class="string">&#x27;$&#x27;</span> || salt.charAt(<span class="number">1</span>) != <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid salt version&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (salt.charAt(<span class="number">2</span>) == <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">		off = <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		minor = salt.charAt(<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (minor != <span class="string">&#x27;a&#x27;</span> || salt.charAt(<span class="number">3</span>) != <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid salt revision&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		off = <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (saltLength - off &lt; <span class="number">25</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid salt&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Extract number of rounds</span></span><br><span class="line">	<span class="keyword">if</span> (salt.charAt(off + <span class="number">2</span>) &gt; <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Missing salt rounds&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	rounds = Integer.parseInt(salt.substring(off, off + <span class="number">2</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 关键点：上面***一大堆就是校验是否符合相应格式，然后下面这行就是取出密码的盐，real_salt就是 Hash 计算前的密码盐（关于盐的介绍：https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6)）</span></span><br><span class="line">    </span><br><span class="line">	real_salt = salt.substring(off + <span class="number">3</span>, off + <span class="number">25</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		passwordb = (password + (minor &gt;= <span class="string">&#x27;a&#x27;</span> ? <span class="string">&quot;\000&quot;</span> : <span class="string">&quot;&quot;</span>)).getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (UnsupportedEncodingException uee) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;UTF-8 is not supported&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	saltb = decode_base64(real_salt, BCRYPT_SALT_LEN);</span><br><span class="line"></span><br><span class="line">	B = <span class="keyword">new</span> BCrypt();</span><br><span class="line">	hashed = B.crypt_raw(passwordb, saltb, rounds);</span><br><span class="line"></span><br><span class="line">	rs.append(<span class="string">&quot;$2&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (minor &gt;= <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">		rs.append(minor);</span><br><span class="line">	&#125;</span><br><span class="line">	rs.append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (rounds &lt; <span class="number">10</span>) &#123;</span><br><span class="line">		rs.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	rs.append(rounds);</span><br><span class="line">	rs.append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">	encode_base64(saltb, saltb.length, rs);</span><br><span class="line">	encode_base64(hashed, bf_crypt_ciphertext.length * <span class="number">4</span> - <span class="number">1</span>, rs);</span><br><span class="line">	<span class="keyword">return</span> rs.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实上面代码就是从数据库得到的“密码”（参数： salt ）进行一系列校验（长度校验等）并截取“密码”中相应的密码盐，利用这个密码盐进行同样的一系列计算 Hash 操作和 Base64 编码拼接一些标识符 生成所谓的“密码”，最后 <code>equalsNoEarlyReturn</code> 方法对同一个密码盐生成的两个“密码”进行匹配。</p>
<p>上述大致就是密码匹配流程了，对于问题<code>“ BCryptPasswordEncoder 编码同一个密码后结果都不一样，怎么进行匹配”</code>的简单解答:</p>
<blockquote>
<p>因为密码盐是随机生成的，但是可以根据数据库查询出来的“密码”拿到密码盐，同一个密码盐+原密码计算 Hash 结果值是能匹配的。</p>
</blockquote>
<p>看看加密的一个过程，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org/springframework/security/crypto/bcrypt/BCryptPasswordEncoder.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(CharSequence rawPassword)</span> </span>&#123;</span><br><span class="line">	String salt;</span><br><span class="line">	<span class="keyword">if</span> (strength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (random != <span class="keyword">null</span>) &#123;</span><br><span class="line">		    <span class="comment">// 生成随机密码盐</span></span><br><span class="line">			salt = BCrypt.gensalt(strength, random);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">		    <span class="comment">// 生成随机密码盐</span></span><br><span class="line">			salt = BCrypt.gensalt(strength);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="comment">// 生成随机密码盐</span></span><br><span class="line">		salt = BCrypt.gensalt();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> BCrypt.hashpw(rawPassword.toString(), salt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>encode 方法传入是原密码，其中 <code>int strength, SecureRandom random</code> 这两个构造参数是 <code>BCryptPasswordEncoder(int strength, SecureRandom random)</code> 构造方法按需传入，如果不指定strength和random，默认执行 <code>BCrypt.gensalt()</code> 这行代码生成也相应密码随机盐。</p>
<p>先看看 <code>gensalt(int log_rounds, SecureRandom random)</code> 方法的代码（可以看看中文注释）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org/springframework/security/crypto/bcrypt/BCrypt.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">gensalt</span><span class="params">(<span class="keyword">int</span> log_rounds, SecureRandom random)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一些检验</span></span><br><span class="line">	<span class="keyword">if</span> (log_rounds &lt; MIN_LOG_ROUNDS || log_rounds &gt; MAX_LOG_ROUNDS) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Bad number of rounds&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	StringBuilder rs = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">byte</span> rnd[] = <span class="keyword">new</span> <span class="keyword">byte</span>[BCRYPT_SALT_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成随机字节并将其置于rnd字节数组</span></span><br><span class="line">	random.nextBytes(rnd);</span><br><span class="line"></span><br><span class="line">	rs.append(<span class="string">&quot;$2a$&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (log_rounds &lt; <span class="number">10</span>) &#123;</span><br><span class="line">	    <span class="comment">// 不够长度补够</span></span><br><span class="line">		rs.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 拼接字符串得到相应的格式</span></span><br><span class="line">	rs.append(log_rounds);</span><br><span class="line">	rs.append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">	encode_base64(rnd, rnd.length, rs);</span><br><span class="line">	<span class="keyword">return</span> rs.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终上面的 <code>gensalt</code> 方法得到一个 随机密码盐+无用字符串（这个字符串可以理解为你输入的密码） 计算 Hash 操作和 Base64 编码拼接一些标识符 生成假“密码”（这个假“密码”为了兼容方便调用 <code>hashpw</code> 方法），最后关键点就是调用 <code>BCrypt.hashpw</code> 方法取到密码盐生成相应的真实“密码”（这个得到的密码可以用于保存在数据库中了）。</p>
<p>对于问题<code>“同一个密码计算 Hash 不应该是一样的吗？每次使用 BCryptPasswordEncoder 编码同一个密码都是不一样的？”</code>的简单解答：</p>
<blockquote>
<p>因为用到的随机密码盐每次都是不一样的，同一个密码和不同的密码盐组合计算出来的 Hash 值肯定不一样啦，所以编码同一个密码得到的结果都是不一样。</p>
</blockquote>
<p>登录注册是每个系统都具备的功能，开发的同学记住一定不能保存明文密码，否则被脱库就会造成严重的后果。如果是通过上述的方法进行密码保存，即便拿到“密码”也非常难还原密码。</p>
<p>上述在密码编码的过程中的思想还是需要掌握：</p>
<ol>
<li>只是保存散列码是不安全的，但是我们可以为密码加盐再通过一些 Hash 值 低概率碰撞且计算速度慢 的散列算法计算 Hash 值保存。</li>
<li>Spring Security 每次 Hash 之前用的盐都是随机，盐可以保存在最终生成的“密码”中，这样每个密码都是用了相应不同的随机盐+原密码计算 Hash 值得到，暴力破解难度也变大了。</li>
</ol>
<h5 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h5><p>Spring Security可以通过 http.authorizeRequests() 对web请求进行授权保护。Spring Security使用标准Filter建立了对web请求的拦截,最终实现对资源的授权访问。</p>
<p>Spring Security的授权流程如下:</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/12/19/Vf7UBSHDQvOlykd.png" alt="UTOOLS1576738453686.png"></p>
<ol>
<li><p>拦截请求,已认证用户访问受保护的web资源将被SecurityFilterChain中的 FilterSecurityInterceptor 的子类拦截。</p>
</li>
<li><p>获取资源访问策略,FilterSecurityInterceptor会从 SecurityMetadataSource 的子类DefaultFilterInvocationSecurityMetadataSource 获取要访问当前资源所需要的权限Collection&lt;ConfigAttribute&gt; 。</p>
<p>SecurityMetadataSource其实就是读取访问策略的抽象,而读取的内容,其实就是我们配置的访问规则, 读取访问策略如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">.authorizeRequests()</span><br><span class="line">.antMatchers(<span class="string">&quot;/r/r1&quot;</span>).hasAuthority(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line">.antMatchers(<span class="string">&quot;/r/r2&quot;</span>).hasAuthority(<span class="string">&quot;p2&quot;</span>)</span><br><span class="line">.antMatchers(<span class="string">&quot;/r/**&quot;</span>).authenticated()</span><br><span class="line">.anyRequest().permitAll()</span><br></pre></td></tr></table></figure></li>
<li><p>最后,FilterSecurityInterceptor会调用 AccessDecisionManager 进行授权决策,若决策通过,则允许访问资源,否则将禁止访问。</p>
</li>
</ol>
<p>AccessDecisionManager(访问决策管理器)的核心接口如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 通过传递的参数来决定用户是否有访问对应受保护资源的权限</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object object,</span></span></span><br><span class="line"><span class="params"><span class="function">			Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException,</span></span><br><span class="line"><span class="function">			InsufficientAuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里着重说明一下decide的参数:</p>
<ul>
<li>authentication:要访问资源的访问者的身份</li>
<li>object:要访问的受保护资源,web请求对应FilterInvocation</li>
<li>configAttributes:是受保护资源的访问策略,通过SecurityMetadataSource获取。</li>
</ul>
<p>decide接口就是用来鉴定当前用户是否有访问对应受保护资源的权限。</p>
<p><strong>授权决策</strong></p>
<p>AccessDecisionManager采用<strong>投票</strong>的方式来确定是否能够访问受保护资源。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/12/19/QwA9hnmzcb7KZCH.png" alt="UTOOLS1576738705217.png"></p>
<p>通过上图可以看出,AccessDecisionManager中包含的一系列AccessDecisionVoter将会被用来对Authentication是否有权访问受保护对象进行投票,AccessDecisionManager根据投票结果,做出最终决策。</p>
<p>AccessDecisionVoter是一个接口,其中定义有三个方法,具体结构如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessDecisionVoter</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ACCESS_GRANTED = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> ACCESS_ABSTAIN = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ACCESS_DENIED = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">vote</span><span class="params">(Authentication authentication, S object,</span></span></span><br><span class="line"><span class="params"><span class="function">			Collection&lt;ConfigAttribute&gt; attributes)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vote()方法的返回结果会是AccessDecisionVoter中定义的三个常量之一。ACCESS_GRANTED表示同意,ACCESS_DENIED表示拒绝,ACCESS_ABSTAIN表示弃权。如果一个AccessDecisionVoter不能判定当前Authentication是否拥有访问对应受保护对象的权限,则其vote()方法的返回值应当为弃权ACCESS_ABSTAIN。</p>
<p>Spring Security内置了三个基于投票的AccessDecisionManager实现类如下,它们分别是AffirmativeBased、ConsensusBased和UnanimousBased</p>
<p>AffirmativeBased的逻辑是:</p>
<ol>
<li>只要有AccessDecisionVoter的投票为ACCESS_GRANTED则同意用户进行访问;</li>
<li>如果全部弃权也表示通过;</li>
<li>如果没有一个人投赞成票,但是有人投反对票,则将抛出AccessDeniedException。</li>
</ol>
<p>Spring security默认使用的是AffirmativeBased。</p>
<p>ConsensusBased的逻辑是:</p>
<ol>
<li>如果赞成票多于反对票则表示通过。</li>
<li>反过来,如果反对票多于赞成票则将抛出AccessDeniedException。</li>
<li>如果赞成票与反对票相同且不等于0,并且属性allowIfEqualGrantedDeniedDecisions的值为true,则表示通过,否则将抛出异常AccessDeniedException。参数allowIfEqualGrantedDeniedDecisions的值默认为true。</li>
<li>如果所有的AccessDecisionVoter都弃权了,则将视参数allowIfAllAbstainDecisions的值而定,如果该值为true则表示通过,否则将抛出异常AccessDeniedException。参数allowIfAllAbstainDecisions的值默认为false。</li>
</ol>
<p>UnanimousBased的逻辑与另外两种实现有点不一样,另外两种会一次性把受保护对象的配置属性全部传递给AccessDecisionVoter进行投票,而UnanimousBased会一次只传递一个ConfigAttribute给AccessDecisionVoter进行投票。这也就意味着如果我们的AccessDecisionVoter的逻辑是只要传递进来的ConfigAttribute中有一个能够匹配则投赞成票,但是放到UnanimousBased中其投票结果就不一定是赞成了。</p>
<p>UnanimousBased的逻辑具体来说是这样的:</p>
<ol>
<li>如果受保护对象配置的某一个ConfigAttribute被任意的AccessDecisionVoter反对了,则将抛出AccessDeniedException。</li>
<li>如果没有反对票,但是有赞成票,则表示通过。</li>
<li>如果全部弃权了,则将视参数allowIfAllAbstainDecisions的值而定,true则通过,false则抛出AccessDeniedException。</li>
</ol>
<p>Spring Security也内置一些投票者实现类如RoleVoter、AuthenticatedVoter和WebExpressionVoter等,可以自行查阅资料进行学习。</p>
<p><strong>权限表达式</strong></p>
<p>springsecurity是通过权限表达式控制授权，springsecurity的权限表达式及说明如下：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/12/19/Y9wxbMdrX2GcqkW.png" alt="UTOOLS1576739076644.png"></p>
<p><strong>自定义认证</strong></p>
<p>Spring Security提供了非常好的认证扩展方法,比如:快速上手中将用户信息存储到内存中,实际开发中用户信息通常在数据库,Spring security可以实现从数据库读取用户信息,Spring security还支持多种授权方法。</p>
<p>上面的示例中我们并没有提供任何的HTML或JSP文件。Spring Security的默认配置没有明确设定一个登录页面的URL,因此Spring Security会根据启用的功能自动生成一个登录页面URL,并使用默认URL处理登录的提交内容,登录后跳转的到默认URL等等。尽管自动生成的登录页面很方便快速启动和运行,但大多数应用程序都希望定义自己的登录页面。</p>
<p>项目参考：<a target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521/learn-sercurity/tree/master/security-spring-boot">https://github.com/hanyunpeng0521/learn-sercurity/tree/master/security-spring-boot</a></p>
<p>spring boot运行jsp需要添加依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 添加servlet依赖模块 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 添加jstl标签库依赖模块 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加tomcat依赖模块.--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用jsp引擎，springboot内置tomcat没有此依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中最主要的，提供jsp引擎的就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tomcat-embed-jasper这个依赖(一定要加)</span><br></pre></td></tr></table></figure>

<p>然后修改配置文件中的Jsp文件访问路径(视图解析)</p>
<p>在application.properties文件中加入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.view.prefix=/WEB-INF/jsp/</span><br><span class="line">spring.mvc.view.suffix=.jsp</span><br></pre></td></tr></table></figure>

<p>配置完成后在webapp/WEB-INF/jsp文件夹下放jsp文件(必须有webapp/WEB-INF这个包，否则访问不到)<br>然后使用<code>mvn spring-boot:run</code>运行</p>
<p><strong>SpringSecurity处理CSRF攻击</strong></p>
<p><code>CSRF（Cross-site request forgery）</code>跨站请求伪造，也被称为<code>One Click Attack</code>或者<code>Session Riding</code>，通常缩写为<code>CSRF</code>或<code>XSRF</code>，是一种对网站的恶意利用。尽管听起来像跨站脚本（<code>XSS</code>），但它与<code>XSS</code>非常不同，<code>XSS</code>利用站点内的信任用户，而<code>CSRF</code>则通过伪装成受信任用户的请求来利用受信任的网站。与<code>XSS</code>攻击相比，<code>CSRF</code>攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比<code>XSS</code>更具危险性。</p>
<p><code>CSRF</code>是一种依赖web浏览器的、被混淆过的代理人攻击（<code>deputy attack</code>）。</p>
<ol>
<li><p>配置过滤器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置CSRF过滤器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> org.springframework.boot.web.servlet.FilterRegistrationBean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;CsrfFilter&gt; <span class="title">csrfFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FilterRegistrationBean&lt;CsrfFilter&gt; registration = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class="line">  registration.setFilter(<span class="keyword">new</span> CsrfFilter(<span class="keyword">new</span> HttpSessionCsrfTokenRepository()));</span><br><span class="line">  registration.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">  registration.setName(<span class="string">&quot;csrfFilter&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在form请求中添加CSRF的隐藏字段</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;(_csrf.parameterName)&#125;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;(_csrf.token)&#125;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在AJAX请求中添加header头</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">&quot;$&#123;_csrf.headerName&#125;&quot;</span>, <span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>jQuery的Ajax全局配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajaxSetup(&#123;</span><br><span class="line">  <span class="string">&quot;beforeSend&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params">request</span>) </span>&#123;</span><br><span class="line">    request.setRequestHeader(<span class="string">&quot;$&#123;_csrf.headerName&#125;&quot;</span>, <span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>另外一种方法则是直接关闭csrf认证，不推荐</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">//关闭默认的csrf认证</span></span><br><span class="line">        http.csrf().disable();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>连接数据库认证</strong></p>
<p>前边的例子我们是将用户信息存储在内存中,实际项目中用户信息存储在数据库中，根据前边对认证流程研究,只需要重新定义UserDetailService即可实现根据用户账号查询数据库。</p>
<p>这里使用H2数据库</p>
<p>pom文件添加文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐starter‐jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.200<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.properties文件添加</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url<span class="operator">=</span>jdbc:h2:mem:test_db</span><br><span class="line">spring.datasource.driverClassName<span class="operator">=</span>org.h2.Driver</span><br><span class="line">spring.datasource.username<span class="operator">=</span>root</span><br><span class="line">spring.datasource.password<span class="operator">=</span><span class="number">123456</span></span><br><span class="line">spring.datasource.schema<span class="operator">=</span>classpath:db<span class="operator">/</span>schema.sql</span><br><span class="line">spring.datasource.data<span class="operator">=</span>classpath:db<span class="operator">/</span>data.sql</span><br><span class="line">spring.h2.console.enabled<span class="operator">=</span><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>在db文件夹下创建schema.sql</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user`</span><br><span class="line">(</span><br><span class="line">  `id`       <span class="type">int</span>   <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">64</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">64</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `fullname` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户姓名&#x27;</span>,</span><br><span class="line">  `mobile`   <span class="type">varchar</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机号&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在db文件夹下创建data.sql</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;$2a$10$1b5mIkehqv5c4KRrX9bUj.A4Y2hug3IGCnMCL5i4RpQrYV12xNKye&#x27;</span>,&quot;张三&quot;,<span class="string">&#x27;13811114444&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>定义模型类型,在 model包定义UserDto:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDto</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String fullname;</span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在dao包定义UserDao:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDto <span class="title">getUserByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select id,username,password,fullname from t_user where username = ?&quot;</span>;</span><br><span class="line">        List&lt;UserDto&gt; list = jdbcTemplate.query(sql, <span class="keyword">new</span> Object[]&#123;username&#125;, <span class="keyword">new</span></span><br><span class="line">                BeanPropertyRowMapper&lt;&gt;(UserDto.class));</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span> &amp;&amp; list.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改：SpringDataUserDetailsService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDataUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;username=&quot;</span> + s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据账号去数据库查询...</span></span><br><span class="line">        UserDto user = userDao.getUserByUsername(s);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里暂时使用静态数据</span></span><br><span class="line">        UserDetails userDetails =</span><br><span class="line">                User.withUsername(user.getFullname()).password(user.getPassword()).authorities(<span class="string">&quot;p1&quot;</span>).build();</span><br><span class="line">        <span class="keyword">return</span> userDetails;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h5><p>用户认证通过后,为了避免用户的每次操作都进行认证可将用户的信息保存在会话中。spring security提供会话管理,认证通过后将身份信息放入SecurityContextHolder上下文,SecurityContext与当前线程进行绑定,方便获取用户身份。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/login‐success&quot;, produces = &#123;&quot;text/plain;charset=utf8&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">loginSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String username = getUsername();</span><br><span class="line">    <span class="keyword">return</span> username + <span class="string">&quot; 登录成功&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前登录用户名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">    <span class="keyword">if</span> (!authentication.isAuthenticated()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object principal = authentication.getPrincipal();</span><br><span class="line">    String username = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (principal <span class="keyword">instanceof</span> org.springframework.security.core.userdetails.UserDetails) &#123;</span><br><span class="line">        username =</span><br><span class="line">                ((org.springframework.security.core.userdetails.UserDetails) principal).getUsername();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        username = principal.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过以下选项准确控制会话何时创建以及Spring Security如何与之交互:</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/12/19/WFzVAvlh4tHQZg6.png" alt="UTOOLS1576747040198.png"></p>
<p>通过以下配置方式对该选项进行配置:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//会话控制</span></span><br><span class="line">    http.sessionManagement()</span><br><span class="line">            .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认情况下,Spring Security会为每个登录成功的用户会新建一个Session,就是ifRequired 。</p>
<p>若选用never,则指示Spring Security对登录成功的用户不创建Session了,但若你的应用程序在某地方新建了session,那么Spring Security会用它的。</p>
<p>若使用stateless,则说明Spring Security对登录成功的用户不会创建Session了,你的应用程序也不会允许新建session。并且它会暗示不使用cookie,所以每个请求都需要重新进行身份验证。这种无状态架构适用于REST API及其无状态认证机制。</p>
<ol>
<li><p>会话超时</p>
<p>可以再sevlet容器中设置Session的超时时间,如下设置Session有效期为3600s;</p>
<p>spring boot 配置文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.servlet.session.timeout=3600s</span><br></pre></td></tr></table></figure>

<p>session超时之后,可以通过Spring Security 设置跳转的路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.sessionManagement()</span><br><span class="line">.expiredUrl(<span class="string">&quot;/login‐view?error=EXPIRED_SESSION&quot;</span>)</span><br><span class="line">.invalidSessionUrl(<span class="string">&quot;/login‐view?error=INVALID_SESSION&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>expired指session过期,invalidSession指传入的sessionid无效。</p>
</li>
<li><p>安全会话cookie</p>
<p>我们可以使用httpOnly和secure标签来保护我们的会话cookie:</p>
<ul>
<li>httpOnly :如果为true,那么浏览器脚本将无法访问cookie</li>
<li>secure :如果为true,则cookie将仅通过HTTPS连接发送</li>
</ul>
<p>spring boot 配置文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.servlet.session.cookie.http‐only=true</span><br><span class="line">server.servlet.session.cookie.secure=true</span><br></pre></td></tr></table></figure></li>
<li><p>会话固定攻击：利用服务器会话不变机制，借他人之手获取认证和授权，然后冒充他人。举例如下：</p>
<ol>
<li>A先打开一个网站 “<a target="_blank" rel="noopener" href="http://unsafe&quot;,然后服务器会回复他一个session/">http://unsafe&quot;，然后服务器会回复他一个session</a> id。比session id=mjg4qid0wioq, Mallory把这个id记下了;</li>
<li>A给B发送一个电子邮件，他假装是银行在宣传自己的新业务，例如，我行推出了一项新服务，率先体验请点击：”<a target="_blank" rel="noopener" href="http://unsafe/?sessionId=mjg4qid0wioq&quot;%EF%BC%8CsessionId%E5%90%8E%E9%9D%A2%E6%98%AFA%E8%87%AA%E5%B7%B1%E7%9A%84session">http://unsafe/?sessionId=mjg4qid0wioq&quot;，sessionId后面是A自己的session</a> id; </li>
<li>Alice被吸引了，点击了”<a target="_blank" rel="noopener" href="http://unsafe/?sessionId=mjg4qid0wioq&quot;%EF%BC%8C%E5%83%8F%E5%BE%80%E5%B8%B8%E4%B8%80%E6%A0%B7%EF%BC%8C%E8%BE%93%E5%85%A5%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84%E5%B8%90%E5%8F%B7%E5%92%8C%E5%8F%A3%E4%BB%A4%E4%BB%8E%E8%80%8C%E7%99%BB%E5%BD%95%E5%88%B0%E9%93%B6%E8%A1%8C%E7%BD%91%E7%AB%99">http://unsafe/?sessionId=mjg4qid0wioq&quot;，像往常一样，输入了自己的帐号和口令从而登录到银行网站</a>;</li>
<li>因为服务器的session id不改变，现在A点击”<a target="_blank" rel="noopener" href="http://unsafe/?SID=mjg4qid0wioq&quot;%E5%90%8E%EF%BC%8C%E4%BB%96%E5%B0%B1%E6%8B%A5%E6%9C%89%E4%BA%86B%E7%9A%84%E8%BA%AB%E4%BB%BD%E3%80%82%E5%8F%AF%E4%BB%A5%E4%B8%BA%E6%89%80%E6%AC%B2%E4%B8%BA%E4%BA%86%E3%80%82">http://unsafe/?SID=mjg4qid0wioq&quot;后，他就拥有了B的身份。可以为所欲为了。</a> </li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/19/Qqci4K.png" alt="Qqci4K.png"></p>
<p>spring security默认是开通session fixation防护的，如果想显示开通，可以通过以下代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.sessionManagement().sessionFixation().migrateSession()</span><br></pre></td></tr></table></figure>

<p>spring 防护的原理为，每当用户认证过后，就会重新生成一个新的session，并抛弃旧的session，下图是spring security的防护原理：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/19/QqcGvQ.png" alt="QqcGvQ.png"></p>
<p>从上图中可知，SessionManagementFilter负责检查一个用户是否是新认证的用户，如果是则会调用接口SessionAuthenticationStrategy进行处理，SessionAuthenticationStrategy的实现类SessionFixationProtectionStrategy会为用户创建一个新的session 同时丢弃旧的session。</p>
<p>spring security session的几个方法选项：</p>
<ul>
<li>none() 关闭spring security的session防护功能，spring不会配置SessionManagementFilter类；</li>
<li>migrateSession() 用户认证之后，会重新创建一个新的session，并且将旧session中的属性，迁移到新的session中；</li>
<li>newSession（）用户认证之后，会新创建一个session，但是不会将旧的session中的属性，迁移到新的session中</li>
</ul>
</li>
<li><p>单用户并发session控制</p>
<p>确保单个用户的单个账号，只有一个活跃的session，这也是一个常见的需求，先看下在Security.java中的代码配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http.sessionManagement().maximumSessions(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HttpSessionEventPublisher</span> <span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">new</span> HttpSessionEventPublisher();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>并发控制的原理</strong></p>
<p>Spring security使用SessionRegistry来维护一个列表，列表记录了每一个活跃的session以及与之相关的认证用户，当session的生命周期发生变化时，容器会产生一个HttpSessionEventPublisher事件，SessionRegistry捕获到HttpSessionEventPublisher事件，并实时地更新列表。当用户访问一个受保护的站点时，SessionManagerFilter会通过SessionRegistry检查用户的激活session是否存在，若不存在，则将SessionRegistry中保存的激活session置为无效。另外，ConcurrentSessionFilter会识别session是否过期，若session过期则更新SessionRegistry。session的过期事件可能是由服务器产生，也可能是由ConcurrentSessionControlStrategy强制设置为过期。</p>
<p>原理图如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/19/QqcbqA.png" alt="QqcbqA.png"></p>
<p><strong>配置session过期重定位地址</strong><br>当spring security检查到session过期后，若未做任何配置，spring security会返回一个用户不友好的页面，因此我们通常需要设置一个地址，当spring security检查到session过期后，将请求重定位到我们的地址上，设置代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.sessionManagement().expiredUrl(&quot;/login&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>阻止认证而不是强制退出</p>
<p>当一个用户已经认证过了，在另外一个地方重新进行登录认证，spring security可以阻止其再次登录认证，从而保持原来的会话可用性；具体的代码设置如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.sessionManager().maximumSession(1).maxSessionsPreventsLogin(true);</span><br></pre></td></tr></table></figure>

<p>当时上述代码还存在一个问题，当用户登陆后，没有退出直接关闭浏览器，则再次打开浏览器时，此时浏览器的session若被删除的话，用户只能等到服务器的session过期后，才能再次登录。</p>
</li>
</ol>
<p><strong>一些常见问题</strong></p>
<ol>
<li>当采用传统的UserDetails认证登录时，若UserDetails的equals方法和hashcode方法没有进行有效的实现，可能会导致，同一个用户多次登录，但是不会触发登录退出事件，这是因为SessionRegistry是使用内存map来存储UserDetails的，对UserDetails的比较会调用其自身的equal方法；</li>
<li>当用户会话持久化到磁盘后，应用服务器重启时，会读取磁盘上的会话，这时已经使用有效会话登录的用户，应该是登录状态，但此时sessionRegistry的内存map是空，因此spring security会报告用户未登录，为解决该问题，有两种方法，一是自定义sessionRegistry的实现，并在容器中禁用会话持久化功能，二是必须实现容器特定的方式，以确保在启动时将持久化会话填充到内存映射中。</li>
<li>spring security较低的版本并没有在session的并发控制中实现‘记住我功能’；</li>
<li>session并发控制的缺省实现并不能用于集群环境中，因此其缺省实现是将session记录在内存map中，服务器1中记录的信息和服务器2记录的信息并不相同；</li>
</ol>
<p><strong>认证信息和HttpSession的关系</strong></p>
<ol>
<li><p>在每一个request的开始，SecurityContextPersistenceFilter负责通过SecurityContextRepository获取SecurityContext的实现；并将其设置到SecurityContextHolder中，随后可以在controller中通过SecurityContextHolder访问SecurityContext;</p>
</li>
<li><p>在请求结束，SecurityContextPersistenceFilter会从SecurityContextHolder中取出SecurityContext并将其保存到SecurityContextRepository中</p>
<p>SecurityContextRepository的缺省实现HttpSessionSecurityContextRepository，使用HttpSession检索和保存SecurityContext的实现，spring security除了只提供了一个SecurityContextRepository的实现即为HttpSessionSecurityContextRepository，但是我们可以定义自己的SecurityContextRepository实现。</p>
</li>
</ol>
<p><strong>典型的业务场景</strong></p>
<p>现在我们有这样一个业务场景，我允许用户多次登录，同时登录的用户可以查看相同的账号在不同的地方的登录session，并且对这些session进行管理，比如查看，删除等操作；如何使用spring security实现上述功能？<br>It is easy!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http.sessionManagement().maximumSession(-<span class="number">1</span>).sessionRegistry(sessionRegistryImp()).expiredUrl(<span class="string">&quot;login&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> SessionRegistry <span class="title">sessionRegistryImp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SessionRegistryImp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们就可以将SessionRegistry实例注入到Controller里面，通过SessionRegistry获取与当前认证用户相关的所有session，示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user/sessions/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sessions</span><span class="params">(Authentication authentication,Model model)</span></span>&#123;</span><br><span class="line">    List&lt;SessionInformation&gt; list=sessionRegistry.getAllSessions(authentication.getPrincipal(),<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h5><p>在WebSecurityConfig的protected void configure(HttpSecurity http)中配置:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.and()</span><br><span class="line">.logout()</span><br><span class="line">.logoutUrl(&quot;/logout&quot;)</span><br><span class="line">.logoutSuccessUrl(&quot;/login‐view?logout&quot;);</span><br></pre></td></tr></table></figure>

<p>当退出操作出发时,将发生:</p>
<ul>
<li>使 HTTP Session 无效</li>
<li>清除 SecurityContextHolder</li>
<li>跳转到 /login-view?logout</li>
</ul>
<p>但是,类似于配置登录功能,咱们可以进一步自定义退出功能:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http.</span><br><span class="line">...</span><br><span class="line">                <span class="comment">//提供系统退出支持,使用 WebSecurityConfigurerAdapter 会自动被应用</span></span><br><span class="line">                .logout()</span><br><span class="line">                <span class="comment">//设置触发退出操作的URL (默认是 /logout ).</span></span><br><span class="line">                .logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">                <span class="comment">//(3)退出之后跳转的URL。默认是 /login?logout</span></span><br><span class="line">                .logoutSuccessUrl(<span class="string">&quot;/login-view?logout&quot;</span>)</span><br><span class="line">                <span class="comment">//定制的 LogoutSuccessHandler ,用于实现用户退出成功时的处理。如果指定了这个选项那么logoutSuccessUrl() 的设置会被忽略</span></span><br><span class="line">                .logoutSuccessHandler(logoutSuccessHandler)</span><br><span class="line">                <span class="comment">//添加一个 LogoutHandler ,用于实现用户退出时的清理工作.默认 SecurityContextLogoutHandler 会被添加为最后一个 LogoutHandler</span></span><br><span class="line">                .addLogoutHandler(logoutHandler)</span><br><span class="line">                <span class="comment">//指定是否在退出时让 HttpSession 无效。 默认设置为 true。</span></span><br><span class="line">                .invalidateHttpSession(<span class="keyword">true</span>)</span><br><span class="line">    			.logoutRequestMatcher(<span class="keyword">new</span> AntPathRequestMatcher(<span class="string">&quot;/logout&quot;</span>,<span class="string">&quot;GET&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>注意:如果让logout在GET请求下生效,必须关闭防止CSRF攻击csrf().disable()。如果开启了CSRF,必须使用post方式请求/logout</p>
<p>在CSRF功能开启的情况下使用GET 去logout,该方法为HTTPSecurity的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logoutRequestMatcher(new AntPathRequestMatcher(logoutUrl, “GET”))</span><br></pre></td></tr></table></figure>

<p>此时指定了提交方法去限制logout</p>
<p><strong>logoutHandler</strong>:</p>
<p>一般来说, LogoutHandler 的实现类被用来执行必要的清理,因而他们不应该抛出异常。</p>
<p>下面是Spring Security提供的一些实现:</p>
<ul>
<li>PersistentTokenBasedRememberMeServices 基于持久化token的RememberMe功能的相关清理</li>
<li>TokenBasedRememberMeService 基于token的RememberMe功能的相关清理</li>
<li>CookieClearingLogoutHandler 退出时Cookie的相关清理</li>
<li>CsrfLogoutHandler 负责在退出时移除csrfToken</li>
<li>SecurityContextLogoutHandler 退出时SecurityContext的相关清理</li>
</ul>
<p>链式API提供了调用相应的 LogoutHandler 实现的快捷方式,比如deleteCookies()。</p>
<h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>授权的方式包括 web授权和方法授权,web授权是通过 url拦截进行授权,方法授权是通过 方法拦截进行授权。他们都会调用accessDecisionManager进行授权决策,若为web授权则拦截器为FilterSecurityInterceptor;若为方法授权则拦截器为MethodSecurityInterceptor。如果同时通过web授权和方法授权则先执行web授权,再执行方法授权,最后决策通过,则允许访问资源,否则将禁止访问</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/19/Qqfrng.png" alt="Qqfrng.png"></p>
<p>角色表:</p>
<p>在db/schame.sql中添加</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_role` (</span><br><span class="line">`id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`role_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`description` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user_role` (</span><br><span class="line">`id` <span class="type">int</span>   <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`user_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`role_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`creator` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_permission` (</span><br><span class="line">`id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`code` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;权限标识符&#x27;</span>,</span><br><span class="line">`description` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">`url` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;请求地址&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_role_permission` (</span><br><span class="line">`id` <span class="type">int</span>   <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`role_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`permission_id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在db/data.sql添加</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span></span><br><span class="line"><span class="keyword">into</span> `t_role`(`id`, `role_name`, `description`, `create_time`, `update_time`, `status`)</span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;管理员&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span></span><br><span class="line"><span class="keyword">into</span> `t_user_role`(`id`, `user_id`, `role_id`, `create_time`, `creator`)</span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span></span><br><span class="line"><span class="keyword">into</span> `t_permission`(`id`, `code`, `description`, `url`)</span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;p1&#x27;</span>, <span class="string">&#x27;测试资源1&#x27;</span>, <span class="string">&#x27;/r/r1&#x27;</span>),</span><br><span class="line">       (<span class="number">2</span>, <span class="string">&#x27;p3&#x27;</span>, <span class="string">&#x27;测试资源2&#x27;</span>, <span class="string">&#x27;/r/r2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span></span><br><span class="line"><span class="keyword">into</span> `t_role_permission`(`id`, `role_id`, `permission_id`)</span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">       (<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>增加PermissionDto</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionDto</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserDao增加方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据用户id查询用户权限</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findPermissionsByUserId</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;SELECT * FROM t_permission WHERE id IN(\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;SELECT permission_id FROM t_role_permission WHERE role_id IN(\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\tSELECT role_id FROM t_user_role WHERE user_id = ? \n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;)\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    List&lt;PermissionDto&gt; list = jdbcTemplate.query(sql, <span class="keyword">new</span> Object[]&#123;userId&#125;, <span class="keyword">new</span></span><br><span class="line">            BeanPropertyRowMapper&lt;&gt;(PermissionDto.class));</span><br><span class="line">    List&lt;String&gt; permissions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.iterator().forEachRemaining(</span><br><span class="line">            c -&gt; permissions.add(c.getCode())</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> permissions;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改SpringDataUserDetailsService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;username=&quot;</span> + s);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//根据账号去数据库查询...</span></span><br><span class="line">     UserDto user = userDao.getUserByUsername(s);</span><br><span class="line">     <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//查询用户权限</span></span><br><span class="line">     List&lt;String&gt; permissions = userDao.findPermissionsByUserId(user.getId());</span><br><span class="line">     String[] perarray = <span class="keyword">new</span> String[permissions.size()];</span><br><span class="line">     permissions.toArray(perarray);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//创建userDetails</span></span><br><span class="line">     UserDetails userDetails =</span><br><span class="line">             User.withUsername(user.getFullname()).password(user.getPassword()).authorities(perarray).build();</span><br><span class="line">     <span class="keyword">return</span> userDetails;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="web授权"><a href="#web授权" class="headerlink" title="web授权"></a>web授权</h5><p>在上面例子中我们完成了认证拦截,并对<code>/r/**</code>下的某些资源进行简单的授权保护,但是我们想进行灵活的授权控制该怎么做呢?通过给 http.authorizeRequests() 添加多个子节点来定制需求到我们的URL,如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//http.authorizeRequests() 方法有多个子节点,每个macher按照他们的声明顺序执行</span></span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/r/r1&quot;</span>).hasAuthority(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/r/r2&quot;</span>).hasAuthority(<span class="string">&quot;p2&quot;</span>)</span><br><span class="line">            <span class="comment">//指定了&quot;/r/r3&quot;URL,同时拥有p1和p2权限才能够访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/r/r3&quot;</span>).access(<span class="string">&quot;hasAuthority(&#x27;p1&#x27;) and hasAuthority(&#x27;p2&#x27;)&quot;</span>)</span><br><span class="line">            <span class="comment">//指定了除了r1、r2、r3之外&quot;/r/**&quot;资源,同时通过身份认证就能够访问,这里使用SpEL(Spring ExpressionLanguage)表达式。。</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/r/**&quot;</span>).authenticated()</span><br><span class="line">            <span class="comment">//剩余的尚未匹配的资源,不做保护。</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//允许表单登录</span></span><br><span class="line">                .formLogin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<p><strong>规则的顺序是重要的,更具体的规则应该先写</strong>.现在以/ admin开始的所有内容都需要具有ADMIN角色的身份验证用户,即使是<code>/admin/login</code>路径(因为<code>/admin/login</code>已经被<code>/admin/**</code>规则匹配,因此第二个规则被忽略).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)</span><br><span class="line">.antMatchers(&quot;/admin/login&quot;).permitAll()</span><br></pre></td></tr></table></figure>

<p>因此,登录页面的规则应该在<code>/admin/**</code>规则之前.例如.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.antMatchers(&quot;/admin/login&quot;).permitAll()</span><br><span class="line">.antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)</span><br></pre></td></tr></table></figure>

<p>保护URL常用的方法有:</p>
<ul>
<li>authenticated() 保护URL,需要用户登录</li>
<li>permitAll() 指定URL无需保护,一般应用与静态资源文件</li>
<li>hasRole(String role) 限制单个角色访问,角色将被增加 “ROLE_” .所以”ADMIN” 将和“ROLE_ADMIN”进行比较.</li>
<li>hasAuthority(String authority) 限制单个权限访问</li>
<li>hasAnyRole(String… roles)允许多个角色访问.</li>
<li>hasAnyAuthority(String… authorities) 允许多个权限访问.</li>
<li>access(String attribute) 该方法使用 SpEL表达式, 所以可以创建复杂的限制.</li>
<li>hasIpAddress(String ipaddressExpression) 限制IP地址或子网</li>
</ul>
<h5 id="方法授权"><a href="#方法授权" class="headerlink" title="方法授权"></a>方法授权</h5><p>现在我们已经掌握了使用如何使用 http.authorizeRequests() 对web资源进行授权保护,从Spring Security2.0版本开始,它支持服务层方法的安全性的支持,我们可以在任何 @Configuration 实例上使用@EnableGlobalMethodSecurity 注释来启用基于注解的安全性。</p>
<p>以下内容将启用Spring Security的 @Secured 注释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodSecurityConfig</span> </span>&#123;<span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后向方法(在类或接口上)添加注解就会限制对该方法的访问。 Spring Security的原生注释支持为该方法定义了一组属性。 这些将被传递给AccessDecisionManager以供它作出实际的决定:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">UserController</span>  </span>&#123;</span><br><span class="line"><span class="meta">@Secured(&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">readAccount</span><span class="params">(Long id)</span></span>&#123;&#125;</span><br><span class="line"><span class="meta">@Secured(&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Account[] findAccounts()&#123;&#125;</span><br><span class="line"><span class="meta">@Secured(&quot;ROLE_TELLER&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">post</span><span class="params">(Account account, <span class="keyword">double</span> amount)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置标明readAccount、findAccounts方法可匿名访问,底层使用WebExpressionVoter投票器,可从<br>AffirmativeBased第23行代码跟踪。</p>
<p>post方法需要有TELLER角色才能访问,底层使用RoleVoter投票器。</p>
<p>使用如下代码可启用prePost注解的支持</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodSecurityConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相应Java代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"><span class="meta">@PreAuthorize(&quot;isAnonymous()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">readAccount</span><span class="params">(Long id)</span></span>&#123;&#125;</span><br><span class="line"><span class="meta">@PreAuthorize(&quot;isAnonymous()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Account[] findAccounts()&#123;&#125;</span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;p_transfer&#x27;) and hasAuthority(&#x27;p_read_account&#x27;)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">post</span><span class="params">(Account account, <span class="keyword">double</span> amount)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置标明readAccount、findAccounts方法可匿名访问,post方法需要同时拥有p_transfer和p_read_account权限才能访问,底层使用WebExpressionVoter投票器,可从AffirmativeBased第23行代码跟踪。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hdfg159/article/details/90677404">Spring Security PasswordEncoder 密码校验和密码加密流程</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/10/07/Java-%E6%A1%86%E6%9E%B6-9-1-1-1/">https://pingxin0521.gitee.io/2019/10/07/Java-%E6%A1%86%E6%9E%B6-9-1-1-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/10/07/Java-%E6%A1%86%E6%9E%B6-9-1-1-2/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring Security 认证的常用方法</div></div></a></div><div class="next-post pull-right"><a href="/2019/10/06/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-1-2/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL 架构和底层知识</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/07/12/Java-SpringBoot-1-4-2/" title="Spring boot 数据访问 MongoDB"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-01-25</div><div class="title">Spring boot 数据访问 MongoDB</div></div></a></div><div><a href="/2019/12/10/Java-SpringBoot-1-6-1/" title="Spring boot 消息队列(使用RabbitMQ)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-02-09</div><div class="title">Spring boot 消息队列(使用RabbitMQ)</div></div></a></div><div><a href="/2019/05/30/Java-SpringCloud-0-0/" title="Spring Cloud 入门 (一)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">Spring Cloud 入门 (一)</div></div></a></div><div><a href="/2019/11/01/Java-SpringCloud-3-0/" title="Spring Cloud 组件之Hystrix (五)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">Spring Cloud 组件之Hystrix (五)</div></div></a></div><div><a href="/2019/10/27/Java-SpringCloud-6-0/" title="微服务组件--分布式追踪系统"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">微服务组件--分布式追踪系统</div></div></a></div><div><a href="/2019/11/03/Java-SpringCloud-6-2/" title="SpringCloud组件之Spring Cloud Sleuth (八)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">SpringCloud组件之Spring Cloud Sleuth (八)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A4%E8%AF%81"><span class="toc-number">1.1.</span> <span class="toc-text">什么是认证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.2.</span> <span class="toc-text">什么是会话</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%88%E6%9D%83"><span class="toc-number">1.3.</span> <span class="toc-text">什么是授权</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">授权的数据模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RBAC"><span class="toc-number">1.5.</span> <span class="toc-text">RBAC</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ESession%E7%9A%84%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">基于Session的认证方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Security"><span class="toc-number"></span> <span class="toc-text">Spring Security</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">认证流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PasswordEncoder"><span class="toc-number">1.2.</span> <span class="toc-text">PasswordEncoder</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">授权流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.4.</span> <span class="toc-text">会话</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%80%E5%87%BA"><span class="toc-number">1.5.</span> <span class="toc-text">退出</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%88%E6%9D%83"><span class="toc-number">2.</span> <span class="toc-text">授权</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#web%E6%8E%88%E6%9D%83"><span class="toc-number">2.1.</span> <span class="toc-text">web授权</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%8E%88%E6%9D%83"><span class="toc-number">2.2.</span> <span class="toc-text">方法授权</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number"></span> <span class="toc-text">参考</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
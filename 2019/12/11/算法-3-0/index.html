<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试--算法 （一） | 平心de小屋</title><meta name="keywords" content="算法"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="练习网站：https:&#x2F;&#x2F;leetcode-cn.com 语言：java 8">
<meta property="og:type" content="article">
<meta property="og:title" content="面试--算法 （一）">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/12/11/%E7%AE%97%E6%B3%95-3-0/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="练习网站：https:&#x2F;&#x2F;leetcode-cn.com 语言：java 8">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg">
<meta property="article:published_time" content="2019-12-11T00:18:59.000Z">
<meta property="article:modified_time" content="2020-03-05T14:22:10.768Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/12/11/%E7%AE%97%E6%B3%95-3-0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试--算法 （一）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-03-05 22:22:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试--算法 （一）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-11T00:18:59.000Z" title="发表于 2019-12-11 08:18:59">2019-12-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-03-05T14:22:10.768Z" title="更新于 2020-03-05 22:22:10">2020-03-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试--算法 （一）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>练习网站：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/">https://leetcode-cn.com</a></p>
<p>语言：java 8</p>
<span id="more"></span>

<h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ol>
<li>暴力解法：时间复杂度O(n^2)</li>
<li>题中未给是有序数组，因此排除二分查找。</li>
<li>使用Map或者字典，空间复杂度O(n),时间复杂度O(n)</li>
</ol>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] indexs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 建立k-v ，一一对应的哈希表</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.containsKey(nums[i]))&#123;</span><br><span class="line">                indexs[<span class="number">0</span>] = i;</span><br><span class="line">                indexs[<span class="number">1</span>] = hash.get(nums[i]);</span><br><span class="line">                <span class="keyword">return</span> indexs;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将数据存入 key为补数 ，value为下标</span></span><br><span class="line">            hash.put(target-nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// // 双重循环 循环极限为(n^2-n)/2 </span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j = nums.length - 1; j &gt; i; j --)&#123;</span></span><br><span class="line">        <span class="comment">//         if(nums[i]+nums[j] == target)&#123;</span></span><br><span class="line">        <span class="comment">//            indexs[0] = i;</span></span><br><span class="line">        <span class="comment">//            indexs[1] = j; </span></span><br><span class="line">        <span class="comment">//            return indexs;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> indexs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求n个数和为m的组合数目"><a href="#求n个数和为m的组合数目" class="headerlink" title="求n个数和为m的组合数目"></a>求n个数和为m的组合数目</h4><p>题目：输入两个整数 n 和 m，从数列1，2，3…….n 中 随意取几个数,使其和等于 m ,要求将其中所有的可能组合列出来.</p>
<p>分析，由该题可知是典型的背包问题，根据该数是否加入进行递归运算。</p>
<p>解法：采用0-1背包的思想，使用递归方法：</p>
<ol>
<li>当选择n时，就用剩下的n-1填满 m-n;</li>
<li>当不选择n是，就用剩下的n-1填满m；</li>
<li>注意的是，当m=n时，即找到了符合条件的解。</li>
</ol>
<p>题解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] mSum(List&lt;Integer&gt; nums,<span class="keyword">int</span> n, <span class="keyword">int</span> m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m&lt;=<span class="number">0</span>||n&lt;=<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(m==n)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(nums.get(i)+<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.add(n);</span><br><span class="line">        mSum(nums,n-<span class="number">1</span>,m-n);</span><br><span class="line">        num.pop();</span><br><span class="line">        mSum(nums,n-<span class="number">1</span>,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1000瓶毒药里面只有1瓶是有毒的，问需要多少只老鼠才能试出那瓶有毒。"><a href="#1000瓶毒药里面只有1瓶是有毒的，问需要多少只老鼠才能试出那瓶有毒。" class="headerlink" title="1000瓶毒药里面只有1瓶是有毒的，问需要多少只老鼠才能试出那瓶有毒。"></a>1000瓶毒药里面只有1瓶是有毒的，问需要多少只老鼠才能试出那瓶有毒。</h4><p>题目：1000瓶毒药里面只有1瓶是有毒的，毒发时间为24个小时，问需要多少只老鼠才能在<strong>24小时</strong>后试出那瓶有毒。</p>
<p>这个题是对bit位的应用，1000接近1024，所以需要10个bit位，对瓶子进行编号，从0到999，这样需要10只老鼠。瓶子的编号分别为：</p>
<p>老鼠用  a ,b ,c ,d ,e ,f ,g ,h ,i , j ,表示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第0号瓶：00000,00000</span><br><span class="line"></span><br><span class="line">第1号瓶：00000,00001  a</span><br><span class="line"></span><br><span class="line">第2号瓶：00000,00010,      b     </span><br><span class="line"></span><br><span class="line">第3号瓶：00000,00011   a   b</span><br><span class="line"></span><br><span class="line">第4号瓶：00000,00101   a        c</span><br><span class="line"></span><br><span class="line">第5号瓶：00000,00111    a   b   c</span><br><span class="line"></span><br><span class="line">。。。。。。</span><br><span class="line"></span><br><span class="line">第999号瓶：11111，00111  a    b   c    []  []  f g  h  i  j </span><br></pre></td></tr></table></figure>

<p>同时给老鼠编号，从1,2,…10，从低位开始，让第n个老鼠喝下第n个bit位为1瓶子中的药水。一周后，若所有的老鼠都没有发病，那么是第一个瓶子有毒，如果有一些老鼠发病，那么共同喝的那瓶毒药的二进制做与运算，得到的就是共同喝的那瓶，最低位+1，变成整数后，对应的数字即为有毒药水的编号。</p>
<p>比如：第四瓶有毒，全部做与运算得到的（编号第三号）00000011 +1 =00000100 = 4 。第四瓶有毒（没有第零瓶，所以+加1）</p>
<p>所以只要10只老鼠就能在 24小时后 排查出到底那瓶有毒。</p>
<h4 id="扑克牌面试问题-从牌顶拿出一张牌放到桌子上-再从牌顶拿一张牌放在手上牌的底部，重复第一步、第二步的操作"><a href="#扑克牌面试问题-从牌顶拿出一张牌放到桌子上-再从牌顶拿一张牌放在手上牌的底部，重复第一步、第二步的操作" class="headerlink" title="扑克牌面试问题:从牌顶拿出一张牌放到桌子上,再从牌顶拿一张牌放在手上牌的底部，重复第一步、第二步的操作"></a>扑克牌面试问题:从牌顶拿出一张牌放到桌子上,再从牌顶拿一张牌放在手上牌的底部，重复第一步、第二步的操作</h4><p>我手中有一堆扑克牌， 但是观众不知道它的顺序。</p>
<ol>
<li><p>第一步， 我从牌顶拿出一张牌， 放到桌子上。</p>
</li>
<li><p>第二步， 我从牌顶再拿一张牌， 放在手上牌的底部。</p>
</li>
<li><p>第三步， 重复第一步、第二步的操作， 直到我手中所有的牌都放到了桌子上。</p>
</li>
</ol>
<p>最后， 观众可以看到桌子上牌的顺序是：(牌底部）1,2,3,4,5,6,7,8,9,10,11,12,13(牌顶部）</p>
<p>请问， 我刚开始拿在手里的牌的顺序是什么？</p>
<p>你的手里拿了13张牌，每一次往桌子上放牌的时候，还要把手牌的第一张放到手牌的最后， 那可以推理出这可以通过13次的循环来完成，每次循环执行两个动作</p>
<ol>
<li><p>先将手牌最上面一张放在桌子上</p>
</li>
<li><p>再将手牌中最上面的一张放手牌的最后</p>
</li>
</ol>
<p>以上的这种操作，我称他为正向操作，也就是手牌到桌子上</p>
<p>问题中是知道了桌子上的结果，需要知道初始手牌的顺序，那其实就是把上面的操作以反向形式操作一次，也就是从桌子上到手里，简称反向操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PokerService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正向，从手到桌子 t2 = &#123;1,12,2,8,3,11,4,9,5,13,6,10,7&#125;;</span></span><br><span class="line"><span class="comment">     * 返回 ｛13,12,11,10,9,8,7,6,5,4,3,2,1&#125;;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pokers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] pokers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//13张牌转换成数组  方便操作，不用考虑太多</span></span><br><span class="line">        LinkedList&lt;Integer&gt; pokerList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> poker : pokers) &#123;</span><br><span class="line">            pokerList.add(poker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//声明一个新的容器，在这里可以理解成桌子</span></span><br><span class="line">        LinkedList&lt;Integer&gt; newPokers2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pokers.length; i++) &#123;</span><br><span class="line">            <span class="comment">//将手牌中的第一张放在桌子上</span></span><br><span class="line">            newPokers2.add(pokerList.pollFirst());</span><br><span class="line">            <span class="comment">//假如这是最后一次循环手牌已经没有了就不需要进入这个判断了</span></span><br><span class="line">            <span class="keyword">if</span> (pokerList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//将第一张放在牌堆的最后</span></span><br><span class="line">                pokerList.addLast(pokerList.pollFirst());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环打印到控制台，</span></span><br><span class="line">        newPokers2.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里的操作是从桌子把牌拿回到手上</span></span><br><span class="line"><span class="comment">     * 从桌子 到 手上 int[] t = &#123;13,12,11,10,9,8,7,6,5,4,3,2,1&#125;;</span></span><br><span class="line"><span class="comment">     * 返回 &#123;1,12,2,8,3,11,4,9,5,13,6,10,7&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pokers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] pokers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从数组转换成list,只是为了方便操作，不用考虑其它的</span></span><br><span class="line">        LinkedList&lt;Integer&gt; pokerList = <span class="keyword">new</span> LinkedList&lt;&gt;(Ints.asList(pokers));</span><br><span class="line">        <span class="comment">//声明一个目标容器，理解成手</span></span><br><span class="line">        LinkedList&lt;Integer&gt; newPokers2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer aPokerList : pokerList) &#123;</span><br><span class="line">            <span class="comment">//判断手上的牌是否大于1张</span></span><br><span class="line">            <span class="keyword">if</span> (newPokers2.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//如果大于一张，则把手牌的最后一张放在最上面</span></span><br><span class="line">                newPokers2.addFirst(newPokers2.pollLast());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从桌子上拿一张牌放在手上</span></span><br><span class="line">            newPokers2.addFirst(aPokerList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环打印到控制台，</span></span><br><span class="line">        newPokers2.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找数组中重复的唯一元素-时间复杂度O（n）-空间复杂度O（1）"><a href="#查找数组中重复的唯一元素-时间复杂度O（n）-空间复杂度O（1）" class="headerlink" title="查找数组中重复的唯一元素+时间复杂度O（n）+空间复杂度O（1）"></a>查找数组中重复的唯一元素+时间复杂度O（n）+空间复杂度O（1）</h4><p>长度为N的数组，元素大小范围在[1，N-1]，只有一个重复的元素，用O（n）的时间复杂度和O（1）的空间复杂度找出来这个重复的元素</p>
<ol>
<li>因为总共有N个数，每个数的范围是1到N-1，只有一个重复的数，所以这些数肯定是连续的</li>
<li>把对应的数放到与之对应的位置上去</li>
<li>因为这些书不包含0，所以可以一直操作arr[0]，把arr[0]上的数字放到对应的位置上去，再把那个位置上的数字放到arr[0]上去</li>
<li>如此循环操作，当arr[0]上的数字与对应位置上的数字相等时，就找到了重复的元素</li>
<li>最坏的情况下循环N次一定能找出来重复的元素</li>
</ol>
<h4 id="查找无序数组中缺失的最小正整数"><a href="#查找无序数组中缺失的最小正整数" class="headerlink" title="查找无序数组中缺失的最小正整数"></a>查找无序数组中缺失的最小正整数</h4><p>一个长度为n的无序数组，找出缺失的最小正整数，<br>例：[2, 3, 1, 5] –&gt; 4 长度为4的数组是[1, 2, 3, 4]<br>[5, 6, 2] –&gt; 1 长度为3的数组是[1, 2, 3]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] mums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = mums.length;</span><br><span class="line">   <span class="comment">// 把数组中小于等于0和大于n的数字，置为-1</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span> || mums[i] &gt; n) &#123;</span><br><span class="line">             mums[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 正常的长度为n的数组，第i个位置上的数字应该是i + 1，把数字放在对应的  位置上，有重复的则置为-1</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">       <span class="keyword">int</span> temp = mums[i];</span><br><span class="line">       <span class="keyword">if</span> (mums[i] != (i + <span class="number">1</span>) &amp;&amp; mums[i] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果该位置上的数字不是 i + 1，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (nums[temp - <span class="number">1</span>] != temp) &#123;</span><br><span class="line">                 nums[i] = nums[temp - <span class="number">1</span>];</span><br><span class="line">                 nums[temp - <span class="number">1</span>] = temp;</span><br><span class="line">                 <span class="comment">// 这时需要继续处理i</span></span><br><span class="line">                i--;</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// 这时，存在的数字都在正确的位置，遍历数字，第一个-1即是缺失的最小数</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (nums[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>；</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 找不到的话，说明不缺</span></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输入一个数字n-如果n为偶数则除以2，若为奇数则加1或者减1，直到n为1，求最少次数-写出一个函数"><a href="#输入一个数字n-如果n为偶数则除以2，若为奇数则加1或者减1，直到n为1，求最少次数-写出一个函数" class="headerlink" title="输入一个数字n 如果n为偶数则除以2，若为奇数则加1或者减1，直到n为1，求最少次数 写出一个函数"></a>输入一个数字n 如果n为偶数则除以2，若为奇数则加1或者减1，直到n为1，求最少次数 写出一个函数</h4><p>首先，这道题肯定可以用动态规划来解，</p>
<ul>
<li>n为整数时，n的解为 n/2 的解加1</li>
<li>n为奇数时，n的解为 (n+1)/2 和 (n-1)/2 的解中较小的解加2</li>
</ul>
<p>通过这个思路，我们可以自底向上依次计算出n的解，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((i&amp;<span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                res[i] = res[i/<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res[i] = Math.min(res[(i+<span class="number">1</span>)/<span class="number">2</span>], res[(i-<span class="number">1</span>)/<span class="number">2</span>]) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的思路可以得到问题的解，但是由于是自底向上依次计算n的解，所以有很多不必要的计算，时间效率和空间效率都不高。</p>
<p>比如，当计算n=100时，如果已经知道n=50的解，那么就可以得出n=100的解，所以n=51到n=99都是没有必要计算的。</p>
<p>如果仍然通过自底向上计算，那么想要忽略51到99这一区间的数字的计算是比较麻烦的，如果是自顶向下计算则容易做到，通过n可以确定只要计算 n/2,(n-1)/2 , (n+1)/2，这三个数就行，利用递归来做代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum2</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getNum2(n/<span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> a = (n-<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> b = (n+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Math.min(getNum2(a), getNum2(b)) + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有两个整型数组A和B，要求找出存在数组A中而不存在数组B中的元素，并打印输出（保持原顺序）"><a href="#有两个整型数组A和B，要求找出存在数组A中而不存在数组B中的元素，并打印输出（保持原顺序）" class="headerlink" title="有两个整型数组A和B，要求找出存在数组A中而不存在数组B中的元素，并打印输出（保持原顺序）"></a>有两个整型数组A和B，要求找出存在数组A中而不存在数组B中的元素，并打印输出（保持原顺序）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">样例输入：</span><br><span class="line"></span><br><span class="line">1,2,3,5,3,6,8,1</span><br><span class="line"></span><br><span class="line">2,3,4</span><br><span class="line"></span><br><span class="line">输出：1 5 6 8 1</span><br></pre></td></tr></table></figure>

<p>思想：利用了一个HashSet中不能存储重复元素，一开始先将B数组的元素输入到hashset中，再利用hashset中的contains方法来判断不在hashset中的元素就是，去除B后剩下A的交集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将array1中在array2中的数字去掉。</span></span><br><span class="line"><span class="comment"> * 题目：有两个整型数组A和B，要求找出存在数组A中而不存在数组B中的元素，并打印输出（保持原顺序）</span></span><br><span class="line"><span class="comment"> * 样例输入：</span></span><br><span class="line"><span class="comment"> * 1,2,3,5,3,6,8,1</span></span><br><span class="line"><span class="comment"> * 2,3,4</span></span><br><span class="line"><span class="comment"> * 输出：1 5 6 8 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : B)</span><br><span class="line">            set.add(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(i))</span><br><span class="line">                list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)</span><br><span class="line">            System.out.print(list.get(i)+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] A =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] B=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        solution(A,B);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最小公倍数和最大公约数的三种算法"><a href="#最小公倍数和最大公约数的三种算法" class="headerlink" title="最小公倍数和最大公约数的三种算法"></a>最小公倍数和最大公约数的三种算法</h4><p><strong>最大公约数：</strong></p>
<ul>
<li><p>辗转相除法</p>
<p>用较小数除较大数，<br>再用出现的余数（第二余数）去除第一余数，<br>如此反复，直到最后余数是0为止。<br>如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。</p>
</li>
</ul>
<p><strong>最小公倍数：</strong></p>
<ul>
<li>公倍数(commonmultiple)指在两个或两个以上的自然数中，如果它们有相同的倍数，这些倍数就是它们的公倍数，其中除0以外最小的一个公倍数，叫做这几个数的最小公倍数。</li>
</ul>
<p>最大公因数和最小公倍数之间还存在着性质：两个自然数的乘积等于这两个自然数的最大公约数和最小公倍数的乘积。</p>
<p>最小公倍数计算方法：</p>
<ol>
<li>分解质因数法</li>
<li>公式法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大公因数-辗转相除法-递归</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">int</span> m )</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span>   n%m ==<span class="number">0</span> ? m :gcd( m, n%m );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辗转相除法：返回公约数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Method</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    a=x;</span><br><span class="line">    b=y;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">        c=a%b;</span><br><span class="line">        a=b;</span><br><span class="line">        b=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相减法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Subtraction</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">            x=x-y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            y=y-x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//穷举法  求公约数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divisor</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="keyword">for</span>(z=x;z&gt;<span class="number">0</span>;z--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%z==<span class="number">0</span>&amp;&amp;y%z==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求公倍数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">multiple</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="keyword">for</span>(z=x;;z++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(z%x==<span class="number">0</span>&amp;&amp;z%y==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Top-K-问题"><a href="#Top-K-问题" class="headerlink" title="Top K 问题"></a>Top K 问题</h4><p>什么是 Top K 问题？简单来说就是在一堆数据里面找到前 K 大（当然也可以是前 K 小）的数。</p>
<p>这个问题也是十分经典的算法问题，不论是面试中还是实际开发中，都非常典型。而这个问题其实也有很多种做法，你真的都懂了么？</p>
<p>其实提到 Top K 问题，最经典的解法还是利用堆。</p>
<p>维护一个大小为 K 的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。</p>
<p>当然，如果是求前 K 个最小的数，只需要改为大顶堆即可</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/18/3Fvj74.png" alt="3Fvj74.png"></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/18/3FxeNd.png" alt="3FxeNd.png"></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/18/3FxYNj.png" alt="3FxYNj.png"></p>
<p>对于海量数据，我们不需要一次性将全部数据取出来，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较。</p>
<p>另外还有一个优势就是对于动态数组，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就直接拿它与堆顶的元素对比。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以里立刻返回给他。</p>
<p>整个操作中，遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK)，加起来就是 O(nlogK) 的复杂度，换个角度来看，如果 K 远小于 n 的话， O(nlogK) 其实就接近于 O(n) 了，甚至会更快，因此也是十分高效的。</p>
<p>最后，对于 Java，我们可以直接使用优先队列 PriorityQueue 来实现一个小顶堆，这里给个代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">solutionByHeap</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (k &gt; input.length || k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : input) &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.size() &lt; k) &#123;</span><br><span class="line">            queue.add(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queue.peek() &lt; num)&#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">            queue.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        list.add(queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="两个数组的元素之和最大的前k项"><a href="#两个数组的元素之和最大的前k项" class="headerlink" title="两个数组的元素之和最大的前k项"></a>两个数组的元素之和最大的前k项</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/28/3rZ7QS.png" alt="3rZ7QS.png"></p>
<p>解决思路：</p>
<blockquote>
<ul>
<li>时间复杂度很低，除了数组排序那块需要O(NlogN)（或者O(MlogM)，看谁最大）之外，后面的顶多需要O(k^2)，应该不是很大。</li>
<li>然后其实有O(N)的解法，链接如下：<a target="_blank" rel="noopener" href="https://blog.csdn.net/huntzw/article/details/25157743">https://blog.csdn.net/huntzw/article/details/25157743</a></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2,4,2,7,7-3,2,5,6,1,9:6</span></span><br><span class="line">    <span class="comment">//16 16 13 13 13 11</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String line = scanner.nextLine();</span><br><span class="line">        String[] tem = line.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        String[] array1 = tem[<span class="number">0</span>].split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        String[] temp = tem[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        String[] array2 = temp[<span class="number">0</span>].split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> K = Integer.parseInt(temp[<span class="number">1</span>]);</span><br><span class="line">        Arrays.sort(array1, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Arrays.sort(array2, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span>[] arr_1 = <span class="keyword">new</span> <span class="keyword">int</span>[array1.length];</span><br><span class="line">        <span class="keyword">int</span>[] arr_2 = <span class="keyword">new</span> <span class="keyword">int</span>[array2.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.length; i++)&#123;</span><br><span class="line">            arr_1[i] = Integer.parseInt(array1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.length; i++)&#123;</span><br><span class="line">            arr_2[i] = Integer.parseInt(array2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; sum = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> num_1 = K &gt; arr_1.length ? arr_1.length : K;</span><br><span class="line">        <span class="keyword">int</span> num_2 = K &gt; arr_2.length ? arr_2.length : K;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num_2; j++)&#123;</span><br><span class="line">                sum.add(arr_1[i] + arr_2[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(sum, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++)</span><br><span class="line">            System.out.println(sum.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>生成窗口的最大值或者最小值数组，时间复杂度：O(N)。 </p>
<p>普通解法的时间复杂度为O(N * win)，也就是每次对一个窗口遍历其中的 win 个数，选出最大值，最优解可以做到 O(N)。</p>
<p>【分析】：准备一个双端队列，双端队列存放着数组中的下标值。假设当前为 arr[i]，则放入规则如下：</p>
<p>left 和 right 指针都只会向右移动，不会回退。 </p>
<ul>
<li><p>right 右滑，窗口加数：</p>
<ul>
<li>1）如果 queue 为空，直接把下标 i 放入 queue  中；</li>
<li>2）如果 queue  不为空，取出当前 queue  队尾存放的下标 j。如果 arr[j] &gt; arr[i]，则直接把 i 放入队尾；</li>
<li>3）如果 arr[j] &lt;= arr[i]，则一直从 queue  的队尾弹出下标，直到某个下标在 queue  中的对应值大于 arr[i]，然后把 i 放入队尾 【为什么可以弹出，因为我永远比你晚过期，我又比你大或者和你一样大，有我在，你永远不可能最大，所以你可以滚了】</li>
</ul>
</li>
<li><p>left 右滑，窗口减数：</p>
<ul>
<li>1）看弹出的 left 是否与队列头相等，如果相等，说明这个队列头已经不在窗口内了，所以弹出 queue  当前的队首元素 。</li>
</ul>
</li>
<li><p>双端队列的队头就是当前窗口最大值的下标。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> right;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Window</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = <span class="number">0</span>;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 往滑动窗口加数时对双端队列的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNumToRight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right == arr.length)&#123;</span><br><span class="line">            <span class="comment">// right已经到达最右了，滑动窗口无法再增加数了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; arr[queue.peekLast()] &lt;= arr[right])&#123;</span><br><span class="line">            <span class="comment">// 弹出比arr[right]小的数的下标</span></span><br><span class="line">            queue.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(right);</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 移除双端队列最左边的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNumFromLeft</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 只有left小于right的时候，才有窗口存在</span></span><br><span class="line">            <span class="keyword">if</span>(queue.peekFirst() == left)&#123;</span><br><span class="line">                <span class="comment">// 要移除的这个数是双端队列的头，则弹出它，表示它已经不在窗口里，失效了</span></span><br><span class="line">                queue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双端队列的头结点就是当前滑动窗口的最大值</span></span><br><span class="line">        <span class="keyword">return</span> arr[queue.peekFirst()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>生成窗口最大值数组</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/28/3rnVxK.png" alt="3rnVxK.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetMaxNumInWindow</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getMaxNumInWin(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> win)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; win || win &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        LinkedList&lt;Integer&gt; maxQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 共有arr.length - win + 1个窗口，即共有arr.length - win + 1个最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length - win + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!maxQueue.isEmpty() &amp;&amp; arr[maxQueue.peekLast()] &lt;= arr[i])&#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 如果当前双端链表中的最后一个值比arr[i]小，则将其弹出，直到找到比arr[i]大的数，将arr[i]放在其后面，</span></span><br><span class="line"><span class="comment">                 * 如果maxQueue中没有比arr[i]大的数，那就将maxQueue中的数全部弹出，arr[i]放在头部</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                maxQueue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            maxQueue.addLast(i);</span><br><span class="line">            <span class="keyword">if</span>(maxQueue.peekFirst() == i - win)&#123;</span><br><span class="line">                <span class="comment">// 只有当窗口形成后才会有从双端队列头部失效一个数,即过期还是没过期</span></span><br><span class="line">                maxQueue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= win - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 至少有一个窗口存在时，才有max</span></span><br><span class="line">                res[index] = arr[maxQueue.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>求一个数组中最大值减去最小值小于或等于 num 的子数组数量（要求O(N)）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**【题目】 给定数组arr和整数num，共返回有多少个子数组满足如下情况: </span></span><br><span class="line"><span class="comment">        max(arr[i..j]) - min(arr[i..j]) &lt;= num </span></span><br><span class="line"><span class="comment">        max(arr[i..j])表示子数组arr[i..j]中的最大值，min(arr[i..j])表 示子数组arr[i..j]中的最小值。</span></span><br><span class="line"><span class="comment">【要求】 如果数组长度为N，请实现时间复杂度为O(N)的解法。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetAllLessNumSubArray</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAllSubArrayLessNum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; maxQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">// 最大值</span></span><br><span class="line">        LinkedList&lt;Integer&gt; minQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">// 最小值</span></span><br><span class="line">        <span class="comment">// 每个元素都会作为子数组中的第一个元素往外扩，进行尝试</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; arr.length)&#123;</span><br><span class="line">            <span class="comment">// 尝试以left开头，right往外扩</span></span><br><span class="line">            <span class="keyword">while</span>(right &lt; arr.length)&#123;</span><br><span class="line">                <span class="comment">// 更新最大值双端队列</span></span><br><span class="line">                <span class="keyword">while</span>(!maxQueue.isEmpty() &amp;&amp; arr[maxQueue.peekLast()] &lt;= arr[right])&#123;</span><br><span class="line">                    maxQueue.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                maxQueue.addLast(arr[right]);</span><br><span class="line">                <span class="comment">// 更新最小值双端队列</span></span><br><span class="line">                <span class="keyword">while</span>(!minQueue.isEmpty() &amp;&amp; arr[minQueue.peekLast()] &lt;= arr[right])&#123;</span><br><span class="line">                    minQueue.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                minQueue.addLast(arr[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[maxQueue.peekFirst()] - arr[minQueue.peekFirst()] &lt;= num)&#123;</span><br><span class="line">                right++;   <span class="comment">// right扩</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 不满足条件了，继续往外扩也是不满足的，left加1，right再重新从新left扩</span></span><br><span class="line">            &#125;</span><br><span class="line">            res += right - left;  <span class="comment">// 以left开头的满足条件的子数组个数为：right - left 个</span></span><br><span class="line">            <span class="comment">// left右移一位</span></span><br><span class="line">            <span class="keyword">if</span>(left == maxQueue.peekFirst())&#123;</span><br><span class="line">                maxQueue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left == minQueue.peekFirst())&#123;</span><br><span class="line">                minQueue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="文件大数据的排序"><a href="#文件大数据的排序" class="headerlink" title="文件大数据的排序"></a>文件大数据的排序</h4><p>题目：有10个文件，每个文件有1000万行，文件内容的每一行为一个自然数；需要，写一个程序，将所有数字排序，分为10个文件输出，如0号文件包含前1000万个数字，1号文件文件包含第1千万-2千万之间的数字，依次类推。</p>
<p>限制：如果使用java，-Xmx需要设置为32MB；其它语言也需限制内存为32MB。</p>
<p>要求:正确输出 使用多线程加分</p>
<p>编写时长：24 小时。提供可运行的程序，以及实现说明。</p>
<p><strong>分析</strong></p>
<p>因为内存限制为32MB，将大文件分割成可以进行内部排序的的小文件，然后利用多路归并排序进行最终外部排序。</p>
<ol>
<li>内存极少的情况下，利用分治策略，利用外存保存中间结果，再用多路归并来排序;</li>
<li>map-reduce的嫡系.</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/18/3AMFCn.png" alt="3AMFCn.png"></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/18/3AMAg0.png" alt="3AMAg0.png"></p>
<ol>
<li><p>分</p>
<p>内存中维护一个极小的核心缓冲区memBuffer，将大文件bigdata按行读入，搜集到memBuffer满或者大文件读完时，对memBuffer中的数据调用内排进行排序，排序后将有序结果写入磁盘文件bigdata.xxx.part.sorted.<br>循环利用memBuffer直到大文件处理完毕，得到n个有序的磁盘文件</p>
</li>
<li><p>合</p>
<p>利用如下原理进行归并排序：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/18/3AMKUJ.png" alt="3AMKUJ.png"></p>
<p>我们举个简单的例子：</p>
<blockquote>
<p>文件1：3,6,9<br>文件2：2,4,8<br>文件3：1,5,7</p>
<p>第一回合：<br>文件1的最小值：3 , 排在文件1的第1行<br>文件2的最小值：2，排在文件2的第1行<br>文件3的最小值：1，排在文件3的第1行<br>那么，这3个文件中的最小值是：min(1,2,3) = 1<br>也就是说，最终大文件的当前最小值，是文件1、2、3的当前最小值的最小值，绕么？<br>上面拿出了最小值1，写入大文件.</p>
<p>第二回合：<br>文件1的最小值：3 , 排在文件1的第1行<br>文件2的最小值：2，排在文件2的第1行<br>文件3的最小值：5，排在文件3的第2行<br>那么，这3个文件中的最小值是：min(5,2,3) = 2<br>将2写入大文件.</p>
<p>也就是说，最小值属于哪个文件，那么就从哪个文件当中取下一行数据.（因为小文件内部有序，下一行数据代表了它当前的最小值）</p>
</blockquote>
</li>
</ol>
<p><strong>步骤</strong></p>
<ol>
<li>产生随机数，生成10个测试文件，10个线程同时进行。</li>
<li>将大文件分割1BM的小文件，每个线程对分割而成的内容进行内部排序后，写入文件，利用自定义阻塞线程池，每次同时写入3~4个文件。</li>
<li>将所有小文件排序后，利用多路排序算法将小文件写入最终文件。</li>
</ol>
<p>使用语言：JAVA</p>
<p>设置 -Xmx32m</p>
<p><strong>代码</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521/LeedCodeLearn/tree/master/src/main/java/lfs">https://github.com/hanyunpeng0521/LeedCodeLearn/tree/master/src/main/java/lfs</a></p>
<h4 id="大数据去重"><a href="#大数据去重" class="headerlink" title="大数据去重"></a>大数据去重</h4><p><a target="_blank" rel="noopener" href="https://www.iteye.com/blog/yacare-1969931">利用位映射原理对大数据排重</a></p>
<h4 id="岛问题"><a href="#岛问题" class="headerlink" title="岛问题"></a>岛问题</h4><p>题目描述：<br> 一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右<br> 四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个<br> 矩阵中有多少个岛？<br> 举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 0 1 0</span><br><span class="line">1 1 1 0 1 0</span><br><span class="line">1 0 0 1 0 0</span><br><span class="line">0 0 0 0 0 0</span><br></pre></td></tr></table></figure>

<p> 这个矩阵中有三个岛。</p>
<p>解决思路：</p>
<p>方法：主要使用感染函数，将1以及连接的1全都感染。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Islands</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断岛的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandNum</span><span class="params">(<span class="keyword">int</span>[][] m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="keyword">null</span> || m[<span class="number">0</span>] == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> N = m.length;</span><br><span class="line">        <span class="keyword">int</span> M = m[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(m[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    infect(m, i, j, N, M);<span class="comment">//感染函数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> N, <span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= N || j &lt; <span class="number">0</span> || j &gt;= M || m[i][j] != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        m[i][j] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//分别对上下左右感染</span></span><br><span class="line">        infect(m, i + <span class="number">1</span>, j, N, M);</span><br><span class="line">        infect(m, i - <span class="number">1</span>, j, N, M);</span><br><span class="line">        infect(m, i, j + <span class="number">1</span>, N, M);</span><br><span class="line">        infect(m, i, j - <span class="number">1</span>, N, M);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] m = &#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Islands islands = <span class="keyword">new</span> Islands();</span><br><span class="line">        <span class="keyword">int</span> num = islands.islandNum(m);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="不含-AAA-或-BBB-的字符串"><a href="#不含-AAA-或-BBB-的字符串" class="headerlink" title="不含 AAA 或 BBB 的字符串"></a>不含 AAA 或 BBB 的字符串</h4><p>给定两个整数 A 和 B，返回任意字符串 S，要求满足：</p>
<p>S 的长度为 A + B，且正好包含 A 个 ‘a’ 字母与 B 个 ‘b’ 字母；<br>子串 ‘aaa’ 没有出现在 S 中；<br>子串 ‘bbb’ 没有出现在 S 中。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：A = 1, B = 2</span><br><span class="line">输出：&quot;abb&quot;</span><br><span class="line">解释：&quot;abb&quot;, &quot;bab&quot; 和 &quot;bba&quot; 都是正确答案。</span><br></pre></td></tr></table></figure>


<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = 4, B = 1</span><br><span class="line">输出：&quot;aabaa&quot;</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ol>
<li>0 &lt;= A &lt;= 100</li>
<li>0 &lt;= B &lt;= 100</li>
<li>对于给定的 A 和 B，保证存在满足要求的 S。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">strWithout3a3b</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"> <span class="keyword">int</span> L = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">boolean</span> writeA = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">while</span> (A &gt; <span class="number">0</span> || B &gt; <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">	 writeA = <span class="keyword">false</span>; <span class="comment">// 是否写&#x27;a&#x27;</span></span><br><span class="line">	 L = ans.length();</span><br><span class="line">	</span><br><span class="line">	 <span class="comment">// 先写&#x27;a&#x27;的条件(贪心策略)</span></span><br><span class="line">	 <span class="keyword">if</span> (L &gt;= <span class="number">2</span> &amp;&amp; (ans.charAt(L-<span class="number">1</span>) == ans.charAt(L-<span class="number">2</span>)))  <span class="comment">// 连续两个字符相同</span></span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="keyword">if</span> (ans.charAt(L-<span class="number">1</span>) == <span class="string">&#x27;b&#x27;</span>)<span class="comment">// 末尾是&#x27;bb&#x27;</span></span><br><span class="line">			 writeA = <span class="keyword">true</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">else</span></span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="keyword">if</span> ( A &gt;= B) <span class="comment">// 先写较长的字符</span></span><br><span class="line">			 writeA = <span class="keyword">true</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">// 开始写&#x27;a&#x27;或写&#x27;b&#x27;</span></span><br><span class="line">	 <span class="keyword">if</span> (writeA)</span><br><span class="line">	 &#123;</span><br><span class="line">		 A--;</span><br><span class="line">		 ans.append(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">else</span></span><br><span class="line">	 &#123;</span><br><span class="line">		 B--;</span><br><span class="line">		 ans.append(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="给定一个正整数num和进制数scale，计算出1-num所有数字在scale进制下的长度之和len"><a href="#给定一个正整数num和进制数scale，计算出1-num所有数字在scale进制下的长度之和len" class="headerlink" title="给定一个正整数num和进制数scale，计算出1~num所有数字在scale进制下的长度之和len"></a>给定一个正整数num和进制数scale，计算出1~num所有数字在scale进制下的长度之和len</h4><p>给定一个正整数num和进制数scale，范围(1&lt;=num&lt;=10^9,scale&gt;1),请计算出1~num所有数字在scale进制下的长度之和len：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/03/05/RiyX2vLEcdY5Zwu.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">findlength</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> scale)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(num&lt;scale)</span><br><span class="line">				sum++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(num&gt;=scale)&#123;</span><br><span class="line">				<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">				index=returnindex(i,scale,index);</span><br><span class="line">				sum=sum+index+<span class="number">1</span>;<span class="comment">//index的意思是多加的位数</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">returnindex</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> scale,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(i/scale&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">			index=returnindex(i/scale, scale, index);</span><br><span class="line">			index=index+<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i/scale&lt;<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> index;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">int</span> length=find(<span class="number">7</span>, <span class="number">2</span>);<span class="comment">//测试用例，结果应该是17</span></span><br><span class="line">        <span class="comment">//下面截图依次是(10,10)(11,10)(100,10)(7,3)的结果</span></span><br><span class="line">		System.out.println(length);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="word-search-二维数组中查找单词（匹配字符串）"><a href="#word-search-二维数组中查找单词（匹配字符串）" class="headerlink" title="word search(二维数组中查找单词（匹配字符串）)"></a>word search(二维数组中查找单词（匹配字符串）)</h4><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,<br>Given board =</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;],</span><br><span class="line">  [&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;],</span><br><span class="line">  [&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>word = <code>&quot;ABCCED&quot;</code>, -&gt; returns <code>true</code>,<br>word = <code>&quot;SEE&quot;</code>, -&gt; returns <code>true</code>,<br>word = <code>&quot;ABCB&quot;</code>, -&gt; returns <code>false</code>.</p>
<p>从二维数组中找字符串是否存在，而且同一个元素不能重复使用。这是字符串匹配类型 题目，要记住方法。将二维数组简化成字符串，也就是字符串匹配了（依次遍历每个元素，将其当做开头，开始匹配）。</p>
<p>1、可以想到的是使用回溯法。</p>
<p>2、不能重复使用，想到用一个数组来标记每个元素的使用情况。</p>
<p>3、其实就是一个字符一个字符地匹配，当前字符相同，则向四周匹配。</p>
<p>4、从二维数组哪个字符开始匹配呢？遍历二维数组，依次将字符当做第一个字符跟字符串开始匹配。</p>
<p>一些注意事项，见代码中的标记。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board==<span class="keyword">null</span>||board.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//用一个数组表示某个位置上的元素是否已经使用过</span></span><br><span class="line">        <span class="keyword">int</span> m=board.length;</span><br><span class="line">        <span class="keyword">int</span> n=board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[m*n];</span><br><span class="line">        <span class="comment">//从每个位置开始遍历看是否包含此字符串。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(helper(board,word,i,j,flag,<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[][] board,String word,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">boolean</span>[] flag,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">　　　　<span class="comment">//当index大于Word的最后一个位置，也就是前面匹配都成功了，可以返回true。</span></span><br><span class="line">        <span class="keyword">if</span>(index==word.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=board.length||j&lt;<span class="number">0</span>||j&gt;=board[<span class="number">0</span>].length||board[i][j]!=word.charAt(index)||flag[i*board[<span class="number">0</span>].length+j]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//符合要求后，表示当前字符与字符串中对应字符相等，将该字符标记为使用过，再去判断剩下的字符。</span></span><br><span class="line">        flag[i*board[<span class="number">0</span>].length+j]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(helper(board,word,i+<span class="number">1</span>,j,flag,index+<span class="number">1</span>)||helper(board,word,i-<span class="number">1</span>,j,flag,index+<span class="number">1</span>)</span><br><span class="line">            ||helper(board,word,i,j-<span class="number">1</span>,flag,index+<span class="number">1</span>)||helper(board,word,i,j+<span class="number">1</span>,flag,index+<span class="number">1</span>))</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">　　　　　　</span><br><span class="line">　　　　　　</span><br><span class="line">　　　　　　　<span class="comment">//这里是关键，如果后面不匹配，就得把该位置的标志清除了，然后返回进行其他位置的比对，不清除会影响结果。</span></span><br><span class="line">           <span class="comment">//如果后面的不匹配，就得把当前的标志清除返回。</span></span><br><span class="line">           flag[i*board[<span class="number">0</span>].length+j]=<span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/12/11/%E7%AE%97%E6%B3%95-3-0/">https://pingxin0521.gitee.io/2019/12/11/%E7%AE%97%E6%B3%95-3-0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/12/11/%E5%91%A8%E8%AE%B0-4-1/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第五周--XSS 攻击</div></div></a></div><div class="next-post pull-right"><a href="/2019/12/10/Java-%E6%A1%86%E6%9E%B6-5-1-2-2/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring MVC 原理 (二)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/05/24/算法-1-0/" title="算法入门"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-02-10</div><div class="title">算法入门</div></div></a></div><div><a href="/2020/06/26/算法-1-3-3/" title="常用算法--分治算法 (三)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-06-28</div><div class="title">常用算法--分治算法 (三)</div></div></a></div><div><a href="/2020/06/27/算法-1-3-4/" title="常用算法--分支限界算法 (四)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-06-28</div><div class="title">常用算法--分支限界算法 (四)</div></div></a></div><div><a href="/2020/06/28/算法-1-3-5/" title="常用算法--动态规划算法 (五)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-06-29</div><div class="title">常用算法--动态规划算法 (五)</div></div></a></div><div><a href="/2019/05/25/算法-1-1/" title="经典算法--七大查找算法"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-11-04</div><div class="title">经典算法--七大查找算法</div></div></a></div><div><a href="/2019/09/24/算法-1-2/" title="经典算法--十大排序算法"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-03-25</div><div class="title">经典算法--十大排序算法</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.</span> <span class="toc-text">两数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82n%E4%B8%AA%E6%95%B0%E5%92%8C%E4%B8%BAm%E7%9A%84%E7%BB%84%E5%90%88%E6%95%B0%E7%9B%AE"><span class="toc-number">2.</span> <span class="toc-text">求n个数和为m的组合数目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1000%E7%93%B6%E6%AF%92%E8%8D%AF%E9%87%8C%E9%9D%A2%E5%8F%AA%E6%9C%891%E7%93%B6%E6%98%AF%E6%9C%89%E6%AF%92%E7%9A%84%EF%BC%8C%E9%97%AE%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E5%8F%AA%E8%80%81%E9%BC%A0%E6%89%8D%E8%83%BD%E8%AF%95%E5%87%BA%E9%82%A3%E7%93%B6%E6%9C%89%E6%AF%92%E3%80%82"><span class="toc-number">3.</span> <span class="toc-text">1000瓶毒药里面只有1瓶是有毒的，问需要多少只老鼠才能试出那瓶有毒。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%91%E5%85%8B%E7%89%8C%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-%E4%BB%8E%E7%89%8C%E9%A1%B6%E6%8B%BF%E5%87%BA%E4%B8%80%E5%BC%A0%E7%89%8C%E6%94%BE%E5%88%B0%E6%A1%8C%E5%AD%90%E4%B8%8A-%E5%86%8D%E4%BB%8E%E7%89%8C%E9%A1%B6%E6%8B%BF%E4%B8%80%E5%BC%A0%E7%89%8C%E6%94%BE%E5%9C%A8%E6%89%8B%E4%B8%8A%E7%89%8C%E7%9A%84%E5%BA%95%E9%83%A8%EF%BC%8C%E9%87%8D%E5%A4%8D%E7%AC%AC%E4%B8%80%E6%AD%A5%E3%80%81%E7%AC%AC%E4%BA%8C%E6%AD%A5%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">扑克牌面试问题:从牌顶拿出一张牌放到桌子上,再从牌顶拿一张牌放在手上牌的底部，重复第一步、第二步的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%94%AF%E4%B8%80%E5%85%83%E7%B4%A0-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O%EF%BC%88n%EF%BC%89-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O%EF%BC%881%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">查找数组中重复的唯一元素+时间复杂度O（n）+空间复杂度O（1）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">查找无序数组中缺失的最小正整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97n-%E5%A6%82%E6%9E%9Cn%E4%B8%BA%E5%81%B6%E6%95%B0%E5%88%99%E9%99%A4%E4%BB%A52%EF%BC%8C%E8%8B%A5%E4%B8%BA%E5%A5%87%E6%95%B0%E5%88%99%E5%8A%A01%E6%88%96%E8%80%85%E5%87%8F1%EF%BC%8C%E7%9B%B4%E5%88%B0n%E4%B8%BA1%EF%BC%8C%E6%B1%82%E6%9C%80%E5%B0%91%E6%AC%A1%E6%95%B0-%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">输入一个数字n 如果n为偶数则除以2，若为奇数则加1或者减1，直到n为1，求最少次数 写出一个函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%95%B4%E5%9E%8B%E6%95%B0%E7%BB%84A%E5%92%8CB%EF%BC%8C%E8%A6%81%E6%B1%82%E6%89%BE%E5%87%BA%E5%AD%98%E5%9C%A8%E6%95%B0%E7%BB%84A%E4%B8%AD%E8%80%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%95%B0%E7%BB%84B%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E5%B9%B6%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA%EF%BC%88%E4%BF%9D%E6%8C%81%E5%8E%9F%E9%A1%BA%E5%BA%8F%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">有两个整型数组A和B，要求找出存在数组A中而不存在数组B中的元素，并打印输出（保持原顺序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E5%92%8C%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">最小公倍数和最大公约数的三种算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Top-K-%E9%97%AE%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text">Top K 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%83%E7%B4%A0%E4%B9%8B%E5%92%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%89%8Dk%E9%A1%B9"><span class="toc-number">11.</span> <span class="toc-text">两个数组的元素之和最大的前k项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">12.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">13.</span> <span class="toc-text">文件大数据的排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D"><span class="toc-number">14.</span> <span class="toc-text">大数据去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B2%9B%E9%97%AE%E9%A2%98"><span class="toc-number">15.</span> <span class="toc-text">岛问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%AB-AAA-%E6%88%96-BBB-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">16.</span> <span class="toc-text">不含 AAA 或 BBB 的字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0num%E5%92%8C%E8%BF%9B%E5%88%B6%E6%95%B0scale%EF%BC%8C%E8%AE%A1%E7%AE%97%E5%87%BA1-num%E6%89%80%E6%9C%89%E6%95%B0%E5%AD%97%E5%9C%A8scale%E8%BF%9B%E5%88%B6%E4%B8%8B%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B9%8B%E5%92%8Clen"><span class="toc-number">17.</span> <span class="toc-text">给定一个正整数num和进制数scale，计算出1~num所有数字在scale进制下的长度之和len</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#word-search-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%8D%95%E8%AF%8D%EF%BC%88%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="toc-number">18.</span> <span class="toc-text">word search(二维数组中查找单词（匹配字符串）)</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
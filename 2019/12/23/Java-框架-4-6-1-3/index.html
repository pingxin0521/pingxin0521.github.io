<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Spring 原理 IOC容器的实现(四) | 平心de小屋</title><meta name="keywords" content="Java,框架,Spring"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="IOC 之 属性填充doCreateBean() 主要用于完成 bean 的创建和初始化工作，我们可以将其分为四个过程：  createBeanInstance() 实例化 bean populateBean() 属性填充 循环依赖的处理 initializeBean() 初始化 bean">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring 原理 IOC容器的实现(四)">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/12/23/Java-%E6%A1%86%E6%9E%B6-4-6-1-3/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="IOC 之 属性填充doCreateBean() 主要用于完成 bean 的创建和初始化工作，我们可以将其分为四个过程：  createBeanInstance() 实例化 bean populateBean() 属性填充 循环依赖的处理 initializeBean() 初始化 bean">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg">
<meta property="article:published_time" content="2019-12-23T11:18:59.000Z">
<meta property="article:modified_time" content="2021-01-09T13:37:23.970Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="框架">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/12/23/Java-%E6%A1%86%E6%9E%B6-4-6-1-3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring 原理 IOC容器的实现(四)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-01-09 21:37:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring 原理 IOC容器的实现(四)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-23T11:18:59.000Z" title="发表于 2019-12-23 19:18:59">2019-12-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-01-09T13:37:23.970Z" title="更新于 2021-01-09 21:37:23">2021-01-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/Spring/">Spring</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring 原理 IOC容器的实现(四)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="IOC-之-属性填充"><a href="#IOC-之-属性填充" class="headerlink" title="IOC 之 属性填充"></a>IOC 之 属性填充</h3><p><code>doCreateBean()</code> 主要用于完成 bean 的创建和初始化工作，我们可以将其分为四个过程：</p>
<ul>
<li><code>createBeanInstance()</code> 实例化 bean</li>
<li><code>populateBean()</code> 属性填充</li>
<li>循环依赖的处理</li>
<li><code>initializeBean()</code> 初始化 bean</li>
</ul>
<span id="more"></span>

<p>第一个过程实例化 bean在前面一篇博客中已经分析完了，这篇博客开始分析 属性填充，也就是 <code>populateBean()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;  </span><br><span class="line">    PropertyValues pvs = mbd.getPropertyValues();  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!pvs.isEmpty()) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// Skip property population phase for null instance.  </span></span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the  </span></span><br><span class="line">    <span class="comment">// state of the bean before properties are set. This can be used, for example,  </span></span><br><span class="line">    <span class="comment">// to support styles of field injection.  </span></span><br><span class="line">    <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;  </span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;  </span><br><span class="line">                <span class="comment">//返回值为是否继续填充bean  </span></span><br><span class="line">                <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;  </span><br><span class="line">                    continueWithPropertyPopulation = <span class="keyword">false</span>;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//如果后处理器发出停止填充命令则终止后续的执行  </span></span><br><span class="line">    <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||  </span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;  </span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by name if applicable.  </span></span><br><span class="line">        <span class="comment">//根据名称自动注入  </span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;  </span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by type if applicable.  </span></span><br><span class="line">        <span class="comment">//根据类型自动注入  </span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;  </span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        pvs = newPvs;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//后处理器已经初始化  </span></span><br><span class="line">    <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();  </span><br><span class="line">    <span class="comment">//需要依赖检查  </span></span><br><span class="line">    <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;  </span><br><span class="line">        PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);  </span><br><span class="line">        <span class="keyword">if</span> (hasInstAwareBpps) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;  </span><br><span class="line">                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;  </span><br><span class="line">                    <span class="comment">//对所有需要依赖检查的属性进行后处理  </span></span><br><span class="line">                    pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);  </span><br><span class="line">                    <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                        <span class="keyword">return</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (needsDepCheck) &#123;  </span><br><span class="line">            <span class="comment">//依赖检查，对应depends-on属性，3.0已经弃用此属性  </span></span><br><span class="line">            checkDependencies(beanName, mbd, filteredPds, pvs);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//将属性应用到bean中  </span></span><br><span class="line">    <span class="comment">//将所有ProtertyValues中的属性填充至BeanWrapper中。  </span></span><br><span class="line">    applyPropertyValues(beanName, mbd, bw, pvs);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们详细分析下populateBean的流程：</p>
<ol>
<li>首先进行属性是否为空的判断</li>
<li>通过调用InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)方法来控制程序是否继续进行属性填充</li>
<li>根据注入类型（byName/byType）提取依赖的bean，并统一存入PropertyValues中</li>
<li>应用InstantiationAwareBeanPostProcessor的postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName)方法，对属性获取完毕填充前的再次处理，典型的应用是RequiredAnnotationBeanPostProcesser类中对属性的验证</li>
<li>将所有的PropertyValues中的属性填充至BeanWrapper中</li>
</ol>
<p>上面步骤中有几个地方是我们比较感兴趣的，它们分别是依赖注入（autowireByName/autowireByType）以及属性填充，接下来进一步分析这几个功能的实现细节</p>
<h4 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h4><p>Spring 会根据注入类型（ byName / byType ）的不同，调用不同的方法（<code>autowireByName()</code> / <code>autowireByType()</code>）来注入属性值。</p>
<h5 id="autowireByName"><a href="#autowireByName" class="headerlink" title="autowireByName()"></a>autowireByName()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Bean 对象中非简单属性</span></span><br><span class="line">    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">    <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">        <span class="comment">// 如果容器中包含指定名称的 bean，则将该 bean 注入到 bean中</span></span><br><span class="line">        <span class="keyword">if</span> (containsBean(propertyName)) &#123;</span><br><span class="line">            <span class="comment">// 递归初始化相关 bean</span></span><br><span class="line">            Object bean = getBean(propertyName);</span><br><span class="line">            <span class="comment">// 为指定名称的属性赋予属性值  </span></span><br><span class="line">            pvs.add(propertyName, bean);</span><br><span class="line">            <span class="comment">// 属性依赖注入</span></span><br><span class="line">            registerDependentBean(propertyName, beanName);</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Added autowiring by name from bean name &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; via property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; to bean named &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Not autowiring property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; of bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; by name: no matching bean found&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法逻辑很简单，获取该 bean 的非简单属性，什么叫做非简单属性呢？就是类型为对象类型的属性，但是这里并不是将所有的对象类型都都会找到，比如 8 个原始类型，String 类型 ，Number类型、Date类型、URL类型、URI类型等都会被忽略，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) &#123;</span><br><span class="line">    Set&lt;String&gt; result = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line">    PropertyDescriptor[] pds = bw.getPropertyDescriptors();</span><br><span class="line">    <span class="keyword">for</span> (PropertyDescriptor pd : pds) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pd.getWriteMethod() != <span class="keyword">null</span> &amp;&amp; !isExcludedFromDependencyCheck(pd) &amp;&amp; !pvs.contains(pd.getName()) &amp;&amp;</span><br><span class="line">                !BeanUtils.isSimpleProperty(pd.getPropertyType())) &#123;</span><br><span class="line">            result.add(pd.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里获取的就是需要依赖注入的属性。</p>
<p>autowireByName()函数的功能就是根据传入的参数中的pvs中找出已经加载的bean，并递归实例化，然后加入到pvs中</p>
<h5 id="autowireByType"><a href="#autowireByType" class="headerlink" title="autowireByType"></a>autowireByType</h5><p>autowireByType与autowireByName对于我们理解与使用来说复杂程度相似，但是实现功能的复杂度却不一样，我们看下方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByType</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    TypeConverter converter = getCustomTypeConverter();  </span><br><span class="line">    <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        converter = bw;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="number">4</span>);  </span><br><span class="line">    <span class="comment">//寻找bw中需要依赖注入的属性  </span></span><br><span class="line">    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);  </span><br><span class="line">    <span class="keyword">for</span> (String propertyName : propertyNames) &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);  </span><br><span class="line">            <span class="comment">// Don&#x27;t try autowiring by type for type Object: never makes sense,  </span></span><br><span class="line">            <span class="comment">// even if it technically is a unsatisfied, non-simple property.  </span></span><br><span class="line">            <span class="keyword">if</span> (!Object.class.equals(pd.getPropertyType())) &#123;  </span><br><span class="line">                <span class="comment">//探测指定属性的set方法  </span></span><br><span class="line">                MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);  </span><br><span class="line">                <span class="comment">// Do not allow eager init for type matching in case of a prioritized post-processor.  </span></span><br><span class="line">                <span class="keyword">boolean</span> eager = !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass());  </span><br><span class="line">                DependencyDescriptor desc = <span class="keyword">new</span> AutowireByTypeDependencyDescriptor(methodParam, eager);  </span><br><span class="line">                <span class="comment">//解析指定beanName的属性所匹配的值，并把解析到的属性名称存储在autowiredBeanNames中，  </span></span><br><span class="line">                Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);  </span><br><span class="line">                <span class="keyword">if</span> (autowiredArgument != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    pvs.add(propertyName, autowiredArgument);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;  </span><br><span class="line">                    <span class="comment">//注册依赖  </span></span><br><span class="line">                    registerDependentBean(autowiredBeanName, beanName);  </span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                        logger.debug(<span class="string">&quot;Autowiring by type from bean name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; via property &#x27;&quot;</span> +  </span><br><span class="line">                                propertyName + <span class="string">&quot;&#x27; to bean named &#x27;&quot;</span> + autowiredBeanName + <span class="string">&quot;&#x27;&quot;</span>);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                autowiredBeanNames.clear();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据名称第一步与根据属性第一步都是寻找bw中需要依赖注入的属性，然后遍历这些属性并寻找类型匹配的bean,其中最复杂就是寻找类型匹配的bean。spring中提供了对集合的类型注入支持，如使用如下注解方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Test&gt; tests;</span><br></pre></td></tr></table></figure>

<p>这种方式spring会把所有与Test匹配的类型找出来并注入到tests属性中，正是由于这一因素，所以在autowireByType函数，新建了局部遍历autowireBeanNames，用于存储所有依赖的bean，如果只是对非集合类的属性注入来说，此属性并无用处。</p>
<p>对于寻找类型匹配的逻辑实现是封装在了resolveDependency函数中，其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, String beanName, Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());  </span><br><span class="line">    <span class="keyword">if</span> (descriptor.getDependencyType().equals(ObjectFactory.class)) &#123;  </span><br><span class="line">        <span class="comment">//ObjectFactory类注入的特殊处理  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DependencyObjectFactory(descriptor, beanName);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (descriptor.getDependencyType().equals(javaxInjectProviderClass)) &#123;  </span><br><span class="line">        <span class="comment">//javaxInjectProviderClass类注入的特殊处理  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DependencyProviderFactory().createDependencyProvider(descriptor, beanName);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//通用处理逻辑  </span></span><br><span class="line">        <span class="keyword">return</span> doResolveDependency(descriptor, descriptor.getDependencyType(), beanName, autowiredBeanNames, typeConverter);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, Class&lt;?&gt; type, String beanName,  </span></span></span><br><span class="line"><span class="params"><span class="function">        Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 用于支持Spring中新增的注解@Value </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);  </span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;  </span><br><span class="line">            String strVal = resolveEmbeddedValue((String) value);  </span><br><span class="line">            BeanDefinition bd = (beanName != <span class="keyword">null</span> &amp;&amp; containsBean(beanName) ? getMergedBeanDefinition(beanName) : <span class="keyword">null</span>);  </span><br><span class="line">            value = evaluateBeanDefinitionString(strVal, bd);  </span><br><span class="line">        &#125;  </span><br><span class="line">        TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());  </span><br><span class="line">        <span class="keyword">return</span> (descriptor.getField() != <span class="keyword">null</span> ?  </span><br><span class="line">                converter.convertIfNecessary(value, type, descriptor.getField()) :  </span><br><span class="line">                converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//如果解析器没有成功解析，则需要考虑各种情况  </span></span><br><span class="line">    <span class="comment">//属性是数组类型  </span></span><br><span class="line">    <span class="keyword">if</span> (type.isArray()) &#123;  </span><br><span class="line">        Class&lt;?&gt; componentType = type.getComponentType();  </span><br><span class="line">        <span class="comment">//根据属性类型找到beanFactory中所有类型的匹配bean，  </span></span><br><span class="line">        <span class="comment">//返回值的构成为：key=匹配的beanName,value=beanName对应的实例化后的bean（通过getBean(beanName)返回）  </span></span><br><span class="line">        Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, componentType, descriptor);  </span><br><span class="line">        <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;  </span><br><span class="line">            <span class="comment">//如果autowire的require属性为true而找到的匹配项却为空则只能抛出异常  </span></span><br><span class="line">            <span class="keyword">if</span> (descriptor.isRequired()) &#123;  </span><br><span class="line">                raiseNoSuchBeanDefinitionException(componentType, <span class="string">&quot;array of &quot;</span> + componentType.getName(), descriptor);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            autowiredBeanNames.addAll(matchingBeans.keySet());  </span><br><span class="line">        &#125;  </span><br><span class="line">        TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());  </span><br><span class="line">        <span class="comment">//通过转换器将bean的值转换为对应的type类型  </span></span><br><span class="line">        <span class="keyword">return</span> converter.convertIfNecessary(matchingBeans.values(), type);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//属性是Collection类型  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Collection.class.isAssignableFrom(type) &amp;&amp; type.isInterface()) &#123;  </span><br><span class="line">        Class&lt;?&gt; elementType = descriptor.getCollectionType();  </span><br><span class="line">        <span class="keyword">if</span> (elementType == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (descriptor.isRequired()) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">&quot;No element type declared for collection [&quot;</span> + type.getName() + <span class="string">&quot;]&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, elementType, descriptor);  </span><br><span class="line">        <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (descriptor.isRequired()) &#123;  </span><br><span class="line">                raiseNoSuchBeanDefinitionException(elementType, <span class="string">&quot;collection of &quot;</span> + elementType.getName(), descriptor);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            autowiredBeanNames.addAll(matchingBeans.keySet());  </span><br><span class="line">        &#125;  </span><br><span class="line">        TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());  </span><br><span class="line">        <span class="keyword">return</span> converter.convertIfNecessary(matchingBeans.values(), type);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//属性是Map类型  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Map.class.isAssignableFrom(type) &amp;&amp; type.isInterface()) &#123;  </span><br><span class="line">        Class&lt;?&gt; keyType = descriptor.getMapKeyType();  </span><br><span class="line">        <span class="keyword">if</span> (keyType == <span class="keyword">null</span> || !String.class.isAssignableFrom(keyType)) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (descriptor.isRequired()) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">&quot;Key type [&quot;</span> + keyType + <span class="string">&quot;] of map [&quot;</span> + type.getName() +  </span><br><span class="line">                        <span class="string">&quot;] must be assignable to [java.lang.String]&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        Class&lt;?&gt; valueType = descriptor.getMapValueType();  </span><br><span class="line">        <span class="keyword">if</span> (valueType == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (descriptor.isRequired()) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">&quot;No value type declared for map [&quot;</span> + type.getName() + <span class="string">&quot;]&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, valueType, descriptor);  </span><br><span class="line">        <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (descriptor.isRequired()) &#123;  </span><br><span class="line">                raiseNoSuchBeanDefinitionException(valueType, <span class="string">&quot;map with value type &quot;</span> + valueType.getName(), descriptor);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            autowiredBeanNames.addAll(matchingBeans.keySet());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> matchingBeans;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);  </span><br><span class="line">        <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (descriptor.isRequired()) &#123;  </span><br><span class="line">                raiseNoSuchBeanDefinitionException(type, <span class="string">&quot;&quot;</span>, descriptor);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;  </span><br><span class="line">            String primaryBeanName = determinePrimaryCandidate(matchingBeans, descriptor);  </span><br><span class="line">            <span class="keyword">if</span> (primaryBeanName == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(type, matchingBeans.keySet());  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                autowiredBeanNames.add(primaryBeanName);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> matchingBeans.get(primaryBeanName);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// We have exactly one match.  </span></span><br><span class="line">        Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();  </span><br><span class="line">        <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            autowiredBeanNames.add(entry.getKey());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//已经确定只有一个匹配项  </span></span><br><span class="line">        <span class="keyword">return</span> entry.getValue();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="applyPropertyValues"><a href="#applyPropertyValues" class="headerlink" title="applyPropertyValues"></a>applyPropertyValues</h4><p>程序运行到这里，已经完成了对所有注入属性的获取，但是获取的属性是以PropertyValues形式存在的，还并没有应用到已经实例化的bean中，这一工作是在applyPropertyValues中。继续跟踪到方法体中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (pvs == <span class="keyword">null</span> || pvs.isEmpty()) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    MutablePropertyValues mpvs = <span class="keyword">null</span>;  </span><br><span class="line">    List&lt;PropertyValue&gt; original;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;  </span><br><span class="line">            ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;  </span><br><span class="line">        mpvs = (MutablePropertyValues) pvs;  </span><br><span class="line">        <span class="comment">//如果mpvs中的值已经被转换为对应的类型那么可以直接设置到beanwapper中  </span></span><br><span class="line">        <span class="keyword">if</span> (mpvs.isConverted()) &#123;  </span><br><span class="line">            <span class="comment">// Shortcut: use the pre-converted values as-is.  </span></span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                bw.setPropertyValues(mpvs);  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </span><br><span class="line">                        mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        original = mpvs.getPropertyValueList();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//如果pvs并不是使用MutablePropertyValues封装的类型，那么直接使用原始的属性获取方法  </span></span><br><span class="line">        original = Arrays.asList(pvs.getPropertyValues());  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    TypeConverter converter = getCustomTypeConverter();  </span><br><span class="line">    <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        converter = bw;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//获取对应的解析器  </span></span><br><span class="line">    BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a deep copy, resolving any references for values.  </span></span><br><span class="line">    List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;PropertyValue&gt;(original.size());  </span><br><span class="line">    <span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;  </span><br><span class="line">    <span class="comment">//遍历属性，将属性转换为对应类的对应属性的类型  </span></span><br><span class="line">    <span class="keyword">for</span> (PropertyValue pv : original) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (pv.isConverted()) &#123;  </span><br><span class="line">            deepCopy.add(pv);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            String propertyName = pv.getName();  </span><br><span class="line">            Object originalValue = pv.getValue();  </span><br><span class="line">            Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);  </span><br><span class="line">            Object convertedValue = resolvedValue;  </span><br><span class="line">            <span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;  </span><br><span class="line">                    !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);  </span><br><span class="line">            <span class="keyword">if</span> (convertible) &#123;  </span><br><span class="line">                convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// Possibly store converted value in merged bean definition,  </span></span><br><span class="line">            <span class="comment">// in order to avoid re-conversion for every created bean instance.  </span></span><br><span class="line">            <span class="keyword">if</span> (resolvedValue == originalValue) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (convertible) &#123;  </span><br><span class="line">                    pv.setConvertedValue(convertedValue);  </span><br><span class="line">                &#125;  </span><br><span class="line">                deepCopy.add(pv);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;  </span><br><span class="line">                    !((TypedStringValue) originalValue).isDynamic() &amp;&amp;  </span><br><span class="line">                    !(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;  </span><br><span class="line">                pv.setConvertedValue(convertedValue);  </span><br><span class="line">                deepCopy.add(pv);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                resolveNecessary = <span class="keyword">true</span>;  </span><br><span class="line">                deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (mpvs != <span class="keyword">null</span> &amp;&amp; !resolveNecessary) &#123;  </span><br><span class="line">        mpvs.setConverted();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set our (possibly massaged) deep copy.  </span></span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环依赖处理"><a href="#循环依赖处理" class="headerlink" title="循环依赖处理"></a>循环依赖处理</h3><p>循环依赖其实就是循环引用，也就是两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/12/25/eC78KSWf1sFYRtn.png" alt="image.png"></p>
<p>注意，这里不是函数的循环调用，是对象的相互依赖关系。循环调用其实就是一个死循环，除非有终结条件。</p>
<p>Spring中循环依赖场景有：</p>
<ol>
<li>构造器的循环依赖</li>
<li>field属性的循环依赖。 </li>
</ol>
<p>对于构造器的循环依赖，Spring 是无法解决的，只能抛出 BeanCurrentlyInCreationException 异常表示循环依赖，所以下面我们分析的都是基于 field 属性的循环依赖。</p>
<p>Spring 只解决 scope 为 singleton 的循环依赖，对于scope 为 prototype 的 bean Spring 无法解决，直接抛出 BeanCurrentlyInCreationException 异常。</p>
<h4 id="如何检测循环依赖"><a href="#如何检测循环依赖" class="headerlink" title="如何检测循环依赖"></a>如何检测循环依赖</h4><p>检测循环依赖相对比较容易，Bean在创建的时候可以给该Bean打标，如果递归调用回来发现正在创建中的话，即说明了循环依赖了。</p>
<h4 id="解决循环依赖"><a href="#解决循环依赖" class="headerlink" title="解决循环依赖"></a>解决循环依赖</h4><p>我们先从加载 bean 最初始的方法 <code>doGetBean()</code> 开始。</p>
<p>在 <code>doGetBean()</code> 中，首先会根据 beanName 从单例 bean 缓存中获取，如果不为空则直接返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是从三个缓存中获取，分别是：singletonObjects、earlySingletonObjects、singletonFactories，三者定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>这三级缓存分别指：</p>
<ol>
<li>singletonFactories ： 单例对象工厂的cache</li>
<li>earlySingletonObjects ：提前暴光的单例对象的Cache</li>
<li>singletonObjects：单例对象的cache</li>
</ol>
<p>他们就是 Spring 解决 singleton bean 的关键因素所在，我称他们为三级缓存，第一级为 singletonObjects，第二级为 earlySingletonObjects，第三级为 singletonFactories。这里我们可以通过 <code>getSingleton()</code> 看到他们是如何配合的，这分析该方法之前，提下其中的 <code>isSingletonCurrentlyInCreation()</code> 和 <code>allowEarlyReference</code>。</p>
<ul>
<li><code>isSingletonCurrentlyInCreation()</code>：判断当前 singleton bean 是否处于创建中。bean 处于创建中也就是说 bean 在初始化但是没有完成初始化，有一个这样的过程其实和 Spring 解决 bean 循环依赖的理念相辅相成，因为 Spring 解决 singleton bean 的核心就在于提前曝光 bean。</li>
<li>allowEarlyReference：从字面意思上面理解就是允许提前拿到引用。其实真正的意思是是否允许从 singletonFactories 缓存中通过 <code>getObject()</code> 拿到对象，为什么会有这样一个字段呢？原因就在于 singletonFactories 才是 Spring 解决 singleton bean 的诀窍所在，这个我们后续分析。</li>
</ul>
<p><code>getSingleton()</code> 整个过程如下：首先从一级缓存 singletonObjects 获取，如果没有且当前指定的 beanName 正在创建，就再从二级缓存中 earlySingletonObjects 获取，如果还是没有获取到且运行 singletonFactories 通过 <code>getObject()</code> 获取，则从三级缓存 singletonFactories 获取，如果获取到则，通过其 <code>getObject()</code> 获取对象，并将其加入到二级缓存 earlySingletonObjects 中 从三级缓存 singletonFactories 删除，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line">this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">this.singletonFactories.remove(beanName);</span><br></pre></td></tr></table></figure>

<p>这样就从三级缓存升级到二级缓存了。</p>
<p>上面是从缓存中获取，但是缓存中的数据从哪里添加进来的呢？一直往下跟会发现在 <code>doCreateBean()</code> ( AbstractAutowireCapableBeanFactory ) 中，有这么一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提前将创建好但还未进行属性赋值的的Bean放入缓存中。</p>
<p>如果 <code>earlySingletonExposure == true</code> 的话，则调用 <code>addSingletonFactory()</code> 将他们添加到缓存中，但是一个 bean 要具备如下条件才会添加至缓存中：</p>
<ul>
<li>单例</li>
<li>运行提前暴露 bean</li>
<li>当前 bean 正在创建中</li>
</ul>
<p><code>addSingletonFactory()</code> 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码我们可以看出 singletonFactories 这个三级缓存才是解决 Spring Bean 循环依赖的诀窍所在。同时这段代码发生在 <code>createBeanInstance()</code> 方法之后，也就是说这个 bean 其实已经被创建出来了，但是它还不是很完美（没有进行属性填充和初始化），但是对于其他依赖它的对象而言已经足够了（可以根据对象引用定位到堆中对象），能够被认出来了，所以 Spring 在这个时候选择将该对象提前曝光出来让大家认识认识。</p>
<p>介绍到这里我们发现三级缓存 singletonFactories 和 二级缓存 earlySingletonObjects 中的值都有出处了，那一级缓存在哪里设置的呢？在类 DefaultSingletonBeanRegistry 中可以发现这个 <code>addSingleton()</code> 方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">        <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">        <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加至一级缓存，同时从二级、三级缓存中删除。这个方法在我们创建 bean 的链路中有哪个地方引用呢？其实在前面已经提到过了，在 <code>doGetBean()</code> 处理不同 scope 时，如果是 singleton，则调用 <code>getSingleton()</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">            <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">            <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Spring 关于 singleton bean 循环依赖已经分析完毕了。所以我们基本上可以确定 Spring 解决循环依赖的方案了：<strong>Spring 在创建 bean 的时候并不是等它完全完成，而是在创建过程中将创建中的 bean 的 ObjectFactory 提前曝光（即加入到 singletonFactories 缓存中），这样一旦下一个 bean 创建的时候需要依赖 bean ，则直接使用 ObjectFactory 的 <code>getObject()</code> 获取了，也就是 <code>getSingleton()</code>中的代码片段了。</strong></p>
<p>到这里，关于 Spring 解决 bean 循环依赖就已经分析完毕了。最后来描述下就上面那个循环依赖 Spring 解决的过程：</p>
<p>首先 A 完成初始化第一步并将自己提前曝光出来（通过 ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象 B，此时就会去尝试 get(B)，这个时候发现 B 还没有被创建出来，然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C，C 也没有被创建出来，这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试 get(A)，这个时候由于 A 已经添加至缓存中（一般都是添加至<strong>三级缓存</strong> singletonFactories ），通过 ObjectFactory 提前曝光，所以可以通过 <code>ObjectFactory.getObject()</code> 拿到 A 对象，C 拿到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中，回到 B ，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路就已经完成了初始化过程了。</p>
<h3 id="bean-的初始化"><a href="#bean-的初始化" class="headerlink" title="bean 的初始化"></a>bean 的初始化</h3><p>一个 bean 经历了 <code>createBeanInstance()</code> 被创建出来，然后又经过一番属性注入，依赖处理，历经千辛万苦，千锤百炼，终于有点儿 bean 实例的样子，能堪大任了，只需要经历最后一步就破茧成蝶了。这最后一步就是初始化，也就是 <code>initializeBean()</code>，所以这篇文章我们分析 <code>doCreateBean()</code> 中最后一步：初始化 bean。</p>
<p>我回到之前的doCreateBean方法中，如下<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/12/25/oOij5g3Ad6Wl8DN.png" alt="image.png"></p>
<p>在populateBean方法下面有一个initializeBean(beanName, exposedObject, mbd)方法，这个就是用来执行用户设定的初始化操作。我们看下方法体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            <span class="comment">// 激活 Aware 方法</span></span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware</span></span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// 后处理器</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 激活用户自定义的 init 方法</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">                beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// 后处理器</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化 bean 的方法其实就是三个步骤的处理，而这三个步骤主要还是根据用户设定的来进行初始化，这三个过程为：</p>
<ol>
<li>激活 Aware 方法</li>
<li>后置处理器的应用</li>
<li>激活自定义的 init 方法</li>
</ol>
<h4 id="激Aware方法"><a href="#激Aware方法" class="headerlink" title="激Aware方法"></a>激Aware方法</h4><p>我们先了解一下Aware方法的使用。Spring中提供了一些Aware接口，比如BeanFactoryAware,ApplicationContextAware,ResourceLoaderAware,ServletContextAware等，实现这些Aware接口的bean在被初始化后，可以取得一些相对应的资源，例如实现BeanFactoryAware的bean在初始化之后，Spring容器将会注入BeanFactory实例，而实现ApplicationContextAware的bean，在bean被初始化后，将会被注入ApplicationContext实例等。</p>
<p>定义普通bean，如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义beanFactoryAware类型的bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanAware</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAware</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//通过hello这个bean id从beanFactory获取实例  </span></span><br><span class="line">        HelloBean hello = (HelloBean)beanFactory.getBean(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        hello.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        MyBeanAware test = (MyBeanAware)ctx.getBean(<span class="string">&quot;myBeanAware&quot;</span>);</span><br><span class="line">        test.testAware();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;myBeanAware&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.chenhao.spring.MyBeanAware&quot;</span>&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;hello&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.chenhao.spring.HelloBean&quot;</span>&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br></pre></td></tr></table></figure>

<p>上面的方法我们获取到Spring中BeanFactory，并且可以根据BeanFactory获取所有的bean,以及进行相关设置。还有其他Aware的使用都是大同小异，看一下Spring的实现方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;  </span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;  </span><br><span class="line">            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;  </span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理器的应用"><a href="#处理器的应用" class="headerlink" title="处理器的应用"></a>处理器的应用</h4><p>BeanPostPrecessor我们经常看到Spring中使用，这是Spring开放式架构的一个必不可少的亮点，给用户充足的权限去更改或者扩展Spring,而除了BeanPostProcessor外还有很多其他的PostProcessor，当然大部分都以此为基础，集成自BeanPostProcessor。BeanPostProcessor在调用用户自定义初始化方法前或者调用自定义初始化方法后分别会调用BeanPostProcessor的postProcessBeforeInitialization和postProcessAfterinitialization方法，使用户可以根据自己的业务需求就行相应的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line"></span><br><span class="line">    Object result = existingBean;  </span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;  </span><br><span class="line">        result = beanProcessor.postProcessBeforeInitialization(result, beanName);  </span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line"></span><br><span class="line">    Object result = existingBean;  </span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;  </span><br><span class="line">        result = beanProcessor.postProcessAfterInitialization(result, beanName);  </span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="激活自定义的init方法"><a href="#激活自定义的init方法" class="headerlink" title="激活自定义的init方法"></a>激活自定义的init方法</h4><p>客户定制的初始化方法除了我们熟知的使用配置init-method外，还有使自定义的bean实现InitializingBean接口，并在afterPropertiesSet中实现自己的初始化业务逻辑。</p>
<p>init-method与afterPropertiesSet都是在初始化bean时执行，执行顺序是afterPropertiesSet先执行，而init-method后执行。</p>
<p>在invokeInitMethods方法中就实现了这两个步骤的初始化调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否实现 InitializingBean</span></span><br><span class="line">    <span class="comment">// 如果实现了 InitializingBean 接口，则只掉调用bean的 afterPropertiesSet()</span></span><br><span class="line">    <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                <span class="keyword">throw</span> pae.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 直接调用 afterPropertiesSet()</span></span><br><span class="line">            ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">        <span class="comment">// 判断是否指定了 init-method()，</span></span><br><span class="line">        <span class="comment">// 如果指定了 init-method()，则再调用制定的init-method</span></span><br><span class="line">        String initMethodName = mbd.getInitMethodName();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">                !(isInitializingBean &amp;&amp; <span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">                !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">            <span class="comment">// 利用反射机制执行</span></span><br><span class="line">            invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先检测当前 bean 是否实现了 InitializingBean 接口，如果实现了则调用其 <code>afterPropertiesSet()</code>，然后再检查是否也指定了 <code>init-method()</code>，如果指定了则通过反射机制调用指定的 <code>init-method()</code>。</p>
<h5 id="init-method"><a href="#init-method" class="headerlink" title="init-method()"></a>init-method()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializingBeanTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOtherName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InitializingBeanTest setOtherName...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;chenhao&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置文件</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;initializingBeanTest&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.chenhao.spring.InitializingBeanTest&quot;</span></span><br><span class="line">        init-method=<span class="string">&quot;setOtherName&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;chenhao123&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chenhao</span><br></pre></td></tr></table></figure>

<p>我们可以使用 <code>标签的 `default-init-method` 属性来统一指定初始化方法，这样就省了需要在每个</code> 标签中都设置 <code>init-method</code> 这样的繁琐工作了。比如在 <code>default-init-method</code> 规定所有初始化操作全部以 <code>initBean()</code> 命名。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/12/25/d2SOv7fJeVqA6D5.png" alt="image.png"></p>
<p>我们看看 invokeCustomInitMethod 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeCustomInitMethod</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">    String initMethodName = mbd.getInitMethodName();</span><br><span class="line">    Assert.state(initMethodName != <span class="keyword">null</span>, <span class="string">&quot;No init method set&quot;</span>);</span><br><span class="line">    Method initMethod = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">            BeanUtils.findMethod(bean.getClass(), initMethodName) :</span><br><span class="line">            ClassUtils.getMethodIfAvailable(bean.getClass(), initMethodName));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mbd.isEnforceInitMethod()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(<span class="string">&quot;Could not find an init method named &#x27;&quot;</span> +</span><br><span class="line">                    initMethodName + <span class="string">&quot;&#x27; on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;No default init method named &#x27;&quot;</span> + initMethodName +</span><br><span class="line">                        <span class="string">&quot;&#x27; found on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Ignore non-existent default lifecycle methods.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Invoking init method  &#x27;&quot;</span> + initMethodName + <span class="string">&quot;&#x27; on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Method methodToInvoke = ClassUtils.getInterfaceMethodIfPossible(initMethod);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            ReflectionUtils.makeAccessible(methodToInvoke);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//反射执行</span></span><br><span class="line">            AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt;</span><br><span class="line">                    methodToInvoke.invoke(bean), getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">            InvocationTargetException ex = (InvocationTargetException) pae.getException();</span><br><span class="line">            <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ReflectionUtils.makeAccessible(initMethod);</span><br><span class="line">            initMethod.invoke(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看出最后是使用反射的方式来执行初始化方法。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/12/23/Java-%E6%A1%86%E6%9E%B6-4-6-1-3/">https://pingxin0521.gitee.io/2019/12/23/Java-%E6%A1%86%E6%9E%B6-4-6-1-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/12/24/Java-%E6%A1%86%E6%9E%B6-4-6-2-0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring 原理 动态AOP (一)</div></div></a></div><div class="next-post pull-right"><a href="/2019/12/22/Java-%E6%A1%86%E6%9E%B6-4-6-1-2/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring 原理 IOC容器的实现(三)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/12/25/Java-框架-4-6-2-1/" title="Spring 原理 动态AOP (二)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">Spring 原理 动态AOP (二)</div></div></a></div><div><a href="/2019/05/22/Java-框架-4-3-1/" title="Spring JDBC"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">Spring JDBC</div></div></a></div><div><a href="/2019/05/22/Java-框架-4-4-1/" title="Spring 测试"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">Spring 测试</div></div></a></div><div><a href="/2019/05/22/Java-框架-4-0-1/" title="Spring  入坑"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">Spring  入坑</div></div></a></div><div><a href="/2019/05/22/Java-框架-4-1-1/" title="Spring  依赖注入(一)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">Spring  依赖注入(一)</div></div></a></div><div><a href="/2019/05/22/Java-框架-4-2-1/" title="Spring AOP和aspectj"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">Spring AOP和aspectj</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC-%E4%B9%8B-%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85"><span class="toc-number">1.</span> <span class="toc-text">IOC 之 属性填充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5"><span class="toc-number">1.1.</span> <span class="toc-text">自动注入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#autowireByName"><span class="toc-number">1.1.1.</span> <span class="toc-text">autowireByName()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#autowireByType"><span class="toc-number">1.1.2.</span> <span class="toc-text">autowireByType</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#applyPropertyValues"><span class="toc-number">1.2.</span> <span class="toc-text">applyPropertyValues</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%A4%84%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">循环依赖处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">2.1.</span> <span class="toc-text">如何检测循环依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">2.2.</span> <span class="toc-text">解决循环依赖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bean-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">bean 的初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BF%80Aware%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">激Aware方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">处理器的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84init%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">激活自定义的init方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#init-method"><span class="toc-number">3.3.1.</span> <span class="toc-text">init-method()</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
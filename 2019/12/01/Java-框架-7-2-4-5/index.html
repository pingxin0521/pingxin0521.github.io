<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Mybatis 源码分析 结果集 ResultSet 自动映射(五) | 平心de小屋</title><meta name="keywords" content="Java,框架,DAO,Mybatis"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="上一篇文章我们已经将SQL发送到了数据库，并返回了ResultSet，接下来就是将结果集 ResultSet 自动映射成实体类对象。这样使用者就无需再手动操作结果集，并将数据填充到实体类对象中。这可大大降低开发的工作量，提高工作效率。">
<meta property="og:type" content="article">
<meta property="og:title" content="Mybatis 源码分析 结果集 ResultSet 自动映射(五)">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/12/01/Java-%E6%A1%86%E6%9E%B6-7-2-4-5/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="上一篇文章我们已经将SQL发送到了数据库，并返回了ResultSet，接下来就是将结果集 ResultSet 自动映射成实体类对象。这样使用者就无需再手动操作结果集，并将数据填充到实体类对象中。这可大大降低开发的工作量，提高工作效率。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg">
<meta property="article:published_time" content="2019-12-01T09:18:59.000Z">
<meta property="article:modified_time" content="2021-01-09T13:37:24.305Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="框架">
<meta property="article:tag" content="DAO">
<meta property="article:tag" content="Mybatis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/12/01/Java-%E6%A1%86%E6%9E%B6-7-2-4-5/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Mybatis 源码分析 结果集 ResultSet 自动映射(五)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-01-09 21:37:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Mybatis 源码分析 结果集 ResultSet 自动映射(五)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-01T09:18:59.000Z" title="发表于 2019-12-01 17:18:59">2019-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-01-09T13:37:24.305Z" title="更新于 2021-01-09 21:37:24">2021-01-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E6%A1%86%E6%9E%B6/">框架</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Mybatis 源码分析 结果集 ResultSet 自动映射(五)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>上一篇文章我们已经将SQL发送到了数据库，并返回了ResultSet，接下来就是将结果集 ResultSet 自动映射成实体类对象。这样使用者就无需再手动操作结果集，并将数据填充到实体类对象中。这可大大降低开发的工作量，提高工作效率。</p>
<span id="more"></span>

<h4 id="映射结果入口"><a href="#映射结果入口" class="headerlink" title="映射结果入口"></a>映射结果入口</h4><p>我们来看看上次看源码的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement)statement;</span><br><span class="line">    <span class="comment">//执行数据库SQL</span></span><br><span class="line">    ps.execute();</span><br><span class="line">    <span class="comment">//进行resultSet自动映射</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果集的处理入口方法是 handleResultSets</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取第一个ResultSet,通常只会有一个</span></span><br><span class="line">    ResultSetWrapper rsw = getFirstResultSet(stmt);</span><br><span class="line">    <span class="comment">//从配置中读取对应的ResultMap，通常也只会有一个，设置多个是通过逗号来分隔，我们平时有这样设置吗？</span></span><br><span class="line">    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">    <span class="keyword">int</span> resultMapCount = resultMaps.size();</span><br><span class="line">    validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">        ResultMap resultMap = resultMaps.get(resultSetCount);</span><br><span class="line">        <span class="comment">// 处理结果集</span></span><br><span class="line">        handleResultSet(rsw, resultMap, multipleResults, <span class="keyword">null</span>);</span><br><span class="line">        rsw = getNextResultSet(stmt);</span><br><span class="line">        cleanUpAfterHandlingResultSet();</span><br><span class="line">        resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下逻辑均与多结果集有关，就不分析了，代码省略</span></span><br><span class="line">    String[] resultSets = mappedStatement.getResultSets();</span><br><span class="line">    <span class="keyword">if</span> (resultSets != <span class="keyword">null</span>) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际运行过程中，通常情况下一个Sql语句只返回一个结果集，对多个结果集的情况不做分析 。实际很少用到。继续看handleResultSet方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResultSet</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleRowValues(rsw, resultMap, <span class="keyword">null</span>, RowBounds.DEFAULT, parentMapping);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建默认的结果处理器</span></span><br><span class="line">                DefaultResultHandler defaultResultHandler = <span class="keyword">new</span> DefaultResultHandler(objectFactory);</span><br><span class="line">                <span class="comment">// 处理结果集的行数据</span></span><br><span class="line">                handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 将结果加入multipleResults中</span></span><br><span class="line">                multipleResults.add(defaultResultHandler.getResultList());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handleRowValues(rsw, resultMap, resultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        closeResultSet(rsw.getResultSet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过handleRowValues 映射ResultSet结果，最后映射的结果会在defaultResultHandler的ResultList集合中，最后将结果加入到multipleResults中就可以返回了，我们继续跟进<strong>handleRowValues这个核心方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRowValues</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler,</span></span></span><br><span class="line"><span class="params"><span class="function">        RowBounds rowBounds, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resultMap.hasNestedResultMaps()) &#123;</span><br><span class="line">        ensureNoRowBounds();</span><br><span class="line">        checkResultHandler();</span><br><span class="line">        <span class="comment">// 处理嵌套映射，关于嵌套映射我们下一篇文章单独分析</span></span><br><span class="line">        handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理简单映射，本文先只分析简单映射</span></span><br><span class="line">        handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过resultMap.hasNestedResultMaps()知道查询语句是否是嵌套查询，如果resultMap中包含&lt;association&gt; 和 &lt;collection&gt;且其select属性不为空，则为嵌套查询，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRowValuesForSimpleResultMap</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap,</span></span></span><br><span class="line"><span class="params"><span class="function">        ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    DefaultResultContext&lt;Object&gt; resultContext = <span class="keyword">new</span> DefaultResultContext&lt;Object&gt;();</span><br><span class="line">    <span class="comment">// 根据 RowBounds 定位到指定行记录</span></span><br><span class="line">    skipRows(rsw.getResultSet(), rowBounds);</span><br><span class="line">    <span class="comment">// ResultSet是一个集合，很有可能我们查询的就是一个List，这就就每条数据遍历处理</span></span><br><span class="line">    <span class="keyword">while</span> (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; rsw.getResultSet().next()) &#123;</span><br><span class="line">        ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 从 resultSet 中获取结果</span></span><br><span class="line">        Object rowValue = getRowValue(rsw, discriminatedResultMap);</span><br><span class="line">        <span class="comment">// 存储结果到resultHandler的ResultList，最后ResultList加入multipleResults中返回</span></span><br><span class="line">        storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们查询的结果很有可能是一个集合，所以这里要遍历集合，每条结果单独进行映射，最后映射的结果加入到resultHandler的ResultList</p>
<p>MyBatis 默认提供了 RowBounds 用于分页，从上面的代码中可以看出，这并非是一个高效的分页方式，是查出所有的数据，进行内存分页。除了使用 RowBounds，还可以使用一些第三方分页插件进行分页。我们来看关键代码getRowValue，处理一行数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getRowValue</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 这个Map是用来存储延迟加载的BountSql的，我们下面来看</span></span><br><span class="line">    <span class="keyword">final</span> ResultLoaderMap lazyLoader = <span class="keyword">new</span> ResultLoaderMap();</span><br><span class="line"> <span class="comment">// 创建实体类对象，比如 Employ 对象</span></span><br><span class="line">    Object rowValue = createResultObject(rsw, resultMap, lazyLoader, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (rowValue != <span class="keyword">null</span> &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) &#123;</span><br><span class="line">        <span class="keyword">final</span> MetaObject metaObject = configuration.newMetaObject(rowValue);</span><br><span class="line">        <span class="keyword">boolean</span> foundValues = <span class="keyword">this</span>.useConstructorMappings;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (shouldApplyAutomaticMappings(resultMap, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="comment">//自动映射,结果集中有的column，但resultMap中并没有配置  </span></span><br><span class="line">            foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, <span class="keyword">null</span>) || foundValues;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 根据 &lt;resultMap&gt; 节点中配置的映射关系进行映射</span></span><br><span class="line">        foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, <span class="keyword">null</span>) || foundValues;</span><br><span class="line">        foundValues = lazyLoader.size() &gt; <span class="number">0</span> || foundValues;</span><br><span class="line">        rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() ? rowValue : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rowValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的逻辑已经注释出来了。分别如下：</p>
<ol>
<li>创建实体类对象</li>
<li>自动映射结果集中有的column，但resultMap中并没有配置</li>
<li>根据 &lt;resultMap&gt; 节点中配置的映射关系进行映射</li>
</ol>
<h4 id="创建实体类对象"><a href="#创建实体类对象" class="headerlink" title="创建实体类对象"></a>创建实体类对象</h4><p>我们想将查询结果映射成实体类对象，第一步当然是要创建实体类对象了，下面我们来看一下 MyBatis 创建实体类对象的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createResultObject</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.useConstructorMappings = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; constructorArgTypes = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; constructorArgs = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用重载方法创建实体类对象</span></span><br><span class="line">    Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">    <span class="keyword">if</span> (resultObject != <span class="keyword">null</span> &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span><br><span class="line">        <span class="keyword">for</span> (ResultMapping propertyMapping : propertyMappings) &#123;</span><br><span class="line">            <span class="comment">// 如果开启了延迟加载，则为 resultObject 生成代理类，如果仅仅是配置的关联查询，没有开启延迟加载，是不会创建代理类</span></span><br><span class="line">            <span class="keyword">if</span> (propertyMapping.getNestedQueryId() != <span class="keyword">null</span> &amp;&amp; propertyMapping.isLazy()) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 创建代理类，默认使用 Javassist 框架生成代理类。</span></span><br><span class="line"><span class="comment">                 * 由于实体类通常不会实现接口，所以不能使用 JDK 动态代理 API 为实体类生成代理。</span></span><br><span class="line"><span class="comment">                 * 并且将lazyLoader传进去了</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                resultObject = configuration.getProxyFactory()</span><br><span class="line">                    .createProxy(resultObject, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.useConstructorMappings =</span><br><span class="line">        resultObject != <span class="keyword">null</span> &amp;&amp; !constructorArgTypes.isEmpty();</span><br><span class="line">    <span class="keyword">return</span> resultObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看 createResultObject 重载方法的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createResultObject</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; resultType = resultMap.getType();</span><br><span class="line">    <span class="keyword">final</span> MetaClass metaType = MetaClass.forClass(resultType, reflectorFactory);</span><br><span class="line">    <span class="keyword">final</span> List&lt;ResultMapping&gt; constructorMappings = resultMap.getConstructorResultMappings();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasTypeHandlerForResultObject(rsw, resultType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> createPrimitiveResultObject(rsw, resultMap, columnPrefix);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!constructorMappings.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> createParameterizedResultObject(rsw, resultType, constructorMappings, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resultType.isInterface() || metaType.hasDefaultConstructor()) &#123;</span><br><span class="line">        <span class="comment">// 通过 ObjectFactory 调用目标类的默认构造方法创建实例</span></span><br><span class="line">        <span class="keyword">return</span> objectFactory.create(resultType);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldApplyAutomaticMappings(resultMap, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> createByConstructorSignature(rsw, resultType, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Do not know how to create an instance of &quot;</span> + resultType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般情况下，MyBatis 会通过 ObjectFactory 调用默认构造方法创建实体类对象。看看是如何创建的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; classToCreate = <span class="keyword">this</span>.resolveInterface(type);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.instantiateClass(classToCreate, constructorArgTypes, constructorArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Constructor constructor;</span><br><span class="line">        <span class="keyword">if</span> (constructorArgTypes != <span class="keyword">null</span> &amp;&amp; constructorArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            constructor = type.getDeclaredConstructor((Class[])constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]));</span><br><span class="line">            <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">                constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//通过反射获取构造器</span></span><br><span class="line">            constructor = type.getDeclaredConstructor();</span><br><span class="line">            <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">                constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通过构造器来实例化对象</span></span><br><span class="line">            <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">&quot;Error instantiating &quot;</span> + type + <span class="string">&quot; with invalid types (&quot;</span> + argTypes + <span class="string">&quot;) or values (&quot;</span> + argValues + <span class="string">&quot;). Cause: &quot;</span> + var9, var9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，就是通过反射创建对象</p>
<h4 id="结果集映射"><a href="#结果集映射" class="headerlink" title="结果集映射"></a>结果集映射</h4><p>映射结果集分为两种情况：一种是自动映射(结果集有但在resultMap里没有配置的字段)，在实际应用中，都会使用自动映射，减少配置的工作。自动映射在Mybatis中也是默认开启的。第二种是映射ResultMap中配置的，我们分这两者映射来看</p>
<h5 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyAutomaticMappings</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 UnMappedColumnAutoMapping 列表</span></span><br><span class="line">    List&lt;UnMappedColumnAutoMapping&gt; autoMapping = createAutomaticMappings(rsw, resultMap, metaObject, columnPrefix);</span><br><span class="line">    <span class="keyword">boolean</span> foundValues = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!autoMapping.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (UnMappedColumnAutoMapping mapping : autoMapping) &#123;</span><br><span class="line">            <span class="comment">// 通过 TypeHandler 从结果集中获取指定列的数据</span></span><br><span class="line">            <span class="keyword">final</span> Object value = mapping.typeHandler.getResult(rsw.getResultSet(), mapping.column);</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                foundValues = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> || (configuration.isCallSettersOnNulls() &amp;&amp; !mapping.primitive)) &#123;</span><br><span class="line">                <span class="comment">// 通过元信息对象设置 value 到实体类对象的指定字段上</span></span><br><span class="line">                metaObject.setValue(mapping.property, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foundValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是获取 UnMappedColumnAutoMapping 集合，然后遍历该集合，并通过 TypeHandler 从结果集中获取数据，最后再将获取到的数据设置到实体类对象中。</p>
<p>UnMappedColumnAutoMapping 用于记录未配置在 &lt;resultMap&gt; 节点中的映射关系。它的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnMappedColumnAutoMapping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String column;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String property;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> primitive;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnMappedColumnAutoMapping</span><span class="params">(String column, String property, TypeHandler&lt;?&gt; typeHandler, <span class="keyword">boolean</span> primitive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.column = column;</span><br><span class="line">        <span class="keyword">this</span>.property = property;</span><br><span class="line">        <span class="keyword">this</span>.typeHandler = typeHandler;</span><br><span class="line">        <span class="keyword">this</span>.primitive = primitive;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅用于记录映射关系。下面看一下获取 UnMappedColumnAutoMapping 集合的过程，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;UnMappedColumnAutoMapping&gt; <span class="title">createAutomaticMappings</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String mapKey = resultMap.getId() + <span class="string">&quot;:&quot;</span> + columnPrefix;</span><br><span class="line">    <span class="comment">// 从缓存中获取 UnMappedColumnAutoMapping 列表</span></span><br><span class="line">    List&lt;UnMappedColumnAutoMapping&gt; autoMapping = autoMappingsCache.get(mapKey);</span><br><span class="line">    <span class="comment">// 缓存未命中</span></span><br><span class="line">    <span class="keyword">if</span> (autoMapping == <span class="keyword">null</span>) &#123;</span><br><span class="line">        autoMapping = <span class="keyword">new</span> ArrayList&lt;UnMappedColumnAutoMapping&gt;();</span><br><span class="line">        <span class="comment">// 从 ResultSetWrapper 中获取未配置在 &lt;resultMap&gt; 中的列名</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; unmappedColumnNames = rsw.getUnmappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">        <span class="keyword">for</span> (String columnName : unmappedColumnNames) &#123;</span><br><span class="line">            String propertyName = columnName;</span><br><span class="line">            <span class="keyword">if</span> (columnPrefix != <span class="keyword">null</span> &amp;&amp; !columnPrefix.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (columnName.toUpperCase(Locale.ENGLISH).startsWith(columnPrefix)) &#123;</span><br><span class="line">                    propertyName = columnName.substring(columnPrefix.length());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将下划线形式的列名转成驼峰式，比如 AUTHOR_NAME -&gt; authorName</span></span><br><span class="line">            <span class="keyword">final</span> String property = metaObject.findProperty(propertyName, configuration.isMapUnderscoreToCamelCase());</span><br><span class="line">            <span class="keyword">if</span> (property != <span class="keyword">null</span> &amp;&amp; metaObject.hasSetter(property)) &#123;</span><br><span class="line">                <span class="comment">// 检测当前属性是否存在于 resultMap 中</span></span><br><span class="line">                <span class="keyword">if</span> (resultMap.getMappedProperties().contains(property)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取属性对于的类型</span></span><br><span class="line">                <span class="keyword">final</span> Class&lt;?&gt; propertyType = metaObject.getSetterType(property);</span><br><span class="line">                <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(propertyType, rsw.getJdbcType(columnName))) &#123;</span><br><span class="line">                    <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(propertyType, columnName);</span><br><span class="line">                    <span class="comment">// 封装上面获取到的信息到 UnMappedColumnAutoMapping 对象中</span></span><br><span class="line">                    autoMapping.add(<span class="keyword">new</span> UnMappedColumnAutoMapping(columnName, property, typeHandler, propertyType.isPrimitive()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    configuration.getAutoMappingUnknownColumnBehavior()</span><br><span class="line">                        .doAction(mappedStatement, columnName, property, propertyType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                configuration.getAutoMappingUnknownColumnBehavior()</span><br><span class="line">                    .doAction(mappedStatement, columnName, (property != <span class="keyword">null</span>) ? property : propertyName, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写入缓存</span></span><br><span class="line">        autoMappingsCache.put(mapKey, autoMapping);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> autoMapping;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先来看看从 ResultSetWrapper 中获取未配置在 &lt;resultMap&gt; 中的列名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getUnmappedColumnNames</span><span class="params">(ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    List&lt;String&gt; unMappedColumnNames = unMappedColumnNamesMap.get(getMapKey(resultMap, columnPrefix));</span><br><span class="line">    <span class="keyword">if</span> (unMappedColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 加载已映射与未映射列名</span></span><br><span class="line">        loadMappedAndUnmappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">        <span class="comment">// 获取未映射列名</span></span><br><span class="line">        unMappedColumnNames = unMappedColumnNamesMap.get(getMapKey(resultMap, columnPrefix));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unMappedColumnNames;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadMappedAndUnmappedColumnNames</span><span class="params">(ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    List&lt;String&gt; mappedColumnNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    List&lt;String&gt; unmappedColumnNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">final</span> String upperColumnPrefix = columnPrefix == <span class="keyword">null</span> ? <span class="keyword">null</span> : columnPrefix.toUpperCase(Locale.ENGLISH);</span><br><span class="line">    <span class="comment">// 获取 &lt;resultMap&gt; 中配置的所有列名</span></span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; mappedColumns = prependPrefixes(resultMap.getMappedColumns(), upperColumnPrefix);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 遍历 columnNames，columnNames 是 ResultSetWrapper 的成员变量，保存了当前结果集中的所有列名</span></span><br><span class="line"><span class="comment">     * 这里是通过ResultSet中的所有列名来获取没有在resultMap中配置的列名</span></span><br><span class="line"><span class="comment">     * 意思是后面进行自动赋值时，只赋值查出来的列名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (String columnName : columnNames) &#123;</span><br><span class="line">        <span class="keyword">final</span> String upperColumnName = columnName.toUpperCase(Locale.ENGLISH);</span><br><span class="line">        <span class="comment">// 检测已映射列名集合中是否包含当前列名</span></span><br><span class="line">        <span class="keyword">if</span> (mappedColumns.contains(upperColumnName)) &#123;</span><br><span class="line">            mappedColumnNames.add(upperColumnName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将列名存入 unmappedColumnNames 中</span></span><br><span class="line">            unmappedColumnNames.add(columnName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存列名集合</span></span><br><span class="line">    mappedColumnNamesMap.put(getMapKey(resultMap, columnPrefix), mappedColumnNames);</span><br><span class="line">    unMappedColumnNamesMap.put(getMapKey(resultMap, columnPrefix), unmappedColumnNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是从当前数据集中获取列名集合，然后获取 &lt;resultMap&gt; 中配置的列名集合。之后遍历数据集中的列名集合，并判断列名是否被配置在了 &lt;resultMap&gt; 节点中。若配置了，则表明该列名已有映射关系，此时该列名存入 mappedColumnNames 中。若未配置，则表明列名未与实体类的某个字段形成映射关系，此时该列名存入 unmappedColumnNames 中。</p>
<h5 id="映射result节点"><a href="#映射result节点" class="headerlink" title="映射result节点"></a>映射result节点</h5><p>接下来分析一下 MyBatis 是如何将结果集中的数据填充到已配置ResultMap映射的实体类字段中的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyPropertyMappings</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject,ResultLoaderMap lazyLoader, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取已映射的列名</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">    <span class="keyword">boolean</span> foundValues = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 获取 ResultMapping集合</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span><br><span class="line">    <span class="comment">// 所有的ResultMapping遍历进行映射</span></span><br><span class="line">    <span class="keyword">for</span> (ResultMapping propertyMapping : propertyMappings) &#123;</span><br><span class="line">        String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line">        <span class="keyword">if</span> (propertyMapping.getNestedResultMapId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            column = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (propertyMapping.isCompositeResult()</span><br><span class="line">            || (column != <span class="keyword">null</span> &amp;&amp; mappedColumnNames.contains(column.toUpperCase(Locale.ENGLISH)))</span><br><span class="line">            || propertyMapping.getResultSet() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从结果集中获取指定列的数据</span></span><br><span class="line">            Object value = getPropertyMappingValue(rsw.getResultSet(), metaObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">final</span> String property = propertyMapping.getProperty();</span><br><span class="line">            <span class="keyword">if</span> (property == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若获取到的值为 DEFERED，则延迟加载该值</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == DEFERED) &#123;</span><br><span class="line">                foundValues = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                foundValues = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> || (configuration.isCallSettersOnNulls() &amp;&amp; !metaObject.getSetterType(property).isPrimitive())) &#123;</span><br><span class="line">                <span class="comment">// 将获取到的值设置到实体类对象中</span></span><br><span class="line">                metaObject.setValue(property, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foundValues;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getPropertyMappingValue</span><span class="params">(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping,ResultLoaderMap lazyLoader, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propertyMapping.getNestedQueryId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取关联查询结果</span></span><br><span class="line">        <span class="keyword">return</span> getNestedQueryMappingValue(rs, metaResultObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMapping.getResultSet() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        addPendingChildRelation(rs, metaResultObject, propertyMapping);</span><br><span class="line">        <span class="keyword">return</span> DEFERED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = propertyMapping.getTypeHandler();</span><br><span class="line">        <span class="keyword">final</span> String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line">        <span class="comment">// 从 ResultSet 中获取指定列的值</span></span><br><span class="line">        <span class="keyword">return</span> typeHandler.getResult(rs, column);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 ResultMap 获取映射对象 ResultMapping 集合。然后遍历 ResultMapping 集合，再此过程中调用 getPropertyMappingValue 获取指定指定列的数据，最后将获取到的数据设置到实体类对象中。</p>
<p>这里和自动映射有一点不同，<strong>自动映射是从直接从ResultSet 中获取指定列的值，但是通过ResultMap多了一种情况，那就是关联查询，也可以说是延迟查询，此关联查询如果没有配置延迟加载，那么就要获取关联查询的值，如果配置了延迟加载，则返回DEFERED</strong></p>
<h4 id="关联查询与延迟加载"><a href="#关联查询与延迟加载" class="headerlink" title="关联查询与延迟加载"></a>关联查询与延迟加载</h4><p>我们的查询经常会碰到一对一，一对多的情况，通常我们可以用一条 SQL 进行多表查询完成任务。当然我们也可以使用关联查询，将一条 SQL 拆成两条去完成查询任务。MyBatis 提供了两个标签用于支持一对一和一对多的使用场景，分别是 &lt;association&gt; 和 &lt;collection&gt;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getPropertyMappingValue</span><span class="params">(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping,ResultLoaderMap lazyLoader, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propertyMapping.getNestedQueryId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取关联查询结果</span></span><br><span class="line">        <span class="keyword">return</span> getNestedQueryMappingValue(rs, metaResultObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMapping.getResultSet() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        addPendingChildRelation(rs, metaResultObject, propertyMapping);</span><br><span class="line">        <span class="keyword">return</span> DEFERED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = propertyMapping.getTypeHandler();</span><br><span class="line">        <span class="keyword">final</span> String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line">        <span class="comment">// 从 ResultSet 中获取指定列的值</span></span><br><span class="line">        <span class="keyword">return</span> typeHandler.getResult(rs, column);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，如果ResultMapping设置了关联查询，也就是<strong>association或者collection配置了select，那么就要通过关联语句来查询结果，并设置到实体类对象的属性中了。如果没配置select，那就简单，直接从ResultSet中通过列名获取结果。</strong>那我们来看看getNestedQueryMappingValue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getNestedQueryMappingValue</span><span class="params">(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping, ResultLoaderMap lazyLoader, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取关联查询 id，id = 命名空间 + &lt;association&gt; 的 select 属性值</span></span><br><span class="line">    <span class="keyword">final</span> String nestedQueryId = propertyMapping.getNestedQueryId();</span><br><span class="line">    <span class="keyword">final</span> String property = propertyMapping.getProperty();</span><br><span class="line">    <span class="comment">// 根据 nestedQueryId 获取关联的 MappedStatement</span></span><br><span class="line">    <span class="keyword">final</span> MappedStatement nestedQuery = configuration.getMappedStatement(nestedQueryId);</span><br><span class="line">    <span class="comment">//获取关联查询MappedStatement的参数类型</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; nestedQueryParameterType = nestedQuery.getParameterMap().getType();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 生成关联查询语句参数对象，参数类型可能是一些包装类，Map 或是自定义的实体类，</span></span><br><span class="line"><span class="comment">     * 具体类型取决于配置信息。以上面的例子为基础，下面分析不同配置对参数类型的影响：</span></span><br><span class="line"><span class="comment">     *   1. &lt;association column=&quot;author_id&quot;&gt; </span></span><br><span class="line"><span class="comment">     *      column 属性值仅包含列信息，参数类型为 author_id 列对应的类型，这里为 Integer</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *   2. &lt;association column=&quot;&#123;id=author_id, name=title&#125;&quot;&gt; </span></span><br><span class="line"><span class="comment">     *      column 属性值包含了属性名与列名的复合信息，MyBatis 会根据列名从 ResultSet 中</span></span><br><span class="line"><span class="comment">     *      获取列数据，并将列数据设置到实体类对象的指定属性中，比如：</span></span><br><span class="line"><span class="comment">     *          Author&#123;id=1, name=&quot;陈浩&quot;&#125;</span></span><br><span class="line"><span class="comment">     *      或是以键值对 &lt;属性, 列数据&gt; 的形式，将两者存入 Map 中。比如：</span></span><br><span class="line"><span class="comment">     *          &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;陈浩&quot;&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      至于参数类型到底为实体类还是 Map，取决于关联查询语句的配置信息。比如：</span></span><br><span class="line"><span class="comment">     *          &lt;select id=&quot;findAuthor&quot;&gt;  -&gt;  参数类型为 Map</span></span><br><span class="line"><span class="comment">     *          &lt;select id=&quot;findAuthor&quot; parameterType=&quot;Author&quot;&gt; -&gt; 参数类型为实体类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Object nestedQueryParameterObject = prepareParameterForNestedQuery(rs, propertyMapping, nestedQueryParameterType, columnPrefix);</span><br><span class="line">    Object value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (nestedQueryParameterObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取 BoundSql，这里设置了运行时参数，所以这里是能直接执行的</span></span><br><span class="line">        <span class="keyword">final</span> BoundSql nestedBoundSql = nestedQuery.getBoundSql(nestedQueryParameterObject);</span><br><span class="line">        <span class="keyword">final</span> CacheKey key = executor.createCacheKey(nestedQuery, nestedQueryParameterObject, RowBounds.DEFAULT, nestedBoundSql);</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; targetType = propertyMapping.getJavaType();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (executor.isCached(nestedQuery, key)) &#123;</span><br><span class="line">            executor.deferLoad(nestedQuery, metaResultObject, property, key, targetType);</span><br><span class="line">            value = DEFERED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建结果加载器</span></span><br><span class="line">            <span class="keyword">final</span> ResultLoader resultLoader = <span class="keyword">new</span> ResultLoader(configuration, executor, nestedQuery, nestedQueryParameterObject, targetType, key, nestedBoundSql);</span><br><span class="line">            <span class="comment">// 检测当前属性是否需要延迟加载</span></span><br><span class="line">            <span class="keyword">if</span> (propertyMapping.isLazy()) &#123;</span><br><span class="line">                <span class="comment">// 添加延迟加载相关的对象到 loaderMap 集合中</span></span><br><span class="line">                lazyLoader.addLoader(property, metaResultObject, resultLoader);</span><br><span class="line">                value = DEFERED;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 直接执行关联查询</span></span><br><span class="line">                <span class="comment">// 如果只是配置关联查询，但是没有开启懒加载，则直接执行关联查询，并返回结果，设置到实体类对象的属性中</span></span><br><span class="line">                value = resultLoader.loadResult();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面先来总结一下该方法的逻辑：</p>
<ol>
<li>根据 nestedQueryId 获取 MappedStatement</li>
<li>生成参数对象</li>
<li>获取 BoundSql</li>
<li>创建结果加载器 ResultLoader</li>
<li>检测当前属性是否需要进行延迟加载，若需要，则添加延迟加载相关的对象到 loaderMap 集合中</li>
<li>如不需要延迟加载，则直接通过结果加载器加载结果</li>
</ol>
<p>以上流程中针对一级缓存的检查是十分有必要的，若缓存命中，可直接取用结果，无需再在执行关联查询 SQL。若缓存未命中，接下来就要按部就班执行延迟加载相关逻辑</p>
<p>我们来看一下添加延迟加载相关对象到 loaderMap 集合中的逻辑，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLoader</span><span class="params">(String property, MetaObject metaResultObject, ResultLoader resultLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将属性名转为大写</span></span><br><span class="line">    String upperFirst = getUppercaseFirstProperty(property);</span><br><span class="line">    <span class="keyword">if</span> (!upperFirst.equalsIgnoreCase(property) &amp;&amp; loaderMap.containsKey(upperFirst)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Nested lazy loaded result property &#x27;&quot;</span> + property +</span><br><span class="line">                                    <span class="string">&quot;&#x27; for query id &#x27;&quot;</span> + resultLoader.mappedStatement.getId() +</span><br><span class="line">                                    <span class="string">&quot; already exists in the result map. The leftmost property of all lazy loaded properties must be unique within a result map.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 LoadPair，并将 &lt;大写属性名，LoadPair对象&gt; 键值对添加到 loaderMap 中</span></span><br><span class="line">    loaderMap.put(upperFirst, <span class="keyword">new</span> LoadPair(property, metaResultObject, resultLoader));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//createResultObject</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createResultObject</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.useConstructorMappings = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; constructorArgTypes = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; constructorArgs = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用重载方法创建实体类对象</span></span><br><span class="line">    Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">    <span class="keyword">if</span> (resultObject != <span class="keyword">null</span> &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span><br><span class="line">        <span class="keyword">for</span> (ResultMapping propertyMapping : propertyMappings) &#123;</span><br><span class="line">            <span class="comment">// 如果开启了延迟加载，则为 resultObject 生成代理类，如果仅仅是配置的关联查询，没有开启延迟加载，是不会创建代理类</span></span><br><span class="line">            <span class="keyword">if</span> (propertyMapping.getNestedQueryId() != <span class="keyword">null</span> &amp;&amp; propertyMapping.isLazy()) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 创建代理类，默认使用 Javassist 框架生成代理类。</span></span><br><span class="line"><span class="comment">                 * 由于实体类通常不会实现接口，所以不能使用 JDK 动态代理 API 为实体类生成代理。</span></span><br><span class="line"><span class="comment">                 * 并且将lazyLoader传进去了</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                resultObject = configuration.getProxyFactory()</span><br><span class="line">                    .createProxy(resultObject, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.useConstructorMappings =</span><br><span class="line">        resultObject != <span class="keyword">null</span> &amp;&amp; !constructorArgTypes.isEmpty();</span><br><span class="line">    <span class="keyword">return</span> resultObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果开启了延迟加载，并且有关联查询，此时是要创建一个代理对象的，将上面存放BondSql的lazyLoader和创建的目标对象resultObject 作为参数传进去。</p>
<p>Mybatis提供了两个实现类CglibProxyFactory和JavassistProxyFactory，分别基于org.javassist:javassist和cglib:cglib进行实现。createProxy方法就是实现懒加载逻辑的核心方法，也是我们分析的目标。</p>
<h5 id="CglibProxyFactory"><a href="#CglibProxyFactory" class="headerlink" title="CglibProxyFactory"></a>CglibProxyFactory</h5><p>CglibProxyFactory基于cglib动态代理模式，<strong>通过继承父类的方式生成动态代理类。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Object target, ResultLoaderMap lazyLoader, Configuration configuration, ObjectFactory objectFactory, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> EnhancedResultObjectProxyImpl.createProxy(target, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">createProxy</span><span class="params">(Object target, ResultLoaderMap lazyLoader, Configuration configuration, ObjectFactory objectFactory, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt; type = target.getClass();</span><br><span class="line">  EnhancedResultObjectProxyImpl callback = <span class="keyword">new</span> EnhancedResultObjectProxyImpl(type, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">  <span class="comment">//由CglibProxyFactory生成对象</span></span><br><span class="line">  Object enhanced = crateProxy(type, callback, constructorArgTypes, constructorArgs);</span><br><span class="line">  <span class="comment">//复制属性</span></span><br><span class="line">  PropertyCopier.copyBeanProperties(type, target, enhanced);</span><br><span class="line">  <span class="keyword">return</span> enhanced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">crateProxy</span><span class="params">(Class&lt;?&gt; type, Callback callback, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">  Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">  enhancer.setCallback(callback);</span><br><span class="line">  <span class="comment">//设置父类对象</span></span><br><span class="line">  enhancer.setSuperclass(type);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    type.getDeclaredMethod(WRITE_REPLACE_METHOD);</span><br><span class="line">    <span class="comment">// ObjectOutputStream will call writeReplace of objects returned by writeReplace</span></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(WRITE_REPLACE_METHOD + <span class="string">&quot; method was found on bean &quot;</span> + type + <span class="string">&quot;, make sure it returns this&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    enhancer.setInterfaces(<span class="keyword">new</span> Class[]&#123;WriteReplaceInterface.class&#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">    <span class="comment">// nothing to do here</span></span><br><span class="line">  &#125;</span><br><span class="line">  Object enhanced;</span><br><span class="line">  <span class="keyword">if</span> (constructorArgTypes.isEmpty()) &#123;</span><br><span class="line">    enhanced = enhancer.create();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] typesArray = constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]);</span><br><span class="line">    Object[] valuesArray = constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]);</span><br><span class="line">    enhanced = enhancer.create(typesArray, valuesArray);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> enhanced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以看到，初始化Enhancer，并调用构造方法，生成对象。从<code>enhancer.setSuperclass(type);</code>也能看出cglib采用的是继承父类的方式。</p>
<h5 id="EnhancedResultObjectProxyImpl"><a href="#EnhancedResultObjectProxyImpl" class="headerlink" title="EnhancedResultObjectProxyImpl"></a>EnhancedResultObjectProxyImpl</h5><p>EnhancedResultObjectProxyImpl实现了MethodInterceptor接口，此接口是Cglib拦截目标对象方法的入口，对目标对象方法的调用都会通过此接口的intercept的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.loader.AbstractEnhancedDeserializationProxy;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.loader.AbstractSerialStateHolder;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.loader.ProxyFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.loader.ResultLoaderMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.loader.WriteReplaceInterface;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.logging.LogFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.ExceptionUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.factory.ObjectFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.property.PropertyCopier;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.property.PropertyNamer;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cglib代理工厂类，实现延迟加载属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> <span class="keyword">implements</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * finalize方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FINALIZE_METHOD = <span class="string">&quot;finalize&quot;</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * writeReplace方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WRITE_REPLACE_METHOD = <span class="string">&quot;writeReplace&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 加载Enhancer，这个是Cglib的入口</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CglibProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Resources.classForName(<span class="string">&quot;net.sf.cglib.proxy.Enhancer&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot enable lazy loading because CGLIB is not available. Add CGLIB to your classpath.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建代理对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> lazyLoader 延迟加载器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> configuration 配置类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objectFactory 对象工厂</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgTypes 构造函数类型[]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgs  构造函数的值[]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Object target, ResultLoaderMap lazyLoader, Configuration configuration, ObjectFactory objectFactory, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> EnhancedResultObjectProxyImpl.createProxy(target, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建一个反序列化代理</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> target 目标</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> unloadedProperties</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objectFactory 对象工厂</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgTypes 构造函数类型数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgs 构造函数值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">createDeserializationProxy</span><span class="params">(Object target, Map&lt;String, ResultLoaderMap.LoadPair&gt; unloadedProperties, ObjectFactory objectFactory, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> EnhancedDeserializationProxyImpl.createProxy(target, unloadedProperties, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Not Implemented</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回代理对象， 这个代理对象在调用任何方法都会调用本类的intercept方法</span></span><br><span class="line"><span class="comment">   * Enhancer 认为这个就是自定义类的工厂，比如这个类需要实现什么接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type 目标类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> callback 结果对象代理实现类，当中有invoke回调方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgTypes 构造函数类型数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgs 构造函数对应字段的值数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Object <span class="title">crateProxy</span><span class="params">(Class&lt;?&gt; type, Callback callback, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// enhancer 配置调节代理对象的一些参数</span></span><br><span class="line">    <span class="comment">// 设置回调方法</span></span><br><span class="line">    <span class="comment">// 设置超类</span></span><br><span class="line">    <span class="comment">//判断当传入目标类型是否有writeReplace方法，没有则配置一个有writeReplace方法的接口（序列化写出）</span></span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setCallback(callback);</span><br><span class="line">    enhancer.setSuperclass(type);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      type.getDeclaredMethod(WRITE_REPLACE_METHOD);</span><br><span class="line">      <span class="comment">// ObjectOutputStream will call writeReplace of objects returned by writeReplace</span></span><br><span class="line">      <span class="keyword">if</span> (LogHolder.log.isDebugEnabled()) &#123;</span><br><span class="line">        LogHolder.log.debug(WRITE_REPLACE_METHOD + <span class="string">&quot; method was found on bean &quot;</span> + type + <span class="string">&quot;, make sure it returns this&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">      <span class="comment">//这个enhancer增加一个WriteReplaceInterface接口</span></span><br><span class="line">      enhancer.setInterfaces(<span class="keyword">new</span> Class[]&#123;WriteReplaceInterface.class&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">      <span class="comment">// nothing to do here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据构造函数创建一个对象</span></span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    <span class="comment">//有参构造</span></span><br><span class="line">    Object enhanced;</span><br><span class="line">    <span class="keyword">if</span> (constructorArgTypes.isEmpty()) &#123;</span><br><span class="line">      enhanced = enhancer.create();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Class&lt;?&gt;[] typesArray = constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]);</span><br><span class="line">      Object[] valuesArray = constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]);</span><br><span class="line">      enhanced = enhancer.create(typesArray, valuesArray);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enhanced;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 结果对象代理实现类，</span></span><br><span class="line"><span class="comment">   * 它实现方法拦截器的intercept方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedResultObjectProxyImpl</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResultLoaderMap lazyLoader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> aggressive;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; lazyLoadTriggerMethods;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; constructorArgTypes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; constructorArgs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理对象创建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 目标class类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lazyLoader 延迟加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configuration 配置信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectFactory 对象工厂</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> constructorArgTypes 构造函数类型数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> constructorArgs 构造函数值数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnhancedResultObjectProxyImpl</span><span class="params">(Class&lt;?&gt; type, ResultLoaderMap lazyLoader, Configuration configuration, ObjectFactory objectFactory, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.type = type;</span><br><span class="line">      <span class="keyword">this</span>.lazyLoader = lazyLoader;</span><br><span class="line">      <span class="keyword">this</span>.aggressive = configuration.isAggressiveLazyLoading();</span><br><span class="line">      <span class="keyword">this</span>.lazyLoadTriggerMethods = configuration.getLazyLoadTriggerMethods();</span><br><span class="line">      <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">      <span class="keyword">this</span>.constructorArgTypes = constructorArgTypes;</span><br><span class="line">      <span class="keyword">this</span>.constructorArgs = constructorArgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象, 将源对象值赋值给代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lazyLoader 延迟加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configuration 配置对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectFactory 对象工厂</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> constructorArgTypes 构造函数类型数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> constructorArgs 构造函数值数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">createProxy</span><span class="params">(Object target, ResultLoaderMap lazyLoader, Configuration configuration, ObjectFactory objectFactory, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取目标的类型</span></span><br><span class="line">      <span class="comment">//创建一个结果对象代理实现类（它实现cglib的MethodInterface接口，完成回调作用invoke方法）</span></span><br><span class="line">      <span class="keyword">final</span> Class&lt;?&gt; type = target.getClass();</span><br><span class="line">      EnhancedResultObjectProxyImpl callback = <span class="keyword">new</span> EnhancedResultObjectProxyImpl(type, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">      Object enhanced = crateProxy(type, callback, constructorArgTypes, constructorArgs);</span><br><span class="line">      PropertyCopier.copyBeanProperties(type, target, enhanced);</span><br><span class="line">      <span class="keyword">return</span> enhanced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回调方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> enhanced 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 代理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object enhanced, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="comment">//获取方法名</span></span><br><span class="line">      <span class="keyword">final</span> String methodName = method.getName();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 同步获取延迟加载对象</span></span><br><span class="line">        <span class="comment">// 如果是执行writeReplace方法(序列化写出）</span></span><br><span class="line">        <span class="comment">// 实例化一个目标对象的实例</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lazyLoader) &#123;</span><br><span class="line">          <span class="keyword">if</span> (WRITE_REPLACE_METHOD.equals(methodName)) &#123;</span><br><span class="line">            Object original;</span><br><span class="line">            <span class="keyword">if</span> (constructorArgTypes.isEmpty()) &#123;</span><br><span class="line">              original = objectFactory.create(type);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              original = objectFactory.create(type, constructorArgTypes, constructorArgs);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将enhanced中的属性复制到orignal对象中</span></span><br><span class="line">            <span class="comment">// 如果延迟加载数量&gt;0,</span></span><br><span class="line">            PropertyCopier.copyBeanProperties(type, enhanced, original);</span><br><span class="line">            <span class="keyword">if</span> (lazyLoader.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> CglibSerialStateHolder(original, lazyLoader.getProperties(), objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> original;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不是writeReplace方法</span></span><br><span class="line">            <span class="comment">// 延迟加载长度大于0， 且不是finalize方法</span></span><br><span class="line">            <span class="comment">// configuration配置延迟加载参数，延迟加载触发的方法包含这个方法</span></span><br><span class="line">            <span class="comment">// 延迟加载所有数据</span></span><br><span class="line">            <span class="keyword">if</span> (lazyLoader.size() &gt; <span class="number">0</span> &amp;&amp; !FINALIZE_METHOD.equals(methodName)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (aggressive || lazyLoadTriggerMethods.contains(methodName)) &#123;</span><br><span class="line">                lazyLoader.loadAll();</span><br><span class="line">                <span class="comment">// setter方法，直接移除</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PropertyNamer.isSetter(methodName)) &#123;</span><br><span class="line">                <span class="keyword">final</span> String property = PropertyNamer.methodToProperty(methodName);</span><br><span class="line">                lazyLoader.remove(property);</span><br><span class="line">                <span class="comment">// getter方法， 加载该属性</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PropertyNamer.isGetter(methodName)) &#123;</span><br><span class="line">                <span class="keyword">final</span> String property = PropertyNamer.methodToProperty(methodName);</span><br><span class="line">                <span class="keyword">if</span> (lazyLoader.hasLoader(property)) &#123;</span><br><span class="line">                  lazyLoader.load(property);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invokeSuper(enhanced, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 他继承抽象反序列化代理和实现了方法拦截</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedDeserializationProxyImpl</span> <span class="keyword">extends</span> <span class="title">AbstractEnhancedDeserializationProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnhancedDeserializationProxyImpl</span><span class="params">(Class&lt;?&gt; type, Map&lt;String, ResultLoaderMap.LoadPair&gt; unloadedProperties, ObjectFactory objectFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">            List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(type, unloadedProperties, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unloadedProperties</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> constructorArgTypes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> constructorArgs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">createProxy</span><span class="params">(Object target, Map&lt;String, ResultLoaderMap.LoadPair&gt; unloadedProperties, ObjectFactory objectFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">            List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Class&lt;?&gt; type = target.getClass();</span><br><span class="line">      EnhancedDeserializationProxyImpl callback = <span class="keyword">new</span> EnhancedDeserializationProxyImpl(type, unloadedProperties, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">      Object enhanced = crateProxy(type, callback, constructorArgTypes, constructorArgs);</span><br><span class="line">      PropertyCopier.copyBeanProperties(type, target, enhanced);</span><br><span class="line">      <span class="keyword">return</span> enhanced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object enhanced, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Object o = <span class="keyword">super</span>.invoke(enhanced, method, args);</span><br><span class="line">      <span class="keyword">return</span> o <span class="keyword">instanceof</span> AbstractSerialStateHolder ? o : methodProxy.invokeSuper(o, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AbstractSerialStateHolder <span class="title">newSerialStateHolder</span><span class="params">(Object userBean, Map&lt;String, ResultLoaderMap.LoadPair&gt; unloadedProperties, ObjectFactory objectFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">            List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CglibSerialStateHolder(userBean, unloadedProperties, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，代理方法首先会检查 aggressive 是否为 true，如果不满足，再去检查 lazyLoadTriggerMethods 是否包含当前方法名。这里两个条件只要一个为 true，当前实体类中所有需要延迟加载。aggressive 和 lazyLoadTriggerMethods 两个变量的值取决于下面的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,hashCode&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>然后代理逻辑会检查使用者是不是调用了实体类的 setter 方法，如果调用了，就将该属性对应的 LoadPair 从 loaderMap 中移除。为什么要这么做呢？答案是：使用者既然手动调用 setter 方法，说明使用者想自定义某个属性的值。此时，延迟加载逻辑不应该再修改该属性的值，所以这里从 loaderMap 中移除属性对于的 LoadPair。</p>
<p>最后如果使用者调用的是某个属性的 <strong>getter 方法</strong>，且该属性配置了延迟加载，此时延迟加载逻辑就会被触发。那接下来，我们来看看延迟加载逻辑是怎样实现的的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">(String property)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 从 loaderMap 中移除 property 所对应的 LoadPair</span></span><br><span class="line">    LoadPair pair = loaderMap.remove(property.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    <span class="keyword">if</span> (pair != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 加载结果</span></span><br><span class="line">        pair.load();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">final</span> Object userObject)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 调用 ResultLoader 的 loadResult 方法加载结果，</span></span><br><span class="line"><span class="comment">     * 并通过 metaResultObject 设置结果到实体类对象中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">this</span>.metaResultObject.setValue(property, <span class="keyword">this</span>.resultLoader.loadResult());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">loadResult</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 执行关联查询</span></span><br><span class="line">    List&lt;Object&gt; list = selectList();</span><br><span class="line">    <span class="comment">// 抽取结果</span></span><br><span class="line">    resultObject = resultExtractor.extractObjectFromList(list, targetType);</span><br><span class="line">    <span class="keyword">return</span> resultObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Executor localExecutor = executor;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread().getId() != <span class="keyword">this</span>.creatorThreadId || localExecutor.isClosed()) &#123;</span><br><span class="line">        localExecutor = newExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 Executor 就行查询，这个之前已经分析过了</span></span><br><span class="line">        <span class="comment">// 这里的parameterObject和boundSql就是我们之前存放在LoadPair中的，现在直接拿来执行了</span></span><br><span class="line">        <span class="keyword">return</span> localExecutor.&lt;E&gt;query(mappedStatement, parameterObject, RowBounds.DEFAULT,</span><br><span class="line">                                      Executor.NO_RESULT_HANDLER, cacheKey, boundSql);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (localExecutor != executor) &#123;</span><br><span class="line">            localExecutor.close(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，延迟加载我们基本已经讲清楚了，我们介绍一下另外的一种代理方式</p>
<h5 id="JavassistProxyFactory"><a href="#JavassistProxyFactory" class="headerlink" title="JavassistProxyFactory"></a>JavassistProxyFactory</h5><p>JavassistProxyFactory使用的是javassist方式，直接修改class文件的字节码格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.util.proxy.MethodHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.util.proxy.Proxy;</span><br><span class="line"><span class="keyword">import</span> javassist.util.proxy.ProxyFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.ExecutorException;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.loader.AbstractEnhancedDeserializationProxy;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.loader.AbstractSerialStateHolder;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.loader.ResultLoaderMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.loader.WriteReplaceInterface;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.logging.LogFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.ExceptionUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.factory.ObjectFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.property.PropertyCopier;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.property.PropertyNamer;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**JavassistProxy字节码生成代理</span></span><br><span class="line"><span class="comment"> * 1.创建一个代理对象然后将目标对象的值赋值给代理对象，这个代理对象是可以实现其他的接口</span></span><br><span class="line"><span class="comment"> * 2. JavassistProxyFactory实现ProxyFactory接口createProxy(创建代理对象的方法)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistProxyFactory</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">ibatis</span>.<span class="title">executor</span>.<span class="title">loader</span>.<span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * finalize方法（垃圾回收）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FINALIZE_METHOD = <span class="string">&quot;finalize&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * writeReplace(序列化写出方法）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WRITE_REPLACE_METHOD = <span class="string">&quot;writeReplace&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 加载ProxyFactory, 也就是JavassistProxy的入口</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JavassistProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Resources.classForName(<span class="string">&quot;javassist.util.proxy.ProxyFactory&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot enable lazy loading because Javassist is not available. Add Javassist to your classpath.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建代理</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> lazyLoader 延迟加载Map集合（那些属性是需要延迟加载的）</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> configuration 配置类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objectFactory 对象工厂</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgTypes 构造函数类型[]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgs  构造函数的值[]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Object target, ResultLoaderMap lazyLoader, Configuration configuration, ObjectFactory objectFactory, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> EnhancedResultObjectProxyImpl.createProxy(target, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">createDeserializationProxy</span><span class="params">(Object target, Map&lt;String, ResultLoaderMap.LoadPair&gt; unloadedProperties, ObjectFactory objectFactory, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> EnhancedDeserializationProxyImpl.createProxy(target, unloadedProperties, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Not Implemented</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取代理对象， 也就是说在执行方法之前首先调用MethodHanlder的invoke方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type 目标类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> callback 回调对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgTypes 构造函数类型数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgs 构造函数值的数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Object <span class="title">crateProxy</span><span class="params">(Class&lt;?&gt; type, MethodHandler callback, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个代理工厂类</span></span><br><span class="line">    <span class="comment">// 配置超类</span></span><br><span class="line">    ProxyFactory enhancer = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    enhancer.setSuperclass(type);</span><br><span class="line">    <span class="comment">//判断是否有writeReplace方法，如果没有将这个代理对象实现WriteReplaceInterface接口，这个接口只有一个writeReplace方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      type.getDeclaredMethod(WRITE_REPLACE_METHOD);</span><br><span class="line">      <span class="comment">// ObjectOutputStream will call writeReplace of objects returned by writeReplace</span></span><br><span class="line">      <span class="keyword">if</span> (LogHolder.log.isDebugEnabled()) &#123;</span><br><span class="line">        LogHolder.log.debug(WRITE_REPLACE_METHOD + <span class="string">&quot; method was found on bean &quot;</span> + type + <span class="string">&quot;, make sure it returns this&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">      enhancer.setInterfaces(<span class="keyword">new</span> Class[]&#123;WriteReplaceInterface.class&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">      <span class="comment">// nothing to do here</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object enhanced;</span><br><span class="line">    Class&lt;?&gt;[] typesArray = constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]);</span><br><span class="line">    Object[] valuesArray = constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据构造函数创建一个代理对象</span></span><br><span class="line">      enhanced = enhancer.create(typesArray, valuesArray);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error creating lazy proxy.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置回调对象</span></span><br><span class="line">    ((Proxy) enhanced).setHandler(callback);</span><br><span class="line">    <span class="keyword">return</span> enhanced;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实现Javassist的MethodHandler接口， 相对于Cglib的MethodInterceptor</span></span><br><span class="line"><span class="comment">   * 他们接口的方法名也是不一样的，Javassist的是invoke, 而cglib是intercept，叫法不同，实现功能是一样的</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedResultObjectProxyImpl</span> <span class="keyword">implements</span> <span class="title">MethodHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延迟加载Map集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResultLoaderMap lazyLoader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否配置延迟加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> aggressive;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延迟加载触发的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; lazyLoadTriggerMethods;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数类型数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; constructorArgTypes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数类型的值数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; constructorArgs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数私有化了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lazyLoader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configuration</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> constructorArgTypes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> constructorArgs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnhancedResultObjectProxyImpl</span><span class="params">(Class&lt;?&gt; type, ResultLoaderMap lazyLoader, Configuration configuration, ObjectFactory objectFactory, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.type = type;</span><br><span class="line">      <span class="keyword">this</span>.lazyLoader = lazyLoader;</span><br><span class="line">      <span class="keyword">this</span>.aggressive = configuration.isAggressiveLazyLoading();</span><br><span class="line">      <span class="keyword">this</span>.lazyLoadTriggerMethods = configuration.getLazyLoadTriggerMethods();</span><br><span class="line">      <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">      <span class="keyword">this</span>.constructorArgTypes = constructorArgTypes;</span><br><span class="line">      <span class="keyword">this</span>.constructorArgs = constructorArgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">createProxy</span><span class="params">(Object target, ResultLoaderMap lazyLoader, Configuration configuration, ObjectFactory objectFactory, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 获取目标类型</span></span><br><span class="line">      <span class="comment">// 创建一个EnhancedResultObjectProxyImpl对象，回调对象</span></span><br><span class="line">      <span class="keyword">final</span> Class&lt;?&gt; type = target.getClass();</span><br><span class="line">      EnhancedResultObjectProxyImpl callback = <span class="keyword">new</span> EnhancedResultObjectProxyImpl(type, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">      Object enhanced = crateProxy(type, callback, constructorArgTypes, constructorArgs);</span><br><span class="line">      PropertyCopier.copyBeanProperties(type, target, enhanced);</span><br><span class="line">      <span class="keyword">return</span> enhanced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回调方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> enhanced 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 代理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object enhanced, Method method, Method methodProxy, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="comment">//获取方法名称</span></span><br><span class="line">      <span class="keyword">final</span> String methodName = method.getName();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lazyLoader) &#123;</span><br><span class="line">          <span class="keyword">if</span> (WRITE_REPLACE_METHOD.equals(methodName)) &#123;</span><br><span class="line">            <span class="comment">//如果方法是writeReplace</span></span><br><span class="line">            Object original;</span><br><span class="line">            <span class="keyword">if</span> (constructorArgTypes.isEmpty()) &#123;</span><br><span class="line">              original = objectFactory.create(type);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              original = objectFactory.create(type, constructorArgTypes, constructorArgs);</span><br><span class="line">            &#125;</span><br><span class="line">            PropertyCopier.copyBeanProperties(type, enhanced, original);</span><br><span class="line">            <span class="keyword">if</span> (lazyLoader.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> JavassistSerialStateHolder(original, lazyLoader.getProperties(), objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> original;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不是writeReplace方法</span></span><br><span class="line">            <span class="comment">// 延迟加载长度大于0， 且不是finalize方法</span></span><br><span class="line">            <span class="comment">// configuration配置延迟加载参数，延迟加载触发的方法包含这个方法</span></span><br><span class="line">            <span class="comment">// 延迟加载所有数据</span></span><br><span class="line">            <span class="keyword">if</span> (lazyLoader.size() &gt; <span class="number">0</span> &amp;&amp; !FINALIZE_METHOD.equals(methodName)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (aggressive || lazyLoadTriggerMethods.contains(methodName)) &#123;</span><br><span class="line">                lazyLoader.loadAll();</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PropertyNamer.isSetter(methodName)) &#123;</span><br><span class="line">                <span class="keyword">final</span> String property = PropertyNamer.methodToProperty(methodName);</span><br><span class="line">                lazyLoader.remove(property);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PropertyNamer.isGetter(methodName)) &#123;</span><br><span class="line">                <span class="keyword">final</span> String property = PropertyNamer.methodToProperty(methodName);</span><br><span class="line">                <span class="keyword">if</span> (lazyLoader.hasLoader(property)) &#123;</span><br><span class="line">                  lazyLoader.load(property);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invoke(enhanced, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedDeserializationProxyImpl</span> <span class="keyword">extends</span> <span class="title">AbstractEnhancedDeserializationProxy</span> <span class="keyword">implements</span> <span class="title">MethodHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnhancedDeserializationProxyImpl</span><span class="params">(Class&lt;?&gt; type, Map&lt;String, ResultLoaderMap.LoadPair&gt; unloadedProperties, ObjectFactory objectFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">            List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(type, unloadedProperties, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">createProxy</span><span class="params">(Object target, Map&lt;String, ResultLoaderMap.LoadPair&gt; unloadedProperties, ObjectFactory objectFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">            List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Class&lt;?&gt; type = target.getClass();</span><br><span class="line">      EnhancedDeserializationProxyImpl callback = <span class="keyword">new</span> EnhancedDeserializationProxyImpl(type, unloadedProperties, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">      Object enhanced = crateProxy(type, callback, constructorArgTypes, constructorArgs);</span><br><span class="line">      PropertyCopier.copyBeanProperties(type, target, enhanced);</span><br><span class="line">      <span class="keyword">return</span> enhanced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object enhanced, Method method, Method methodProxy, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Object o = <span class="keyword">super</span>.invoke(enhanced, method, args);</span><br><span class="line">      <span class="keyword">return</span> o <span class="keyword">instanceof</span> AbstractSerialStateHolder ? o : methodProxy.invoke(o, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AbstractSerialStateHolder <span class="title">newSerialStateHolder</span><span class="params">(Object userBean, Map&lt;String, ResultLoaderMap.LoadPair&gt; unloadedProperties, ObjectFactory objectFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">            List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JavassistSerialStateHolder(userBean, unloadedProperties, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LogHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(JavassistProxyFactory.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释已经很清楚了，我就不累述了</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/12/01/Java-%E6%A1%86%E6%9E%B6-7-2-4-5/">https://pingxin0521.gitee.io/2019/12/01/Java-%E6%A1%86%E6%9E%B6-7-2-4-5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a><a class="post-meta__tags" href="/tags/DAO/">DAO</a><a class="post-meta__tags" href="/tags/Mybatis/">Mybatis</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/12/03/%E6%9C%8D%E5%8A%A1%E5%99%A8-Apache-Tomcat-2-1/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Apache Tomcat 源码分析 (一)</div></div></a></div><div class="next-post pull-right"><a href="/2019/12/01/Java-%E6%A1%86%E6%9E%B6-7-2-4-4/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mybatis 源码分析 Select执行流程(四)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/11/22/Java-框架-7-2-3-2/" title="Mybatis 插件原理"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">Mybatis 插件原理</div></div></a></div><div><a href="/2019/11/19/Java-框架-7-2-2-1/" title="MyBatis 的关联映射"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">MyBatis 的关联映射</div></div></a></div><div><a href="/2019/11/20/Java-框架-7-2-2-2/" title="Mybatis 动态SQL、批量操作"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">Mybatis 动态SQL、批量操作</div></div></a></div><div><a href="/2019/11/22/Java-框架-7-2-3-1/" title="Mybatis 常用插件框架"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">Mybatis 常用插件框架</div></div></a></div><div><a href="/2019/11/22/Java-框架-7-2-3-3/" title="Mybatis 插件 PageHelper源码分析"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">Mybatis 插件 PageHelper源码分析</div></div></a></div><div><a href="/2019/11/28/Java-框架-7-2-4-1/" title="Mybatis 源码分析 (一)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">Mybatis 源码分析 (一)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%BB%93%E6%9E%9C%E5%85%A5%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">映射结果入口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">创建实体类对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E9%9B%86%E6%98%A0%E5%B0%84"><span class="toc-number">3.</span> <span class="toc-text">结果集映射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%98%A0%E5%B0%84"><span class="toc-number">3.1.</span> <span class="toc-text">自动映射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%A0%E5%B0%84result%E8%8A%82%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">映射result节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.</span> <span class="toc-text">关联查询与延迟加载</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CglibProxyFactory"><span class="toc-number">4.1.</span> <span class="toc-text">CglibProxyFactory</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EnhancedResultObjectProxyImpl"><span class="toc-number">4.2.</span> <span class="toc-text">EnhancedResultObjectProxyImpl</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JavassistProxyFactory"><span class="toc-number">4.3.</span> <span class="toc-text">JavassistProxyFactory</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Mybatis 源码分析 Select执行流程(四) | 平心de小屋</title><meta name="keywords" content="Java,框架,DAO,Mybatis"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="我们回顾一下MapperMethod 的execute方法">
<meta property="og:type" content="article">
<meta property="og:title" content="Mybatis 源码分析 Select执行流程(四)">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/12/01/Java-%E6%A1%86%E6%9E%B6-7-2-4-4/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="我们回顾一下MapperMethod 的execute方法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg">
<meta property="article:published_time" content="2019-12-01T09:18:59.000Z">
<meta property="article:modified_time" content="2021-01-09T13:37:24.297Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="框架">
<meta property="article:tag" content="DAO">
<meta property="article:tag" content="Mybatis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/12/01/Java-%E6%A1%86%E6%9E%B6-7-2-4-4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Mybatis 源码分析 Select执行流程(四)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-01-09 21:37:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Mybatis 源码分析 Select执行流程(四)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-01T09:18:59.000Z" title="发表于 2019-12-01 17:18:59">2019-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-01-09T13:37:24.297Z" title="更新于 2021-01-09 21:37:24">2021-01-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E6%A1%86%E6%9E%B6/">框架</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Mybatis 源码分析 Select执行流程(四)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>我们回顾一下MapperMethod 的execute方法</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据 SQL 类型执行相应的数据库操作</span></span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">            <span class="comment">// 对用户传入的参数进行转换，下同</span></span><br><span class="line">            Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            <span class="comment">// 执行插入操作，rowCountResult 方法用于处理返回值</span></span><br><span class="line">            result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">            Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            <span class="comment">// 执行更新操作</span></span><br><span class="line">            result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">            Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            <span class="comment">// 执行删除操作</span></span><br><span class="line">            result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SELECT:</span><br><span class="line">            <span class="comment">// 根据目标方法的返回类型进行相应的查询操作</span></span><br><span class="line">            <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">                executeWithResultHandler(sqlSession, args);</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">                <span class="comment">// 执行查询操作，并返回多个结果 </span></span><br><span class="line">                result = executeForMany(sqlSession, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">                <span class="comment">// 执行查询操作，并将结果封装在 Map 中返回</span></span><br><span class="line">                result = executeForMap(sqlSession, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">                <span class="comment">// 执行查询操作，并返回一个 Cursor 对象</span></span><br><span class="line">                result = executeForCursor(sqlSession, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">                <span class="comment">// 执行查询操作，并返回一个结果</span></span><br><span class="line">                result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FLUSH:</span><br><span class="line">            <span class="comment">// 执行刷新操作</span></span><br><span class="line">            result = sqlSession.flushStatements();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="selectOne-方法分析"><a href="#selectOne-方法分析" class="headerlink" title="selectOne 方法分析"></a>selectOne 方法分析</h3><p>本节选择分析 selectOne 方法，主要是因为 selectOne 在内部会调用 selectList 方法。同时分析 selectOne 方法等同于分析 selectList 方法。代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 执行查询操作，并返回一个结果</span><br><span class="line">result = sqlSession.selectOne(command.getName(), param);</span><br></pre></td></tr></table></figure>

<p>我们看到是通过sqlSession来执行查询的，并且传入的参数为command.getName()和param，也就是namespace.methodName（mapper.EmployeeMapper.getAll）和方法的运行参数。我们知道了，所有的数据库操作都是交给sqlSession来执行的，那我们就来看看sqlSession的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultSqlSession</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 selectList 获取结果</span></span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">this</span>.&lt;T&gt;selectList(statement, parameter);</span><br><span class="line">    <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果查询结果大于1则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TooManyResultsException(</span><br><span class="line">            <span class="string">&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot;</span> + list.size());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，selectOne 方法在内部调用 selectList 了方法，并取 selectList 返回值的第1个元素作为自己的返回值。如果 selectList 返回的列表元素大于1，则抛出异常。下面我们来看看 selectList 方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultSqlSession</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用重载方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.selectList(statement, parameter, RowBounds.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过MappedStatement的Id获取 MappedStatement</span></span><br><span class="line">        MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">        <span class="comment">// 调用 Executor 实现类中的 query 方法</span></span><br><span class="line">        <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们之前创建<strong>DefaultSqlSession</strong>的时候，是创建了一个Executor的实例作为其属性的，我们看到<strong>通过MappedStatement的Id获取 MappedStatement后，就交由Executor去执行了</strong></p>
<p>我们回顾一下前面的文章，Executor的创建过程，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个执行器，默认是SIMPLE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="comment">//根据executorType来创建相应的执行器,Configuration默认是SIMPLE</span></span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//创建SimpleExecutor实例，并且包含Configuration和transaction属性</span></span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果要求缓存，生成另一种CachingExecutor,装饰者模式,默认都是返回CachingExecutor</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二级缓存开关配置示例</span></span><br><span class="line"><span class="comment">     * &lt;settings&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/settings&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      <span class="comment">//CachingExecutor使用装饰器模式，将executor的功能添加上了二级缓存的功能，二级缓存会单独文章来讲</span></span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处调用插件,通过插件可以改变Executor行为，此处我们后面单独文章讲</span></span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>executor包含了Configuration和Transaction，默认的执行器为SimpleExecutor，如果开启了二级缓存(默认开启)，则CachingExecutor会包装SimpleExecutor，那么我们该看CachingExecutor的<strong>query</strong>方法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CachingExecutor</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 BoundSql</span></span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">   <span class="comment">// 创建 CacheKey</span></span><br><span class="line">    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    <span class="comment">// 调用重载方法</span></span><br><span class="line">    <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码用于获取 BoundSql 对象，创建 CacheKey 对象，然后再将这两个对象传给重载方法。CacheKey 以及接下来即将出现的一二级缓存将会独立成文进行分析。</p>
<h4 id="获取-BoundSql"><a href="#获取-BoundSql" class="headerlink" title="获取 BoundSql"></a>获取 BoundSql</h4><p>我们先来看看获取BoundSql</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 BoundSql</span></span><br><span class="line">BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br></pre></td></tr></table></figure>

<p>调用了MappedStatement的getBoundSql方法，并将运行时参数传入其中，我们大概的猜一下，这里是不是拼接SQL语句呢，并将运行时参数设置到SQL语句中？</p>
<p>我们都知道 SQL 是配置在映射文件中的，但由于映射文件中的 SQL 可能会包含占位符 #{}，以及动态 SQL 标签，比如 &lt;if&gt;、&lt;where&gt; 等。因此，我们并不能直接使用映射文件中配置的 SQL。MyBatis 会将映射文件中的 SQL 解析成一组 SQL 片段。我们需要对这一组片段进行解析，从每个片段对象中获取相应的内容。然后将这些内容组合起来即可得到一个完成的 SQL 语句，这个完整的 SQL 以及其他的一些信息最终会存储在 BoundSql 对象中。下面我们来看一下 BoundSql 类的成员变量信息，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object parameterObject;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; additionalParameters;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MetaObject metaParameters;</span><br></pre></td></tr></table></figure>

<p>下面用一个表格列举各个成员变量的含义。</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>sql</td>
<td>String</td>
<td>一个完整的 SQL 语句，可能会包含问号 ? 占位符</td>
</tr>
<tr>
<td>parameterMappings</td>
<td>List</td>
<td>参数映射列表，SQL 中的每个 #{xxx} 占位符都会被解析成相应的 ParameterMapping 对象</td>
</tr>
<tr>
<td>parameterObject</td>
<td>Object</td>
<td>运行时参数，即用户传入的参数，比如 Article 对象，或是其他的参数</td>
</tr>
<tr>
<td>additionalParameters</td>
<td>Map</td>
<td>附加参数集合，用于存储一些额外的信息，比如 datebaseId 等</td>
</tr>
<tr>
<td>metaParameters</td>
<td>MetaObject</td>
<td>additionalParameters 的元信息对象</td>
</tr>
</tbody></table>
<p>接下来我们接着MappedStatement 的 getBoundSql 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 sqlSource 的 getBoundSql 获取 BoundSql，把method运行时参数传进去</span></span><br><span class="line">    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);<span class="keyword">return</span> boundSql;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MappedStatement 的 getBoundSql 在内部调用了 SqlSource 实现类的 getBoundSql 方法，并把method运行时参数传进去，SqlSource 是一个接口，它有如下几个实现类：</p>
<ul>
<li>DynamicSqlSource</li>
<li>RawSqlSource</li>
<li>StaticSqlSource</li>
<li>ProviderSqlSource</li>
<li>VelocitySqlSource</li>
</ul>
<p>当 SQL 配置中包含 <code>$&#123;&#125;</code>（不是 #{}）占位符，或者包含 &lt;if&gt;、&lt;where&gt; 等标签时，会被认为是动态 SQL，此时使用 DynamicSqlSource 存储 SQL 片段。否则，使用 RawSqlSource 存储 SQL 配置信息。我们来看看DynamicSqlSource的<strong>getBoundSql</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DynamicSqlSource</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 DynamicContext</span></span><br><span class="line">    DynamicContext context = <span class="keyword">new</span> DynamicContext(configuration, parameterObject);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 SQL 片段，并将解析结果存储到 DynamicContext 中，这里会将$&#123;&#125;替换成method对应的运行时参数，也会解析&lt;if&gt;&lt;where&gt;等SqlNode</span></span><br><span class="line">    rootSqlNode.apply(context);</span><br><span class="line">    </span><br><span class="line">    SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">    Class&lt;?&gt; parameterType = parameterObject == <span class="keyword">null</span> ? Object.class : parameterObject.getClass();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 构建 StaticSqlSource，在此过程中将 sql 语句中的占位符 #&#123;&#125; 替换为问号 ?，</span></span><br><span class="line"><span class="comment">     * 并为每个占位符构建相应的 ParameterMapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 调用 StaticSqlSource 的 getBoundSql 获取 BoundSql</span></span><br><span class="line">    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 DynamicContext 的 ContextMap 中的内容拷贝到 BoundSql 中</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123;</span><br><span class="line">        boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> boundSql;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法由数个步骤组成，这里总结一下：</p>
<ol>
<li>创建 DynamicContext</li>
<li>解析 SQL 片段，并将解析结果存储到 DynamicContext 中</li>
<li>解析 SQL 语句，并构建 StaticSqlSource</li>
<li>调用 StaticSqlSource 的 getBoundSql 获取 BoundSql</li>
<li>将 DynamicContext 的 ContextMap 中的内容拷贝到 BoundSql</li>
</ol>
<p><strong>DynamicContext</strong></p>
<p>DynamicContext 是 SQL 语句构建的上下文，每个 SQL 片段解析完成后，都会将解析结果存入 DynamicContext 中。待所有的 SQL 片段解析完毕后，一条完整的 SQL 语句就会出现在 DynamicContext 对象中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAMETER_OBJECT_KEY = <span class="string">&quot;_parameter&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATABASE_ID_KEY = <span class="string">&quot;_databaseId&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bindings 则用于存储一些额外的信息，比如运行时参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ContextMap bindings;</span><br><span class="line">    <span class="comment">//sqlBuilder 变量用于存放 SQL 片段的解析结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringBuilder sqlBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicContext</span><span class="params">(Configuration configuration, Object parameterObject)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ContextMap,并将运行时参数放入ContextMap中</span></span><br><span class="line">        <span class="keyword">if</span> (parameterObject != <span class="keyword">null</span> &amp;&amp; !(parameterObject <span class="keyword">instanceof</span> Map)) &#123;</span><br><span class="line">            MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">            bindings = <span class="keyword">new</span> ContextMap(metaObject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bindings = <span class="keyword">new</span> ContextMap(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存放运行时参数 parameterObject 以及 databaseId</span></span><br><span class="line">        bindings.put(PARAMETER_OBJECT_KEY, parameterObject);</span><br><span class="line">        bindings.put(DATABASE_ID_KEY, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(String name, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bindings.put(name, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拼接Sql片段</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendSql</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlBuilder.append(sql);</span><br><span class="line">        <span class="keyword">this</span>.sqlBuilder.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//得到sql字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sqlBuilder.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继承HashMap</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextMap</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> MetaObject parameterMetaObject;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ContextMap</span><span class="params">(MetaObject parameterMetaObject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.parameterMetaObject = parameterMetaObject;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            String strKey = (String) key;</span><br><span class="line">            <span class="comment">// 检查是否包含 strKey，若包含则直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">super</span>.containsKey(strKey)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.get(strKey);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parameterMetaObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 从运行时参数中查找结果，这里会在$&#123;name&#125;解析时，通过name获取运行时参数值，替换掉$&#123;name&#125;字符串</span></span><br><span class="line">                <span class="keyword">return</span> parameterMetaObject.getValue(strKey);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析 SQL 片段</strong></p>
<p>接着我们来看看解析SQL片段的逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rootSqlNode.apply(context);</span><br></pre></td></tr></table></figure>

<p>对于一个包含了 ${} 占位符，或 &lt;if&gt;、&lt;where&gt; 等标签的 SQL，在解析的过程中，会被分解成多个片段。每个片段都有对应的类型，每种类型的片段都有不同的解析逻辑。在源码中，片段这个概念等价于 sql 节点，即 SqlNode。</p>
<p>StaticTextSqlNode 用于存储静态文本，TextSqlNode 用于存储带有 ${} 占位符的文本，IfSqlNode 则用于存储 &lt;if&gt; 节点的内容。MixedSqlNode 内部维护了一个 SqlNode 集合，用于存储各种各样的 SqlNode。接下来，我将会对 MixedSqlNode 、StaticTextSqlNode、TextSqlNode、IfSqlNode、WhereSqlNode 以及 TrimSqlNode 等进行分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MixedSqlNode</span> <span class="keyword">implements</span> <span class="title">SqlNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SqlNode&gt; contents;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MixedSqlNode</span><span class="params">(List&lt;SqlNode&gt; contents)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.contents = contents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历 SqlNode 集合</span></span><br><span class="line">        <span class="keyword">for</span> (SqlNode sqlNode : contents) &#123;</span><br><span class="line">            <span class="comment">// 调用 salNode 对象本身的 apply 方法解析 sql</span></span><br><span class="line">            sqlNode.apply(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MixedSqlNode 可以看做是 SqlNode 实现类对象的容器，凡是实现了 SqlNode 接口的类都可以存储到 MixedSqlNode 中，包括它自己。MixedSqlNode 解析方法 apply 逻辑比较简单，即遍历 SqlNode 集合，并调用其他 SqlNode实现类对象的 apply 方法解析 sql。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StaticTextSqlNode</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTextSqlNode</span> <span class="keyword">implements</span> <span class="title">SqlNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticTextSqlNode</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接拼接当前sql片段的文本到DynamicContext的sqlBuilder中</span></span><br><span class="line">        context.appendSql(text);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StaticTextSqlNode 用于存储静态文本，直接将其存储的 SQL 的文本值拼接到 DynamicContext 的<strong>sqlBuilder</strong>中即可。下面分析一下 TextSqlNode。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextSqlNode</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextSqlNode</span> <span class="keyword">implements</span> <span class="title">SqlNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String text;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Pattern injectionFilter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 $&#123;&#125; 占位符解析器</span></span><br><span class="line">        GenericTokenParser parser = createParser(<span class="keyword">new</span> BindingTokenParser(context, injectionFilter));</span><br><span class="line">        <span class="comment">// 解析 $&#123;&#125; 占位符，通过ONGL 从用户传入的参数中获取结果，替换text中的$&#123;&#125; 占位符</span></span><br><span class="line">        <span class="comment">// 并将解析结果的文本拼接到DynamicContext的sqlBuilder中</span></span><br><span class="line">        context.appendSql(parser.parse(text));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> GenericTokenParser <span class="title">createParser</span><span class="params">(TokenHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建占位符解析器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;$&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingTokenParser</span> <span class="keyword">implements</span> <span class="title">TokenHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> DynamicContext context;</span><br><span class="line">        <span class="keyword">private</span> Pattern injectionFilter;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BindingTokenParser</span><span class="params">(DynamicContext context, Pattern injectionFilter)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.context = context;</span><br><span class="line">            <span class="keyword">this</span>.injectionFilter = injectionFilter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">handleToken</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">            Object parameter = context.getBindings().get(<span class="string">&quot;_parameter&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (parameter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                context.getBindings().put(<span class="string">&quot;value&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SimpleTypeRegistry.isSimpleType(parameter.getClass())) &#123;</span><br><span class="line">                context.getBindings().put(<span class="string">&quot;value&quot;</span>, parameter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过 ONGL 从用户传入的参数中获取结果</span></span><br><span class="line">            Object value = OgnlCache.getValue(content, context.getBindings());</span><br><span class="line">            String srtValue = (value == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : String.valueOf(value));</span><br><span class="line">            <span class="comment">// 通过正则表达式检测 srtValue 有效性</span></span><br><span class="line">            checkInjection(srtValue);</span><br><span class="line">            <span class="keyword">return</span> srtValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GenericTokenParser 是一个通用的标记解析器，用于解析形如 ${name}，#{id} 等标记。此时是解析 ${name}的形式，从运行时参数的Map中获取到key为name的值，直接用运行时参数替换掉 ${name}字符串，将替换后的text字符串拼接到DynamicContext的sqlBuilder中</p>
<p>举个例子吧，比喻我们有如下SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE name = &#x27;$&#123;name&#125;&#x27; and id= $&#123;id&#125;</span><br></pre></td></tr></table></figure>

<p>假如我们传的参数 Map中name值为 chenhao,id为1，那么该 SQL 最终会被解析成如下的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE name = &#x27;chenhao&#x27; and id= 1</span><br></pre></td></tr></table></figure>

<p>很明显这种直接拼接值很容易造成SQL注入，假如我们传入的参数为name值为 chenhao’; DROP TABLE user;# ，解析得到的结果为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE name = &#x27;chenhao&#x27;; DROP TABLE user;#&#x27;</span><br></pre></td></tr></table></figure>

<p>由于传入的参数没有经过转义，最终导致了一条 SQL 被恶意参数拼接成了两条 SQL。这就是为什么我们不应该在 SQL 语句中是用 ${} 占位符，风险太大。接着我们来看看IfSqlNode</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IfSqlNode</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfSqlNode</span> <span class="keyword">implements</span> <span class="title">SqlNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExpressionEvaluator evaluator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String test;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlNode contents;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IfSqlNode</span><span class="params">(SqlNode contents, String test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.test = test;</span><br><span class="line">        <span class="keyword">this</span>.contents = contents;</span><br><span class="line">        <span class="keyword">this</span>.evaluator = <span class="keyword">new</span> ExpressionEvaluator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过 ONGL 评估 test 表达式的结果</span></span><br><span class="line">        <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">            <span class="comment">// 若 test 表达式中的条件成立，则调用其子节点节点的 apply 方法进行解析</span></span><br><span class="line">            <span class="comment">// 如果是静态SQL节点，则会直接拼接到DynamicContext中</span></span><br><span class="line">            contents.apply(context);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IfSqlNode 对应的是 &lt;if test=’xxx’&gt; 节点，首先是通过 ONGL 检测 test 表达式是否为 true，如果为 true，则调用其子节点的 apply 方法继续进行解析。如果子节点是静态SQL节点，则子节点的文本值会直接拼接到DynamicContext中</p>
<p>好了，其他的SqlNode我就不一一分析了，大家有兴趣的可以去看看</p>
<p><strong>解析 #{} 占位符</strong></p>
<p>经过前面的解析，我们已经能从 DynamicContext 获取到完整的 SQL 语句了。但这并不意味着解析过程就结束了，因为当前的 SQL 语句中还有一种占位符没有处理，即 #{}。与 ${} 占位符的处理方式不同，MyBatis 并不会直接将 #{} 占位符替换为相应的参数值，而是将其替换成<strong>？</strong>。其解析是在如下代码中实现的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</span><br></pre></td></tr></table></figure>

<p>我们看到将前面解析过的sql字符串和运行时参数的Map作为参数，我们来看看parse方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parse</span><span class="params">(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 #&#123;&#125; 占位符处理器</span></span><br><span class="line">    ParameterMappingTokenHandler handler = <span class="keyword">new</span> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);</span><br><span class="line">    <span class="comment">// 创建 #&#123;&#125; 占位符解析器</span></span><br><span class="line">    GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;#&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, handler);</span><br><span class="line">    <span class="comment">// 解析 #&#123;&#125; 占位符，并返回解析结果字符串</span></span><br><span class="line">    String sql = parser.parse(originalSql);</span><br><span class="line">    <span class="comment">// 封装解析结果到 StaticSqlSource 中，并返回,因为所有的动态参数都已经解析了，可以封装成一个静态的SqlSource</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StaticSqlSource(configuration, sql, handler.getParameterMappings());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleToken</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 content 的对应的 ParameterMapping</span></span><br><span class="line">    parameterMappings.add(buildParameterMapping(content));</span><br><span class="line">    <span class="comment">// 返回 ?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;?&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到将Sql中的 #{} 占位符替换成”?”，并且将对应的参数转化成ParameterMapping 对象，通过buildParameterMapping 完成,最后创建一个StaticSqlSource，将sql字符串和ParameterMappings为参数传入，返回这个StaticSqlSource</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ParameterMapping <span class="title">buildParameterMapping</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将#&#123;xxx&#125; 占位符中的内容解析成 Map。</span></span><br><span class="line"><span class="comment">     *   #&#123;age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler&#125;</span></span><br><span class="line"><span class="comment">     *      上面占位符中的内容最终会被解析成如下的结果：</span></span><br><span class="line"><span class="comment">     *  &#123;</span></span><br><span class="line"><span class="comment">     *      &quot;property&quot;: &quot;age&quot;,</span></span><br><span class="line"><span class="comment">     *      &quot;typeHandler&quot;: &quot;MyTypeHandler&quot;, </span></span><br><span class="line"><span class="comment">     *      &quot;jdbcType&quot;: &quot;NUMERIC&quot;, </span></span><br><span class="line"><span class="comment">     *      &quot;javaType&quot;: &quot;int&quot;</span></span><br><span class="line"><span class="comment">     *  &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;String, String&gt; propertiesMap = parseParameterMapping(content);</span><br><span class="line">    String property = propertiesMap.get(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">    Class&lt;?&gt; propertyType;</span><br><span class="line">    <span class="comment">// metaParameters 为 DynamicContext 成员变量 bindings 的元信息对象</span></span><br><span class="line">    <span class="keyword">if</span> (metaParameters.hasGetter(property)) &#123;</span><br><span class="line">        propertyType = metaParameters.getGetterType(property);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * parameterType 是运行时参数的类型。如果用户传入的是单个参数，比如 Employe 对象，此时 </span></span><br><span class="line"><span class="comment">     * parameterType 为 Employe.class。如果用户传入的多个参数，比如 [id = 1, author = &quot;chenhao&quot;]，</span></span><br><span class="line"><span class="comment">     * MyBatis 会使用 ParamMap 封装这些参数，此时 parameterType 为 ParamMap.class。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterType)) &#123;</span><br><span class="line">        propertyType = parameterType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (JdbcType.CURSOR.name().equals(propertiesMap.get(<span class="string">&quot;jdbcType&quot;</span>))) &#123;</span><br><span class="line">        propertyType = java.sql.ResultSet.class;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (property == <span class="keyword">null</span> || Map.class.isAssignableFrom(parameterType)) &#123;</span><br><span class="line">        propertyType = Object.class;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 代码逻辑走到此分支中，表明 parameterType 是一个自定义的类，</span></span><br><span class="line"><span class="comment">         * 比如 Employe，此时为该类创建一个元信息对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MetaClass metaClass = MetaClass.forClass(parameterType, configuration.getReflectorFactory());</span><br><span class="line">        <span class="comment">// 检测参数对象有没有与 property 想对应的 getter 方法</span></span><br><span class="line">        <span class="keyword">if</span> (metaClass.hasGetter(property)) &#123;</span><br><span class="line">            <span class="comment">// 获取成员变量的类型</span></span><br><span class="line">            propertyType = metaClass.getGetterType(property);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            propertyType = Object.class;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ParameterMapping.Builder builder = <span class="keyword">new</span> ParameterMapping.Builder(configuration, property, propertyType);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 propertyType 赋值给 javaType</span></span><br><span class="line">    Class&lt;?&gt; javaType = propertyType;</span><br><span class="line">    String typeHandlerAlias = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历 propertiesMap</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : propertiesMap.entrySet()) &#123;</span><br><span class="line">        String name = entry.getKey();</span><br><span class="line">        String value = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;javaType&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 如果用户明确配置了 javaType，则以用户的配置为准</span></span><br><span class="line">            javaType = resolveClass(value);</span><br><span class="line">            builder.javaType(javaType);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;jdbcType&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 解析 jdbcType</span></span><br><span class="line">            builder.jdbcType(resolveJdbcType(value));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;mode&quot;</span>.equals(name)) &#123;...&#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;numericScale&quot;</span>.equals(name)) &#123;...&#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;resultMap&quot;</span>.equals(name)) &#123;...&#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;typeHandler&quot;</span>.equals(name)) &#123;</span><br><span class="line">            typeHandlerAlias = value;    </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;jdbcTypeName&quot;</span>.equals(name)) &#123;...&#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;property&quot;</span>.equals(name)) &#123;...&#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;expression&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Expression based parameters are not supported yet&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;An invalid property &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; was found in mapping #&#123;&quot;</span> + content</span><br><span class="line">                + <span class="string">&quot;&#125;.  Valid properties are &quot;</span> + parameterProperties);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (typeHandlerAlias != <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder.typeHandler(resolveTypeHandler(javaType, typeHandlerAlias));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建 ParameterMapping 对象</span></span><br><span class="line">    <span class="keyword">return</span> builder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL 中的 #{name, …} 占位符被替换成了问号 ?。#{name, …} 也被解析成了一个 ParameterMapping 对象。我们再来看一下 StaticSqlSource 的创建过程。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticSqlSource</span> <span class="keyword">implements</span> <span class="title">SqlSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticSqlSource</span><span class="params">(Configuration configuration, String sql)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(configuration, sql, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticSqlSource</span><span class="params">(Configuration configuration, String sql, List&lt;ParameterMapping&gt; parameterMappings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sql = sql;</span><br><span class="line">        <span class="keyword">this</span>.parameterMappings = parameterMappings;</span><br><span class="line">        <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 BoundSql 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BoundSql(configuration, sql, parameterMappings, parameterObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们通过创建的StaticSqlSource就可以获取BoundSql对象了，并传入运行时参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br></pre></td></tr></table></figure>

<p>也就是调用上面创建的StaticSqlSource 中的getBoundSql方法，这是简单的 <strong>return new</strong> <strong>BoundSql(configuration, sql, parameterMappings, parameterObject);</strong> ，接着看看BoundSql</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundSql</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String sql;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line">   <span class="keyword">private</span> Object parameterObject;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; additionalParameters;</span><br><span class="line">    <span class="keyword">private</span> MetaObject metaParameters;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundSql</span><span class="params">(Configuration configuration, String sql, List&lt;ParameterMapping&gt; parameterMappings, Object parameterObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sql = sql;</span><br><span class="line">        <span class="keyword">this</span>.parameterMappings = parameterMappings;</span><br><span class="line">        <span class="keyword">this</span>.parameterObject = parameterObject;</span><br><span class="line">        <span class="keyword">this</span>.additionalParameters = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">this</span>.metaParameters = configuration.newMetaObject(<span class="keyword">this</span>.additionalParameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sql;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到只是做简单的赋值。BoundSql中包含了sql，#{}解析成的parameterMappings，还有运行时参数parameterObject。好了，SQL解析我们就介绍这么多。我们先回顾一下我们代码是从哪里开始的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CachingExecutor</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 BoundSql</span></span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">   <span class="comment">// 创建 CacheKey</span></span><br><span class="line">    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    <span class="comment">// 调用重载方法</span></span><br><span class="line">    <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，我们刚才都是分析的第三行代码，获取到了<strong>BoundSql，</strong>CacheKey 和二级缓存有关，我们留在下一篇文章单独来讲，接着我们看第七行重载方法 <strong>query</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 从 MappedStatement 中获取缓存</span></span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="comment">// 若映射文件中未配置缓存或参照缓存，此时 cache = null</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        flushCacheIfRequired(ms);</span><br><span class="line">        <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ensureNoOutParams(ms, boundSql);</span><br><span class="line">            List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 若缓存未命中，则调用被装饰类的 query 方法，也就是SimpleExecutor的query方法</span></span><br><span class="line">                list = delegate.&lt;E&gt;query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">                tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用被装饰类的 query 方法,这里的delegate我们知道应该是SimpleExecutor</span></span><br><span class="line">    <span class="keyword">return</span> delegate.&lt;E&gt;query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码涉及到了二级缓存，若二级缓存为空，或未命中，则调用被装饰类的 query 方法。被装饰类为SimpleExecutor，而SimpleExecutor继承BaseExecutor，那我们来看看 BaseExecutor 的query方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BaseExecutor</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">        clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        queryStack++;</span><br><span class="line">        <span class="comment">// 从一级缓存中获取缓存项，一级缓存我们也下一篇文章单独讲</span></span><br><span class="line">        list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 一级缓存未命中，则从数据库中查询</span></span><br><span class="line">            list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">            deferredLoad.load();</span><br><span class="line">        &#125;</span><br><span class="line">        deferredLoads.clear();</span><br><span class="line">        <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">            clearLocalCache();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从一级缓存中查找查询结果。若缓存未命中，再向数据库进行查询。至此我们明白了一级二级缓存的大概思路，先从二级缓存中查找，若未命中二级缓存，再从一级缓存中查找，若未命中一级缓存，再从数据库查询数据，那我们来看看是怎么从数据库查询的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BaseExecutor</span></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds,</span></span></span><br><span class="line"><span class="params"><span class="function">    ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="comment">// 向缓存中存储一个占位符</span></span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 doQuery 进行查询</span></span><br><span class="line">        list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 移除占位符</span></span><br><span class="line">        localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存查询结果</span></span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">        localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了<strong>doQuery</strong>方法进行查询，最后将查询结果放入一级缓存，我们来看看doQuery,在SimpleExecutor中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleExecutor</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        <span class="comment">// 创建 StatementHandler</span></span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="comment">// 创建 Statement</span></span><br><span class="line">        stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        <span class="comment">// 执行查询操作</span></span><br><span class="line">        <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭 Statement</span></span><br><span class="line">        closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看看第一步创建<strong>StatementHandler</strong> </p>
<h4 id="创建StatementHandler"><a href="#创建StatementHandler" class="headerlink" title="创建StatementHandler"></a>创建StatementHandler</h4><p>StatementHandler有什么作用呢？通过这个对象获取Statement对象，然后填充运行时参数，最后调用query完成查询。我们来看看其创建过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement,</span></span></span><br><span class="line"><span class="params"><span class="function">    Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建具有路由功能的 StatementHandler</span></span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 应用插件到 StatementHandler 上</span></span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看RoutingStatementHandler的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StatementHandler delegate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds,</span></span></span><br><span class="line"><span class="params"><span class="function">        ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 StatementType 创建不同的 StatementHandler </span></span><br><span class="line">        <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> STATEMENT:</span><br><span class="line">                delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PREPARED:</span><br><span class="line">                delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CALLABLE:</span><br><span class="line">                delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RoutingStatementHandler 的构造方法会根据 MappedStatement 中的 statementType 变量创建不同的 StatementHandler 实现类。那statementType 是什么呢？我们还要回顾一下MappedStatement 的创建过程</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/27/lVJtIg.png" alt="lVJtIg.png"></p>
<p>我们看到statementType 的默认类型为PREPARED，这里将会创建PreparedStatementHandler。</p>
<p>接着我们看下面一行代码prepareStatement,</p>
<h4 id="创建-Statement"><a href="#创建-Statement" class="headerlink" title="创建 Statement"></a>创建 Statement</h4><p>创建 Statement 在 stmt = prepareStatement(handler, ms.getStatementLog()); 这句代码，那我们跟进去看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    <span class="comment">// 获取数据库连接</span></span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    <span class="comment">// 创建 Statement，</span></span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">  <span class="comment">// 为 Statement 设置参数</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中我们终于看到了和jdbc相关的内容了，创建完Statement，最后就可以执行查询操作了</p>
<h3 id="Select-语句的执行过程"><a href="#Select-语句的执行过程" class="headerlink" title="Select 语句的执行过程"></a>Select 语句的执行过程</h3><p>查询方法里面的doQuery方法，这里面就是调用JDBC的API了，其中的逻辑比较复杂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleExecutor</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        <span class="comment">// 创建 StatementHandler</span></span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="comment">// 创建 Statement</span></span><br><span class="line">        stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        <span class="comment">// 执行查询操作</span></span><br><span class="line">        <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭 Statement</span></span><br><span class="line">        closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第6行处我们创建了一个<strong>PreparedStatementHandler，</strong>我们要接着第8行代码开始分析，也就是创建 Statement，先不忙着分析，我们先来回顾一下 ，我们以前是怎么使用jdbc的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *    第一步，加载驱动，创建数据库的连接</span></span><br><span class="line"><span class="comment">     *    第二步，编写sql</span></span><br><span class="line"><span class="comment">     *    第三步，需要对sql进行预编译</span></span><br><span class="line"><span class="comment">     *    第四步，向sql里面设置参数</span></span><br><span class="line"><span class="comment">     *    第五步，执行sql</span></span><br><span class="line"><span class="comment">     *    第六步，释放资源 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = <span class="string">&quot;jdbc:mysql://localhost:3306/chenhao&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">&quot;liulx&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        login(<span class="string">&quot;lucy&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username , String password)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>; </span><br><span class="line">        PreparedStatement psmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加载驱动程序</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//获得数据库连接</span></span><br><span class="line">            conn = DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">            <span class="comment">//编写sql</span></span><br><span class="line">            String sql = <span class="string">&quot;select * from user where name =? and password = ?&quot;</span>;<span class="comment">//问号相当于一个占位符</span></span><br><span class="line">            <span class="comment">//对sql进行预编译</span></span><br><span class="line">            psmt = conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//设置参数</span></span><br><span class="line">            psmt.setString(<span class="number">1</span>, username);</span><br><span class="line">            psmt.setString(<span class="number">2</span>, password);</span><br><span class="line">            <span class="comment">//执行sql ,返回一个结果集</span></span><br><span class="line">            rs = psmt.executeQuery();</span><br><span class="line">            <span class="comment">//输出结果</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                System.out.println(rs.getString(<span class="string">&quot;user_name&quot;</span>)+<span class="string">&quot; 年龄：&quot;</span>+rs.getInt(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放资源</span></span><br><span class="line">            conn.close();</span><br><span class="line">            psmt.close();</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中注释已经很清楚了，我们来看看mybatis中是怎么和数据库打交道的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    <span class="comment">// 获取数据库连接</span></span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">   <span class="comment">// 创建 Statement，</span></span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">   <span class="comment">// 为 Statement 设置参数</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中我们终于看到了和jdbc相关的内容了，大概分为下面三个步骤：</p>
<ol>
<li>获取数据库连接</li>
<li>创建PreparedStatement</li>
<li>为PreparedStatement设置运行时参数</li>
</ol>
<p>我们先来看看获取数据库连接，跟进代码看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BaseExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnection</span><span class="params">(Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//通过transaction来获取Connection</span></span><br><span class="line">    Connection connection = <span class="keyword">this</span>.transaction.getConnection();</span><br><span class="line">    <span class="keyword">return</span> statementLog.isDebugEnabled() ? ConnectionLogger.newInstance(connection, statementLog, <span class="keyword">this</span>.queryStack) : connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到是通过Executor中的transaction属性来获取Connection，那我们就先来看看transaction，根据前面配置 &lt;transactionManager type=”jdbc”/&gt;，则MyBatis会创建一个JdbcTransactionFactory.class 实例，Executor中的transaction是一个JdbcTransaction.class 实例，其实现Transaction接口，那我们先来看看Transaction</p>
<h4 id="JdbcTransaction"><a href="#JdbcTransaction" class="headerlink" title="JdbcTransaction"></a>JdbcTransaction</h4><p>我们先来看看其接口Transaction</p>
<h5 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取数据库连接</span></span><br><span class="line">    <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">//关闭事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">//获取超时时间</span></span><br><span class="line">    <span class="function">Integer <span class="title">getTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们看看其实现类<strong>JdbcTransaction</strong></p>
<h5 id="JdbcTransaction-1"><a href="#JdbcTransaction-1" class="headerlink" title="JdbcTransaction"></a>JdbcTransaction</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTransaction</span> <span class="keyword">implements</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(JdbcTransaction.class);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//数据库连接</span></span><br><span class="line">  <span class="keyword">protected</span> Connection connection;</span><br><span class="line">  <span class="comment">//数据源信息</span></span><br><span class="line">  <span class="keyword">protected</span> DataSource dataSource;</span><br><span class="line">  <span class="comment">//隔离级别</span></span><br><span class="line">  <span class="keyword">protected</span> TransactionIsolationLevel level;</span><br><span class="line">  <span class="comment">//是否为自动提交</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> autoCommmit;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JdbcTransaction</span><span class="params">(DataSource ds, TransactionIsolationLevel desiredLevel, <span class="keyword">boolean</span> desiredAutoCommit)</span> </span>&#123;</span><br><span class="line">    dataSource = ds;</span><br><span class="line">    level = desiredLevel;</span><br><span class="line">    autoCommmit = desiredAutoCommit;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JdbcTransaction</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.connection = connection;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//如果事务中不存在connection，则获取一个connection并放入connection属性中</span></span><br><span class="line">    <span class="comment">//第一次肯定为空</span></span><br><span class="line">    <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">      openConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果事务中已经存在connection，则直接返回这个connection</span></span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * commit()功能 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; !connection.getAutoCommit()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Committing JDBC Connection [&quot;</span> + connection + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//使用connection的commit()</span></span><br><span class="line">      connection.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rollback()功能 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; !connection.getAutoCommit()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Rolling back JDBC Connection [&quot;</span> + connection + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//使用connection的rollback()</span></span><br><span class="line">      connection.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * close()功能 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      resetAutoCommit();</span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Closing JDBC Connection [&quot;</span> + connection + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//使用connection的close()</span></span><br><span class="line">      connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Opening JDBC Connection&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过dataSource来获取connection，并设置到transaction的connection属性中</span></span><br><span class="line">    connection = dataSource.getConnection();</span><br><span class="line">   <span class="keyword">if</span> (level != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//通过connection设置事务的隔离级别</span></span><br><span class="line">      connection.setTransactionIsolation(level.getLevel());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置事务是否自动提交</span></span><br><span class="line">    setDesiredAutoCommit(autoCommmit);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setDesiredAutoCommit</span><span class="params">(<span class="keyword">boolean</span> desiredAutoCommit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.connection.getAutoCommit() != desiredAutoCommit) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;Setting autocommit to &quot;</span> + desiredAutoCommit + <span class="string">&quot; on JDBC Connection [&quot;</span> + <span class="keyword">this</span>.connection + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通过connection设置事务是否自动提交</span></span><br><span class="line">            <span class="keyword">this</span>.connection.setAutoCommit(desiredAutoCommit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TransactionException(<span class="string">&quot;Error configuring AutoCommit.  Your driver may not support getAutoCommit() or setAutoCommit(). Requested setting: &quot;</span> + desiredAutoCommit + <span class="string">&quot;.  Cause: &quot;</span> + var3, var3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到JdbcTransaction中有一个Connection属性和dataSource属性，使用connection来进行提交、回滚、关闭等操作，也就是说JdbcTransaction其实只是在jdbc的connection上面封装了一下，实际使用的其实还是jdbc的事务。我们看看getConnection()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库连接</span></span><br><span class="line"><span class="keyword">protected</span> Connection connection;</span><br><span class="line"><span class="comment">//数据源信息</span></span><br><span class="line"><span class="keyword">protected</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">//如果事务中不存在connection，则获取一个connection并放入connection属性中</span></span><br><span class="line"><span class="comment">//第一次肯定为空</span></span><br><span class="line"><span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">  openConnection();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果事务中已经存在connection，则直接返回这个connection</span></span><br><span class="line"><span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">  log.debug(<span class="string">&quot;Opening JDBC Connection&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过dataSource来获取connection，并设置到transaction的connection属性中</span></span><br><span class="line">connection = dataSource.getConnection();</span><br><span class="line"><span class="keyword">if</span> (level != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">//通过connection设置事务的隔离级别</span></span><br><span class="line">  connection.setTransactionIsolation(level.getLevel());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置事务是否自动提交</span></span><br><span class="line">setDesiredAutoCommit(autoCommmit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先是判断当前事务中是否存在connection，如果存在，则直接返回connection，如果不存在则通过dataSource来获取connection，这里我们明白了一点，如果当前事务没有关闭，也就是没有释放connection，那么在同一个Transaction中使用的是同一个connection,我们再来想想，transaction是SimpleExecutor中的属性，SimpleExecutor又是SqlSession中的属性，那我们可以这样说，同一个SqlSession中只有一个SimpleExecutor，SimpleExecutor中有一个Transaction，Transaction有一个connection。我们来看看如下例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="comment">//创建一个SqlSession</span></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         EmployeeMapper employeeMapper = sqlSession.getMapper(Employee.class);</span><br><span class="line">         UserMapper userMapper = sqlSession.getMapper(User.class);</span><br><span class="line">         List&lt;Employee&gt; allEmployee = employeeMapper.getAll();</span><br><span class="line">         List&lt;User&gt; allUser = userMapper.getAll();</span><br><span class="line">         Employee employee = employeeMapper.getOne();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到同一个sqlSession可以获取多个Mapper代理对象，则多个Mapper代理对象中的sqlSession引用应该是同一个，那么多个Mapper代理对象调用方法应该是同一个Connection，直到调用close(),所以说我们的sqlSession是线程不安全的，如果所有的业务都使用一个sqlSession，那Connection也是同一个，一个业务执行完了就将其关闭，那其他的业务还没执行完呢。大家明白了吗？我们回归到源码，connection = dataSource.getConnection();，最终还是调用dataSource来获取连接，那我们是不是要来看看dataSource呢？</p>
<p>我们还是从前面的配置文件来看&lt;dataSource type=”UNPOOLED|POOLED”&gt;，这里有UNPOOLED和POOLED两种DataSource，一种是使用连接池，一种是普通的DataSource，UNPOOLED将会创将new UnpooledDataSource()实例，POOLED将会new pooledDataSource()实例，都实现DataSource接口，那我们先来看看DataSource接口</p>
<p><strong>DataSource</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataSource</span>  <span class="keyword">extends</span> <span class="title">CommonDataSource</span>,<span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取数据库连接</span></span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，只有一个获取数据库连接的接口，那我们来看看其实现类</p>
<h4 id="UnpooledDataSource"><a href="#UnpooledDataSource" class="headerlink" title="UnpooledDataSource"></a>UnpooledDataSource</h4><p>UnpooledDataSource，从名称上即可知道，该种数据源不具有池化特性。该种数据源每次会返回一个新的数据库连接，而非复用旧的连接。其核心的方法有三个，分别如下：</p>
<ol>
<li>initializeDriver - 初始化数据库驱动</li>
<li>doGetConnection - 获取数据连接</li>
<li>configureConnection - 配置数据库连接</li>
</ol>
<h5 id="初始化数据库驱动"><a href="#初始化数据库驱动" class="headerlink" title="初始化数据库驱动"></a>初始化数据库驱动</h5><p>看下我们上面使用JDBC的例子，在执行 SQL 之前，通常都是先获取数据库连接。一般步骤都是加载数据库驱动，然后通过 DriverManager 获取数据库连接。UnpooledDataSource 也是使用 JDBC 访问数据库的，因此它获取数据库连接的过程一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UnpooledDataSource</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader driverClassLoader;</span><br><span class="line">    <span class="keyword">private</span> Properties driverProperties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Driver&gt; registeredDrivers = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Boolean autoCommit;</span><br><span class="line">    <span class="keyword">private</span> Integer defaultTransactionIsolationLevel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">(String driver, String url, String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.driver = driver;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initializeDriver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 检测当前 driver 对应的驱动实例是否已经注册</span></span><br><span class="line">        <span class="keyword">if</span> (!registeredDrivers.containsKey(driver)) &#123;</span><br><span class="line">            Class&lt;?&gt; driverType;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加载驱动类型</span></span><br><span class="line">                <span class="keyword">if</span> (driverClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 使用 driverClassLoader 加载驱动</span></span><br><span class="line">                    driverType = Class.forName(driver, <span class="keyword">true</span>, driverClassLoader);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 通过其他 ClassLoader 加载驱动</span></span><br><span class="line">                    driverType = Resources.classForName(driver);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过反射创建驱动实例</span></span><br><span class="line">                Driver driverInstance = (Driver) driverType.newInstance();</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 注册驱动，注意这里是将 Driver 代理类 DriverProxy 对象注册到 DriverManager 中的，而非 Driver 对象本身。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                DriverManager.registerDriver(<span class="keyword">new</span> DriverProxy(driverInstance));</span><br><span class="line">                <span class="comment">// 缓存驱动类名和实例，防止多次注册</span></span><br><span class="line">                registeredDrivers.put(driver, driverInstance);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;Error setting driver on UnpooledDataSource. Cause: &quot;</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DriverManager</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class="keyword">new</span> CopyOnWriteArrayList&lt;DriverInfo&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(java.sql.Driver driver)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(driver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        registeredDrivers.addIfAbsent(<span class="keyword">new</span> DriverInfo(driver));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This is for compatibility with the original DriverManager</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过反射机制加载驱动Driver，并将其注册到DriverManager中的一个常量集合中，供后面获取连接时使用，为什么这里是一个List呢？我们实际开发中有可能使用到了多种数据库类型，如Mysql、Oracle等，其驱动都是不同的，不同的数据源获取连接时使用的是不同的驱动。<br>在我们使用JDBC的时候，也没有通过DriverManager.registerDriver(new DriverProxy(driverInstance));去注册Driver啊，如果我们使用的是Mysql数据源，那我们来看Class.forName(“com.mysql.jdbc.Driver”);这句代码发生了什么<br>Class.forName主要是做了什么呢？它主要是要求JVM查找并装载指定的类。这样我们的类com.mysql.jdbc.Driver就被装载进来了。而且在类被装载进JVM的时候，它的静态方法就会被执行。我们来看com.mysql.jdbc.Driver的实现代码。在它的实现里有这么一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException E) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，这里使用了DriverManager并将该类给注册上去了。所以，对于任何实现前面Driver接口的类，只要在他们被装载进JVM的时候注册DriverManager就可以实现被后续程序使用。</p>
<p>作为那些被加载的Driver实现，他们本身在被装载时会在执行的static代码段里通过调用DriverManager.registerDriver()来把自身注册到DriverManager的registeredDrivers列表中。这样后面就可以通过得到的Driver来取得连接了。</p>
<h4 id="获取数据库连接"><a href="#获取数据库连接" class="headerlink" title="获取数据库连接"></a>获取数据库连接</h4><p>在上面例子中使用 JDBC 时，我们都是通过 DriverManager 的接口方法获取数据库连接。我们来看看UnpooledDataSource是如何获取的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UnpooledDataSource</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGetConnection(username, password);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">doGetConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">if</span> (driverProperties != <span class="keyword">null</span>) &#123;</span><br><span class="line">        props.putAll(driverProperties);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (username != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 存储 user 配置</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;user&quot;</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 存储 password 配置</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用重载方法</span></span><br><span class="line">    <span class="keyword">return</span> doGetConnection(props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">doGetConnection</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化驱动,我们上一节已经讲过了，只用初始化一次</span></span><br><span class="line">    initializeDriver();</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    Connection connection = DriverManager.getConnection(url, properties);</span><br><span class="line">    <span class="comment">// 配置连接，包括自动提交以及事务等级</span></span><br><span class="line">    configureConnection(connection);</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureConnection</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (autoCommit != <span class="keyword">null</span> &amp;&amp; autoCommit != conn.getAutoCommit()) &#123;</span><br><span class="line">        <span class="comment">// 设置自动提交</span></span><br><span class="line">        conn.setAutoCommit(autoCommit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (defaultTransactionIsolationLevel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置事务隔离级别</span></span><br><span class="line">        conn.setTransactionIsolation(defaultTransactionIsolationLevel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法将一些配置信息放入到 Properties 对象中，然后将数据库连接和 Properties 对象传给 DriverManager 的 getConnection 方法即可获取到数据库连接。我们来看看是怎么获取数据库连接的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取类加载器</span></span><br><span class="line">    ClassLoader callerCL = caller != <span class="keyword">null</span> ? caller.getClassLoader() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(DriverManager.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (callerCL == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处省略部分代码 </span></span><br><span class="line">    <span class="comment">// 这里遍历的是在registerDriver(Driver driver)方法中注册的驱动对象</span></span><br><span class="line">    <span class="comment">// 每个DriverInfo包含了驱动对象和其信息</span></span><br><span class="line">    <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断是否为当前线程类加载器加载的驱动类</span></span><br><span class="line">      <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          println(<span class="string">&quot;trying &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 获取连接对象，这里调用了Driver的父类的方法</span></span><br><span class="line">          <span class="comment">// 如果这里有多个DriverInfo，比喻Mysql和Oracle的Driver都注册registeredDrivers了</span></span><br><span class="line">          <span class="comment">// 这里所有的Driver都会尝试使用url和info去连接，哪个连接上了就返回</span></span><br><span class="line">          <span class="comment">// 会不会所有的都会连接上呢？不会，因为url的写法不同，不同的Driver会判断url是否适合当前驱动</span></span><br><span class="line">          Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">          <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 打印连接成功信息</span></span><br><span class="line">            println(<span class="string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">            <span class="comment">// 返回连接对像</span></span><br><span class="line">            <span class="keyword">return</span> (con);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">          <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</span><br><span class="line">            reason = ex;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;    skipping: &quot;</span> + aDriver.getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中循环所有注册的驱动，然后通过驱动进行连接，所有的驱动都会尝试连接，但是不同的驱动，连接的URL是不同的，如Mysql的url是jdbc:mysql://localhost:3306/chenhao，以jdbc:mysql://开头，则其Mysql的驱动肯定会判断获取连接的url符合，Oracle的也类似，我们来看看Mysql的驱动获取连接</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/27/lVtrUU.png" alt="lVtrUU.png"></p>
<h4 id="PooledDataSource"><a href="#PooledDataSource" class="headerlink" title="PooledDataSource"></a>PooledDataSource</h4><p>PooledDataSource 内部实现了连接池功能，用于复用数据库连接。因此，从效率上来说，PooledDataSource 要高于 UnpooledDataSource。但是最终获取Connection还是通过UnpooledDataSource，只不过PooledDataSource 提供一个存储Connection的功能。</p>
<h5 id="辅助类介绍"><a href="#辅助类介绍" class="headerlink" title="辅助类介绍"></a>辅助类介绍</h5><p>PooledDataSource 需要借助两个辅助类帮其完成功能，这两个辅助类分别是 PoolState 和 PooledConnection。PoolState 用于记录连接池运行时的状态，比如连接获取次数，无效连接数量等。同时 PoolState 内部定义了两个 PooledConnection 集合，用于存储空闲连接和活跃连接。PooledConnection 内部定义了一个 Connection 类型的变量，用于指向真实的数据库连接。以及一个 Connection 的代理类，用于对部分方法调用进行拦截。至于为什么要拦截，随后将进行分析。除此之外，PooledConnection 内部也定义了一些字段，用于记录数据库连接的一些运行时状态。接下来，我们来看一下 PooledConnection 的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PooledConnection</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledConnection</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLOSE = <span class="string">&quot;close&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] IFACES = <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Connection.class&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hashCode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PooledDataSource dataSource;</span><br><span class="line">    <span class="comment">// 真实的数据库连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Connection realConnection;</span><br><span class="line">    <span class="comment">// 数据库连接代理</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Connection proxyConnection;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从连接池中取出连接时的时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> checkoutTimestamp;</span><br><span class="line">    <span class="comment">// 数据库连接创建时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> createdTimestamp;</span><br><span class="line">    <span class="comment">// 数据库连接最后使用时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastUsedTimestamp;</span><br><span class="line">    <span class="comment">// connectionTypeCode = (url + username + password).hashCode()</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> connectionTypeCode;</span><br><span class="line">    <span class="comment">// 表示连接是否有效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> valid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PooledConnection</span><span class="params">(Connection connection, PooledDataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hashCode = connection.hashCode();</span><br><span class="line">        <span class="keyword">this</span>.realConnection = connection;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">        <span class="keyword">this</span>.createdTimestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">this</span>.lastUsedTimestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">this</span>.valid = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 创建 Connection 的代理类对象</span></span><br><span class="line">        <span class="keyword">this</span>.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面再来看看 PoolState 的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PoolState </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> PooledDataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲连接列表</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; idleConnections = <span class="keyword">new</span> ArrayList&lt;PooledConnection&gt;();</span><br><span class="line">    <span class="comment">// 活跃连接列表</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; activeConnections = <span class="keyword">new</span> ArrayList&lt;PooledConnection&gt;();</span><br><span class="line">    <span class="comment">// 从连接池中获取连接的次数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> requestCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 请求连接总耗时（单位：毫秒）</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedRequestTime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 连接执行时间总耗时</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 执行时间超时的连接数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> claimedOverdueConnectionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 超时时间累加值</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTimeOfOverdueConnections = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 等待时间累加值</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedWaitTime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 等待次数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> hadToWaitCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 无效连接数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> badConnectionCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家记住上面的空闲连接列表和活跃连接列表</p>
<h5 id="获取连接"><a href="#获取连接" class="headerlink" title="获取连接"></a>获取连接</h5><p>前面已经说过，PooledDataSource 会将用过的连接进行回收，以便可以复用连接。因此从 PooledDataSource 获取连接时，如果空闲链接列表里有连接时，可直接取用。那如果没有空闲连接怎么办呢？此时有两种解决办法，要么创建新连接，要么等待其他连接完成任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PooledDataSource</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(PooledDataSource.class);</span><br><span class="line">    <span class="comment">//这里有辅助类PoolState</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PoolState state = <span class="keyword">new</span> PoolState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//还有一个UnpooledDataSource属性，其实真正获取Connection是由UnpooledDataSource来完成的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnpooledDataSource dataSource;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumActiveConnections = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumIdleConnections = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumCheckoutTime = <span class="number">20000</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> poolTimeToWait = <span class="number">20000</span>;</span><br><span class="line">    <span class="keyword">protected</span> String poolPingQuery = <span class="string">&quot;NO PING QUERY SET&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> poolPingEnabled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> poolPingConnectionsNotUsedFor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedConnectionTypeCode;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> UnpooledDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">(String driver, String url, String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造器中创建UnpooledDataSource对象</span></span><br><span class="line">        <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> UnpooledDataSource(driver, url, username, password);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.popConnection(<span class="keyword">this</span>.dataSource.getUsername(), <span class="keyword">this</span>.dataSource.getPassword()).getProxyConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> PooledConnection <span class="title">popConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> countedWait = <span class="keyword">false</span>;</span><br><span class="line">        PooledConnection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> localBadConnectionCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">                <span class="comment">// 检测空闲连接集合（idleConnections）是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (!state.idleConnections.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// idleConnections 不为空，表示有空闲连接可以使用，直接从空闲连接集合中取出一个连接</span></span><br><span class="line">                    conn = state.idleConnections.remove(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 暂无空闲连接可用，但如果活跃连接数还未超出限制</span></span><br><span class="line"><span class="comment">                     *（poolMaximumActiveConnections），则可创建新的连接</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (state.activeConnections.size() &lt; poolMaximumActiveConnections) &#123;</span><br><span class="line">                        <span class="comment">// 创建新连接，看到没，还是通过dataSource获取连接，也就是UnpooledDataSource获取连接</span></span><br><span class="line">                        conn = <span class="keyword">new</span> PooledConnection(dataSource.getConnection(), <span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 连接池已满，不能创建新连接</span></span><br><span class="line">                        <span class="comment">// 取出运行时间最长的连接</span></span><br><span class="line">                        PooledConnection oldestActiveConnection = state.activeConnections.get(<span class="number">0</span>);</span><br><span class="line">                        <span class="comment">// 获取运行时长</span></span><br><span class="line">                        <span class="keyword">long</span> longestCheckoutTime = oldestActiveConnection.getCheckoutTime();</span><br><span class="line">                        <span class="comment">// 检测运行时长是否超出限制，即超时</span></span><br><span class="line">                        <span class="keyword">if</span> (longestCheckoutTime &gt; poolMaximumCheckoutTime) &#123;</span><br><span class="line">                            <span class="comment">// 累加超时相关的统计字段</span></span><br><span class="line">                            state.claimedOverdueConnectionCount++;</span><br><span class="line">                            state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span><br><span class="line">                            state.accumulatedCheckoutTime += longestCheckoutTime;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 从活跃连接集合中移除超时连接</span></span><br><span class="line">                            state.activeConnections.remove(oldestActiveConnection);</span><br><span class="line">                            <span class="comment">// 若连接未设置自动提交，此处进行回滚操作</span></span><br><span class="line">                            <span class="keyword">if</span> (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    oldestActiveConnection.getRealConnection().rollback();</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (SQLException e) &#123;...&#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 创建一个新的 PooledConnection，注意，</span></span><br><span class="line"><span class="comment">                             * 此处复用 oldestActiveConnection 的 realConnection 变量</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            conn = <span class="keyword">new</span> PooledConnection(oldestActiveConnection.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 复用 oldestActiveConnection 的一些信息，注意 PooledConnection 中的 </span></span><br><span class="line"><span class="comment">                             * createdTimestamp 用于记录 Connection 的创建时间，而非 PooledConnection </span></span><br><span class="line"><span class="comment">                             * 的创建时间。所以这里要复用原连接的时间信息。</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());</span><br><span class="line">                            conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 设置连接为无效状态</span></span><br><span class="line">                            oldestActiveConnection.invalidate();</span><br><span class="line">                            </span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 运行时间最长的连接并未超时</span></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!countedWait) &#123;</span><br><span class="line">                                    state.hadToWaitCount++;</span><br><span class="line">                                    countedWait = <span class="keyword">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">long</span> wt = System.currentTimeMillis();</span><br><span class="line">                                <span class="comment">// 当前线程进入等待状态</span></span><br><span class="line">                                state.wait(poolTimeToWait);</span><br><span class="line">                                state.accumulatedWaitTime += System.currentTimeMillis() - wt;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">                            <span class="comment">// 进行回滚操作</span></span><br><span class="line">                            conn.getRealConnection().rollback();</span><br><span class="line">                        &#125;</span><br><span class="line">                        conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));</span><br><span class="line">                        <span class="comment">// 设置统计字段</span></span><br><span class="line">                        conn.setCheckoutTimestamp(System.currentTimeMillis());</span><br><span class="line">                        conn.setLastUsedTimestamp(System.currentTimeMillis());</span><br><span class="line">                        state.activeConnections.add(conn);</span><br><span class="line">                        state.requestCount++;</span><br><span class="line">                        state.accumulatedRequestTime += System.currentTimeMillis() - t;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 连接无效，此时累加无效连接相关的统计字段</span></span><br><span class="line">                        state.badConnectionCount++;</span><br><span class="line">                        localBadConnectionCount++;</span><br><span class="line">                        conn = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (localBadConnectionCount &gt; (poolMaximumIdleConnections</span><br><span class="line">                            + poolMaximumLocalBadConnectionTolerance)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(...);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(...);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从连接池中获取连接首先会遇到两种情况：</p>
<ol>
<li>连接池中有空闲连接</li>
<li>连接池中无空闲连接</li>
</ol>
<p>对于第一种情况，把连接取出返回即可。对于第二种情况，则要进行细分，会有如下的情况。</p>
<ol>
<li>活跃连接数没有超出最大活跃连接数</li>
<li>活跃连接数超出最大活跃连接数</li>
</ol>
<p>对于上面两种情况，第一种情况比较好处理，直接创建新的连接即可。至于第二种情况，需要再次进行细分。</p>
<ol>
<li>活跃连接的运行时间超出限制，即超时了</li>
<li>活跃连接未超时</li>
</ol>
<p>对于第一种情况，我们直接将超时连接强行中断，并进行回滚，然后复用部分字段重新创建 PooledConnection 即可。对于第二种情况，目前没有更好的处理方式了，只能等待了。</p>
<h5 id="回收连接"><a href="#回收连接" class="headerlink" title="回收连接"></a>回收连接</h5><p>相比于获取连接，回收连接的逻辑要简单的多。回收连接成功与否只取决于空闲连接集合的状态，所需处理情况很少，因此比较简单。</p>
<p>我们还是来看看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Connection getConnection() throws SQLException &#123;</span><br><span class="line">    return this.popConnection(this.dataSource.getUsername(), this.dataSource.getPassword()).getProxyConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的是PooledConnection的一个代理类，为什么不直接使用PooledConnection的realConnection呢？我们可以看下PooledConnection这个类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class PooledConnection implements InvocationHandler &#123;</span><br></pre></td></tr></table></figure>

<p> 很熟悉是吧，标准的代理类用法，看下其invoke方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PooledConnection</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    <span class="comment">// 重点在这里，如果调用了其close方法，则实际执行的是将连接放回连接池的操作</span></span><br><span class="line">    <span class="keyword">if</span> (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) &#123;</span><br><span class="line">        dataSource.pushConnection(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">                <span class="comment">// issue #579 toString() should never fail</span></span><br><span class="line">                <span class="comment">// throw an SQLException instead of a Runtime</span></span><br><span class="line">                checkConnection();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 其他的操作都交给realConnection执行</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(realConnection, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们来看看<strong>pushConnection</strong>做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pushConnection</span><span class="params">(PooledConnection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">        <span class="comment">// 从活跃连接池中移除连接</span></span><br><span class="line">        state.activeConnections.remove(conn);</span><br><span class="line">        <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">            <span class="comment">// 空闲连接集合未满</span></span><br><span class="line">            <span class="keyword">if</span> (state.idleConnections.size() &lt; poolMaximumIdleConnections</span><br><span class="line">                &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) &#123;</span><br><span class="line">                state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回滚未提交的事务</span></span><br><span class="line">                <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">                    conn.getRealConnection().rollback();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建新的 PooledConnection</span></span><br><span class="line">                PooledConnection newConn = <span class="keyword">new</span> PooledConnection(conn.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">                state.idleConnections.add(newConn);</span><br><span class="line">                <span class="comment">// 复用时间信息</span></span><br><span class="line">                newConn.setCreatedTimestamp(conn.getCreatedTimestamp());</span><br><span class="line">                newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将原连接置为无效状态</span></span><br><span class="line">                conn.invalidate();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通知等待的线程</span></span><br><span class="line">                state.notifyAll();</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 空闲连接集合已满</span></span><br><span class="line">                state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">                <span class="comment">// 回滚未提交的事务</span></span><br><span class="line">                <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">                    conn.getRealConnection().rollback();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 关闭数据库连接</span></span><br><span class="line">                conn.getRealConnection().close();</span><br><span class="line">                conn.invalidate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            state.badConnectionCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先将连接从活跃连接集合中移除，如果空闲集合未满，此时复用原连接的字段信息创建新的连接，并将其放入空闲集合中即可；若空闲集合已满，此时无需回收连接，直接关闭即可。</p>
<p>连接池总觉得很神秘，但仔细分析完其代码之后，也就没那么神秘了，就是将连接使用完之后放到一个集合中，下面再获取连接的时候首先从这个集合中获取。 还有PooledConnection的代理模式的使用，值得我们学习</p>
<p>好了，我们已经获取到了数据库连接，接下来要创建<strong>PrepareStatement</strong>了，我们上面JDBC的例子是怎么获取的？ <strong>psmt = conn.prepareStatement(sql);，直接通过Connection来获取，并且把sql传进去了</strong>，我们看看Mybaits中是怎么创建PrepareStatement的</p>
<h4 id="创建PreparedStatement"><a href="#创建PreparedStatement" class="headerlink" title="创建PreparedStatement"></a>创建PreparedStatement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PreparedStatementHandler</span></span><br><span class="line">stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement statement = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Statement</span></span><br><span class="line">        statement = instantiateStatement(connection);</span><br><span class="line">        <span class="comment">// 设置超时和 FetchSize</span></span><br><span class="line">        setStatementTimeout(statement, transactionTimeout);</span><br><span class="line">        setFetchSize(statement);</span><br><span class="line">        <span class="keyword">return</span> statement;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        closeStatement(statement);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        closeStatement(statement);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error preparing statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//获取sql字符串，比如&quot;select * from user where id= ?&quot;</span></span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    <span class="comment">// 根据条件调用不同的 prepareStatement 方法创建 PreparedStatement</span></span><br><span class="line">    <span class="keyword">if</span> (mappedStatement.getKeyGenerator() <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line">        String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">        <span class="keyword">if</span> (keyColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//通过connection获取Statement，将sql语句传进去</span></span><br><span class="line">            <span class="keyword">return</span> connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedStatement.getResultSetType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到没和jdbc的形式一模一样，我们具体来看看<strong>connection.prepareStatement</strong>做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql, <span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">boolean</span> canServerPrepare = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    String nativeSql = getProcessEscapeCodesForPrepStmts() ? nativeSQL(sql) : sql;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.useServerPreparedStmts &amp;&amp; getEmulateUnsupportedPstmts()) &#123;</span><br><span class="line">        canServerPrepare = canHandleAsServerPreparedStatement(nativeSql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.useServerPreparedStmts &amp;&amp; getEmulateUnsupportedPstmts()) &#123;</span><br><span class="line">        canServerPrepare = canHandleAsServerPreparedStatement(nativeSql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.useServerPreparedStmts &amp;&amp; canServerPrepare) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getCachePreparedStatements()) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这里使用的是ServerPreparedStatement创建PreparedStatement</span></span><br><span class="line">                pStmt = ServerPreparedStatement.getInstance(getMultiHostSafeProxy(), nativeSql, <span class="keyword">this</span>.database, resultSetType, resultSetConcurrency);</span><br><span class="line"></span><br><span class="line">                pStmt.setResultSetType(resultSetType);</span><br><span class="line">                pStmt.setResultSetConcurrency(resultSetConcurrency);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException sqlEx) &#123;</span><br><span class="line">                <span class="comment">// Punt, if necessary</span></span><br><span class="line">                <span class="keyword">if</span> (getEmulateUnsupportedPstmts()) &#123;</span><br><span class="line">                    pStmt = (PreparedStatement) clientPrepareStatement(nativeSql, resultSetType, resultSetConcurrency, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> sqlEx;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pStmt = (PreparedStatement) clientPrepareStatement(nativeSql, resultSetType, resultSetConcurrency, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只用看最关键的第21行代码，使用<strong>ServerPreparedStatement的getInstance返回一个</strong>PreparedStatement，其实本质上<strong>ServerPreparedStatement继承了PreparedStatement对象</strong>，我们看看其构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ServerPreparedStatement</span><span class="params">(ConnectionImpl conn, String sql, String catalog, <span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.serverPrepare(sql);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var10) &#123;</span><br><span class="line">        <span class="keyword">this</span>.realClose(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">throw</span> var10;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var11) &#123;</span><br><span class="line">        <span class="keyword">this</span>.realClose(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        SQLException sqlEx = SQLError.createSQLException(var11.toString(), <span class="string">&quot;S1000&quot;</span>, <span class="keyword">this</span>.getExceptionInterceptor());</span><br><span class="line">        sqlEx.initCause(var11);</span><br><span class="line">        <span class="keyword">throw</span> sqlEx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//略...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续调用this.serverPrepare(sql);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerPreparedStatement</span> <span class="keyword">extends</span> <span class="title">PreparedStatement</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存放运行时参数的数组</span></span><br><span class="line">    <span class="keyword">private</span> ServerPreparedStatement.BindValue[] parameterBindings;</span><br><span class="line">    <span class="comment">//服务器预编译好的sql语句返回的serverStatementId</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> serverStatementId;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serverPrepare</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.connection.getMutex()) &#123;</span><br><span class="line">            MysqlIO mysql = <span class="keyword">this</span>.connection.getIO();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//向sql服务器发送了一条PREPARE指令</span></span><br><span class="line">                Buffer prepareResultPacket = mysql.sendCommand(MysqlDefs.COM_PREPARE, sql, (Buffer)<span class="keyword">null</span>, <span class="keyword">false</span>, characterEncoding, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//记录下了预编译好的sql语句所对应的serverStatementId</span></span><br><span class="line">                <span class="keyword">this</span>.serverStatementId = prepareResultPacket.readLong();</span><br><span class="line">                <span class="keyword">this</span>.fieldCount = prepareResultPacket.readInt();</span><br><span class="line">                <span class="comment">//获取参数个数，比喻 select * from user where id= ？and name = ？，其中有两个？，则这里返回的参数个数应该为2</span></span><br><span class="line">                <span class="keyword">this</span>.parameterCount = prepareResultPacket.readInt();</span><br><span class="line">                <span class="keyword">this</span>.parameterBindings = <span class="keyword">new</span> ServerPreparedStatement.BindValue[<span class="keyword">this</span>.parameterCount];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.parameterCount; ++i) &#123;</span><br><span class="line">                    <span class="comment">//根据参数个数，初始化数组</span></span><br><span class="line">                    <span class="keyword">this</span>.parameterBindings[i] = <span class="keyword">new</span> ServerPreparedStatement.BindValue();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException var16) &#123;</span><br><span class="line">                <span class="keyword">throw</span> sqlEx;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.connection.getIO().clearInputStream();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServerPreparedStatement继承PreparedStatement，ServerPreparedStatement初始化的时候就向sql服务器发送了一条PREPARE指令，把SQL语句传到mysql服务器，如<code>select * from user where id= ？and name = ？</code>，mysql服务器会对sql进行编译，并保存在服务器，返回预编译语句对应的id，并保存在</p>
<p>ServerPreparedStatement中，同时创建BindValue[] parameterBindings数组，后面设置参数就直接添加到此数组中。好了，此时我们创建了一个ServerPreparedStatement并返回，下面就是设置运行时参数了</p>
<h4 id="设置运行时参数到-SQL-中"><a href="#设置运行时参数到-SQL-中" class="headerlink" title="设置运行时参数到 SQL 中"></a>设置运行时参数到 SQL 中</h4><p>我们已经获取到了PreparedStatement，接下来就是将运行时参数设置到PreparedStatement中，如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler.parameterize(stmt);</span><br></pre></td></tr></table></figure>

<p>JDBC是怎么设置的呢？我们看看上面的例子，很简单吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">psmt = conn.prepareStatement(sql);</span><br><span class="line">//设置参数</span><br><span class="line">psmt.setString(1, username);</span><br><span class="line">psmt.setString(2, password);</span><br></pre></td></tr></table></figure>

<p>我们来看看parameterize方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过参数处理器 ParameterHandler 设置运行时参数到 PreparedStatement 中</span></span><br><span class="line">    parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultParameterHandler</span> <span class="keyword">implements</span> <span class="title">ParameterHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MappedStatement mappedStatement;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object parameterObject;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BoundSql boundSql;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 从 BoundSql 中获取 ParameterMapping 列表，每个 ParameterMapping 与原始 SQL 中的 #&#123;xxx&#125; 占位符一一对应</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">        <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">                ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">                <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">                    Object value;</span><br><span class="line">                    <span class="comment">// 获取属性名</span></span><br><span class="line">                    String propertyName = parameterMapping.getProperty();</span><br><span class="line">                    <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">                        value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        value = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">                        value = parameterObject;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 为用户传入的参数 parameterObject 创建元信息对象</span></span><br><span class="line">                        MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">                        <span class="comment">// 从用户传入的参数中获取 propertyName 对应的值</span></span><br><span class="line">                        value = metaObject.getValue(propertyName);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">                    JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 由类型处理器 typeHandler 向 ParameterHandler 设置参数</span></span><br><span class="line">                        typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (TypeException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(...);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(...);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先从boundSql中获取parameterMappings 集合，这块大家可以看看我前面的文章，然后遍历获取 parameterMapping中的propertyName ，如#{name} 中的name,然后从运行时参数parameterObject中获取name对应的参数值，最后设置到PreparedStatement 中，我们主要来看是如何设置参数的。也就是</p>
<p>typeHandler.setParameter(ps, i + 1, value, jdbcType);，这句代码最终会向我们例子中一样执行，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, String parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ps.setString(i, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还记得我们的PreparedStatement是什么吗？是ServerPreparedStatement，那我们就来看看ServerPreparedStatement的setString方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setString</span><span class="params">(<span class="keyword">int</span> parameterIndex, String x)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.checkClosed();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setNull(parameterIndex, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//根据参数下标从parameterBindings数组总获取BindValue</span></span><br><span class="line">        ServerPreparedStatement.BindValue binding = <span class="keyword">this</span>.getBinding(parameterIndex, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">this</span>.setType(binding, <span class="keyword">this</span>.stringTypeCode);</span><br><span class="line">        <span class="comment">//设置参数值</span></span><br><span class="line">        binding.value = x;</span><br><span class="line">        binding.isNull = <span class="keyword">false</span>;</span><br><span class="line">        binding.isLongData = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> ServerPreparedStatement.<span class="function">BindValue <span class="title">getBinding</span><span class="params">(<span class="keyword">int</span> parameterIndex, <span class="keyword">boolean</span> forLongData)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.checkClosed();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parameterBindings.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> SQLError.createSQLException(Messages.getString(<span class="string">&quot;ServerPreparedStatement.8&quot;</span>), <span class="string">&quot;S1009&quot;</span>, <span class="keyword">this</span>.getExceptionInterceptor());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        --parameterIndex;</span><br><span class="line">        <span class="keyword">if</span> (parameterIndex &gt;= <span class="number">0</span> &amp;&amp; parameterIndex &lt; <span class="keyword">this</span>.parameterBindings.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.parameterBindings[parameterIndex] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.parameterBindings[parameterIndex] = <span class="keyword">new</span> ServerPreparedStatement.BindValue();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.parameterBindings[parameterIndex].isLongData &amp;&amp; !forLongData) &#123;</span><br><span class="line">                <span class="keyword">this</span>.detectedLongParameterSwitch = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.parameterBindings[parameterIndex].isSet = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.parameterBindings[parameterIndex].boundBeforeExecutionNum = (<span class="keyword">long</span>)<span class="keyword">this</span>.numberOfExecutions;</span><br><span class="line">            <span class="comment">//根据参数下标从parameterBindings数组总获取BindValue</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.parameterBindings[parameterIndex];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> SQLError.createSQLException(Messages.getString(<span class="string">&quot;ServerPreparedStatement.9&quot;</span>) + (parameterIndex + <span class="number">1</span>) + Messages.getString(<span class="string">&quot;ServerPreparedStatement.10&quot;</span>) + <span class="keyword">this</span>.parameterBindings.length, <span class="string">&quot;S1009&quot;</span>, <span class="keyword">this</span>.getExceptionInterceptor());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是根据参数下标从ServerPreparedStatement的参数数组parameterBindings中获取BindValue对象，然后设置值，好了现在ServerPreparedStatement包含了预编译SQL语句的Id和参数数组，最后一步便是执行SQL了。</p>
<h4 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h4><p>执行查询操作就是我们本节开头的最后一行代码，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return handler.&lt;E&gt;query(stmt, resultHandler);</span><br></pre></td></tr></table></figure>

<p>我们来看看query是怎么做的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement)statement;</span><br><span class="line">    <span class="comment">//直接执行ServerPreparedStatement的execute方法</span></span><br><span class="line">    ps.execute();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.checkClosed();</span><br><span class="line">    ConnectionImpl locallyScopedConn = <span class="keyword">this</span>.connection;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.checkReadOnlySafeStatement()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> SQLError.createSQLException(Messages.getString(<span class="string">&quot;PreparedStatement.20&quot;</span>) + Messages.getString(<span class="string">&quot;PreparedStatement.21&quot;</span>), <span class="string">&quot;S1009&quot;</span>, <span class="keyword">this</span>.getExceptionInterceptor());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ResultSetInternalMethods rs = <span class="keyword">null</span>;</span><br><span class="line">        CachedResultSetMetaData cachedMetadata = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(locallyScopedConn.getMutex()) &#123;</span><br><span class="line">            <span class="comment">//略....</span></span><br><span class="line">            rs = <span class="keyword">this</span>.executeInternal(rowLimit, sendPacket, doStreaming, <span class="keyword">this</span>.firstCharOfStmt == <span class="string">&#x27;S&#x27;</span>, metadataFromCache, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//略....</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rs != <span class="keyword">null</span> &amp;&amp; rs.reallyResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>省略了很多代码，只看最关键的<strong>executeInternal</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServerPreparedStatement</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ResultSetInternalMethods <span class="title">executeInternal</span><span class="params">(<span class="keyword">int</span> maxRowsToRetrieve, Buffer sendPacket, <span class="keyword">boolean</span> createStreamingResultSet, <span class="keyword">boolean</span> queryIsSelectOnly, Field[] metadataFromCache, <span class="keyword">boolean</span> isBatch)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.serverExecute(maxRowsToRetrieve, createStreamingResultSet, metadataFromCache);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var11) &#123;</span><br><span class="line">        <span class="keyword">throw</span> sqlEx;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ResultSetInternalMethods <span class="title">serverExecute</span><span class="params">(<span class="keyword">int</span> maxRowsToRetrieve, <span class="keyword">boolean</span> createStreamingResultSet, Field[] metadataFromCache)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.connection.getMutex()) &#123;</span><br><span class="line">        <span class="comment">//略....</span></span><br><span class="line">        MysqlIO mysql = <span class="keyword">this</span>.connection.getIO();</span><br><span class="line">        Buffer packet = mysql.getSharedSendPacket();</span><br><span class="line">        packet.clear();</span><br><span class="line">        packet.writeByte((<span class="keyword">byte</span>)MysqlDefs.COM_EXECUTE);</span><br><span class="line">        <span class="comment">//将该语句对应的id写入数据包</span></span><br><span class="line">        packet.writeLong(<span class="keyword">this</span>.serverStatementId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">//将对应的参数写入数据包</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.parameterCount; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.parameterBindings[i].isLongData) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.parameterBindings[i].isNull) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.storeBinding(packet, <span class="keyword">this</span>.parameterBindings[i], mysql);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nullBitsBuffer[i / <span class="number">8</span>] = (<span class="keyword">byte</span>)(nullBitsBuffer[i / <span class="number">8</span>] | <span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发送数据包,表示执行id对应的预编译sql</span></span><br><span class="line">        Buffer resultPacket = mysql.sendCommand(MysqlDefs.COM_EXECUTE, (String)<span class="keyword">null</span>, packet, <span class="keyword">false</span>, (String)<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//略....</span></span><br><span class="line">        ResultSetImpl rs = mysql.readAllResults(<span class="keyword">this</span>,  <span class="keyword">this</span>.resultSetType,  resultPacket, <span class="keyword">true</span>, (<span class="keyword">long</span>)<span class="keyword">this</span>.fieldCount, metadataFromCache);</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> rs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServerPreparedStatement在记录下serverStatementId后，对于相同SQL模板的操作，每次只是发送serverStatementId和对应的参数，省去了编译sql的过程。 至此我们的已经从数据库拿到了查询结果，但是结果是ResultSetImpl类型，我们还需要将返回结果转化成我们的java对象呢，留在下一篇来讲吧</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/12/01/Java-%E6%A1%86%E6%9E%B6-7-2-4-4/">https://pingxin0521.gitee.io/2019/12/01/Java-%E6%A1%86%E6%9E%B6-7-2-4-4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a><a class="post-meta__tags" href="/tags/DAO/">DAO</a><a class="post-meta__tags" href="/tags/Mybatis/">Mybatis</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/12/01/Java-%E6%A1%86%E6%9E%B6-7-2-4-5/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mybatis 源码分析 结果集 ResultSet 自动映射(五)</div></div></a></div><div class="next-post pull-right"><a href="/2019/11/30/Java-%E6%A1%86%E6%9E%B6-7-2-4-3/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mybatis 源码分析 SqlSession创建流程、Mapper接口底层原理(三)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/11/22/Java-框架-7-2-3-2/" title="Mybatis 插件原理"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">Mybatis 插件原理</div></div></a></div><div><a href="/2019/11/19/Java-框架-7-2-2-1/" title="MyBatis 的关联映射"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">MyBatis 的关联映射</div></div></a></div><div><a href="/2019/11/20/Java-框架-7-2-2-2/" title="Mybatis 动态SQL、批量操作"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">Mybatis 动态SQL、批量操作</div></div></a></div><div><a href="/2019/11/22/Java-框架-7-2-3-1/" title="Mybatis 常用插件框架"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">Mybatis 常用插件框架</div></div></a></div><div><a href="/2019/11/22/Java-框架-7-2-3-3/" title="Mybatis 插件 PageHelper源码分析"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">Mybatis 插件 PageHelper源码分析</div></div></a></div><div><a href="/2019/11/28/Java-框架-7-2-4-1/" title="Mybatis 源码分析 (一)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">Mybatis 源码分析 (一)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#selectOne-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">selectOne 方法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-BoundSql"><span class="toc-number">1.1.</span> <span class="toc-text">获取 BoundSql</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAStatementHandler"><span class="toc-number">1.2.</span> <span class="toc-text">创建StatementHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Statement"><span class="toc-number">1.3.</span> <span class="toc-text">创建 Statement</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Select-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">Select 语句的执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JdbcTransaction"><span class="toc-number">2.1.</span> <span class="toc-text">JdbcTransaction</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Transaction"><span class="toc-number">2.1.1.</span> <span class="toc-text">Transaction</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JdbcTransaction-1"><span class="toc-number">2.1.2.</span> <span class="toc-text">JdbcTransaction</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UnpooledDataSource"><span class="toc-number">2.2.</span> <span class="toc-text">UnpooledDataSource</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">初始化数据库驱动</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.3.</span> <span class="toc-text">获取数据库连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PooledDataSource"><span class="toc-number">2.4.</span> <span class="toc-text">PooledDataSource</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.4.1.</span> <span class="toc-text">辅助类介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.4.2.</span> <span class="toc-text">获取连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.4.3.</span> <span class="toc-text">回收连接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAPreparedStatement"><span class="toc-number">2.5.</span> <span class="toc-text">创建PreparedStatement</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0%E5%88%B0-SQL-%E4%B8%AD"><span class="toc-number">2.6.</span> <span class="toc-text">设置运行时参数到 SQL 中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.7.</span> <span class="toc-text">执行查询</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
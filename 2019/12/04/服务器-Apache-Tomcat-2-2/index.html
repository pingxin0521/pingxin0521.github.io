<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Apache Tomcat 源码分析 (二) | 平心de小屋</title><meta name="keywords" content="服务器,Tomcat"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Tomcat的启动流程">
<meta property="og:type" content="article">
<meta property="og:title" content="Apache Tomcat 源码分析 (二)">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/12/04/%E6%9C%8D%E5%8A%A1%E5%99%A8-Apache-Tomcat-2-2/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="Tomcat的启动流程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg">
<meta property="article:published_time" content="2019-12-04T03:18:59.000Z">
<meta property="article:modified_time" content="2020-05-31T10:47:38.433Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="服务器">
<meta property="article:tag" content="Tomcat">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/12/04/%E6%9C%8D%E5%8A%A1%E5%99%A8-Apache-Tomcat-2-2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Apache Tomcat 源码分析 (二)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-05-31 18:47:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Apache Tomcat 源码分析 (二)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-04T03:18:59.000Z" title="发表于 2019-12-04 11:18:59">2019-12-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-05-31T10:47:38.433Z" title="更新于 2020-05-31 18:47:38">2020-05-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/">Tomcat</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>67分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Apache Tomcat 源码分析 (二)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="Tomcat的启动流程"><a href="#Tomcat的启动流程" class="headerlink" title="Tomcat的启动流程"></a>Tomcat的启动流程</h3><span id="more"></span>

<p>基于Tomcat 8.5.55</p>
<p>tomcat的启动的起点是Server.start()方法，在这里它会依次启动<code>Container</code>和 <code>Connector</code>相关组件，最后到达EndPoint（Tomcat启动的Socket管理者），完成整个启动过程。如下图是个简易过程：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/29/luvoGQ.png" alt="luvoGQ.png"></p>
<h4 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h4><p><code>initClassLoaders()</code> 创建以下类加载器，一般catalinaLoader 和sharedLoader 都默认和 commonLoader 为同一个</p>
<ol>
<li><ul>
<li><code>commonLoader</code> 加载 catalina 相关顶层公用的类，默认扫描 <code>CATALINA_HOME</code>, <code>CATALINA_BASE</code> 下的class</li>
<li><code>catalinaLoader</code> 加载tomcat 应用相关的类</li>
<li><code>sharedLoader</code> 加载 Web 应用的类</li>
</ul>
</li>
</ol>
<p><code>catalinaLoader</code> 被设置为 ContextClassLoader</p>
<p>创建 <code>org.apache.catalina.startup.Catalina</code>。将 <code>Catalina.parentClassLoader</code> 设置为 <code>sharedLoader</code>。依次调用<code>Catalina.load()</code> 和 <code>Catalina.start()</code> 方法。</p>
<h4 id="初始化-Initialisation"><a href="#初始化-Initialisation" class="headerlink" title="初始化 Initialisation"></a>初始化 Initialisation</h4><h5 id="Catalina-load"><a href="#Catalina-load" class="headerlink" title="Catalina.load()"></a>Catalina.load()</h5><ol>
<li><p><code>Catalina.load()</code> 读取 conf/server.xml 中的配置作为 <code>Digester</code> 的输入。根据配置生成相应的 <code>Server</code>, <code>Listener</code>, <code>Service</code>, <code>Engine</code>, <code>Host</code>, <code>Context</code> 等及其内部相关组件(如<code>Valve</code>, <code>Listener</code>)。</p>
<p><code>Engine</code>, <code>Host</code>, <code>Context</code> 的配置读取逻辑被单独放在了<code>EngineRuleSet</code>, <code>HostRuleSet</code>, <code>ContextRuleSet</code> 中。<strong>特别需要关注伴随<code>Host</code>, <code>Context</code> 生成的<code>HostConfig</code>, <code>ContextConfig</code>。</strong>（<code>EngineConfig</code> 没有实际内容略去）这两个 Config class 会监听 Container 的生命时间，作出许多关键配置。</p>
</li>
<li><p><code>getServer().init()</code> 初始化 Server 组件</p>
</li>
</ol>
<h5 id="StandardServer-init"><a href="#StandardServer-init" class="headerlink" title="StandardServer.init()"></a>StandardServer.init()</h5><p><code>StandardServer.initInternal()</code> 遍历所有其 <code>services</code> 调用 <code>init()</code> 方法</p>
<h5 id="StandardService-init"><a href="#StandardService-init" class="headerlink" title="StandardService.init()"></a>StandardService.init()</h5><p><code>StandardService.initInternal()</code> 依次init 其管辖组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Engine.init()</span><br><span class="line">Executor.init()</span><br><span class="line">MapperListener.init()</span><br><span class="line">Connector.init()</span><br></pre></td></tr></table></figure>

<p>LifecycleBase 的 <code>start</code> 方法中，会检查若 state == NEW 则先 <code>init()</code>，Host, Context, Wrapper 均由此方法init</p>
<h5 id="Context-init"><a href="#Context-init" class="headerlink" title="Context.init()"></a>Context.init()</h5><p>ContextConfig 会监听 <code>AFTER_INIT_EVENT</code>, 并触发 <code>ContextConfig.init()</code></p>
<p>创建 <code>Digester</code> 依照 <code>ContextRuleSet</code> 读取配置文件并设置相应属性。</p>
<h4 id="启动-Start"><a href="#启动-Start" class="headerlink" title="启动 Start"></a>启动 Start</h4><h5 id="Catalina-start"><a href="#Catalina-start" class="headerlink" title="Catalina.start()"></a>Catalina.start()</h5><p><code>Catalina.start()</code> 调用 <code>Server.start()</code>。<code>StandardServer</code> 遍历 <code>services</code> 调用 <code>Service.start()</code></p>
<h5 id="Service-start"><a href="#Service-start" class="headerlink" title="Service.start()"></a>Service.start()</h5><p><code>Service.start()</code> 依次 start 其管辖组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Engine.start()Executor.start()MapperListener.start()Connector.start()</span><br></pre></td></tr></table></figure>

<h5 id="MapperListener"><a href="#MapperListener" class="headerlink" title="MapperListener"></a>MapperListener</h5><ol>
<li>循环向engine 及其child containers 注册自己为 listener, 以监听containers 的变动。</li>
<li>循环遍历 engine 及其child containers, 注册进 <code>Mapper</code> 里。</li>
</ol>
<h5 id="StandardThreadExecutor"><a href="#StandardThreadExecutor" class="headerlink" title="StandardThreadExecutor"></a>StandardThreadExecutor</h5><p>backed by a <code>ThreadPoolExecutor</code>, with default minSpareThreads = 25, maxThreads = 200. maxQueueSize = Integer.MAX_VALUE</p>
<p>生成对应的ThreadPoolExecutor.</p>
<h5 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h5><p>Tomcat的Connector是Coyote connector的一种实现，这是tomcat的官方解释：The Coyote HTTP/1.1 Connector element represents a Connector component that supports the HTTP/1.1 protocol. It enables Catalina to function as a stand-alone web server, in addition to its ability to execute servlets and JSP pages.<br> Tomcat8之后默认使用nio作为接受请求策略，默认在Service启动的时候进行初始化，当然也可以单独启动，在默认的构造函数中会初始化ProtocolHandler</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/29/luxpRJ.png" alt="luxpRJ.png"></p>
<p>tomcat中支持两种协议的连接器：HTTP/1.1与AJP/1.3</p>
<p>HTTP/1.1协议负责建立HTTP连接，web应用通过浏览器访问tomcat服务器用的就是这个连接器，默认监听的是8080端口；现在高版本也支持http2</p>
<p>AJP/1.3协议负责和其他HTTP服务器建立连接，监听的是8009端口，比如tomcat和apache或者iis集成时需要用到这个连接器。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/29/luxEdK.png" alt="luxEdK.png"></p>
<p><strong><code>Connector</code>的启动其实就是<code>ProtocolHandler</code>的启动</strong>，如下图：</p>
<h4 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h4><p><code>ContainerBase.startInternal()</code> 依次执行</p>
<ol>
<li>向<code>startStopExecutor</code> 提交 <code>start()</code> 所有子container的任务并等待完成。（<code>startStopExecutor</code> 就是一个普通的线程池）。</li>
<li>start pipeline</li>
<li>在deamon线程上start <code>ContainerBackgroundProcessor</code> ，会定期遍历调用自己和子类的 <code>backgroundProcess()</code> 方法。</li>
</ol>
<h4 id="HostConfig"><a href="#HostConfig" class="headerlink" title="HostConfig"></a>HostConfig</h4><p>监听了Host 生命周期事件，实现了Context 的动态部署。</p>
<ul>
<li><p>监听 Host 的 <code>START_EVENT</code> 事件<br>若设置了 deployOnStartup （默认为true），则会执行 <code>deployApps()</code></p>
</li>
<li><p>监听 Host <code>PERIODIC_EVENT</code> 事件<br>如果设置了 <code>autoDeploy</code> （默认为true)，则会检查文件更新并执行 <code>deployApps()</code></p>
</li>
<li><ol>
<li>检查加载的Application 是否有更新（通过文件的lastModified 来检查）</li>
<li>检查是否存在旧版本的Application 可以 undeploy，是则undeploy</li>
<li>调用 <code>deployApps()</code> 尝试搜索及deploy 新的 application。</li>
</ol>
</li>
</ul>
<h5 id="deployApps"><a href="#deployApps" class="headerlink" title="deployApps()"></a>deployApps()</h5><p>依次</p>
<ul>
<li>执行<code>deployDescriptors()</code> 搜索 <code>$CATALINA_BASE/&#123;engine_name&#125;/&#123;host_name&#125;</code> 下的 xml 文件作为context config 进行部署</li>
<li>执行<code>deployWARs()</code> 搜索部署 <code>appbase</code> 下的所有 war</li>
<li>执行<code>deployDirectories()</code> 搜索部署 <code>appbase</code> 下的所有目录</li>
</ul>
<p><code>deployWARs()</code>和<code>deployDirectories()</code>会以目录下的<code>META-INF/context.xml</code> 作为context的配置，<code>deployDescriptors()</code>以 <code>$CATALINA_BASE/&#123;engine_name&#125;/&#123;host_name&#125;/*.xml</code> 作为配置，生成对应的 <code>StandardContext</code>, 并调用 <code>addChild()</code> 方法，添加到当前host。<br>值得一提的是<code>addChild()</code>的过程中会 start 子容器，而start 方法中会检查容器状态，适时 <code>init()</code> 容器。如此完成Context 的动态加载。</p>
<h4 id="Context-start"><a href="#Context-start" class="headerlink" title="Context.start()"></a>Context.start()</h4><p>简要列举<code>Context.start()</code> 的步骤</p>
<ol>
<li>start WebResourceRoot</li>
<li><code>new WebappLoader(getParentClassLoader())</code> 生成 WebappLoader。</li>
<li>start WebappLoader, 创建webapp 级别的classloader <code>ParallelWebappClassLoader</code></li>
<li>设置 <code>ParallelWebappClassLoader</code> 为当前 ContextClassLoader</li>
<li>发出 <code>CONFIGURE_START_EVENT</code> 事件。</li>
<li>start child container 和 pipeline</li>
<li>调用<code>initializers</code>里所有 <code>ServletContainerInitializer</code> 的 <code>onStartup</code> 方法</li>
<li><code>listenerStart()</code></li>
<li><code>filterStart()</code></li>
<li><code>loadOnStartup(findChildren())</code> 实例化并init 所有 load on startup 的servlet</li>
<li>将 ContextClassLoader 设置回去</li>
</ol>
<h4 id="ContextConfig-configureStart"><a href="#ContextConfig-configureStart" class="headerlink" title="ContextConfig.configureStart()"></a>ContextConfig.configureStart()</h4><p>ContextConfig 监听 <code>CONFIGURE_START_EVENT</code>，调用<code>configureStart()</code>以对Context 进行配置。<code>configureStart()</code> 调用 <code>webConfig()</code> 完成配置</p>
<ol>
<li>解析global, host level 的web-fragments</li>
<li><code>processServletContainerInitializers()</code> 搜索所有的 <code>ServletContainerInitializers</code>。这里使用了 <code>ClassLoader.getResources()</code> 来搜索所有的 <code>META-INF/services/javax.servlet.ServletContainerInitializer</code> 资源</li>
<li>把web-fragments merge 进web.xml 配置里</li>
<li><code>configureContext()</code> 利用merge 完的配置再次配置 Context。</li>
<li>将web-fragment 相关的 META-INF/resource 添加进当前 Context</li>
<li>把之前搜索到的<code>ServletContainerInitializer</code> 添加到 Context.</li>
</ol>
<h3 id="Http请求处理过程"><a href="#Http请求处理过程" class="headerlink" title="Http请求处理过程"></a>Http请求处理过程</h3><p>终于进行到<code>Connector</code>的分析阶段了，这也是Tomcat里面最复杂的一块功能了。<code>Connector</code>中文名为<code>连接器</code>，既然是连接器，它肯定会连接某些东西，连接些什么呢？</p>
<blockquote>
<p><code>Connector</code>用于接受请求并将请求封装成Request和Response，然后交给<code>Container</code>进行处理，<code>Container</code>处理完之后再交给<code>Connector</code>返回给客户端。</p>
</blockquote>
<p>要理解<code>Connector</code>，我们需要问自己4个问题。</p>
<ol>
<li>Connector如何接受请求的？</li>
<li>如何将请求封装成Request和Response的？</li>
<li>封装完之后的Request和Response如何交给Container进行处理的？</li>
<li>Container处理完之后如何交给Connector并返回给客户端的？</li>
</ol>
<p>先来一张<code>Connector</code>的整体结构图</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/29/lnt5Pf.png" alt="lnt5Pf.png"></p>
<p>【注意】：不同的协议、不同的通信方式，<code>ProtocolHandler</code>会有不同的实现。在Tomcat 9.0.29中，<code>ProtocolHandler</code>的类继承层级如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/12/29/lKC156.png" alt="lKC156.png"></p>
<p>针对上述的类继承层级图，我们做如下说明：</p>
<ol>
<li>ajp和http11是两种不同的协议</li>
<li>nio、nio2和apr是不同的通信方式</li>
<li>协议和通信方式可以相互组合。</li>
</ol>
<p><code>ProtocolHandler</code>包含三个部件：<code>Endpoint</code>、<code>Processor</code>、<code>Adapter</code>。</p>
<ol>
<li><code>Endpoint</code>用来处理底层Socket的网络连接，<code>Processor</code>用于将<code>Endpoint</code>接收到的Socket封装成Request，<code>Adapter</code>用于将Request交给Container进行具体的处理。</li>
<li><code>Endpoint</code>由于是处理底层的Socket网络连接，因此<code>Endpoint</code>是用来实现<code>TCP/IP协议</code>的，而<code>Processor</code>用来实现<code>HTTP协议</code>的，<code>Adapter</code>将请求适配到Servlet容器进行具体的处理。</li>
<li><code>Endpoint</code>的抽象实现类AbstractEndpoint里面定义了<code>Acceptor</code>和<code>AsyncTimeout</code>两个内部类和一个<code>Handler接口</code>。<code>Acceptor</code>用于监听请求，<code>AsyncTimeout</code>用于检查异步Request的超时，<code>Handler</code>用于处理接收到的Socket，在内部调用<code>Processor</code>进行处理。</li>
</ol>
<p>至此，我们已经明白了问题（1）、（2）和（3）。至于（4），当我们了解了Container自然就明白了</p>
<h4 id="Connector源码分析入口"><a href="#Connector源码分析入口" class="headerlink" title="Connector源码分析入口"></a>Connector源码分析入口</h4><p> 我们在<code>Service</code>标准实现<code>StandardService</code>的源码中发现，其<code>init()</code>、<code>start()</code>、<code>stop()</code>和<code>destroy()</code>方法分别会对Connectors的同名方法进行调用。而一个<code>Service</code>对应着多个<code>Connector</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Service.init()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">        engine.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize any Executors</span></span><br><span class="line">    <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">            ((JmxEnabled) executor).setDomain(getDomain());</span><br><span class="line">        &#125;</span><br><span class="line">        executor.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize mapper listener</span></span><br><span class="line">    mapperListener.init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize our defined Connectors</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connector.init();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                String message = sm.getString(</span><br><span class="line">                        <span class="string">&quot;standardService.connector.initFailed&quot;</span>, connector);</span><br><span class="line">                log.error(message, e);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>))</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Service.start()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled())</span><br><span class="line">        log.info(sm.getString(<span class="string">&quot;standardService.start.name&quot;</span>, <span class="keyword">this</span>.name));</span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start our defined Container first</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (engine) &#123;</span><br><span class="line">            engine.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (executors) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Executor executor: executors) &#123;</span><br><span class="line">            executor.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapperListener.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start our defined Connectors second</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Connector connector: connectors) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// If it has already failed, don&#x27;t try and start it</span></span><br><span class="line">                <span class="keyword">if</span> (connector.getState() != LifecycleState.FAILED) &#123;</span><br><span class="line">                    connector.start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(sm.getString(</span><br><span class="line">                        <span class="string">&quot;standardService.connector.startFailed&quot;</span>,</span><br><span class="line">                        connector), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们知道<code>Connector</code>实现了<code>Lifecycle</code>接口，所以它是一个<code>生命周期组件</code>。所以<code>Connector</code>的启动逻辑入口在于<code>init()</code>和<code>start()</code>。</p>
<h5 id="Connector构造方法"><a href="#Connector构造方法" class="headerlink" title="Connector构造方法"></a>Connector构造方法</h5><p>在分析之前，我们看看<code>server.xml</code>，该文件已经体现出了tomcat中各个组件的大体结构。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">&quot;8005&quot;</span> <span class="attr">shutdown</span>=<span class="string">&quot;SHUTDOWN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.startup.VersionLoggerListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.AprLifecycleListener&quot;</span> <span class="attr">SSLEngine</span>=<span class="string">&quot;on&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">&quot;UserDatabase&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">&quot;org.apache.catalina.UserDatabase&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">&quot;User database that can be updated and saved&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">&quot;conf/tomcat-users.xml&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8009&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;AJP/1.3&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.LockOutRealm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">resourceName</span>=<span class="string">&quot;UserDatabase&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;logs&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">&quot;localhost_access_log&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;.txt&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">&quot;%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个文件中，我们看到一个<code>Connector</code>有几个关键属性，<code>port</code>和<code>protocol</code>是其中的两个。<code>server.xml</code>默认支持两种协议：<code>HTTP/1.1</code>和<code>AJP/1.3</code>。其中<code>HTTP/1.1</code>用于支持http1.1协议，而<code>AJP/1.3</code>用于支持对apache服务器的通信。</p>
<p>接下来我们看看构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Connector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>); <span class="comment">// 1. 无参构造方法，传入参数为空协议，会默认使用`HTTP/1.1`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Connector</span><span class="params">(String protocol)</span> </span>&#123;</span><br><span class="line">    setProtocol(protocol);</span><br><span class="line">    <span class="comment">// Instantiate protocol handler</span></span><br><span class="line">    <span class="comment">// 5. 使用protocolHandler的类名构造ProtocolHandler的实例</span></span><br><span class="line">    ProtocolHandler p = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(protocolHandlerClassName);</span><br><span class="line">        p = (ProtocolHandler) clazz.getConstructor().newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(sm.getString(</span><br><span class="line">                <span class="string">&quot;coyoteConnector.protocolHandlerInstantiationFailed&quot;</span>), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.protocolHandler = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Globals.STRICT_SERVLET_COMPLIANCE) &#123;</span><br><span class="line">        uriCharset = StandardCharsets.ISO_8859_1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        uriCharset = StandardCharsets.UTF_8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProtocol</span><span class="params">(String protocol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> aprConnector = AprLifecycleListener.isAprAvailable() &amp;&amp;</span><br><span class="line">            AprLifecycleListener.getUseAprConnector();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. `HTTP/1.1`或`null`，protocolHandler使用`org.apache.coyote.http11.Http11NioProtocol`，不考虑apr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;HTTP/1.1&quot;</span>.equals(protocol) || protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aprConnector) &#123;</span><br><span class="line">            setProtocolHandlerClassName(<span class="string">&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setProtocolHandlerClassName(<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. `AJP/1.3`，protocolHandler使用`org.apache.coyote.ajp.AjpNioProtocol`，不考虑apr</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;AJP/1.3&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aprConnector) &#123;</span><br><span class="line">            setProtocolHandlerClassName(<span class="string">&quot;org.apache.coyote.ajp.AjpAprProtocol&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setProtocolHandlerClassName(<span class="string">&quot;org.apache.coyote.ajp.AjpNioProtocol&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 其他情况，使用传入的protocol作为protocolHandler的类名</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        setProtocolHandlerClassName(protocol);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码我们看到构造方法主要做了下面几件事情：</p>
<ol>
<li>无参构造方法，传入参数为空协议，会默认使用<code>HTTP/1.1</code></li>
<li><code>HTTP/1.1</code>或<code>null</code>，protocolHandler使用<code>org.apache.coyote.http11.Http11NioProtocol</code>，不考虑apr</li>
<li><code>AJP/1.3</code>，protocolHandler使用<code>org.apache.coyote.ajp.AjpNioProtocol</code>，不考虑apr</li>
<li>其他情况，使用传入的protocol作为protocolHandler的类名</li>
<li>使用protocolHandler的类名构造ProtocolHandler的实例</li>
</ol>
<h5 id="Connector-init"><a href="#Connector-init" class="headerlink" title="Connector.init()"></a>Connector.init()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize adapter</span></span><br><span class="line">    <span class="comment">// 1. 初始化adapter</span></span><br><span class="line">    adapter = <span class="keyword">new</span> CoyoteAdapter(<span class="keyword">this</span>);</span><br><span class="line">    protocolHandler.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure parseBodyMethodsSet has a default</span></span><br><span class="line">    <span class="comment">// 2. 设置接受body的method列表，默认为POST</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == parseBodyMethodsSet) &#123;</span><br><span class="line">        setParseBodyMethods(getParseBodyMethods());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isAprAvailable()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerNoApr&quot;</span>,</span><br><span class="line">                getProtocolHandlerClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (AprLifecycleListener.isAprAvailable() &amp;&amp; AprLifecycleListener.getUseOpenSSL() &amp;&amp;</span><br><span class="line">            protocolHandler <span class="keyword">instanceof</span> AbstractHttp11JsseProtocol) &#123;</span><br><span class="line">        AbstractHttp11JsseProtocol&lt;?&gt; jsseProtocolHandler =</span><br><span class="line">                (AbstractHttp11JsseProtocol&lt;?&gt;) protocolHandler;</span><br><span class="line">        <span class="keyword">if</span> (jsseProtocolHandler.isSSLEnabled() &amp;&amp;</span><br><span class="line">                jsseProtocolHandler.getSslImplementationName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// OpenSSL is compatible with the JSSE configuration, so use it if APR is available</span></span><br><span class="line">            jsseProtocolHandler.setSslImplementationName(OpenSSLImplementation.class.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 初始化protocolHandler</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        protocolHandler.init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerInitializationFailed&quot;</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>init()</code>方法做了3件事情</p>
<ol>
<li>初始化adapter</li>
<li>设置接受body的method列表，默认为POST</li>
<li>初始化protocolHandler</li>
</ol>
<p>从<code>ProtocolHandler类继承层级</code>我们知道<code>ProtocolHandler</code>的子类都必须实现<code>AbstractProtocol</code>抽象类，而<code>protocolHandler.init();</code>的逻辑代码正是在这个抽象类里面。我们来分析一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getLog().isInfoEnabled()) &#123;</span><br><span class="line">        getLog().info(sm.getString(<span class="string">&quot;abstractProtocolHandler.init&quot;</span>, getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oname == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Component not pre-registered so register it</span></span><br><span class="line">        oname = createObjectName();</span><br><span class="line">        <span class="keyword">if</span> (oname != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">        rgOname = <span class="keyword">new</span> ObjectName(domain + <span class="string">&quot;:type=GlobalRequestProcessor,name=&quot;</span> + getName());</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(</span><br><span class="line">                getHandler().getGlobal(), rgOname, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 设置endpoint的名字，默认为：http-nio-&#123;port&#125;</span></span><br><span class="line">    String endpointName = getName();</span><br><span class="line">    endpoint.setName(endpointName.substring(<span class="number">1</span>, endpointName.length()-<span class="number">1</span>));</span><br><span class="line">    endpoint.setDomain(domain);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 初始化endpoint</span></span><br><span class="line">    endpoint.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着分析一下<code>Endpoint.init()</code>里面又做了什么。该方法位于<code>AbstactEndpoint</code>抽象类，该类是基于模板方法模式实现的，主要调用了子类的<code>bind()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stopInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 执行bind()方法</span></span><br><span class="line">    <span class="keyword">if</span> (bindOnInit) &#123;</span><br><span class="line">        bind();</span><br><span class="line">        bindState = BindState.BOUND_ON_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Register endpoint (as ThreadPool - historical name)</span></span><br><span class="line">        oname = <span class="keyword">new</span> ObjectName(domain + <span class="string">&quot;:type=ThreadPool,name=\&quot;&quot;</span> + getName() + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        ObjectName socketPropertiesOname = <span class="keyword">new</span> ObjectName(domain +</span><br><span class="line">                <span class="string">&quot;:type=ThreadPool,name=\&quot;&quot;</span> + getName() + <span class="string">&quot;\&quot;,subType=SocketProperties&quot;</span>);</span><br><span class="line">        socketProperties.setObjectName(socketPropertiesOname);</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(socketProperties, socketPropertiesOname, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (SSLHostConfig sslHostConfig : findSslHostConfigs()) &#123;</span><br><span class="line">            registerJmx(sslHostConfig);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续分析<code>bind()</code>方法，我们终于看到了我们想要看的东西了。关键的代码在于<code>serverSock.socket().bind(addr,getAcceptCount());</code>，用于绑定<code>ServerSocket</code>到指定的IP和端口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!getUseInheritedChannel()) &#123;</span><br><span class="line">        serverSock = ServerSocketChannel.open();</span><br><span class="line">        socketProperties.setProperties(serverSock.socket());</span><br><span class="line">        InetSocketAddress addr = (getAddress()!=<span class="keyword">null</span>?<span class="keyword">new</span> InetSocketAddress(getAddress(),getPort()):<span class="keyword">new</span> InetSocketAddress(getPort()));</span><br><span class="line">        <span class="comment">//绑定ServerSocket到指定的IP和端口</span></span><br><span class="line">        serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Retrieve the channel provided by the OS</span></span><br><span class="line">        Channel ic = System.inheritedChannel();</span><br><span class="line">        <span class="keyword">if</span> (ic <span class="keyword">instanceof</span> ServerSocketChannel) &#123;</span><br><span class="line">            serverSock = (ServerSocketChannel) ic;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (serverSock == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(sm.getString(<span class="string">&quot;endpoint.init.bind.inherited&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize thread count defaults for acceptor, poller</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> Doesn&#x27;t seem to work that well with multiple accept threads</span></span><br><span class="line">        acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//minimum one poller thread</span></span><br><span class="line">        pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setStopLatch(<span class="keyword">new</span> CountDownLatch(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    selectorPool.open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，我们已经分析完了<code>init()</code>方法，接下来我们分析<code>start()</code>方法。关键代码就一行，调用<code>ProtocolHandler.start()</code>方法。</p>
<h5 id="Connector-start"><a href="#Connector-start" class="headerlink" title="Connector.start()"></a>Connector.start()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate settings before starting</span></span><br><span class="line">    <span class="keyword">if</span> (getPort() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(</span><br><span class="line">                <span class="string">&quot;coyoteConnector.invalidPort&quot;</span>, Integer.valueOf(getPort())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        protocolHandler.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerStartFailed&quot;</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们深入<code>ProtocolHandler.start()</code>方法。</p>
<ol>
<li>调用<code>Endpoint.start()</code>方法</li>
<li>开启异步超时线程，线程执行单元为<code>Asynctimeout</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getLog().isInfoEnabled()) &#123;</span><br><span class="line">        getLog().info(sm.getString(<span class="string">&quot;abstractProtocolHandler.start&quot;</span>, getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 调用`Endpoint.start()`方法</span></span><br><span class="line">    endpoint.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start async timeout thread</span></span><br><span class="line">    <span class="comment">// 2. 开启异步超时线程，线程执行单元为`Asynctimeout`</span></span><br><span class="line">    asyncTimeout = <span class="keyword">new</span> AsyncTimeout();</span><br><span class="line">    Thread timeoutThread = <span class="keyword">new</span> Thread(asyncTimeout, getNameInternal() + <span class="string">&quot;-AsyncTimeout&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> priority = endpoint.getThreadPriority();</span><br><span class="line">    <span class="keyword">if</span> (priority &lt; Thread.MIN_PRIORITY || priority &gt; Thread.MAX_PRIORITY) &#123;</span><br><span class="line">        priority = Thread.NORM_PRIORITY;</span><br><span class="line">    &#125;</span><br><span class="line">    timeoutThread.setPriority(priority);</span><br><span class="line">    timeoutThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    timeoutThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这儿我们重点关注<code>Endpoint.start()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1. `bind()`已经在`init()`中分析过了</span></span><br><span class="line">    <span class="keyword">if</span> (bindState == BindState.UNBOUND) &#123;</span><br><span class="line">        bind();</span><br><span class="line">        bindState = BindState.BOUND_ON_START;</span><br><span class="line">    &#125;</span><br><span class="line">    startInternal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">        running = <span class="keyword">true</span>;</span><br><span class="line">        paused = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        processorCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                socketProperties.getProcessorCache());</span><br><span class="line">        eventCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                        socketProperties.getEventCache());</span><br><span class="line">        nioChannels = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create worker collection</span></span><br><span class="line">        <span class="comment">// 2. 创建工作者线程池</span></span><br><span class="line">        <span class="keyword">if</span> ( getExecutor() == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            createExecutor();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 初始化连接latch，用于限制请求的并发量</span></span><br><span class="line">        initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start poller threads</span></span><br><span class="line">        <span class="comment">// 4. 开启poller线程。poller用于对接受者线程生产的消息（或事件）进行处理，poller最终调用的是Handler的代码</span></span><br><span class="line">        pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">            pollers[i] = <span class="keyword">new</span> Poller();</span><br><span class="line">            Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">&quot;-ClientPoller-&quot;</span>+i);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            pollerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 开启acceptor线程</span></span><br><span class="line">        startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startAcceptorThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getAcceptorThreadCount();</span><br><span class="line">    acceptors = <span class="keyword">new</span> Acceptor[count];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        acceptors[i] = createAcceptor();</span><br><span class="line">        String threadName = getName() + <span class="string">&quot;-Acceptor-&quot;</span> + i;</span><br><span class="line">        acceptors[i].setThreadName(threadName);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(acceptors[i], threadName);</span><br><span class="line">        t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">        t.setDaemon(getDaemon());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>bind()</code>已经在<code>init()</code>中分析过了</li>
<li>创建工作者线程池</li>
<li>初始化连接latch，用于限制请求的并发量</li>
<li>创建轮询Poller线程。poller用于对接受者线程生产的消息（或事件）进行处理，poller最终调用的是Handler的代码</li>
<li>创建Acceptor线程</li>
</ol>
<h4 id="Connector请求逻辑"><a href="#Connector请求逻辑" class="headerlink" title="Connector请求逻辑"></a>Connector请求逻辑</h4><p>分析完了<code>Connector</code>的启动逻辑之后，我们就需要进一步分析一下http的请求逻辑，当请求从客户端发起之后，需要经过哪些操作才能真正地得到执行？</p>
<h4 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h4><p>Acceptor线程主要用于监听套接字，将已连接套接字转给Poller线程。Acceptor线程数由AbstracEndPoint的acceptorThreadCount成员变量控制，默认值为1</p>
<p>AbstractEndpoint.Acceptor是AbstractEndpoint类的静态抽象类，实现了Runnable接口，部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">AcceptorState</span> </span>&#123;</span><br><span class="line">        NEW, RUNNING, PAUSED, ENDED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> AcceptorState state = AcceptorState.NEW;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AcceptorState <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setThreadName</span><span class="params">(<span class="keyword">final</span> String threadName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName = threadName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> String <span class="title">getThreadName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NioEndpoint的Acceptor成员内部类继承了AbstractEndpoint.Acceptor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span>.<span class="title">Acceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> errorDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Loop until we receive a shutdown command</span></span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Loop if endpoint is paused</span></span><br><span class="line">            <span class="comment">// 1. 运行过程中，如果`Endpoint`暂停了，则`Acceptor`进行自旋（间隔50毫秒） `       </span></span><br><span class="line">            <span class="keyword">while</span> (paused &amp;&amp; running) &#123;</span><br><span class="line">                state = AcceptorState.PAUSED;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// Ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 如果`Endpoint`终止运行了，则`Acceptor`也会终止</span></span><br><span class="line">            <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            state = AcceptorState.RUNNING;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//if we have reached max connections, wait</span></span><br><span class="line">                <span class="comment">// 3. 如果请求达到了最大连接数，则wait直到连接数降下来</span></span><br><span class="line">                countUpOrAwaitConnection();</span><br><span class="line"></span><br><span class="line">                SocketChannel socket = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Accept the next incoming connection from the server</span></span><br><span class="line">                    <span class="comment">// socket</span></span><br><span class="line">                    <span class="comment">// 4. 接受下一次连接的socket</span></span><br><span class="line">                    socket = serverSock.accept();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    <span class="comment">// We didn&#x27;t get a socket</span></span><br><span class="line">                    countDownConnection();</span><br><span class="line">                    <span class="keyword">if</span> (running) &#123;</span><br><span class="line">                        <span class="comment">// Introduce delay if necessary</span></span><br><span class="line">                        errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">                        <span class="comment">// re-throw</span></span><br><span class="line">                        <span class="keyword">throw</span> ioe;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Successful accept, reset the error delay</span></span><br><span class="line">                errorDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Configure the socket</span></span><br><span class="line">                <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</span><br><span class="line">                    <span class="comment">// setSocketOptions() will hand the socket off to</span></span><br><span class="line">                    <span class="comment">// an appropriate processor if successful</span></span><br><span class="line">                    <span class="comment">// 5. `setSocketOptions()`这儿是关键，会将socket以事件的方式传递给poller</span></span><br><span class="line">                    <span class="keyword">if</span> (!setSocketOptions(socket)) &#123;</span><br><span class="line">                        closeSocket(socket);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    closeSocket(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                ExceptionUtils.handleThrowable(t);</span><br><span class="line">                log.error(sm.getString(<span class="string">&quot;endpoint.accept.fail&quot;</span>), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        state = AcceptorState.ENDED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上代码可以看到：</p>
<ul>
<li>countUpOrAwaitConnection函数检查当前最大连接数，若未达到maxConnections则加一，否则等待；</li>
<li>socket = serverSock.accept()这一行中的serverSock正是NioEndpoint的bind函数中打开的ServerSocketChannel。为了引用这个变量，NioEndpoint的Acceptor类是成员而不再是静态类；</li>
<li>setSocketOptions函数调用上的注释表明该函数将已连接套接字交给Poller线程处理。</li>
</ul>
<p>setSocketOptions方法接着处理已连接套接字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setSocketOptions</span><span class="params">(SocketChannel socket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Process the connection</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//disable blocking, APR style, we are gonna be polling it</span></span><br><span class="line">        socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Socket sock = socket.socket();</span><br><span class="line">        socketProperties.setProperties(sock);</span><br><span class="line"></span><br><span class="line">        NioChannel channel = nioChannels.pop();</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            SocketBufferHandler bufhandler = <span class="keyword">new</span> SocketBufferHandler(</span><br><span class="line">                    socketProperties.getAppReadBufSize(),</span><br><span class="line">                    socketProperties.getAppWriteBufSize(),</span><br><span class="line">                    socketProperties.getDirectBuffer());</span><br><span class="line">            <span class="keyword">if</span> (isSSLEnabled()) &#123;</span><br><span class="line">                channel = <span class="keyword">new</span> SecureNioChannel(socket, bufhandler, selectorPool, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel = <span class="keyword">new</span> NioChannel(socket, bufhandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.setIOChannel(socket);</span><br><span class="line">            channel.reset();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将channel注册到poller，注意关键的两个方法，`getPoller0()`和`Poller.register()`</span></span><br><span class="line">        getPoller0().register(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&quot;</span>,t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable tt) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(tt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Tell to close the socket</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从NioChannel栈中出栈一个，若能重用（即不为null）则重用对象，否则新建一个NioChannel对象；</li>
<li>getPoller0方法利用轮转法选择一个Poller线程，利用Poller类的register方法将上述NioChannel对象注册到该Poller线程上；</li>
<li>若成功转给Poller线程该函数返回true，否则返回false。返回false后，Acceptor类的closeSocket函数会关闭通道和底层Socket连接并将当前最大连接数减一。</li>
</ul>
<h5 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h5><p>Poller线程主要用于以较少的资源轮询已连接套接字以保持连接，当数据可用时转给工作线程。</p>
<p>Poller线程数由NioEndPoint的pollerThreadCount成员变量控制，默认值为2与可用处理器数二者之间的较小值。<br>Poller实现了Runnable接口，可以看到构造函数为每个Poller打开了一个新的Selector。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SynchronizedQueue&lt;PollerEvent&gt; events =</span><br><span class="line">            <span class="keyword">new</span> SynchronizedQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">// 省略一些代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Poller</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Selector <span class="title">getSelector</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> selector;&#125;</span><br><span class="line">    <span class="comment">// 省略一些代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将channel注册到poller，注意关键的两个方法，<code>getPoller0()</code>和<code>Poller.register()</code>。先来分析一下<code>getPoller0()</code>，该方法比较关键的一个地方就是<code>以取模的方式</code>对poller数量进行轮询获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The socket poller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Poller[] pollers = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> AtomicInteger pollerRotater = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an available poller in true round robin fashion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The next poller in sequence</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Poller <span class="title">getPoller0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = Math.abs(pollerRotater.incrementAndGet()) % pollers.length;</span><br><span class="line">    <span class="keyword">return</span> pollers[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们分析一下<code>Poller.register()</code>方法。因为<code>Poller</code>维持了一个<code>events同步队列</code>，所以<code>Acceptor</code>接受到的channel会放在这个队列里面，放置的代码为<code>events.offer(event);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SynchronizedQueue&lt;PollerEvent&gt; events = <span class="keyword">new</span> SynchronizedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers a newly created socket with the poller.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socket    The newly created socket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> NioChannel socket)</span> </span>&#123;</span><br><span class="line">        socket.setPoller(<span class="keyword">this</span>);</span><br><span class="line">        NioSocketWrapper ka = <span class="keyword">new</span> NioSocketWrapper(socket, NioEndpoint.<span class="keyword">this</span>);</span><br><span class="line">        socket.setSocketWrapper(ka);</span><br><span class="line">        ka.setPoller(<span class="keyword">this</span>);</span><br><span class="line">        ka.setReadTimeout(getSocketProperties().getSoTimeout());</span><br><span class="line">        ka.setWriteTimeout(getSocketProperties().getSoTimeout());</span><br><span class="line">        ka.setKeepAliveLeft(NioEndpoint.<span class="keyword">this</span>.getMaxKeepAliveRequests());</span><br><span class="line">        ka.setSecure(isSSLEnabled());</span><br><span class="line">        ka.setReadTimeout(getConnectionTimeout());</span><br><span class="line">        ka.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">        PollerEvent r = eventCache.pop();</span><br><span class="line">        ka.interestOps(SelectionKey.OP_READ);<span class="comment">//this is what OP_REGISTER turns into.</span></span><br><span class="line">        <span class="keyword">if</span> ( r==<span class="keyword">null</span>) r = <span class="keyword">new</span> PollerEvent(socket,ka,OP_REGISTER);</span><br><span class="line">        <span class="keyword">else</span> r.reset(socket,ka,OP_REGISTER);</span><br><span class="line">        addEvent(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEvent</span><span class="params">(PollerEvent event)</span> </span>&#123;</span><br><span class="line">        events.offer(event);</span><br><span class="line">        <span class="keyword">if</span> ( wakeupCounter.incrementAndGet() == <span class="number">0</span> ) selector.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PollerEvent"><a href="#PollerEvent" class="headerlink" title="PollerEvent"></a>PollerEvent</h5><p>接下来看一下PollerEvent，PollerEvent实现了Runnable接口，用来表示一个轮询事件，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PollerEvent</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NioChannel socket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> interestOps;</span><br><span class="line">    <span class="keyword">private</span> NioSocketWrapper socketWrapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PollerEvent</span><span class="params">(NioChannel ch, NioSocketWrapper w, <span class="keyword">int</span> intOps)</span> </span>&#123;</span><br><span class="line">        reset(ch, w, intOps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(NioChannel ch, NioSocketWrapper w, <span class="keyword">int</span> intOps)</span> </span>&#123;</span><br><span class="line">        socket = ch;</span><br><span class="line">        interestOps = intOps;</span><br><span class="line">        socketWrapper = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reset(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interestOps == OP_REGISTER) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.getIOChannel().register(</span><br><span class="line">                        socket.getPoller().getSelector(), SelectionKey.OP_READ, socketWrapper);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">                log.error(sm.getString(<span class="string">&quot;endpoint.nio.registerFail&quot;</span>), x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    socket.socketWrapper.getEndpoint().countDownConnection();</span><br><span class="line">                    ((NioSocketWrapper) socket.socketWrapper).closed = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> NioSocketWrapper socketWrapper = (NioSocketWrapper) key.attachment();</span><br><span class="line">                    <span class="keyword">if</span> (socketWrapper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//we are registering the key to start with, reset the fairness counter.</span></span><br><span class="line">                        <span class="keyword">int</span> ops = key.interestOps() | interestOps;</span><br><span class="line">                        socketWrapper.interestOps(ops);</span><br><span class="line">                        key.interestOps(ops);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        socket.getPoller().cancelledKey(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancelledKeyException ckx) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.getPoller().cancelledKey(key);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ignore) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在run函数中：</p>
<ul>
<li>若感兴趣集是自定义的OP_REGISTER，则说明该事件表示的已连接套接字通道尚未被轮询线程处理过，那么将该通道注册到Poller线程的Selector上，感兴趣集是OP_READ，通道注册的附件是一个NioSocketWrapper对象。从Poller的register方法添加事件即是这样的过程；</li>
<li>否则获得已连接套接字通道注册到Poller线程的Selector上的SelectionKey，为key添加新的感兴趣集。</li>
</ul>
<h5 id="重访Poller"><a href="#重访Poller" class="headerlink" title="重访Poller"></a>重访Poller</h5><p>上文提到Poller类实现了Runnable接口，其重写的run方法如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">events</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    PollerEvent pe = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = events.size(); i &lt; size &amp;&amp; (pe = events.poll()) != <span class="keyword">null</span>; i++ ) &#123;</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//直接调用run方法</span></span><br><span class="line">            pe.run();</span><br><span class="line">            pe.reset();</span><br><span class="line">            <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</span><br><span class="line">                eventCache.push(pe);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( Throwable x ) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&quot;</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Loop until destroy() is called</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> hasEvents = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!close) &#123;</span><br><span class="line">                /执行PollerEvent的run方法</span><br><span class="line">                hasEvents = events();</span><br><span class="line">                <span class="keyword">if</span> (wakeupCounter.getAndSet(-<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//if we are here, means we have other stuff to do</span></span><br><span class="line">                    <span class="comment">//do a non blocking select</span></span><br><span class="line">                    keyCount = selector.selectNow();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    keyCount = selector.select(selectorTimeout);</span><br><span class="line">                &#125;</span><br><span class="line">                wakeupCounter.set(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                events();</span><br><span class="line">                timeout(<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    log.error(sm.getString(<span class="string">&quot;endpoint.nio.selectorCloseFail&quot;</span>), ioe);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(x);</span><br><span class="line">            log.error(<span class="string">&quot;&quot;</span>,x);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//either we timed out or we woke up, process events first</span></span><br><span class="line">        <span class="keyword">if</span> ( keyCount == <span class="number">0</span> ) hasEvents = (hasEvents | events());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前选择器中所有注册的“选择键(已就绪的监听事件)”</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">            keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Walk through the collection of ready keys and dispatch</span></span><br><span class="line">        <span class="comment">// any active event.</span></span><br><span class="line">        <span class="comment">// 对已经准备好的key进行处理</span></span><br><span class="line">        <span class="keyword">while</span> (iterator != <span class="keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">            SelectionKey sk = iterator.next();</span><br><span class="line">            NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</span><br><span class="line">            <span class="comment">// Attachment may be null if another thread has called</span></span><br><span class="line">            <span class="comment">// cancelledKey()</span></span><br><span class="line">            <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">// 真正处理key的地方</span></span><br><span class="line">                processKey(sk, attachment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//process timeouts</span></span><br><span class="line">        timeout(keyCount,hasEvents);</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">    getStopLatch().countDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>若队列里有元素则会先把队列里的事件均执行一遍，PollerEvent的run方法会将通道注册到Poller的Selector上；</li>
<li>对select返回的SelectionKey进行处理，由于在PollerEvent中注册通道时带上了NioSocketWrapper附件，因此这里可以用SelectionKey的attachment方法得到，接着调用processKey去处理已连接套接字通道。</li>
</ul>
<p>我们接着分析<code>processKey()</code>，该方法又会根据key的类型，来分别处理读和写。</p>
<ol>
<li>处理读事件，比如生成Request对象</li>
<li>处理写事件，比如将生成的Response对象通过socket写回客户端</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processKey</span><span class="params">(SelectionKey sk, NioSocketWrapper attachment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( close ) &#123;</span><br><span class="line">            cancelledKey(sk);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( sk.isValid() &amp;&amp; attachment != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sk.isReadable() || sk.isWritable() ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( attachment.getSendfileData() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                    processSendfile(sk,attachment, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    unreg(sk, attachment, sk.readyOps());</span><br><span class="line">                    <span class="keyword">boolean</span> closeSocket = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 1. 处理读事件，比如生成Request对象</span></span><br><span class="line">                    <span class="comment">// Read goes before write</span></span><br><span class="line">                    <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_READ, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 2. 处理写事件，比如将生成的Response对象通过socket写回客户端</span></span><br><span class="line">                    <span class="keyword">if</span> (!closeSocket &amp;&amp; sk.isWritable()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_WRITE, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (closeSocket) &#123;</span><br><span class="line">                        cancelledKey(sk);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//invalid key</span></span><br><span class="line">            cancelledKey(sk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> ( CancelledKeyException ckx ) &#123;</span><br><span class="line">        cancelledKey(sk);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        log.error(<span class="string">&quot;&quot;</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续来分析方法<code>processSocket()</code>。</p>
<ol>
<li>从<code>processorCache</code>里面拿一个<code>Processor</code>来处理socket，<code>Processor</code>的实现为<code>SocketProcessor</code></li>
<li>将<code>Processor</code>放到工作线程池中执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span></span><br><span class="line"><span class="params"><span class="function">        SocketEvent event, <span class="keyword">boolean</span> dispatch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (socketWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 从`processorCache`里面拿一个`Processor`来处理socket，`Processor`的实现为`SocketProcessor`</span></span><br><span class="line">        SocketProcessorBase&lt;S&gt; sc = processorCache.pop();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sc.reset(socketWrapper, event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 将`Processor`放到工作线程池中执行</span></span><br><span class="line">        Executor executor = getExecutor();</span><br><span class="line">        <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor.execute(sc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sc.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;</span><br><span class="line">        getLog().warn(sm.getString(<span class="string">&quot;endpoint.executor.fail&quot;</span>, socketWrapper) , ree);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        <span class="comment">// This means we got an OOM or similar creating a thread, or that</span></span><br><span class="line">        <span class="comment">// the pool and its queue are full</span></span><br><span class="line">        getLog().error(sm.getString(<span class="string">&quot;endpoint.process.fail&quot;</span>), t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dispatch参数表示是否要在另外的线程中处理，上文processKey各处传递的参数都是true。</p>
<ul>
<li>dispatch为true且工作线程池存在时会执行executor.execute(sc)，之后是由工作线程池处理已连接套接字；</li>
<li>否则继续由Poller线程自己处理已连接套接字。</li>
</ul>
<p>AbstractEndPoint类的createSocketProcessor是抽象方法，NioEndPoint类实现了它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SocketProcessorBase&lt;NioChannel&gt; <span class="title">createSocketProcessor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        SocketWrapperBase&lt;NioChannel&gt; socketWrapper, SocketEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SocketProcessor(socketWrapper, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们分析<code>SocketProcessor.doRun()</code>方法（<code>SocketProcessor.run()</code>方法最终调用此方法）。该方法将处理逻辑交给<code>Handler</code>处理，当event为null时，则表明是一个<code>OPEN_READ</code>事件。</p>
<p>该类的注释说明SocketProcessor与Worker的作用等价。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class is the equivalent of the Worker, but will simply use in an</span></span><br><span class="line"><span class="comment"> * external Executor thread pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketProcessor</span> <span class="keyword">extends</span> <span class="title">SocketProcessorBase</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketProcessor</span><span class="params">(SocketWrapperBase&lt;NioChannel&gt; socketWrapper, SocketEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(socketWrapper, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NioChannel socket = socketWrapper.getSocket();</span><br><span class="line">        SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> handshake = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (socket.isHandshakeComplete()) &#123;</span><br><span class="line">                        <span class="comment">// No TLS handshaking required. Let the handler</span></span><br><span class="line">                        <span class="comment">// process this socket / event combination.</span></span><br><span class="line">                        handshake = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == SocketEvent.STOP || event == SocketEvent.DISCONNECT ||</span><br><span class="line">                            event == SocketEvent.ERROR) &#123;</span><br><span class="line">                        <span class="comment">// Unable to complete the TLS handshake. Treat it as</span></span><br><span class="line">                        <span class="comment">// if the handshake failed.</span></span><br><span class="line">                        handshake = -<span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        handshake = socket.handshake(key.isReadable(), key.isWritable());</span><br><span class="line">                        <span class="comment">// The handshake process reads/writes from/to the</span></span><br><span class="line">                        <span class="comment">// socket. status may therefore be OPEN_WRITE once</span></span><br><span class="line">                        <span class="comment">// the handshake completes. However, the handshake</span></span><br><span class="line">                        <span class="comment">// happens when the socket is opened so the status</span></span><br><span class="line">                        <span class="comment">// must always be OPEN_READ after it completes. It</span></span><br><span class="line">                        <span class="comment">// is OK to always set this as it is only used if</span></span><br><span class="line">                        <span class="comment">// the handshake completes.</span></span><br><span class="line">                        event = SocketEvent.OPEN_READ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                handshake = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) log.debug(<span class="string">&quot;Error during SSL handshake&quot;</span>,x);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancelledKeyException ckx) &#123;</span><br><span class="line">                handshake = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (handshake == <span class="number">0</span>) &#123;</span><br><span class="line">                SocketState state = SocketState.OPEN;</span><br><span class="line">                <span class="comment">// Process the request from this socket</span></span><br><span class="line">                <span class="comment">// 将处理逻辑交给`Handler`处理，当event为null时，则表明是一个`OPEN_READ`事件</span></span><br><span class="line">                <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    state = getHandler().process(socketWrapper, SocketEvent.OPEN_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    state = getHandler().process(socketWrapper, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (state == SocketState.CLOSED) &#123;</span><br><span class="line">                    close(socket, key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handshake == -<span class="number">1</span> ) &#123;</span><br><span class="line">                close(socket, key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handshake == SelectionKey.OP_READ)&#123;</span><br><span class="line">                socketWrapper.registerReadInterest();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handshake == SelectionKey.OP_WRITE)&#123;</span><br><span class="line">                socketWrapper.registerWriteInterest();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException cx) &#123;</span><br><span class="line">            socket.getPoller().cancelledKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (VirtualMachineError vme) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(vme);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&quot;</span>, t);</span><br><span class="line">            socket.getPoller().cancelledKey(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            socketWrapper = <span class="keyword">null</span>;</span><br><span class="line">            event = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//return to cache</span></span><br><span class="line">            <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</span><br><span class="line">                processorCache.push(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Handler的关键方法是process(),虽然这个方法有很多条件分支，但是逻辑却非常清楚，主要是调用Processor.process()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketState <span class="title">process</span><span class="params">(SocketWrapperBase&lt;S&gt; wrapper, SocketEvent status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (processor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            processor = getProtocol().createProcessor();</span><br><span class="line">            register(processor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        processor.setSslSupport(</span><br><span class="line">                wrapper.getSslSupport(getProtocol().getClientCertProvider()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Associate the processor with the connection</span></span><br><span class="line">        connections.put(socket, processor);</span><br><span class="line"></span><br><span class="line">        SocketState state = SocketState.CLOSED;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 关键的代码，终于找到你了</span></span><br><span class="line">            state = processor.process(wrapper, status);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> ( state == SocketState.UPGRADING);</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        <span class="comment">// any other exception or error is odd. Here we log it</span></span><br><span class="line">        <span class="comment">// with &quot;ERROR&quot; level, so it will show up even on</span></span><br><span class="line">        <span class="comment">// less-than-verbose logs.</span></span><br><span class="line">        getLog().error(sm.getString(<span class="string">&quot;abstractConnectionHandler.error&quot;</span>), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ContainerThreadMarker.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure socket/processor is removed from the list of current</span></span><br><span class="line">    <span class="comment">// connections</span></span><br><span class="line">    connections.remove(socket);</span><br><span class="line">    release(processor);</span><br><span class="line">    <span class="keyword">return</span> SocketState.CLOSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//createProcessor </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Http11Processor <span class="title">createProcessor</span><span class="params">()</span> </span>&#123;                          </span><br><span class="line">    <span class="comment">// 构建 Http11Processor</span></span><br><span class="line">    Http11Processor processor = <span class="keyword">new</span> Http11Processor(</span><br><span class="line">            proto.getMaxHttpHeaderSize(), (JIoEndpoint)proto.endpoint, <span class="comment">// 1. http header 的最大尺寸</span></span><br><span class="line">            proto.getMaxTrailerSize(),proto.getMaxExtensionSize());</span><br><span class="line">    processor.setAdapter(proto.getAdapter());</span><br><span class="line">    <span class="comment">// 2. 默认的 KeepAlive 情况下, 每个 Socket 处理的最多的 请求次数</span></span><br><span class="line">    processor.setMaxKeepAliveRequests(proto.getMaxKeepAliveRequests());</span><br><span class="line">    <span class="comment">// 3. 开启 KeepAlive 的 Timeout</span></span><br><span class="line">    processor.setKeepAliveTimeout(proto.getKeepAliveTimeout());      </span><br><span class="line">    <span class="comment">// 4. http 当遇到文件上传时的 默认超时时间 (300 * 1000)    </span></span><br><span class="line">    processor.setConnectionUploadTimeout(</span><br><span class="line">            proto.getConnectionUploadTimeout());                      </span><br><span class="line">    processor.setDisableUploadTimeout(proto.getDisableUploadTimeout());</span><br><span class="line">    <span class="comment">// 5. 当 http 请求的 body size超过这个值时, 通过 gzip 进行压缩</span></span><br><span class="line">    processor.setCompressionMinSize(proto.getCompressionMinSize());  </span><br><span class="line">    <span class="comment">// 6. http 请求是否开启 compression 处理    </span></span><br><span class="line">    processor.setCompression(proto.getCompression());                  </span><br><span class="line">    processor.setNoCompressionUserAgents(proto.getNoCompressionUserAgents());</span><br><span class="line">    <span class="comment">// 7. http body里面的内容是 &quot;text/html,text/xml,text/plain&quot; 才会进行 压缩处理</span></span><br><span class="line">    processor.setCompressableMimeTypes(proto.getCompressableMimeTypes());</span><br><span class="line">    processor.setRestrictedUserAgents(proto.getRestrictedUserAgents());</span><br><span class="line">    <span class="comment">// 8. socket 的 buffer, 默认 9000</span></span><br><span class="line">    processor.setSocketBuffer(proto.getSocketBuffer());       </span><br><span class="line">    <span class="comment">// 9. 最大的 Post 处理尺寸的大小 4 * 1000    </span></span><br><span class="line">    processor.setMaxSavePostSize(proto.getMaxSavePostSize());          </span><br><span class="line">    processor.setServer(proto.getServer());</span><br><span class="line">    processor.setDisableKeepAlivePercentage(</span><br><span class="line">            proto.getDisableKeepAlivePercentage());                    </span><br><span class="line">    register(processor);                                               </span><br><span class="line">    <span class="keyword">return</span> processor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这儿我们主要关注的是<code>Processor</code>对于读的操作，也只有一行代码。调用<code>service()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProcessorLight</span> <span class="keyword">implements</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SocketState <span class="title">process</span><span class="params">(SocketWrapperBase&lt;?&gt; socketWrapper, SocketEvent status)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SocketState state = SocketState.CLOSED;</span><br><span class="line">        Iterator&lt;DispatchType&gt; dispatches = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (dispatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">                DispatchType nextDispatch = dispatches.next();</span><br><span class="line">                state = dispatch(nextDispatch.getSocketStatus());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.DISCONNECT) &#123;</span><br><span class="line">                <span class="comment">// Do nothing here, just wait for it to get recycled</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync() || isUpgrade() || state == SocketState.ASYNC_END) &#123;</span><br><span class="line">                state = dispatch(status);</span><br><span class="line">                <span class="keyword">if</span> (state == SocketState.OPEN) &#123;</span><br><span class="line">                    <span class="comment">// There may be pipe-lined data to read. If the data isn&#x27;t</span></span><br><span class="line">                    <span class="comment">// processed now, execution will exit this loop and call</span></span><br><span class="line">                    <span class="comment">// release() which will recycle the processor (and input</span></span><br><span class="line">                    <span class="comment">// buffer) deleting any pipe-lined data. To avoid this,</span></span><br><span class="line">                    <span class="comment">// process it now.</span></span><br><span class="line">                    state = service(socketWrapper);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.OPEN_WRITE) &#123;</span><br><span class="line">                <span class="comment">// Extra write event likely after async, ignore</span></span><br><span class="line">                state = SocketState.LONG;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.OPEN_READ)&#123;</span><br><span class="line">                <span class="comment">// 调用`service()`方法</span></span><br><span class="line">                state = service(socketWrapper);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Default to closing the socket if the SocketEvent passed in</span></span><br><span class="line">                <span class="comment">// is not consistent with the current state of the Processor</span></span><br><span class="line">                state = SocketState.CLOSED;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</span><br><span class="line">                getLog().debug(<span class="string">&quot;Socket: [&quot;</span> + socketWrapper +</span><br><span class="line">                        <span class="string">&quot;], Status in: [&quot;</span> + status +</span><br><span class="line">                        <span class="string">&quot;], State out: [&quot;</span> + state + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (state != SocketState.CLOSED &amp;&amp; isAsync()) &#123;</span><br><span class="line">                state = asyncPostProcess();</span><br><span class="line">                <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</span><br><span class="line">                    getLog().debug(<span class="string">&quot;Socket: [&quot;</span> + socketWrapper +</span><br><span class="line">                            <span class="string">&quot;], State after async post processing: [&quot;</span> + state + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dispatches == <span class="keyword">null</span> || !dispatches.hasNext()) &#123;</span><br><span class="line">                <span class="comment">// Only returns non-null iterator if there are</span></span><br><span class="line">                <span class="comment">// dispatches to process.</span></span><br><span class="line">                dispatches = getIteratorAndClearDispatches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (state == SocketState.ASYNC_END ||</span><br><span class="line">                dispatches != <span class="keyword">null</span> &amp;&amp; state != SocketState.CLOSED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Processor.service()</code>方法比较重要的地方就两点。该方法非常得长，也超过了200行，在此我们不再拷贝此方法的代码。</p>
<ol>
<li>生成Request和Response对象</li>
<li>调用<code>Adapter.service()</code>方法，将生成的Request和Response对象传进去</li>
</ol>
<h5 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h5><p><code>Adapter</code>用于连接<code>Connector</code>和<code>Container</code>，起到承上启下的作用。<code>Processor</code>会调用<code>Adapter.service()</code>方法。我们来分析一下，主要做了下面几件事情：</p>
<ol>
<li>根据coyote框架的request和response对象，生成connector的request和response对象（是HttpServletRequest和HttpServletResponse的封装）</li>
<li>补充header</li>
<li>解析请求，该方法会出现代理服务器、设置必要的header等操作</li>
<li>真正进入容器的地方，调用Engine容器下pipeline的阀门</li>
<li>通过request.finishRequest 与 response.finishResponse(刷OutputBuffer中的数据到浏览器) 来完成整个请求</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(org.apache.coyote.Request req, org.apache.coyote.Response res)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 根据coyote框架的request和response对象，生成connector的request和response对象（是HttpServletRequest和HttpServletResponse的封装）</span></span><br><span class="line">    Request request = (Request) req.getNote(ADAPTER_NOTES);</span><br><span class="line">    Response response = (Response) res.getNote(ADAPTER_NOTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Create objects</span></span><br><span class="line">        request = connector.createRequest();</span><br><span class="line">        request.setCoyoteRequest(req);</span><br><span class="line">        response = connector.createResponse();</span><br><span class="line">        response.setCoyoteResponse(res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Link objects</span></span><br><span class="line">        request.setResponse(response);</span><br><span class="line">        response.setRequest(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set as notes</span></span><br><span class="line">        req.setNote(ADAPTER_NOTES, request);</span><br><span class="line">        res.setNote(ADAPTER_NOTES, response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set query string encoding</span></span><br><span class="line">        req.getParameters().setQueryStringCharset(connector.getURICharset());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 补充header</span></span><br><span class="line">    <span class="keyword">if</span> (connector.getXpoweredBy()) &#123;</span><br><span class="line">        response.addHeader(<span class="string">&quot;X-Powered-By&quot;</span>, POWERED_BY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> async = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> postParseSuccess = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    req.getRequestProcessor().setWorkerThreadName(THREAD_NAME.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Parse and set Catalina and configuration specific</span></span><br><span class="line">        <span class="comment">// request parameters</span></span><br><span class="line">        <span class="comment">// 3. 解析请求，该方法会出现代理服务器、设置必要的header等操作</span></span><br><span class="line">        <span class="comment">// 用来处理请求映射 (获取 host, context, wrapper, URI 后面的参数的解析, sessionId )</span></span><br><span class="line">        postParseSuccess = postParseRequest(req, request, res, response);</span><br><span class="line">        <span class="keyword">if</span> (postParseSuccess) &#123;</span><br><span class="line">            <span class="comment">//check valves if we support async</span></span><br><span class="line">            request.setAsyncSupported(</span><br><span class="line">                    connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">            <span class="comment">// Calling the container</span></span><br><span class="line">            <span class="comment">// 4. 真正进入容器的地方，调用Engine容器下pipeline的阀门</span></span><br><span class="line">            connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                    request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (request.isAsync()) &#123;</span><br><span class="line">            async = <span class="keyword">true</span>;</span><br><span class="line">            ReadListener readListener = req.getReadListener();</span><br><span class="line">            <span class="keyword">if</span> (readListener != <span class="keyword">null</span> &amp;&amp; request.isFinished()) &#123;</span><br><span class="line">                <span class="comment">// Possible the all data may have been read during service()</span></span><br><span class="line">                <span class="comment">// method so this needs to be checked here</span></span><br><span class="line">                ClassLoader oldCL = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    oldCL = request.getContext().bind(<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (req.sendAllDataReadEvent()) &#123;</span><br><span class="line">                        req.getReadListener().onAllDataRead();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    request.getContext().unbind(<span class="keyword">false</span>, oldCL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Throwable throwable =</span><br><span class="line">                    (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If an async request was started, is not going to end once</span></span><br><span class="line">            <span class="comment">// this container thread finishes and an error occurred, trigger</span></span><br><span class="line">            <span class="comment">// the async error process</span></span><br><span class="line">            <span class="keyword">if</span> (!request.isAsyncCompleting() &amp;&amp; throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                request.getAsyncContextInternal().setErrorState(throwable, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//5. 通过request.finishRequest 与 response.finishResponse(刷OutputBuffer中的数据到浏览器) 来完成整个请求</span></span><br><span class="line">            request.finishRequest();</span><br><span class="line">            <span class="comment">//将 org.apache.catalina.connector.Response对应的 OutputBuffer 中的数据 刷到 org.apache.coyote.Response 对应的 InternalOutputBuffer 中, 并且最终调用 socket对应的 outputStream 将数据刷出去( 这里会组装 Http Response 中的 header 与 body 里面的数据, 并且刷到远端 )</span></span><br><span class="line">            response.finishResponse();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AtomicBoolean error = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        res.action(ActionCode.IS_ERROR, error);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.isAsyncCompleting() &amp;&amp; error.get()) &#123;</span><br><span class="line">            <span class="comment">// Connection will be forcibly closed which will prevent</span></span><br><span class="line">            <span class="comment">// completion happening at the usual point. Need to trigger</span></span><br><span class="line">            <span class="comment">// call to onComplete() here.</span></span><br><span class="line">            res.action(ActionCode.ASYNC_POST_PROCESS,  <span class="keyword">null</span>);</span><br><span class="line">            async = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Access log</span></span><br><span class="line">        <span class="keyword">if</span> (!async &amp;&amp; postParseSuccess) &#123;</span><br><span class="line">            <span class="comment">// Log only if processing was invoked.</span></span><br><span class="line">            <span class="comment">// If postParseRequest() failed, it has already logged it.</span></span><br><span class="line">            Context context = request.getContext();</span><br><span class="line">            <span class="comment">// If the context is null, it is likely that the endpoint was</span></span><br><span class="line">            <span class="comment">// shutdown, this connection closed and the request recycled in</span></span><br><span class="line">            <span class="comment">// a different thread. That thread will have updated the access</span></span><br><span class="line">            <span class="comment">// log so it is OK not to update the access log here in that</span></span><br><span class="line">            <span class="comment">// case.</span></span><br><span class="line">            <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">                context.logAccess(request, response,</span><br><span class="line">                        System.currentTimeMillis() - req.getStartTime(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        req.getRequestProcessor().setWorkerThreadName(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recycle the wrapper request and response</span></span><br><span class="line">        <span class="keyword">if</span> (!async) &#123;</span><br><span class="line">            request.recycle();</span><br><span class="line">            response.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="请求预处理"><a href="#请求预处理" class="headerlink" title="请求预处理"></a>请求预处理</h5><p>postParseRequest方法对请求做预处理，如对路径去除分号表示的路径参数、进行URI解码、规格化（点号和两点号）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">postParseRequest</span><span class="params">(org.apache.coyote.Request req, Request request,</span></span></span><br><span class="line"><span class="params"><span class="function">        org.apache.coyote.Response res, Response response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    MessageBytes decodedURI = req.decodedURI();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (undecodedURI.getType() == MessageBytes.T_BYTES) &#123;</span><br><span class="line">        <span class="comment">// Copy the raw URI to the decodedURI</span></span><br><span class="line">        decodedURI.duplicate(undecodedURI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parse the path parameters. This will:</span></span><br><span class="line">        <span class="comment">//   - strip out the path parameters</span></span><br><span class="line">        <span class="comment">//   - convert the decodedURI to bytes</span></span><br><span class="line">        parsePathParameters(req, request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// URI decoding</span></span><br><span class="line">        <span class="comment">// %xx decoding of the URL</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            req.getURLDecoder().convert(decodedURI, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            res.setStatus(<span class="number">400</span>);</span><br><span class="line">            res.setMessage(<span class="string">&quot;Invalid URI: &quot;</span> + ioe.getMessage());</span><br><span class="line">            connector.getService().getContainer().logAccess(</span><br><span class="line">                    request, response, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Normalization</span></span><br><span class="line">        <span class="keyword">if</span> (!normalize(req.decodedURI())) &#123;</span><br><span class="line">            res.setStatus(<span class="number">400</span>);</span><br><span class="line">            res.setMessage(<span class="string">&quot;Invalid URI&quot;</span>);</span><br><span class="line">            connector.getService().getContainer().logAccess(</span><br><span class="line">                    request, response, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Character decoding</span></span><br><span class="line">        convertURI(decodedURI, request);</span><br><span class="line">        <span class="comment">// Check that the URI is still normalized</span></span><br><span class="line">        <span class="keyword">if</span> (!checkNormalize(req.decodedURI())) &#123;</span><br><span class="line">            res.setStatus(<span class="number">400</span>);</span><br><span class="line">            res.setMessage(<span class="string">&quot;Invalid URI character encoding&quot;</span>);</span><br><span class="line">            connector.getService().getContainer().logAccess(</span><br><span class="line">                    request, response, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* The URI is chars or String, and has been sent using an in-memory</span></span><br><span class="line"><span class="comment">            * protocol handler. The following assumptions are made:</span></span><br><span class="line"><span class="comment">            * - req.requestURI() has been set to the &#x27;original&#x27; non-decoded,</span></span><br><span class="line"><span class="comment">            *   non-normalized URI</span></span><br><span class="line"><span class="comment">            * - req.decodedURI() has been set to the decoded, normalized form</span></span><br><span class="line"><span class="comment">            *   of req.requestURI()</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        decodedURI.toChars();</span><br><span class="line">        <span class="comment">// Remove all path parameters; any needed path parameter should be set</span></span><br><span class="line">        <span class="comment">// using the request object rather than passing it in the URL</span></span><br><span class="line">        CharChunk uriCC = decodedURI.getCharChunk();</span><br><span class="line">        <span class="keyword">int</span> semicolon = uriCC.indexOf(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (semicolon &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            decodedURI.setChars</span><br><span class="line">                (uriCC.getBuffer(), uriCC.getStart(), semicolon);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request mapping.</span></span><br><span class="line">    MessageBytes serverName;</span><br><span class="line">    <span class="keyword">if</span> (connector.getUseIPVHosts()) &#123;</span><br><span class="line">        serverName = req.localName();</span><br><span class="line">        <span class="keyword">if</span> (serverName.isNull()) &#123;</span><br><span class="line">            <span class="comment">// well, they did ask for it</span></span><br><span class="line">            res.action(ActionCode.REQ_LOCAL_NAME_ATTRIBUTE, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverName = req.serverName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Version for the second mapping loop and</span></span><br><span class="line">    <span class="comment">// Context that we expect to get for that version</span></span><br><span class="line">    String version = <span class="keyword">null</span>;</span><br><span class="line">    Context versionContext = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> mapRequired = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (mapRequired) &#123;</span><br><span class="line">        <span class="comment">// This will map the the latest version by default</span></span><br><span class="line">        connector.getService().getMapper().map(serverName, decodedURI,</span><br><span class="line">                version, request.getMappingData());</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以MessageBytes的类型是T_BYTES为例：</p>
<ul>
<li>parsePathParameters方法去除URI中分号表示的路径参数；</li>
<li>req.getURLDecoder()得到一个UDecoder实例，它的convert方法对URI解码，这里的解码只是移除百分号，计算百分号后两位的十六进制数字值以替代原来的三位百分号编码；</li>
<li>normalize方法规格化URI，解释路径中的“.”和“..”；</li>
<li>convertURI方法利用Connector的uriEncoding属性将URI的字节转换为字符表示；</li>
<li>注意connector.getService().getMapper().map(serverName, decodedURI, version, request.getMappingData()) 这行，之前Service启动时MapperListener注册了该Service内的各Host和Context。根据URI选择Context时，Mapper的map方法采用的是convertURI方法解码后的URI与每个Context的路径去比较</li>
</ul>
<h5 id="容器处理"><a href="#容器处理" class="headerlink" title="容器处理"></a>容器处理</h5><p>如果请求可以被传给容器的Pipeline即当postParseRequest方法返回true时，则由容器继续处理，在service方法中有connector.getService().getContainer().getPipeline().getFirst().invoke(request, response)这一行：</p>
<ul>
<li>Connector调用getService返回StandardService；</li>
<li>StandardService调用getContainer返回StandardEngine；</li>
<li>StandardEngine调用getPipeline返回与其关联的StandardPipeline；</li>
</ul>
<h4 id="Engine处理请求"><a href="#Engine处理请求" class="headerlink" title="Engine处理请求"></a>Engine处理请求</h4><p>我们在前面的文章中讲过**<code>StandardEngine</code><strong>的构造函数为自己的Pipeline添加了基本阀</strong><code>StandardEngineValve</code>**，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StandardEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    pipeline.setBasic(<span class="keyword">new</span> StandardEngineValve());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        setJvmRoute(System.getProperty(<span class="string">&quot;jvmRoute&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">        log.warn(sm.getString(<span class="string">&quot;standardEngine.jvmRouteFail&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看看<code>StandardEngineValve</code>的<code>invoke()</code>方法。该方法主要是选择合适的Host，然后调用Host中pipeline的第一个<code>Valve的invoke()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Select the Host to be used for this Request</span></span><br><span class="line">    Host host = request.getHost();</span><br><span class="line">    <span class="keyword">if</span> (host == <span class="keyword">null</span>) &#123;</span><br><span class="line">        response.sendError</span><br><span class="line">            (HttpServletResponse.SC_BAD_REQUEST,</span><br><span class="line">             sm.getString(<span class="string">&quot;standardEngine.noHost&quot;</span>,</span><br><span class="line">                          request.getServerName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">        request.setAsyncSupported(host.getPipeline().isAsyncSupported());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ask this Host to process this request</span></span><br><span class="line">    host.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法很简单，校验该Engline 容器是否含有Host容器，如果不存在，返回400错误，否则继续执行 <code>host.getPipeline().getFirst().invoke(request, response)</code>，可以看到 Host 容器先获取自己的管道，再获取第一个阀门，我们再看看该阀门的 invoke 方法。</p>
<h4 id="Host处理请求"><a href="#Host处理请求" class="headerlink" title="Host处理请求"></a>Host处理请求</h4><p>分析Host的时候，我们从Host的构造函数入手，该方法主要是设置基础阀门。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public StandardHost() &#123;</span><br><span class="line">    super();</span><br><span class="line">    pipeline.setBasic(new StandardHostValve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StandardPipeline调用getFirst得到第一个阀去处理请求，由于基本阀是最后一个，所以最后会由基本阀去处理请求。</p>
<p>StandardHost的Pipeline里面一定有 ErrorReportValve 与 StandardHostValve两个Valve，ErrorReportValve主要是检测 Http 请求过程中是否出现过什么异常, 有异常的话, 直接拼装 html 页面, 输出到客户端。</p>
<p>我们看看ErrorReportValve的invoke方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">// Perform the request</span></span><br><span class="line">    <span class="comment">// 1. 先将 请求转发给下一个 Valve</span></span><br><span class="line">    getNext().invoke(request, response);  </span><br><span class="line">    <span class="comment">// 2. 这里的 isCommitted 表明, 请求是正常处理结束    </span></span><br><span class="line">    <span class="keyword">if</span> (response.isCommitted()) &#123;               </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 判断请求过程中是否有异常发生</span></span><br><span class="line">    Throwable throwable = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line">    <span class="keyword">if</span> (request.isAsyncStarted() &amp;&amp; ((response.getStatus() &lt; <span class="number">400</span> &amp;&amp;</span><br><span class="line">            throwable == <span class="keyword">null</span>) || request.isAsyncDispatching())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// The response is an error</span></span><br><span class="line">        response.setError();</span><br><span class="line">        <span class="comment">// Reset the response (if possible)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4. 重置 response 里面的数据(此时 Response 里面可能有些数据)</span></span><br><span class="line">            response.reset();                  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 5. 这就是我们常看到的 500 错误码</span></span><br><span class="line">        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    response.setSuspended(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 6. 这里就是将 异常的堆栈信息组合成 html 页面, 输出到前台        </span></span><br><span class="line">        report(request, response, throwable);                                   </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable tt) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(tt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (request.isAsyncStarted()) &#123;          </span><br><span class="line">        <span class="comment">// 7. 若是异步请求的话, 设置对应的 complete (对应的是 异步 Servlet)                   </span></span><br><span class="line">        request.getAsyncContext().complete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法首先执行了下个阀门的 invoke 方法。然后根据返回的Request 属性设置一些错误信息。那么下个阀门是谁呢？其实就是基础阀门了：StandardHostValve，该阀门的 invoke 的方法是如何实现的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Select the Context to be used for this Request</span></span><br><span class="line">    Context context = request.getContext();</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        response.sendError</span><br><span class="line">            (HttpServletResponse.SC_INTERNAL_SERVER_ERROR,</span><br><span class="line">             sm.getString(<span class="string">&quot;standardHost.noContext&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind the context CL to the current thread</span></span><br><span class="line">    <span class="keyword">if</span>( context.getLoader() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">        <span class="comment">// Not started - it should check for availability first</span></span><br><span class="line">        <span class="comment">// This should eventually move to Engine, it&#x27;s generic.</span></span><br><span class="line">        <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">            PrivilegedAction&lt;Void&gt; pa = <span class="keyword">new</span> PrivilegedSetTccl(</span><br><span class="line">                    context.getLoader().getClassLoader());</span><br><span class="line">            AccessController.doPrivileged(pa);                </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread.currentThread().setContextClassLoader</span><br><span class="line">                    (context.getLoader().getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">        request.setAsyncSupported(context.getPipeline().isAsyncSupported());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t fire listeners during async processing</span></span><br><span class="line">    <span class="comment">// If a request init listener throws an exception, the request is</span></span><br><span class="line">    <span class="comment">// aborted</span></span><br><span class="line">    <span class="keyword">boolean</span> asyncAtStart = request.isAsync(); </span><br><span class="line">    <span class="comment">// An async error page may dispatch to another resource. This flag helps</span></span><br><span class="line">    <span class="comment">// ensure an infinite error handling loop is not entered</span></span><br><span class="line">    <span class="keyword">boolean</span> errorAtStart = response.isError();</span><br><span class="line">    <span class="keyword">if</span> (asyncAtStart || context.fireRequestInitEvent(request)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ask this Context to process this request</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            context.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            <span class="keyword">if</span> (errorAtStart) &#123;</span><br><span class="line">                container.getLogger().error(<span class="string">&quot;Exception Processing &quot;</span> +</span><br><span class="line">                        request.getRequestURI(), t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);</span><br><span class="line">                throwable(request, response, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the request was async at the start and an error occurred then</span></span><br><span class="line">        <span class="comment">// the async error handling will kick-in and that will fire the</span></span><br><span class="line">        <span class="comment">// request destroyed event *after* the error handling has taken</span></span><br><span class="line">        <span class="comment">// place</span></span><br><span class="line">        <span class="keyword">if</span> (!(request.isAsync() || (asyncAtStart &amp;&amp;</span><br><span class="line">                request.getAttribute(</span><br><span class="line">                        RequestDispatcher.ERROR_EXCEPTION) != <span class="keyword">null</span>))) &#123;</span><br><span class="line">            <span class="comment">// Protect against NPEs if context was destroyed during a</span></span><br><span class="line">            <span class="comment">// long running request.</span></span><br><span class="line">            <span class="keyword">if</span> (context.getState().isAvailable()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!errorAtStart) &#123;</span><br><span class="line">                    <span class="comment">// Error page processing</span></span><br><span class="line">                    response.setSuspended(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                    Throwable t = (Throwable) request.getAttribute(</span><br><span class="line">                            RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        throwable(request, response, t);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        status(request, response);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                context.fireRequestDestroyEvent(request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Access a session (if present) to update last accessed time, based on a</span></span><br><span class="line">    <span class="comment">// strict interpretation of the specification</span></span><br><span class="line">    <span class="keyword">if</span> (ACCESS_SESSION) &#123;</span><br><span class="line">        request.getSession(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore the context classloader</span></span><br><span class="line">    <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">        PrivilegedAction&lt;Void&gt; pa = <span class="keyword">new</span> PrivilegedSetTccl(</span><br><span class="line">                StandardHostValve.class.getClassLoader());</span><br><span class="line">        AccessController.doPrivileged(pa);                </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.currentThread().setContextClassLoader</span><br><span class="line">                (StandardHostValve.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先校验了Request 是否存在 Context，其实在执行 CoyoteAdapter.postParseRequest 方法的时候就设置了，如果Context 不存在，就返回500，接着还是老套路：context.getPipeline().getFirst().invoke，该管道获取的是基础阀门：StandardContextValve，我们还是关注他的 invoke 方法。</p>
<h4 id="Context处理请求"><a href="#Context处理请求" class="headerlink" title="Context处理请求"></a>Context处理请求</h4><p>接着Context会去处理请求，同理，StandardContextValve的invoke方法会被调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">// Disallow any direct access to resources under WEB-INF or META-INF</span></span><br><span class="line">    MessageBytes requestPathMB = request.getRequestPathMB();</span><br><span class="line">    <span class="keyword">if</span> ((requestPathMB.startsWithIgnoreCase(<span class="string">&quot;/META-INF/&quot;</span>, <span class="number">0</span>))</span><br><span class="line">            || (requestPathMB.equalsIgnoreCase(<span class="string">&quot;/META-INF&quot;</span>))</span><br><span class="line">            || (requestPathMB.startsWithIgnoreCase(<span class="string">&quot;/WEB-INF/&quot;</span>, <span class="number">0</span>))</span><br><span class="line">            || (requestPathMB.equalsIgnoreCase(<span class="string">&quot;/WEB-INF&quot;</span>))) &#123;</span><br><span class="line">        response.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Select the Wrapper to be used for this Request</span></span><br><span class="line">    Wrapper wrapper = request.getWrapper();</span><br><span class="line">    <span class="keyword">if</span> (wrapper == <span class="keyword">null</span> || wrapper.isUnavailable()) &#123;</span><br><span class="line">        response.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acknowledge the request</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response.sendAcknowledgement();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        container.getLogger().error(sm.getString(</span><br><span class="line">                <span class="string">&quot;standardContextValve.acknowledgeException&quot;</span>), ioe);</span><br><span class="line">        request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, ioe);</span><br><span class="line">        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">        request.setAsyncSupported(wrapper.getPipeline().isAsyncSupported());</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Wrapper处理请求"><a href="#Wrapper处理请求" class="headerlink" title="Wrapper处理请求"></a>Wrapper处理请求</h4><p>Wrapper是一个Servlet的包装，我们先来看看构造方法。主要作用就是设置基础阀门<code>StandardWrapperValve</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StandardWrapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    swValve=<span class="keyword">new</span> StandardWrapperValve();</span><br><span class="line">    pipeline.setBasic(swValve);</span><br><span class="line">    broadcaster = <span class="keyword">new</span> NotificationBroadcasterSupport();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看看<code>StandardWrapperValve</code>的<code>invoke()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize local variables we may need</span></span><br><span class="line">    <span class="keyword">boolean</span> unavailable = <span class="keyword">false</span>;</span><br><span class="line">    Throwable throwable = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// This should be a Request attribute...</span></span><br><span class="line">    <span class="keyword">long</span> t1=System.currentTimeMillis();</span><br><span class="line">    requestCount.incrementAndGet();</span><br><span class="line">    StandardWrapper wrapper = (StandardWrapper) getContainer();</span><br><span class="line">    Servlet servlet = <span class="keyword">null</span>;</span><br><span class="line">    Context context = (Context) wrapper.getParent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for the application being marked unavailable</span></span><br><span class="line">    <span class="keyword">if</span> (!context.getState().isAvailable()) &#123;</span><br><span class="line">        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                       sm.getString(<span class="string">&quot;standardContext.isUnavailable&quot;</span>));</span><br><span class="line">        unavailable = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for the servlet being marked unavailable</span></span><br><span class="line">    <span class="keyword">if</span> (!unavailable &amp;&amp; wrapper.isUnavailable()) &#123;</span><br><span class="line">        container.getLogger().info(sm.getString(<span class="string">&quot;standardWrapper.isUnavailable&quot;</span>,</span><br><span class="line">                wrapper.getName()));</span><br><span class="line">        <span class="keyword">long</span> available = wrapper.getAvailable();</span><br><span class="line">        <span class="keyword">if</span> ((available &gt; <span class="number">0L</span>) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">            response.setDateHeader(<span class="string">&quot;Retry-After&quot;</span>, available);</span><br><span class="line">            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                    sm.getString(<span class="string">&quot;standardWrapper.isUnavailable&quot;</span>,</span><br><span class="line">                            wrapper.getName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (available == Long.MAX_VALUE) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                    sm.getString(<span class="string">&quot;standardWrapper.notFound&quot;</span>,</span><br><span class="line">                            wrapper.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        unavailable = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a servlet instance to process this request</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 关键点1：这儿调用Wrapper的allocate()方法分配一个Servlet实例</span></span><br><span class="line">        <span class="keyword">if</span> (!unavailable) &#123;</span><br><span class="line">            servlet = wrapper.allocate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnavailableException e) &#123;</span><br><span class="line">        container.getLogger().error(</span><br><span class="line">                sm.getString(<span class="string">&quot;standardWrapper.allocateException&quot;</span>,</span><br><span class="line">                        wrapper.getName()), e);</span><br><span class="line">        <span class="keyword">long</span> available = wrapper.getAvailable();</span><br><span class="line">        <span class="keyword">if</span> ((available &gt; <span class="number">0L</span>) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">            response.setDateHeader(<span class="string">&quot;Retry-After&quot;</span>, available);</span><br><span class="line">            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                       sm.getString(<span class="string">&quot;standardWrapper.isUnavailable&quot;</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (available == Long.MAX_VALUE) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                       sm.getString(<span class="string">&quot;standardWrapper.notFound&quot;</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">        container.getLogger().error(sm.getString(<span class="string">&quot;standardWrapper.allocateException&quot;</span>,</span><br><span class="line">                         wrapper.getName()), StandardWrapper.getRootCause(e));</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        container.getLogger().error(sm.getString(<span class="string">&quot;standardWrapper.allocateException&quot;</span>,</span><br><span class="line">                         wrapper.getName()), e);</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">        servlet = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MessageBytes requestPathMB = request.getRequestPathMB();</span><br><span class="line">    DispatcherType dispatcherType = DispatcherType.REQUEST;</span><br><span class="line">    <span class="keyword">if</span> (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;</span><br><span class="line">    request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);</span><br><span class="line">    request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,</span><br><span class="line">            requestPathMB);</span><br><span class="line">    <span class="comment">// Create the filter chain for this request</span></span><br><span class="line">    <span class="comment">// 关键点2，创建过滤器链，类似于Pipeline的功能</span></span><br><span class="line">    ApplicationFilterChain filterChain =</span><br><span class="line">            ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the filter chain for this request</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> This also calls the servlet&#x27;s service() method</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((servlet != <span class="keyword">null</span>) &amp;&amp; (filterChain != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// Swallow output if needed</span></span><br><span class="line">            <span class="keyword">if</span> (context.getSwallowOutput()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SystemLogHandler.startCapture();</span><br><span class="line">                    <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</span><br><span class="line">                        request.getAsyncContextInternal().doInternalDispatch();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 关键点3，调用过滤器链的doFilter，最终会调用到Servlet的service方法</span></span><br><span class="line">                        filterChain.doFilter(request.getRequest(),</span><br><span class="line">                                response.getResponse());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    String log = SystemLogHandler.stopCapture();</span><br><span class="line">                    <span class="keyword">if</span> (log != <span class="keyword">null</span> &amp;&amp; log.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        context.getLogger().info(log);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</span><br><span class="line">                    request.getAsyncContextInternal().doInternalDispatch();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 关键点3，调用过滤器链的doFilter，最终会调用到Servlet的service方法</span></span><br><span class="line">                    filterChain.doFilter</span><br><span class="line">                        (request.getRequest(), response.getResponse());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClientAbortException e) &#123;</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        container.getLogger().error(sm.getString(</span><br><span class="line">                <span class="string">&quot;standardWrapper.serviceException&quot;</span>, wrapper.getName(),</span><br><span class="line">                context.getName()), e);</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnavailableException e) &#123;</span><br><span class="line">        container.getLogger().error(sm.getString(</span><br><span class="line">                <span class="string">&quot;standardWrapper.serviceException&quot;</span>, wrapper.getName(),</span><br><span class="line">                context.getName()), e);</span><br><span class="line">        <span class="comment">//            throwable = e;</span></span><br><span class="line">        <span class="comment">//            exception(request, response, e);</span></span><br><span class="line">        wrapper.unavailable(e);</span><br><span class="line">        <span class="keyword">long</span> available = wrapper.getAvailable();</span><br><span class="line">        <span class="keyword">if</span> ((available &gt; <span class="number">0L</span>) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">            response.setDateHeader(<span class="string">&quot;Retry-After&quot;</span>, available);</span><br><span class="line">            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                       sm.getString(<span class="string">&quot;standardWrapper.isUnavailable&quot;</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (available == Long.MAX_VALUE) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                        sm.getString(<span class="string">&quot;standardWrapper.notFound&quot;</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Do not save exception in &#x27;throwable&#x27;, because we</span></span><br><span class="line">        <span class="comment">// do not want to do exception(request, response, e) processing</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">        Throwable rootCause = StandardWrapper.getRootCause(e);</span><br><span class="line">        <span class="keyword">if</span> (!(rootCause <span class="keyword">instanceof</span> ClientAbortException)) &#123;</span><br><span class="line">            container.getLogger().error(sm.getString(</span><br><span class="line">                    <span class="string">&quot;standardWrapper.serviceExceptionRoot&quot;</span>,</span><br><span class="line">                    wrapper.getName(), context.getName(), e.getMessage()),</span><br><span class="line">                    rootCause);</span><br><span class="line">        &#125;</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        container.getLogger().error(sm.getString(</span><br><span class="line">                <span class="string">&quot;standardWrapper.serviceException&quot;</span>, wrapper.getName(),</span><br><span class="line">                context.getName()), e);</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release the filter chain (if any) for this request</span></span><br><span class="line">    <span class="comment">// 关键点4，释放掉过滤器链及其相关资源</span></span><br><span class="line">    <span class="keyword">if</span> (filterChain != <span class="keyword">null</span>) &#123;</span><br><span class="line">        filterChain.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键点5，释放掉Servlet及相关资源</span></span><br><span class="line">    <span class="comment">// Deallocate the allocated servlet instance</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (servlet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wrapper.deallocate(servlet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        container.getLogger().error(sm.getString(<span class="string">&quot;standardWrapper.deallocateException&quot;</span>,</span><br><span class="line">                         wrapper.getName()), e);</span><br><span class="line">        <span class="keyword">if</span> (throwable == <span class="keyword">null</span>) &#123;</span><br><span class="line">            throwable = e;</span><br><span class="line">            exception(request, response, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this servlet has been marked permanently unavailable,</span></span><br><span class="line">    <span class="comment">// unload it and release this instance</span></span><br><span class="line">    <span class="comment">// 关键点6，如果servlet被标记为永远不可达，则需要卸载掉它，并释放这个servlet实例</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((servlet != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">            (wrapper.getAvailable() == Long.MAX_VALUE)) &#123;</span><br><span class="line">            wrapper.unload();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        container.getLogger().error(sm.getString(<span class="string">&quot;standardWrapper.unloadException&quot;</span>,</span><br><span class="line">                         wrapper.getName()), e);</span><br><span class="line">        <span class="keyword">if</span> (throwable == <span class="keyword">null</span>) &#123;</span><br><span class="line">            throwable = e;</span><br><span class="line">            exception(request, response, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> t2=System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> time=t2-t1;</span><br><span class="line">    processingTime += time;</span><br><span class="line">    <span class="keyword">if</span>( time &gt; maxTime) maxTime=time;</span><br><span class="line">    <span class="keyword">if</span>( time &lt; minTime) minTime=time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过阅读源码，我们发现了几个关键点。现罗列如下，后面我们会逐一分析这些关键点相关的源码。</p>
<ol>
<li>关键点1：这儿调用Wrapper的allocate()方法分配一个Servlet实例</li>
<li>关键点2，创建过滤器链，类似于Pipeline的功能</li>
<li>关键点3，调用过滤器链的doFilter，最终会调用到Servlet的service方法</li>
<li>关键点4，释放掉过滤器链及其相关资源</li>
<li>关键点5，释放掉Servlet及相关资源</li>
<li>关键点6，如果servlet被标记为永远不可达，则需要卸载掉它，并释放这个servlet实例</li>
</ol>
<p><strong>关键点1 - Wrapper分配Servlet实例</strong></p>
<p>我们来分析一下Wrapper.allocate()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Servlet <span class="title">allocate</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are currently unloading this servlet, throw an exception</span></span><br><span class="line">    <span class="comment">// 卸载过程中，不能分配Servlet</span></span><br><span class="line">    <span class="keyword">if</span> (unloading) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(sm.getString(<span class="string">&quot;standardWrapper.unloading&quot;</span>, getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> newInstance = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If not SingleThreadedModel, return the same instance every time</span></span><br><span class="line">    <span class="comment">// 如果Wrapper没有实现SingleThreadedModel，则每次都会返回同一个Servlet</span></span><br><span class="line">    <span class="keyword">if</span> (!singleThreadModel) &#123;</span><br><span class="line">        <span class="comment">// Load and initialize our instance if necessary</span></span><br><span class="line">        <span class="comment">// 实例为null或者实例还未初始化，使用synchronized来保证并发时的原子性</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span> || !instanceInitialized) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;Allocating non-STM instance&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Note: We don&#x27;t know if the Servlet implements</span></span><br><span class="line">                        <span class="comment">// SingleThreadModel until we have loaded it.</span></span><br><span class="line">                        <span class="comment">// 加载Servlet</span></span><br><span class="line">                        instance = loadServlet();</span><br><span class="line">                        newInstance = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!singleThreadModel) &#123;</span><br><span class="line">                            <span class="comment">// For non-STM, increment here to prevent a race</span></span><br><span class="line">                            <span class="comment">// condition with unload. Bug 43683, test case</span></span><br><span class="line">                            <span class="comment">// #3</span></span><br><span class="line">                            countAllocated.incrementAndGet();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        ExceptionUtils.handleThrowable(e);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(sm.getString(<span class="string">&quot;standardWrapper.allocate&quot;</span>), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 初始化Servlet</span></span><br><span class="line">                <span class="keyword">if</span> (!instanceInitialized) &#123;</span><br><span class="line">                    initServlet(instance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (singleThreadModel) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newInstance) &#123;</span><br><span class="line">                <span class="comment">// Have to do this outside of the sync above to prevent a</span></span><br><span class="line">                <span class="comment">// possible deadlock</span></span><br><span class="line">                <span class="keyword">synchronized</span> (instancePool) &#123;</span><br><span class="line">                    instancePool.push(instance);</span><br><span class="line">                    nInstances++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非单线程模型，直接返回已经创建的Servlet，也就是说，这种情况下只会创建一个Servlet</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(<span class="string">&quot;  Returning non-STM instance&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// For new instances, count will have been incremented at the</span></span><br><span class="line">            <span class="comment">// time of creation</span></span><br><span class="line">            <span class="keyword">if</span> (!newInstance) &#123;</span><br><span class="line">                countAllocated.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是单线程模式，则使用servlet对象池技术来加载多个Servlet</span></span><br><span class="line">    <span class="keyword">synchronized</span> (instancePool) &#123;</span><br><span class="line">        <span class="keyword">while</span> (countAllocated.get() &gt;= nInstances) &#123;</span><br><span class="line">            <span class="comment">// Allocate a new instance if possible, or else wait</span></span><br><span class="line">            <span class="keyword">if</span> (nInstances &lt; maxInstances) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    instancePool.push(loadServlet());</span><br><span class="line">                    nInstances++;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    ExceptionUtils.handleThrowable(e);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(sm.getString(<span class="string">&quot;standardWrapper.allocate&quot;</span>), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    instancePool.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// Ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;  Returning allocated STM instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        countAllocated.incrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> instancePool.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下来，注意以下几点即可：</p>
<ol>
<li>卸载过程中，不能分配Servlet</li>
<li>如果不是单线程模式，则每次都会返回同一个Servlet（默认Servlet实现方式）</li>
<li><code>Servlet</code>实例为<code>null</code>或者<code>Servlet</code>实例还<code>未初始化</code>，使用synchronized来保证并发时的原子性</li>
<li>如果是单线程模式，则使用servlet对象池技术来加载多个Servlet</li>
</ol>
<p>接下来我们看看<code>loadServlet()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Servlet <span class="title">loadServlet</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Nothing to do if we already have an instance or an instance pool</span></span><br><span class="line">    <span class="keyword">if</span> (!singleThreadModel &amp;&amp; (instance != <span class="keyword">null</span>))</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line">    PrintStream out = System.out;</span><br><span class="line">    <span class="keyword">if</span> (swallowOutput) &#123;</span><br><span class="line">        SystemLogHandler.startCapture();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Servlet servlet;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> t1=System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// Complain if no servlet class has been specified</span></span><br><span class="line">        <span class="keyword">if</span> (servletClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            unavailable(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException</span><br><span class="line">                (sm.getString(<span class="string">&quot;standardWrapper.notClass&quot;</span>, getName()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键的地方，就是通过实例管理器，创建Servlet实例，而实例管理器是通过特殊的类加载器来加载给定的类</span></span><br><span class="line">        InstanceManager instanceManager = ((StandardContext)getParent()).getInstanceManager();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            servlet = (Servlet) instanceManager.newInstance(servletClass);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            unavailable(<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// Restore the context ClassLoader</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException</span><br><span class="line">                (sm.getString(<span class="string">&quot;standardWrapper.notServlet&quot;</span>, servletClass), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">            ExceptionUtils.handleThrowable(e);</span><br><span class="line">            unavailable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Added extra log statement for Bugzilla 36630:</span></span><br><span class="line">            <span class="comment">// https://bz.apache.org/bugzilla/show_bug.cgi?id=36630</span></span><br><span class="line">            <span class="keyword">if</span>(log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(sm.getString(<span class="string">&quot;standardWrapper.instantiate&quot;</span>, servletClass), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Restore the context ClassLoader</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException</span><br><span class="line">                (sm.getString(<span class="string">&quot;standardWrapper.instantiate&quot;</span>, servletClass), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (multipartConfigElement == <span class="keyword">null</span>) &#123;</span><br><span class="line">            MultipartConfig annotation =</span><br><span class="line">                    servlet.getClass().getAnnotation(MultipartConfig.class);</span><br><span class="line">            <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                multipartConfigElement =</span><br><span class="line">                        <span class="keyword">new</span> MultipartConfigElement(annotation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Special handling for ContainerServlet instances</span></span><br><span class="line">        <span class="comment">// Note: The InstanceManager checks if the application is permitted</span></span><br><span class="line">        <span class="comment">//       to load ContainerServlets</span></span><br><span class="line">        <span class="keyword">if</span> (servlet <span class="keyword">instanceof</span> ContainerServlet) &#123;</span><br><span class="line">            ((ContainerServlet) servlet).setWrapper(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        classLoadTime=(<span class="keyword">int</span>) (System.currentTimeMillis() -t1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (servlet <span class="keyword">instanceof</span> SingleThreadModel) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instancePool == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instancePool = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            singleThreadModel = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用Servlet的init方法</span></span><br><span class="line">        initServlet(servlet);</span><br><span class="line"></span><br><span class="line">        fireContainerEvent(<span class="string">&quot;load&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        loadTime=System.currentTimeMillis() -t1;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (swallowOutput) &#123;</span><br><span class="line">            String log = SystemLogHandler.stopCapture();</span><br><span class="line">            <span class="keyword">if</span> (log != <span class="keyword">null</span> &amp;&amp; log.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getServletContext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    getServletContext().log(log);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    out.println(log);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> servlet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键的地方有两个：</p>
<ol>
<li>通过实例管理器，创建Servlet实例，而实例管理器是通过特殊的类加载器来加载给定的类</li>
<li>调用Servlet的init方法</li>
</ol>
<p><strong>关键点2 - 创建过滤器链</strong></p>
<p>创建过滤器链是调用的<code>org.apache.catalina.core.ApplicationFilterFactory</code>的<code>createFilterChain()</code>方法。我们来分析一下这个方法。该方法需要注意的地方已经在代码的comments里面说明了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationFilterChain <span class="title">createFilterChain</span><span class="params">(ServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">        Wrapper wrapper, Servlet servlet)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there is no servlet to execute, return null</span></span><br><span class="line">    <span class="keyword">if</span> (servlet == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and initialize a filter chain object</span></span><br><span class="line">    <span class="comment">// 1. 如果加密打开了，则可能会多次调用这个方法</span></span><br><span class="line">    <span class="comment">// 2. 为了避免重复生成filterChain对象，所以会将filterChain对象放在Request里面进行缓存</span></span><br><span class="line">    ApplicationFilterChain filterChain = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (request <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">        Request req = (Request) request;</span><br><span class="line">        <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">            <span class="comment">// Security: Do not recycle</span></span><br><span class="line">            filterChain = <span class="keyword">new</span> ApplicationFilterChain();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            filterChain = (ApplicationFilterChain) req.getFilterChain();</span><br><span class="line">            <span class="keyword">if</span> (filterChain == <span class="keyword">null</span>) &#123;</span><br><span class="line">                filterChain = <span class="keyword">new</span> ApplicationFilterChain();</span><br><span class="line">                req.setFilterChain(filterChain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Request dispatcher in use</span></span><br><span class="line">        filterChain = <span class="keyword">new</span> ApplicationFilterChain();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    filterChain.setServlet(servlet);</span><br><span class="line">    filterChain.setServletSupportsAsync(wrapper.isAsyncSupported());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire the filter mappings for this Context</span></span><br><span class="line">    StandardContext context = (StandardContext) wrapper.getParent();</span><br><span class="line">    <span class="comment">// 从这儿看出过滤器链对象里面的元素是根据Context里面的filterMaps来生成的</span></span><br><span class="line">    FilterMap filterMaps[] = context.findFilterMaps();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are no filter mappings, we are done</span></span><br><span class="line">    <span class="keyword">if</span> ((filterMaps == <span class="keyword">null</span>) || (filterMaps.length == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> (filterChain);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire the information we will need to match filter mappings</span></span><br><span class="line">    DispatcherType dispatcher =</span><br><span class="line">            (DispatcherType) request.getAttribute(Globals.DISPATCHER_TYPE_ATTR);</span><br><span class="line"></span><br><span class="line">    String requestPath = <span class="keyword">null</span>;</span><br><span class="line">    Object attribute = request.getAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR);</span><br><span class="line">    <span class="keyword">if</span> (attribute != <span class="keyword">null</span>)&#123;</span><br><span class="line">        requestPath = attribute.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String servletName = wrapper.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the relevant path-mapped filters to this filter chain</span></span><br><span class="line">    <span class="comment">// 类型和路径都匹配的情况下，将context.filterConfig放到过滤器链里面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!matchDispatcher(filterMaps[i] ,dispatcher)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!matchFiltersURL(filterMaps[i], requestPath))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)</span><br><span class="line">            context.findFilterConfig(filterMaps[i].getFilterName());</span><br><span class="line">        <span class="keyword">if</span> (filterConfig == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// FIXME - log configuration problem</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.addFilter(filterConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add filters that match on servlet name second</span></span><br><span class="line">    <span class="comment">// 类型和servlet名称都匹配的情况下，将context.filterConfig放到过滤器链里面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!matchDispatcher(filterMaps[i] ,dispatcher)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!matchFiltersServlet(filterMaps[i], servletName))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)</span><br><span class="line">            context.findFilterConfig(filterMaps[i].getFilterName());</span><br><span class="line">        <span class="keyword">if</span> (filterConfig == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// FIXME - log configuration problem</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.addFilter(filterConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the completed filter chain</span></span><br><span class="line">    <span class="keyword">return</span> filterChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点3 - 调用过滤器链的doFilter</strong></p>
<p>ApplicationFilterChain类的doFilter函数代码如下,它会将处理委托给internalDoFilter函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">        <span class="keyword">final</span> ServletRequest req = request;</span><br><span class="line">        <span class="keyword">final</span> ServletResponse res = response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.security.AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> java.security.PrivilegedExceptionAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">                        internalDoFilter(req,res);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">catch</span>( PrivilegedActionException pe) &#123;</span><br><span class="line">            Exception e = pe.getException();</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ServletException)</span><br><span class="line">                <span class="keyword">throw</span> (ServletException) e;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IOException)</span><br><span class="line">                <span class="keyword">throw</span> (IOException) e;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RuntimeException)</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        internalDoFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationFilterChain类的internalDoFilter函数代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. `internalDoFilter`方法通过pos和n来调用过滤器链里面的每个过滤器。pos表示当前的过滤器下标，n表示总的过滤器数量</span></span><br><span class="line"><span class="comment">// 2. `internalDoFilter`方法最终会调用servlet.service()方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalDoFilter</span><span class="params">(ServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the next filter if there is one</span></span><br><span class="line">    <span class="comment">// 1. 当pos小于n时, 则执行Filter</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 2. 得到 过滤器 Filter，执行一次post++</span></span><br><span class="line">        ApplicationFilterConfig filterConfig = filters[pos++];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Filter filter = filterConfig.getFilter();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (request.isAsyncSupported() &amp;&amp; <span class="string">&quot;false&quot;</span>.equalsIgnoreCase(</span><br><span class="line">                    filterConfig.getFilterDef().getAsyncSupported())) &#123;</span><br><span class="line">                request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">                <span class="keyword">final</span> ServletRequest req = request;</span><br><span class="line">                <span class="keyword">final</span> ServletResponse res = response;</span><br><span class="line">                Principal principal =</span><br><span class="line">                    ((HttpServletRequest) req).getUserPrincipal();</span><br><span class="line"></span><br><span class="line">                Object[] args = <span class="keyword">new</span> Object[]&#123;req, res, <span class="keyword">this</span>&#125;;</span><br><span class="line">                SecurityUtil.doAsPrivilege (<span class="string">&quot;doFilter&quot;</span>, filter, classType, args, principal);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 4. 这里的 filter 的执行 有点递归的感觉, 通过 pos 来控制从 filterChain 里面拿出那个 filter 来进行操作</span></span><br><span class="line">                <span class="comment">// 这里把this（filterChain）传到自定义filter里面，我们自定义的filter，会重写doFilter，在这里会被调用，doFilter里面会执行业务逻辑，如果执行业务逻辑成功，则会调用 filterChain.doFilter(servletRequest, servletResponse); ，filterChain就是这里传过去的this；如果业务逻辑执行失败，则return，filterChain终止，后面的servlet.service(request, response)也不会执行了</span></span><br><span class="line">                <span class="comment">// 所以在 Filter 里面所调用 return, 则会终止 Filter 的调用, 而下面的 Servlet.service 更本就没有调用到</span></span><br><span class="line">                filter.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">            ExceptionUtils.handleThrowable(e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(sm.getString(<span class="string">&quot;filterChain.filter&quot;</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We fell off the end of the chain -- call the servlet instance</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">            lastServicedRequest.set(request);</span><br><span class="line">            lastServicedResponse.set(response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123;</span><br><span class="line">            request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,</span><br><span class="line">                    Boolean.FALSE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Use potentially wrapped request from this point</span></span><br><span class="line">        <span class="keyword">if</span> ((request <span class="keyword">instanceof</span> HttpServletRequest) &amp;&amp;</span><br><span class="line">                (response <span class="keyword">instanceof</span> HttpServletResponse) &amp;&amp;</span><br><span class="line">                Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">            <span class="keyword">final</span> ServletRequest req = request;</span><br><span class="line">            <span class="keyword">final</span> ServletResponse res = response;</span><br><span class="line">            Principal principal =</span><br><span class="line">                ((HttpServletRequest) req).getUserPrincipal();</span><br><span class="line">            Object[] args = <span class="keyword">new</span> Object[]&#123;req, res&#125;;</span><br><span class="line">            SecurityUtil.doAsPrivilege(<span class="string">&quot;service&quot;</span>,</span><br><span class="line">                                       servlet,</span><br><span class="line">                                       classTypeUsedInService,</span><br><span class="line">                                       args,</span><br><span class="line">                                       principal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当pos等于n时，过滤器都执行完毕，终于执行了熟悉的servlet.service(request, response)方法。</span></span><br><span class="line">            servlet.service(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(sm.getString(<span class="string">&quot;filterChain.servlet&quot;</span>), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">            lastServicedRequest.set(<span class="keyword">null</span>);</span><br><span class="line">            lastServicedResponse.set(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义Filter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;myfilter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileterController</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter初始化中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;登录逻辑&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;登录失败&quot;</span>)&#123;</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">            <span class="comment">//后面的拦截器和servlet都不会执行了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//登录成功，执行下一个过滤器</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter销毁中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>pos和n是ApplicationFilterChain的成员变量，分别表示过滤器链的当前位置和过滤器总数，所以当pos小于n时，会不断执行ApplicationFilterChain的doFilter方法；</strong></li>
<li><strong>当pos等于n时，过滤器都执行完毕，终于执行了熟悉的servlet.service(request, response)方法。</strong></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Soy-technology/p/11223604.html">Tomcat源码分析（下载、启动）</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/12/04/%E6%9C%8D%E5%8A%A1%E5%99%A8-Apache-Tomcat-2-2/">https://pingxin0521.gitee.io/2019/12/04/%E6%9C%8D%E5%8A%A1%E5%99%A8-Apache-Tomcat-2-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a><a class="post-meta__tags" href="/tags/Tomcat/">Tomcat</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/12/05/%E6%9C%8D%E5%8A%A1%E5%99%A8-Apache-Tomcat-2-3/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Apache Tomcat 源码分析 (三)</div></div></a></div><div class="next-post pull-right"><a href="/2019/12/03/%E6%9C%8D%E5%8A%A1%E5%99%A8-Apache-Tomcat-2-1/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Apache Tomcat 源码分析 (一)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/06/01/服务器-Apache-Httpd-3/" title="Apache Httpd配置tomcat集群"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-06-02</div><div class="title">Apache Httpd配置tomcat集群</div></div></a></div><div><a href="/2020/05/09/服务器-Apache-Tomcat-1-2/" title="Apache Tomcat 优化"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-05-31</div><div class="title">Apache Tomcat 优化</div></div></a></div><div><a href="/2019/10/31/服务器-Apache-Tomcat-2-0/" title="Apache Tomcat 源码 (零)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-05-31</div><div class="title">Apache Tomcat 源码 (零)</div></div></a></div><div><a href="/2019/12/05/服务器-Apache-Tomcat-2-3/" title="Apache Tomcat 源码分析 (三)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-05-31</div><div class="title">Apache Tomcat 源码分析 (三)</div></div></a></div><div><a href="/2019/04/03/服务器-Apache-Tomcat-1-1/" title="Apache Tomcat入门"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-05-31</div><div class="title">Apache Tomcat入门</div></div></a></div><div><a href="/2019/12/03/服务器-Apache-Tomcat-2-1/" title="Apache Tomcat 源码分析 (一)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-05-31</div><div class="title">Apache Tomcat 源码分析 (一)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Tomcat的启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bootstrap"><span class="toc-number">1.1.</span> <span class="toc-text">Bootstrap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-Initialisation"><span class="toc-number">1.2.</span> <span class="toc-text">初始化 Initialisation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Catalina-load"><span class="toc-number">1.2.1.</span> <span class="toc-text">Catalina.load()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StandardServer-init"><span class="toc-number">1.2.2.</span> <span class="toc-text">StandardServer.init()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StandardService-init"><span class="toc-number">1.2.3.</span> <span class="toc-text">StandardService.init()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Context-init"><span class="toc-number">1.2.4.</span> <span class="toc-text">Context.init()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8-Start"><span class="toc-number">1.3.</span> <span class="toc-text">启动 Start</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Catalina-start"><span class="toc-number">1.3.1.</span> <span class="toc-text">Catalina.start()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Service-start"><span class="toc-number">1.3.2.</span> <span class="toc-text">Service.start()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MapperListener"><span class="toc-number">1.3.3.</span> <span class="toc-text">MapperListener</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StandardThreadExecutor"><span class="toc-number">1.3.4.</span> <span class="toc-text">StandardThreadExecutor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Connector"><span class="toc-number">1.3.5.</span> <span class="toc-text">Connector</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Containers"><span class="toc-number">1.4.</span> <span class="toc-text">Containers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HostConfig"><span class="toc-number">1.5.</span> <span class="toc-text">HostConfig</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#deployApps"><span class="toc-number">1.5.1.</span> <span class="toc-text">deployApps()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Context-start"><span class="toc-number">1.6.</span> <span class="toc-text">Context.start()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ContextConfig-configureStart"><span class="toc-number">1.7.</span> <span class="toc-text">ContextConfig.configureStart()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Http%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">Http请求处理过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Connector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%85%A5%E5%8F%A3"><span class="toc-number">2.1.</span> <span class="toc-text">Connector源码分析入口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Connector%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">Connector构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Connector-init"><span class="toc-number">2.1.2.</span> <span class="toc-text">Connector.init()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Connector-start"><span class="toc-number">2.1.3.</span> <span class="toc-text">Connector.start()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Connector%E8%AF%B7%E6%B1%82%E9%80%BB%E8%BE%91"><span class="toc-number">2.2.</span> <span class="toc-text">Connector请求逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Acceptor"><span class="toc-number">2.3.</span> <span class="toc-text">Acceptor</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Poller"><span class="toc-number">2.3.1.</span> <span class="toc-text">Poller</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PollerEvent"><span class="toc-number">2.3.2.</span> <span class="toc-text">PollerEvent</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E8%AE%BFPoller"><span class="toc-number">2.3.3.</span> <span class="toc-text">重访Poller</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Processor"><span class="toc-number">2.3.4.</span> <span class="toc-text">Processor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Adapter"><span class="toc-number">2.3.5.</span> <span class="toc-text">Adapter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">2.3.6.</span> <span class="toc-text">请求预处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%A4%84%E7%90%86"><span class="toc-number">2.3.7.</span> <span class="toc-text">容器处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Engine%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="toc-number">2.4.</span> <span class="toc-text">Engine处理请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Host%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="toc-number">2.5.</span> <span class="toc-text">Host处理请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Context%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="toc-number">2.6.</span> <span class="toc-text">Context处理请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Wrapper%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="toc-number">2.7.</span> <span class="toc-text">Wrapper处理请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">3.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
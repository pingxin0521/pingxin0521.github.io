<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据结构--树和二叉树 | 平心de小屋</title><meta name="keywords" content="数据结构"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、2-3树、红黑树等等。本文中对数据结构中常见的几种树的概念和用途进行了汇总，不求严格精准，但求简单易懂。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构--树和二叉树">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-1/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、2-3树、红黑树等等。本文中对数据结构中常见的几种树的概念和用途进行了汇总，不求严格精准，但求简单易懂。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg">
<meta property="article:published_time" content="2019-05-04T02:18:59.000Z">
<meta property="article:modified_time" content="2019-10-18T07:41:12.000Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构--树和二叉树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2019-10-18 15:41:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构--树和二叉树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-05-04T02:18:59.000Z" title="发表于 2019-05-04 10:18:59">2019-05-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-10-18T07:41:12.000Z" title="更新于 2019-10-18 15:41:12">2019-10-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构--树和二叉树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、2-3树、红黑树等等。本文中对数据结构中常见的几种树的概念和用途进行了汇总，不求严格精准，但求简单易懂。</p>
<span id="more"></span>

<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p><strong>树（Tree）</strong>是n（n&gt;=0)个结点的有限集。n=0时称为空树。在任意一颗非空树中：<br> 1）有且仅有一个特定的称为根（Root）的结点；<br> 2）当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、……、Tn，其中每一个集合本身又是一棵树，并且称为根的子树。</p>
<p>此外，树的定义还需要强调以下两点：<br> 1）n&gt;0时根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点。<br> 2）m&gt;0时，子树的个数没有限制，但它们一定是互不相交的。<br> 示例树：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/19/5d0a0de69760022508.png" alt="1.png"></p>
<p>由树的定义可以看出，树的定义使用了递归的方式。递归在树的学习过程中起着重要作用</p>
<p><strong>结点的度</strong></p>
<p>结点拥有的子树数目称为结点的<strong>度</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/19/5d0a0de6affd611835.png" alt="2.png"></p>
<p><strong>二叉树的度</strong></p>
<p>通俗的讲二叉树中连接节点和节点的线就是度，有n个节点，就有n-1个度，节点数总是比度要多一个，那么度为0的节点一定是叶子节点，因为该节点的下面不再有线；度为1的节点即：该节点只有一个分支；同理度为2的节点就是有两个分支。在二叉树中不可能存在度为3或大于3的节点！</p>
<p>关于度和节点之间的关系还有很多公式：度为0的节点数为度为2的节点数加1，即n0=n2+1<br>这个公式的推理方法如下：<br>设：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">k:总度数</span><br><span class="line">k+1:总节点数</span><br><span class="line">n0:度为0的节点</span><br><span class="line">n1:度为1的节点</span><br><span class="line">n2:度为二的节点</span><br><span class="line">根据二叉树中度和节点的守衡原理，可列出以下一组方程：</span><br><span class="line">k=n2*2+n1;</span><br><span class="line">k+1=n2+n1+n0;</span><br><span class="line">将上面两式相减得到：n0=n2+1；</span><br></pre></td></tr></table></figure>

<p>例如：已知767个节点的完全二叉树，求其叶子节点个数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n=n0+n1+n2;</span><br></pre></td></tr></table></figure>

<p>由上面，消掉n2得到：<code>n=2n0+n1-1;</code></p>
<p>由于完全二叉树度为1的只有0个或1个两种情况，所以，将0或1带入上面公式，整理后得：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n0=（n+1）/2或者n0=n/2;</span><br></pre></td></tr></table></figure>

<p>看看n是否能被2整除，能则用<code>n0=n/2</code>。否则用<code>n0=（n+1）/2</code></p>
<p>既叶子节点为<code>n0=（n+1）/2=384</code></p>
<p>再比如一棵二叉树有10个度为1的节点，7个度为2的节点，则二叉树有多少个节点（25）</p>
<p>根据刚才说的，节点数比度数多1，可以列出计算式子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 * 1 + 7 * 2 + 1 = 25</span><br></pre></td></tr></table></figure>

<p><strong>结点关系</strong></p>
<p>结点子树的根结点为该结点的<strong>孩子结点</strong>。相应该结点称为孩子结点的<strong>双亲结点</strong>。</p>
<p>上图，A为B的双亲结点，B为A的孩子结点。</p>
<p>同一个双亲结点的孩子结点之间互称<strong>兄弟结点</strong>。<br>上图，结点B与结点C互为兄弟结点。</p>
<p><strong>结点层次</strong></p>
<p>从根开始定义起，根为第一层，根的孩子为第二层，以此类推。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/19/5d0a0de6aff5129603.png" alt="3.png"></p>
<p> <strong>树的深度</strong></p>
<p>树中结点的最大层次数称为树的深度或高度。上图所示树的深度为4。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构。</p>
<p><strong>二叉树的定义：</strong>二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2i-1个结点；深度为k的二叉树至多有2k-1个结点；对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。</p>
<p><strong>二叉树的示例</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/19/5d0a0eae2082a99428.png" alt="1.png"></p>
<p><strong>满二叉树和完全二叉树：</strong></p>
<p>满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。</p>
<p>满二叉树的性质：</p>
<ul>
<li><p>一颗树深度为h，最大层数为k，深度与最大层数相同，k=h;</p>
</li>
<li><p>叶子数为2h;</p>
</li>
<li><p> 第k层的结点数是：2k-1;</p>
</li>
<li><p>总结点数是：2k-1，且总节点数一定是奇数。</p>
</li>
</ul>
<p>完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。</p>
<p><strong>注：</strong>完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/15/5d0457b91d9d394312.png" alt="2.png"></p>
<p><strong>二叉树的性质：</strong></p>
<ul>
<li>在非空二叉树中，第i层的结点总数不超过2^(i-1), i&gt;=1;</li>
<li> 深度为h的二叉树最多有2^h-1个结点(h&gt;=1)，最少有h个结点;</li>
<li>对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;</li>
<li>具有n个结点的完全二叉树的深度为log2(n+1);</li>
<li>有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：<ul>
<li>若i为结点编号则 如果i&gt;1，则其父结点的编号为i/2；</li>
<li>如果2i&lt;=N，则其左儿子（即左子树的根结点）的编号为2i；若2i&gt;N，则无左儿子；</li>
<li>如果2i+1&lt;=N，则其右儿子的结点编号为2i+1；若2i+1&gt;N，则无右儿子。</li>
</ul>
</li>
<li>给定N个节点，能构成h(N)种不同的二叉树，其中h(N)为卡特兰数的第N项，h(n)=C(2*n, n)/(n+1)。</li>
<li>设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i。</li>
</ul>
<h5 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h5><p><strong>顺序存储</strong></p>
<p>二叉树的顺序存储结构中节点的存放次序是：对该树中每个节点进行编号，其编号从小到大的顺序就是节点存放在连续存储单元的先后次序。</p>
<p> 若把二叉树存储到一维数组中,则该编号就是下标值加1（注意C/C++语言中数组的起始下标为0）。</p>
<p>树中各节点的编号与等高度的完全二叉树中对应位置上节点的编号相同。 </p>
<p>定义为节点内包含的数据类型的数组</p>
<p>顺序二叉树，如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/19/5d0a106b488ab37677.png" alt="1.png"></p>
<p>字符串：<code>&quot;#ABD#C#E######F&quot;;</code></p>
<p><strong>链式存储</strong></p>
<p>在二叉树的链接存储中，节点的结构如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T val;</span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode left;</span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(BinaryTreeNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(BinaryTreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，val表示值域，用于存储对应的数据元素，left和right分别表示左指针域和右指针域，用于分别存储左孩子节点和右孩子节点（即左、右子树的根节点）的存储位置。</p>
<h5 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h5><p>创建二叉树，一般有两种情况：初始化一个根节点或者初始化一棵空二叉树。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树的清空"><a href="#二叉树的清空" class="headerlink" title="二叉树的清空"></a>二叉树的清空</h5><p>对于二叉树的清空，首先提供一个清空某个节点为根节点的子树的方法，即递归的删除每个节点；接着提供删除一个删除树的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树的清空：</span></span><br><span class="line"><span class="comment">     * 首先提供一个清空以某个节点为根节点的子树的方法，既递归地删除每个节点；</span></span><br><span class="line"><span class="comment">     * 接着提供一个删除树的方法，直接通过第一种方法删除到根节点即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//清除某个子树的所有节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">            clear(node.getLeft());</span><br><span class="line">            clear(node.getRight());</span><br><span class="line">            node.setLeft(<span class="keyword">null</span>);</span><br><span class="line">            node.setRight(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear1</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;BinaryTreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            BinaryTreeNode n = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (n.getLeft()!=<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                queue.offer(n.getLeft());</span><br><span class="line">                n.setLeft(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n.getRight()!=<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                queue.offer(n.getRight());</span><br><span class="line">                n.setRight(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        clear(root);</span><br><span class="line">        root=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="判断二叉树是否为空"><a href="#判断二叉树是否为空" class="headerlink" title="判断二叉树是否为空"></a>判断二叉树是否为空</h5><p>只需判断根节点是否存在即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断二叉树是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="求二叉树的高度"><a href="#求二叉树的高度" class="headerlink" title="求二叉树的高度"></a>求二叉树的高度</h5><p>思路：首先需要一种获取以某个节点为子树的高度方法，使用递归实现。如果一个节点为空，那么这个节点肯定是一颗空树，高度为0；如果不为空，则遍历地比较它的左右子树高度，高的一个为这颗子树的最大高度，然后加上自身的高度即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求二叉树的高度：</span></span><br><span class="line"><span class="comment"> * 首先要一种获取以某个节点为子树的高度的方法，使用递归调用。</span></span><br><span class="line"><span class="comment"> * 如果一个节点为空，那么这个节点肯定是一颗空树，高度为0；</span></span><br><span class="line"><span class="comment"> * 如果不为空，那么我们要遍历地比较它的左子树高度和右子树高度，</span></span><br><span class="line"><span class="comment"> * 高的一个为这个子树的最大高度，然后加上自己本身的高度就是了</span></span><br><span class="line"><span class="comment"> * 获取二叉树的高度，只需要调用第一种方法，即传入根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//获取二叉树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">heigh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> heigh(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取以某节点为子树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">heigh</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//递归结束，空子树高度为0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//递归获取左子树高度</span></span><br><span class="line">        <span class="keyword">int</span> l = heigh(node.getLeft());</span><br><span class="line">        <span class="comment">//递归获取右子树高度</span></span><br><span class="line">        <span class="keyword">int</span> r = heigh(node.getRight());</span><br><span class="line">        <span class="comment">//高度应该算更高的一边，（+1是因为要算上自身这一层）</span></span><br><span class="line">        <span class="keyword">return</span> l &gt; r ? (l + <span class="number">1</span>) : (r + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归，使用层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">heigh1</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    Queue&lt;BinaryTreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        width=queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">            BinaryTreeNode treeNode = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (treeNode.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(treeNode.getLeft());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(treeNode.getRight());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="求二叉树的节点数"><a href="#求二叉树的节点数" class="headerlink" title="求二叉树的节点数"></a>求二叉树的节点数</h5><p>思路：获取二叉树节点数，需要获取以某个节点为根的子树的节点数实现。<br>如果节点为空，则个数肯定为0；如果不为空，则算上这个节点之后，继续递归计算所有子树的节点数，全部相加即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取二叉树的节点数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求二叉树的节点数：</span></span><br><span class="line"><span class="comment"> * 求节点数时，我们看看获取某个节点为子树的节点数的实现。</span></span><br><span class="line"><span class="comment"> * 首先节点为空，则个数肯定为0；</span></span><br><span class="line"><span class="comment"> * 如果不为空，那就算上这个节点之后继续递归所有左右子树的子节点数，</span></span><br><span class="line"><span class="comment"> * 全部相加就是以所给节点为根的子树的节点数</span></span><br><span class="line"><span class="comment"> * 如果求二叉树的节点数，则输入根节点即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//如果节点为空，则返回节点数为0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//计算本节点 所以要+1</span></span><br><span class="line">        <span class="comment">//递归获取左子树节点数和右子树节点数，最终相加</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + size(node.getLeft()) + size(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size1</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//如果节点为空，则返回节点数为0</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    Queue&lt;BinaryTreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode treeNode = queue.poll();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (treeNode.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(treeNode.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (treeNode.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(treeNode.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="返回某节点的父亲节点"><a href="#返回某节点的父亲节点" class="headerlink" title="返回某节点的父亲节点"></a>返回某节点的父亲节点</h5><p>思路：首先，同样需要通过一种方法来获取某个节点在某个子树中的父节点，这里使用递归实现，接着通过这种方法获取这个节点在二叉树中的父节点<br>事实上，以现有的这种二叉树的形式，我们并没有办法直接获取一个节点的父节点，  这里只能通过从根节点遍历来比较获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node节点在subTree子树中的父节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getParent</span><span class="params">(BinaryTreeNode subTree,BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(subTree==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;   <span class="comment">//如果是空子树，则没有父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(subTree.getLeftChirld()==node || subTree.getRightChirld() == node)&#123;</span><br><span class="line">        <span class="keyword">return</span> subTree;   <span class="comment">//如果子树的根节点的左右孩子之一是待查节点，则返回子树的根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    BinaryTreeNode parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(getParent(subTree.getLeftChirld(),node)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        parent = getParent(subTree.getLeftChirld(),node);</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//递归左右子树</span></span><br><span class="line">        <span class="keyword">return</span> getParent(subTree.getRightChirld(),node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找node节点在二叉树中的父节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getParent</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (root==<span class="keyword">null</span>||root==node)? <span class="keyword">null</span>:getParent(root,node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="返回左右子树"><a href="#返回左右子树" class="headerlink" title="返回左右子树"></a>返回左右子树</h5><p>这个操作很简单，直接用节点的方法来获取即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取某个节点的左子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getleftTree</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node.getLeftChirld();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取某个节点的右子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getrightTree</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node.getRightChirld();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树的插入"><a href="#二叉树的插入" class="headerlink" title="二叉树的插入"></a>二叉树的插入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给某个节点插入左节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertLeft</span><span class="params">(BinaryTreeNode parent,BinaryTreeNode newnode)</span></span>&#123;</span><br><span class="line">    parent.setLeftChirld(newnode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给某个节点插入右节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertRitht</span><span class="params">(BinaryTreeNode parent,BinaryTreeNode newnode)</span></span>&#123;</span><br><span class="line">    parent.setRightChirld(newnode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h5><p>二叉树的遍历是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。<br> 二叉树的访问次序可以分为四种：</p>
<blockquote>
<p>前序遍历<br> 中序遍历<br> 后序遍历<br> 层序遍历</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/19/5d0a372939eca26594.png" alt="1.png"></p>
<ol>
<li><p><strong>前序遍历</strong>通俗的说就是从二叉树的根结点出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。</p>
<ul>
<li>从根结点出发，则第一次到达结点A，故输出A;</li>
<li>继续向左访问，第一次访问结点B，故输出B；</li>
<li>按照同样规则，输出D，输出H；</li>
<li>当到达叶子结点H，返回到D，此时已经是第二次到达D，故不在输出D，进而向D右子树访问，D右子树不为空，则访问至I，第一次到达I，则输出I；</li>
<li>I为叶子结点，则返回到D，D左右子树已经访问完毕，则返回到B，进而到B右子树，第一次到达E，故输出E；</li>
<li>向E左子树，故输出J；</li>
<li>按照同样的访问规则，继续输出C、F、G；</li>
</ul>
<p>前序遍历输出为：<strong>ABDHIEJCFG</strong></p>
</li>
<li><p><strong>中序遍历</strong>就是从二叉树的根结点出发，当第二次到达结点时就输出结点数据，按照先向左在向右的方向访问。</p>
<ul>
<li>从根结点出发，则第一次到达结点A，不输出A，继续向左访问，第一次访问结点B，不输出B；继续到达D，H；</li>
<li>到达H，H左子树为空，则返回到H，此时第二次访问H，故输出H；</li>
<li>H右子树为空，则返回至D，此时第二次到达D，故输出D；</li>
<li>由D返回至B，第二次到达B，故输出B；</li>
<li>按照同样规则继续访问，输出J、E、A、F、C、G；</li>
</ul>
<p>中序遍历输出为：<strong>HDIBJEAFCG</strong></p>
</li>
<li><p><strong>后序遍历</strong>就是从二叉树的根结点出发，当第三次到达结点时就输出结点数据，按照先向左在向右的方向访问。</p>
<ul>
<li>从根结点出发，则第一次到达结点A，不输出A，继续向左访问，第一次访问结点B，不输出B；继续到达D，H；</li>
<li>到达H，H左子树为空，则返回到H，此时第二次访问H，不输出H；</li>
<li>H右子树为空，则返回至H，此时第三次到达H，故输出H；</li>
<li>由H返回至D，第二次到达D，不输出D；</li>
<li>继续访问至I，I左右子树均为空，故第三次访问I时，输出I；</li>
<li>返回至D，此时第三次到达D，故输出D；</li>
<li>按照同样规则继续访问，输出J、E、B、F、G、C，A；</li>
</ul>
<p>后序遍历输出为：<strong>HIDJEBFGCA</strong></p>
</li>
<li><p>层次遍历就是按照树的层次自上而下的遍历二叉树。层次遍历结果为：<strong>ABCDEFGHIJ</strong></p>
<p>编程关键点：【建立一个队列】</p>
</li>
</ol>
<p>虽然二叉树的遍历过程看似繁琐，但是由于二叉树是一种递归定义的结构，故采用递归方式遍历二叉树的代码十分简单。</p>
<p>递归实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树的前序遍历递归算法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(node.getVal());</span><br><span class="line">        PreOrderTraverse(node.getLeft());</span><br><span class="line">        PreOrderTraverse(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//前序遍历非递归方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreOrderNonRec</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;BinaryTreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        System.out.print(node.getVal());</span><br><span class="line">        stack.push(node);</span><br><span class="line">        node=node.getLeft();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()||node!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node!=<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(node.getVal());</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node=node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            node=stack.pop().getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*二叉树的中序遍历递归算法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        InOrderTraverse(node.getLeft());</span><br><span class="line">        System.out.print(node.getVal());</span><br><span class="line">        InOrderTraverse(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*二叉树的中序遍历非递归算法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InOrderNonRec</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;BinaryTreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(node);</span><br><span class="line">        node=node.getLeft();</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() || node!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node!=<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node=node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(stack.peek());</span><br><span class="line">            node=stack.pop().getRight();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*二叉树的后序遍历递归算法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PostOrderTraverse(node.getLeft());</span><br><span class="line">        PostOrderTraverse(node.getRight());</span><br><span class="line">        System.out.print(node.getVal());</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/*二叉树的后序遍历非递归算法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PostOrderNonRec</span><span class="params">(BinaryTreeNode node, Function f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryTreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            node = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> ((node.getLeft() == <span class="keyword">null</span> &amp;&amp; node.getRight() == <span class="keyword">null</span>) ||</span><br><span class="line">                    (pre != <span class="keyword">null</span> &amp;&amp; (pre == node.getLeft() || pre == node.getRight()))) &#123;</span><br><span class="line">                f.function(node.getVal());</span><br><span class="line">                pre = node;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(node.getRight());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(node.getLeft());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BinaryTreeNode node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryTreeNode p=node;</span><br><span class="line">        Queue&lt;BinaryTreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(p);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            p=queue.poll();</span><br><span class="line">            System.out.println(p.getVal());</span><br><span class="line">            <span class="keyword">if</span> (p.getLeft()!=<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                queue.offer(p.getLeft());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.getRight()!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(p.getRight());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>哈夫曼树（Huffman Tree）是最优二叉树。给定n个权值作为n个叶子的结点，构造一棵二叉树，若树的带权路径长度达到最小，这棵树则被称为哈夫曼树</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/10/18/zDbUqkLAOIH6ghS.png" alt="UTOOLS1571383580764.png"></p>
<p><strong>路径和长度</strong></p>
<p><strong>定义：</strong>在一棵树中，从一个结点往下可以达到的孩子和孙子结点之间的通路称为路径。路径中分支的数目称为路径长度，若根节点的的层数为 1，则从根节点到L层结点的路径长度为L-1<br><strong>例：</strong>25和36的路径长度是2，8、13、13和19的路径长度是3，6和7的路径长度是4，2和5的路径长度是5</p>
<p><strong>结点的权及带权路径长度</strong></p>
<p><strong>定义：</strong>若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。<br><strong>例：</strong>节点8的路径长度是3，它的带权路径长度= 路径长度 * 权 = 3 * 8 = 24</p>
<p><strong>树的带权路径长度</strong></p>
<p><strong>定义：</strong>树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WPL=25*2+36*2+8*3+13*3+13*3+19*3+6*4+7*4+2*5+5*5=5911</span><br></pre></td></tr></table></figure>

<p><strong>哈夫曼编码</strong></p>
<p>构造哈夫曼树的目的是为了完成哈夫曼编码，哈夫曼编码是一种变长、极少多余编码方案。相对于等长编码，将文件中每个字符转换为固定个数的二进制位，变长编码根据字符使用频率的高低，使用了不同长度的二进制位与不同字符进行映射，使得频率高的字符对应的二进制位较短，频率低的字符对应的二进制位较长。使得源文件利用哈夫曼编码后的二进制序列大小，相对于原编码方案能够有较大缩小，如此即完成了文件的压缩。哈夫曼编码能够用于实现文件的无损压缩，自然保证了文件解压缩过程的正确性，即二进制序列向字符的映射过程不会发生错乱。解码过程的正确性通过哈夫曼树的结构可以得到证明，以哈夫曼树中的每个叶子节点作为一个字符，则从根节点到每个叶子的路径都是唯一的，即不存在一个叶子节点的路径是另一个叶子节点的路径前缀。满足该特性的编码称之为前缀编码，所以哈夫曼编码中能够实现二进制到字符的正确映射。</p>
<p>假设哈夫曼树有n个权值，n个权值分别时w1,w2,w3…wn</p>
<ol>
<li>将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；</li>
<li>在森林中选出根结点的权值最小的两棵树进行合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；</li>
<li>从森林中删除选取的两棵树，并将新树加入森林；</li>
<li>重复(02)、(03)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</li>
</ol>
<p>第1步：创建森林，森林包括5棵树，这5棵树的权值是7，8，9，10，19</p>
<p>第2步：在森林中，选择根节点权值最小的两棵树7和8进行合并，将它们作为一颗新树的左右孩子，新树的权值是左右孩子的权值之和，新树的权值是15。 然后，将树7和树8从森林中删除，并将新的树(树11)添加到森林中。</p>
<p>第3步：在森林中，选择根节点权值最小的两棵树9，10进行合并。得到的新树的权值是19， 然后，将树9和树10从森林中删除，并将新的树19添加到森林中。</p>
<p>第4步：在森林中，选择根节点权值最小的两棵树15，19进行合并。得到的新树的权值是34。 然后，将树15和树19从森林中删除，并将新的树34添加到森林中。</p>
<p>第5步：在森林中，选择根节点权值最小的两棵树19和34进行合并。得到的新树的权值是53。 然后，将树19和树34从森林中删除，并将新的树53添加到森林中。</p>
<p>此时，森林中只有一棵树53。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">CreateHuffmanTree</span><span class="params">(HuffmanTree &amp;HT,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    m=<span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">    HT=<span class="keyword">new</span> HTNode[m+<span class="number">1</span>];  <span class="comment">//0号单元未用，需动态分配m+1个单元，HT[m]表示根结点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i)     <span class="comment">//将1到m号单元的双亲，左孩子，右孩子的下标初始化为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        HT[i].parent=<span class="number">0</span>;</span><br><span class="line">        HT[i].lchild=<span class="number">0</span>;</span><br><span class="line">        HT[i].rchild=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;++i) <span class="comment">//输入前n个单元中叶子结点的权值</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;HT[i].weight;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=n+<span class="number">1</span>;i&lt;m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过n-1次的选择删除合并来创建哈夫曼树</span></span><br><span class="line">        <span class="built_in">Select</span>(HT,i<span class="number">-1</span>,s1,s2);</span><br><span class="line">        <span class="comment">//在HT[k](l&lt;=k&lt;=i-1)中选择两个双亲域为0且权值最小的结点，并返回在HT中的序号s1和s2</span></span><br><span class="line">        HT[si].parent=i;</span><br><span class="line">        HT[s2].parent=i;</span><br><span class="line">        <span class="comment">//得到新结点i,从森林中删除s1,s2，将s1,s2的双亲0改为1</span></span><br><span class="line">        HT[i].lchild=s1;</span><br><span class="line">        HT[i].rchild=s2;<span class="comment">//s1,s2分别为i的左右孩子</span></span><br><span class="line">        HT[i].weight=HT[s1].weight+HT[s2].weight;<span class="comment">//i的权值为左右孩子之和</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h4><p>面试中常见的二叉树操作作个总结：</p>
<ol>
<li><p>求树的叶子数；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//树的叶子数，递归</span><br><span class="line">    public int CountLeaves(BinaryTreeNode node) &#123;</span><br><span class="line">        if (node == null)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        if (node.getLeft() == null &amp;&amp; node.getRight() == null)</span><br><span class="line">            return 1;</span><br><span class="line"></span><br><span class="line">        return CountLeaves(node.getLeft()) + CountLeaves(node.getRight());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>求二叉树第k层的节点个数;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求二叉树第 k 层的结点个数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKLevel</span><span class="params">(BinaryTreeNode node, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == node) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> getKLevel(node.getLeft(), k - <span class="number">1</span>) +</span><br><span class="line">               getKLevel(node.getRight(), k - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>判断两棵二叉树是否结构相同；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断两棵二叉树是否结构相同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">StructureCmp</span><span class="params">(BinaryTreeNode node1,BinaryTreeNode node2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node1==<span class="keyword">null</span>&amp;&amp;node2==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (node1==<span class="keyword">null</span>||node2==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> StructureCmp(node1.getLeft(),node2.getLeft())&amp;&amp;</span><br><span class="line">                StructureCmp(node1.getRight(),node2.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>求二叉树的镜像；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求二叉树的镜像</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">mirror</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node.setLeft(mirror(node.getRight()));</span><br><span class="line">        node.setRight(mirror(node.getLeft()));</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>求两个节点的最低公共祖先节点；</p>
<p>最低公共祖先，即 LCA（Lowest Common Ancestor），见下图：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/20/5d0ae24544cd114285.jpg" alt="1.jpg"></p>
<p>结点 3 和结点 4 的最近公共祖先是结点 2，即 LCA(3,4)=2。在此，需要注意到当两个结点在同一棵子树上的情况，如结点 3 和结点 2 的最近公共祖先为 2，即 LCA(3,2)=2。同理 LCA(5,6)=4，LCA(6,10)=1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求两个节点的最低公共祖先节点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">findLCA</span><span class="params">(BinaryTreeNode node,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 BinaryTreeNode target1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 BinaryTreeNode target2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node==<span class="keyword">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (node==target1||node==target2)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125;</span><br><span class="line">       BinaryTreeNode left=findLCA(node.getLeft(),target1,target2);</span><br><span class="line">       BinaryTreeNode right=findLCA(node.getRight(),target1,target2);</span><br><span class="line">       <span class="keyword">if</span> (left!=<span class="keyword">null</span>&amp;&amp;right!=<span class="keyword">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> left!=<span class="keyword">null</span>?left:right;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>求任意两节点距离；</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/20/5d0ae3635394034116.png" alt="1.png"></p>
<p>首先找到两个结点的 LCA，然后分别计算 LCA 与它们的距离，最后相加即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLevel</span><span class="params">(BinaryTreeNode node, BinaryTreeNode target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == node) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> level = findLevel(node.getLeft(), target);</span><br><span class="line">    <span class="keyword">if</span> (level == -<span class="number">1</span>) &#123;</span><br><span class="line">        level = findLevel(node.getRight(), target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (level != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//求任意两结点距离</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distanceNodes</span><span class="params">(BinaryTreeNode node,</span></span></span><br><span class="line"><span class="params"><span class="function">                         BinaryTreeNode target1,</span></span></span><br><span class="line"><span class="params"><span class="function">                         BinaryTreeNode target2)</span> </span>&#123;</span><br><span class="line">    BinaryTreeNode lca = findLCA(node, target1, target2);</span><br><span class="line">    <span class="keyword">int</span> l1 = findLevel(lca, target1);</span><br><span class="line">    <span class="keyword">int</span> l2 = findLevel(lca, target2);</span><br><span class="line">    <span class="keyword">return</span> l1 + l2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>找出二叉树中某个节点的所有祖先节点；</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/20/5d0ae5bc5815074949.jpg" alt="1.jpg"></p>
<p>如果给定结点 5，则其所有祖先结点为 4,2,1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出二叉树中某个结点的所有祖先结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findAllAncestors</span><span class="params">(BinaryTreeNode node, </span></span></span><br><span class="line"><span class="params"><span class="function">                                    BinaryTreeNode target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node==target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (findAllAncestors(node.getLeft(), target)||</span><br><span class="line">        findAllAncestors(node.getRight(), target))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(node.getVal());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>不使用递归和栈遍历二叉树；</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/20/5d0aebb05af2117291.png" alt="2.png"></p>
<p>先看<strong>前序遍历</strong>，步骤如下：</p>
<ol>
<li>如果当前结点的左孩子为空，则输出当前结点并将其右孩子作为当前结点；</li>
<li>如果当前结点的左孩子不为空，在当前结点的左子树中找到当前结点在中序遍历下的前驱结点；<br>2.1. 如果前驱结点的右孩子为空，将它的右孩子设置为当前结点，输出当前结点并把当前结点更新为当前结点的左孩子；<br>2.2. 如果前驱结点的右孩子为当前结点，将它的右孩子重新设为空，当前结点更新为当前结点的右孩子；</li>
<li>重复以上步骤 1 和 2，直到当前结点为空。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreOrderMorris</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">        BinaryTreeNode cur = node;</span><br><span class="line">        BinaryTreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.print(cur.getVal());</span><br><span class="line">                cur = cur.getRight();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = cur.getLeft();</span><br><span class="line">                <span class="keyword">while</span> (pre.getRight() != <span class="keyword">null</span> &amp;&amp; pre.getRight() != cur) &#123;</span><br><span class="line">                    pre = pre.getRight();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pre.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.print(cur.getVal());</span><br><span class="line">                    pre.setRight(cur);</span><br><span class="line">                    cur = cur.getLeft();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre.setRight(<span class="keyword">null</span>);</span><br><span class="line">                    cur = cur.getRight();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再来看<strong>中序遍历</strong>，和前序遍历相比只改动一句代码，步骤如下：</p>
<ol>
<li>如果当前结点的左孩子为空，则输出当前结点并将其右孩子作为当前结点；</li>
<li>如果当前结点的左孩子不为空，在当前结点的左子树中找到当前结点在中序遍历下的前驱结点；<br>2.1. 如果前驱结点的右孩子为空，将它的右孩子设置为当前结点，当前结点更新为当前结点的左孩子；<br>2.2. 如果前驱结点的右孩子为当前结点，将它的右孩子重新设为空，输出当前结点，当前结点更新为当前结点的右孩子；</li>
<li>重复以上步骤 1 和 2，直到当前结点为空。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InOrderMorris</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">     BinaryTreeNode cur = node;</span><br><span class="line">     BinaryTreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (cur.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">             System.out.print(cur.getVal());</span><br><span class="line">             cur = cur.getRight();</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             pre = cur.getLeft();</span><br><span class="line">             <span class="keyword">while</span> (pre.getRight() != <span class="keyword">null</span> &amp;&amp; pre.getRight() != cur) &#123;</span><br><span class="line">                 pre = pre.getRight();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (pre.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 pre.setRight(cur);</span><br><span class="line">                 cur = cur.getLeft();</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 System.out.print(cur.getVal());</span><br><span class="line">                 pre.setRight(<span class="keyword">null</span>);</span><br><span class="line">                 cur = cur.getRight();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>最后看下<strong>后序遍历</strong>，后序遍历有点复杂，需要建立一个虚假根结点 dummy，令其左孩子是 root。并且还需要一个子过程，就是倒序输出某两个结点之间路径上的各个结点。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/20/5d0aeb78f2b1393604.png" alt="1.png"></p>
<p>步骤如下：</p>
<ol>
<li>如果当前结点的左孩子为空，则将其右孩子作为当前结点；</li>
<li>如果当前结点的左孩子不为空，在当前结点的左子树中找到当前结点在中序遍历下的前驱结点；<br>2.1. 如果前驱结点的右孩子为空，将它的右孩子设置为当前结点，当前结点更新为当前结点的左孩子；<br>2.2. 如果前驱结点的右孩子为当前结点，将它的右孩子重新设为空，倒序输出从当前结点的左孩子到该前驱结点这条路径上的所有结点，当前结点更新为当前结点的右孩子；</li>
<li>重复以上步骤 1 和 2，直到当前结点为空。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReversePrint</span><span class="params">(BinaryTreeNode from, BinaryTreeNode to)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (from == to) &#123;</span><br><span class="line">           System.out.print(from.getVal());</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       ReversePrint(from.getRight(), to);</span><br><span class="line">       System.out.print(from.getVal());</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PostOrderMorris</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">       BinaryTreeNode dummy = <span class="keyword">new</span> BinaryTreeNode();<span class="comment">// 一个虚假根结点</span></span><br><span class="line">       dummy.setLeft(node);</span><br><span class="line">       dummy.setLeft(<span class="keyword">null</span>);</span><br><span class="line">       BinaryTreeNode cur = dummy;</span><br><span class="line">       BinaryTreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (cur.getLeft() == <span class="keyword">null</span>) &#123; <span class="comment">// 步骤 1</span></span><br><span class="line">               cur = cur.getRight();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               pre = cur.getLeft();</span><br><span class="line">               <span class="keyword">while</span> (pre.getRight() != <span class="keyword">null</span> &amp;&amp; pre.getRight() != cur) &#123;</span><br><span class="line">                   <span class="comment">// 步骤 2，找到 cur 的前驱结点</span></span><br><span class="line">                   pre = pre.getRight();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (pre.getRight() == <span class="keyword">null</span>) &#123;<span class="comment">// 步骤 2.1，cur 未被访问，将 cur 结点作为其前驱结点的右孩子</span></span><br><span class="line">                   pre.setRight(cur);</span><br><span class="line">                   cur = cur.getLeft();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;<span class="comment">// 步骤 2.2，cur 已被访问，恢复树的原有结构，更改 right 指针</span></span><br><span class="line">                   pre.setRight(<span class="keyword">null</span>);</span><br><span class="line">                   ReversePrint(cur.getLeft(), pre);</span><br><span class="line">                   cur = cur.getRight();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>二叉树前序中序推后序；</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>序列</th>
</tr>
</thead>
<tbody><tr>
<td>前序</td>
<td>[1 2 4 7 3 5 8 9 6]</td>
</tr>
<tr>
<td>中序</td>
<td>[4 7 2 1 8 5 9 3 6]</td>
</tr>
<tr>
<td>后序</td>
<td>[7 4 2 8 9 5 6 3 1]</td>
</tr>
</tbody></table>
<p>以上面图表为例，步骤如下：</p>
<ol>
<li>根据前序可知根结点为 1；</li>
<li>根据中序可知 4 7 2 为根结点 1 的左子树和 8 5 9 3 6 为根结点 1 的右子树；</li>
<li>递归实现，把 4 7 2 当做新的一棵树和 8 5 9 3 6 也当做新的一棵树；</li>
<li>在递归的过程中输出后序。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p>判断二叉树是不是完全二叉树;</p>
<p>若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树（Complete Binary Tree）。如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/20/5d0af0f6e2ce668878.jpg" alt="1.jpg"></p>
<p>首先若一个结点只有右孩子，肯定不是完全二叉树；其次若只有左孩子或没有孩子，那么接下来的所有结点肯定都没有孩子，否则就不是完全二叉树，因此设置 flag 标记变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断二叉树是不是完全二叉树</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCBT</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">       Queue&lt;BinaryTreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.offer(node);</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">           BinaryTreeNode p = queue.poll();</span><br><span class="line">           <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">               <span class="keyword">if</span> (p.getLeft() != <span class="keyword">null</span> || p.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (p.getLeft() != <span class="keyword">null</span> &amp;&amp; p.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   queue.offer(p.getLeft());</span><br><span class="line">                   queue.offer(p.getRight());</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   queue.offer(p.getLeft());</span><br><span class="line">                   flag = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   flag = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> flag;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>判断是否是二叉查找树的后序遍历结果；</p>
<p>在后续遍历得到的序列中，最后一个元素为树的根结点。从头开始扫描这个序列，比根结点小的元素都应该位于序列的左半部分；从第一个大于跟结点开始到跟结点前面的一个元素为止，所有元素都应该大于跟结点，因为这部分元素对应的是树的右子树。根据这样的划分，把序列划分为左右两部分，我们递归地确认序列的左、右两部分是不是都是二元查找树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否是二叉查找树的后序遍历结果</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isSequenceOfBST</span><span class="params">(T[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - begin &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T root_data = arr[end];</span><br><span class="line">        <span class="keyword">int</span> i = begin;</span><br><span class="line">        <span class="keyword">for</span> (; arr[i].compareTo(root_data) &lt; <span class="number">0</span>; i++) <span class="comment">// 取得左子树</span></span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; end; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j].compareTo(root_data) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSequenceOfBST(arr, begin, i - <span class="number">1</span>) &amp;&amp;</span><br><span class="line">                isSequenceOfBST(arr, i, end - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p> 给定一个二叉查找树中的结点（存在一个指向父亲结点的指针），找出在中序遍历下它的后继和前驱；</p>
</li>
</ol>
<pre><code>一棵二叉查找树的中序遍历序列，正好是升序序列。假如根结点的父结点为 nullptr，则：

1. 如果当前结点有右孩子，则后继结点为这个右孩子的最左孩子；
2. 如果当前结点没有右孩子；
   2.1. 当前结点为根结点，返回 nullptr；
   2.2. 当前结点只是个普通结点，也就是存在父结点；
        2.2.1. 当前结点是父亲结点的左孩子，则父亲结点就是后继结点；
        2.2.2. 当前结点是父亲结点的右孩子，沿着父亲结点往上走，直到 n-1 代祖先是 n 代祖先的左孩子，则后继为 n 代祖先或遍历到根结点也没找到符合的，则当前结点就是中序遍历的最后一个结点，返回 nullptr。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定一个二叉查找树中的结点（存在一个指向父亲结点的指针），找出在中序遍历下它的后继和前驱</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">increment</span><span class="params">(BinaryTreeNode node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.getRight()!=<span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node=node.getRight();</span><br><span class="line">        <span class="keyword">while</span> (node.getLeft()!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node=node.getLeft();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        BinaryTreeNode p=node.getParent();</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>&amp;&amp;p.getRight()==node)</span><br><span class="line">        &#123;</span><br><span class="line">            node=p;</span><br><span class="line">            p=p.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">        node=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

上述的代码是基于结点有 parent 指针的，若题意要求没有 parent 呢？

如果**没有指向父亲**结点的指针，则必须给定根节点；中序遍历二叉树，用栈来进行非递归遍历；用cur_pop指向当前出栈的结点，prev指向上一出栈的结点；当prev_pop为输入结点时，cur_pop即为所求的后继结点。时间复杂度为O(N)。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给出二叉树的一个结点，返回它中序遍历顺序的下一个结点。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">increment</span><span class="params">(BinaryTreeNode root, BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span> || node == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Stack&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">      stack.push(root);</span><br><span class="line">      BinaryTreeNode prev = <span class="keyword">null</span>, cur = <span class="keyword">null</span>;</span><br><span class="line">      BinaryTreeNode ptn = root.getLeft();</span><br><span class="line">      <span class="keyword">while</span> (!stack.empty() || ptn != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ptn != <span class="keyword">null</span>) &#123;</span><br><span class="line">              stack.push(ptn);</span><br><span class="line">              ptn = ptn.getLeft();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              prev = cur;</span><br><span class="line">              cur = stack.pop();</span><br><span class="line">              <span class="keyword">if</span> (prev == node) &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              ptn = cur.getRight();</span><br><span class="line">    </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (prev == node) &#123;</span><br><span class="line">          <span class="keyword">return</span> cur;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

而求前驱结点的话，只需把上述代码的 left 与 right 互调即可，很简单。
</code></pre>
<ol start="13">
<li><p>二分查找树转化为排序的循环双链表；</p>
<p>要求不能创建任何新的结点，只调整指针的指向。</p>
<p>二分查找树的中序遍历即为升序排列，问题就在于如何在遍历的时候更改指针的指向。一种简单的方法时，遍历二分查找树，讲遍历的结果放在一个数组中，之后再把该数组转化为双链表。如果题目要求只能使用O(1)内存，则只能在遍历的同时构建双链表，即进行指针的替换</p>
<p>我们需要用递归的方法来解决，假定每个递归调用都会返回构建好的双链表，可把问题分解为左右两个子树。</p>
<p>由于左右子树都已经是有序的，当前节点作为中间的一个节点，把左右子树得到的链表连接起来即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树转双向链表</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">treeToList</span><span class="params">(BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       BinaryTreeNode list = <span class="keyword">null</span>;</span><br><span class="line">       Stack&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</span><br><span class="line">       <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">               stack.push(node);</span><br><span class="line">               node = node.getRight();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               node = stack.pop();</span><br><span class="line">               <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   list = node;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   list.setLeft(node);</span><br><span class="line">                   node.setRight(list);</span><br><span class="line">                   list = node;</span><br><span class="line">               &#125;</span><br><span class="line">               node = node.getRight();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3398.html">哈夫曼树（赫夫曼树、最优树）详解</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-1/">https://pingxin0521.gitee.io/2019/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-2/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构--查找树</div></div></a></div><div class="next-post pull-right"><a href="/2019/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-0/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构--线性结构</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/05/14/数据结构-1-1/" title="跳表--二分查找的有序链表"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-06-29</div><div class="title">跳表--二分查找的有序链表</div></div></a></div><div><a href="/2019/05/04/数据结构-0/" title="数据结构入门"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-11-05</div><div class="title">数据结构入门</div></div></a></div><div><a href="/2019/06/27/数据结构-1-2/" title="bitMap--大数据的利器"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-02-28</div><div class="title">bitMap--大数据的利器</div></div></a></div><div><a href="/2020/02/27/数据结构-1-3/" title="字符串"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-03-12</div><div class="title">字符串</div></div></a></div><div><a href="/2019/05/04/数据结构-2-2/" title="数据结构--查找树"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-06-29</div><div class="title">数据结构--查找树</div></div></a></div><div><a href="/2019/12/31/数据结构-2-3/" title="数据结构--红黑树"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-02-28</div><div class="title">数据结构--红黑树</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">0.1.</span> <span class="toc-text">二叉树的存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">0.2.</span> <span class="toc-text">二叉树的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B8%85%E7%A9%BA"><span class="toc-number">0.3.</span> <span class="toc-text">二叉树的清空</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-number">0.4.</span> <span class="toc-text">判断二叉树是否为空</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6"><span class="toc-number">0.5.</span> <span class="toc-text">求二叉树的高度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0"><span class="toc-number">0.6.</span> <span class="toc-text">求二叉树的节点数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%9F%90%E8%8A%82%E7%82%B9%E7%9A%84%E7%88%B6%E4%BA%B2%E8%8A%82%E7%82%B9"><span class="toc-number">0.7.</span> <span class="toc-text">返回某节点的父亲节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91"><span class="toc-number">0.8.</span> <span class="toc-text">返回左右子树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">0.9.</span> <span class="toc-text">二叉树的插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-number">0.10.</span> <span class="toc-text">二叉树遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">哈夫曼树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95"><span class="toc-number">2.</span> <span class="toc-text">面试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">3.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
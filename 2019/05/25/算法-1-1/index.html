<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>经典算法--七大查找算法 | 平心de小屋</title><meta name="keywords" content="算法"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概念定义 查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素。  查找表（Search Table）：由同一类型的数据元素构成的集合，如数组、字符串、二维数组等  关键字（Key）：数据元素中某个数据项的值，又称为键值，如数值、数段、子字符串等  主键（Primary Key）：可唯一的标识某个数据元素或记录的关键字">
<meta property="og:type" content="article">
<meta property="og:title" content="经典算法--七大查找算法">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/05/25/%E7%AE%97%E6%B3%95-1-1/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="概念定义 查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素。  查找表（Search Table）：由同一类型的数据元素构成的集合，如数组、字符串、二维数组等  关键字（Key）：数据元素中某个数据项的值，又称为键值，如数值、数段、子字符串等  主键（Primary Key）：可唯一的标识某个数据元素或记录的关键字">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg">
<meta property="article:published_time" content="2019-05-25T05:18:59.000Z">
<meta property="article:modified_time" content="2019-11-04T14:47:06.151Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/05/25/%E7%AE%97%E6%B3%95-1-1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '经典算法--七大查找算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2019-11-04 22:47:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">经典算法--七大查找算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-05-25T05:18:59.000Z" title="发表于 2019-05-25 13:18:59">2019-05-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-11-04T14:47:06.151Z" title="更新于 2019-11-04 22:47:06">2019-11-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="经典算法--七大查找算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="概念定义"><a href="#概念定义" class="headerlink" title="概念定义"></a>概念定义</h4><ul>
<li><p>查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素。</p>
</li>
<li><p>查找表（Search Table）：由同一类型的数据元素构成的集合，如数组、字符串、二维数组等</p>
</li>
<li><p>关键字（Key）：数据元素中某个数据项的值，又称为键值，如数值、数段、子字符串等</p>
</li>
<li><p>主键（Primary Key）：可唯一的标识某个数据元素或记录的关键字</p>
</li>
</ul>
<span id="more"></span>

<p>按照查找表的排序状态可以分为：<strong>无序查找</strong>和<strong>有序查找</strong>。顾名思义，无序查找就是查找数列中的数是无序的，有序查找要求所查找数列是已经按照一定的规律排好序了，常见算法中大多都是无序查找。</p>
<p>查找表按照操作方式可分为：</p>
<ol>
<li><p>静态查找表（Static Search Table）：只做查找操作的查找表。它的主要操作是：</p>
<ul>
<li>查询某个“特定的”数据元素是否在表中</li>
<li>检索某个“特定的”数据元素和各种属性</li>
</ul>
</li>
<li><p>动态查找表（Dynamic Search Table）：在查找中同时进行插入或删除等操作：</p>
<ul>
<li>查找时插入数据</li>
<li>查找时删除数据</li>
</ul>
</li>
</ol>
<p>根据查找表的数据结构又可以分成很多类，一般来说有：线性表、树、图等等</p>
<p><strong>平均查找长度（Average Search Length，ASL）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/10/31/KIUI4e.png" alt="KIUI4e.png"></p>
<p>其中n为查找表中元素个数，Pi为查找第i个元素的概率，通常假设每个元素查找概率相同，Pi=1/n，Ci是找到第i个元素的比较次数。</p>
<p><strong>一个算法的ASL越大，说明时间性能差，反之，时间性能好，这也是显而易见的。</strong></p>
<p>下面进行介绍，使用整数数组作为查找表，其他查找类型可以进行类比。</p>
<h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><p>顺序查找又称为线性查找，是一种最简单的查找方法。适用于线性表的顺序存储结构和链式存储结构。该算法的时间复杂度为O(n)。</p>
<p><strong>类型：</strong>无序查找。</p>
<p><strong>基本思路</strong></p>
<p>从第一个元素m开始逐个与需要查找的元素x进行比较，当比较到元素值相同(即m=x)时返回元素m的下标，如果比较到最后都没有找到，则返回-1。</p>
<p><strong>复杂度分析：</strong></p>
<table>
<thead>
<tr>
<th align="center">平均查找长度</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(n+1)/2</td>
<td align="center">O(n)</td>
</tr>
</tbody></table>
<p>查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;</p>
<p>当查找不成功时，需要n+1次比较，时间复杂度为O(n);</p>
<p>所以，顺序查找的时间复杂度为O(n)。</p>
<p><strong>优缺点</strong></p>
<ul>
<li>缺点：是当n 很大时，平均查找长度较大，效率低；</li>
<li>优点：是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyp</span></span><br><span class="line"><span class="comment"> * Project name is LeedCodeLearn</span></span><br><span class="line"><span class="comment"> * Include in test06</span></span><br><span class="line"><span class="comment"> * hyp create at 19-10-31</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Search</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = makeData();</span><br><span class="line">        <span class="keyword">int</span> target = random.nextInt() % <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//顺序查找</span></span><br><span class="line">        testTime(<span class="string">&quot;顺序查找&quot;</span>,arr,target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] makeData() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt() % <span class="number">100000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTime</span><span class="params">(String name, <span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;算法名称：&quot;</span> + name);</span><br><span class="line">        <span class="keyword">long</span> d = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;查找表:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        System.out.println(<span class="string">&quot;目标数值:&quot;</span> + target);</span><br><span class="line">        System.out.println(<span class="string">&quot;查找结果：&quot;</span> + sequentialSearch(arr, target));</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时:&quot;</span> + (System.currentTimeMillis() - d));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sequentialSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == key) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="二分查找（折半查找）"><a href="#二分查找（折半查找）" class="headerlink" title="二分查找（折半查找）"></a>二分查找（折半查找）</h4><p>二分查找（Binary Search），是一种在<strong>有序数组</strong>中查找某一特定元素的查找算法。查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则查找过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。</p>
<p>这种查找算法每一次比较都使查找范围缩小一半</p>
<p><strong>算法描述</strong></p>
<p>给予一个包含 n个带值元素的数组A </p>
<ol>
<li> 令 L为0 ， R为 n-1 ；</li>
<li>如果L&gt;R，则搜索以失败告终 ；</li>
<li>令 m (中间值元素)为  ⌊(L+R)/2⌋；</li>
<li>如果 Am&lt;T，令 L为 m + 1 并回到步骤二 ；</li>
<li>如果 Am&gt;T，令 R为 m - 1 并回到步骤二；</li>
</ol>
<ul>
<li><strong>复杂度分析：</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">平均查找长度</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">log2(n+1)</td>
<td align="center">O(log2n)</td>
</tr>
</tbody></table>
<p>空间复杂度：O(1)</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> bom = <span class="number">0</span>, top = arr.length - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (bom &lt;= top) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == arr[bom]) &#123;</span><br><span class="line">                index = bom;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key == arr[top]) &#123;</span><br><span class="line">                index = top;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (bom + top) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (key == arr[mid]) &#123;</span><br><span class="line">                index = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; arr[mid]) &#123;</span><br><span class="line">                bom = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                top = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><p><strong>类型：</strong>有序查找</p>
<p><strong>基本思想：</strong><br> 是二分查找的一种优化，将查找点改进为自适应选择以提高查找效率。（将<code>mid = (low + high) /2</code>取中值的取法换成了<code>mid = low + (target - arr[low]) / (arr[high] - arr[low] * (high - low))</code>）</p>
<p>时间复杂性：如果元素均匀分布，则O(log2(log2n))，在最坏的情况下可能需要 O（n）。</p>
<p>空间复杂度：O（1）</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">interpolationSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> bom = <span class="number">0</span>, top = arr.length - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (bom &lt;= top) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == arr[bom]) &#123;</span><br><span class="line">                index = bom;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key == arr[top]) &#123;</span><br><span class="line">                index = top;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = bom + (key - arr[bom]) / (arr[top] - arr[bom] * (top - bom));</span><br><span class="line">            <span class="keyword">if</span> (key == arr[mid]) &#123;</span><br><span class="line">                index = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; arr[mid]) &#123;</span><br><span class="line">                bom = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                top = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h4><p><strong>未理解</strong></p>
<p><strong>类型：</strong>有序查找。</p>
<p>斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、····，在数学上，斐波那契被递归方法如下定义：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n&gt;=2）。该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618）</p>
<p><strong>基本思想：</strong><br> 同样的是，它是二分查找的一个优化，它是根据斐波那契序列的特点对有序表进行分割。他要求开始表中记录的个数为某个斐波那契数小1，即n=F(k)-1;然后需要装填一个长度为n的新数组，且<code>mid = low + fib(k - 1) - 1</code>，k为<code>fib(k) - 1</code>刚好大于原数组长度的那个值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种</span><br><span class="line"> 1）相等，mid位置的元素即为所求</span><br><span class="line"> </span><br><span class="line"> 2）&gt;，low=mid+1,k-=2;</span><br><span class="line"> 说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。</span><br><span class="line"> </span><br><span class="line"> 3）&lt;，high=mid-1,k-=1。</span><br><span class="line"> </span><br><span class="line">说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong> </p>
<p>最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 用斐波那契查找在nums数组中查找key的index</span></span><br><span class="line"><span class="comment">	 *  先用快排对数组进行排序，原先数组长度为orginalLength</span></span><br><span class="line"><span class="comment">	 *  然后建立斐波那契数列，用list不断加入，直到&gt;orginalLength,</span></span><br><span class="line"><span class="comment">	 *  斐波那契数列的最后一位F(k),newLength=F(k)-1&gt;=orginalLength</span></span><br><span class="line"><span class="comment">	 *  将原来排序后的数组加入长度为newLength的数组中， 多出来空位的用最后一位填满</span></span><br><span class="line"><span class="comment">	 *  然后设定begin=0,end=newLength-1,k=上面对应的k</span></span><br><span class="line"><span class="comment">	 * 	mid=begin+F(k-1)-1,查找mid的值与key的大小</span></span><br><span class="line"><span class="comment">	 * 	如果相同，返回index,如果index&gt;=orginalLength,返回orginalLength-1</span></span><br><span class="line"><span class="comment">	 * 	如果mid&lt;key,那么begin=mid+1，k=k-2如果mid&gt;key,那么end=mid-1,k=k-1</span></span><br><span class="line"><span class="comment">	 * 	然后循环，直到end&lt;begin,返回-1</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 如果数组中没有这个key，返回-1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacciSearch</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> orginalLength=nums.length;</span><br><span class="line">		QuickSort.quickSort(nums, <span class="number">0</span>, orginalLength-<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//然后建立斐波那契数列，用list不断加入，直到&gt;orginalLength</span></span><br><span class="line">		List&lt;Integer&gt; fiboList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		fiboList.add(<span class="number">0</span>);</span><br><span class="line">		fiboList.add(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			Integer now=fiboList.get(i-<span class="number">2</span>)+fiboList.get(i-<span class="number">1</span>);</span><br><span class="line">			fiboList.add(now);</span><br><span class="line">			i++;</span><br><span class="line">			<span class="keyword">if</span>(now&gt;orginalLength)&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//斐波那契数列的最后一位F(k),newLength=F(k)-1&gt;=orginalLength</span></span><br><span class="line">		<span class="keyword">int</span> k=fiboList.size()-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> newLength=fiboList.get(k)-<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//将原来排序后的数组加入长度为newLength的数组中， 多出来空位的用最后一位填满</span></span><br><span class="line">		<span class="keyword">int</span>[] newNums=<span class="keyword">new</span> <span class="keyword">int</span>[newLength];</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;newLength;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;orginalLength)&#123;</span><br><span class="line">				newNums[i]=nums[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				newNums[i]=nums[orginalLength-<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">						</span><br><span class="line">		<span class="comment">//begin=0,end=newLength-1,k=上面对应的k</span></span><br><span class="line">		<span class="keyword">int</span> begin=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> end=newLength-<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//循环，直到end&lt;begin,返回-1</span></span><br><span class="line">		<span class="keyword">while</span>(begin&lt;=end)&#123;</span><br><span class="line">			<span class="keyword">int</span> mid=begin+fiboList.get(k-<span class="number">1</span>)-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">int</span> now=nums[mid];</span><br><span class="line">			<span class="keyword">if</span>(now==key)&#123;</span><br><span class="line">				<span class="comment">//如果相同，返回index,如果index&gt;=orginalLength,返回orginalLength-1</span></span><br><span class="line">				<span class="keyword">if</span>(mid&gt;=orginalLength)&#123;</span><br><span class="line">					<span class="keyword">return</span> orginalLength-<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> mid;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(now&lt;key)&#123;</span><br><span class="line">				<span class="comment">//如果mid&lt;key,那么begin=mid+1，k=k-2</span></span><br><span class="line">				begin=mid+<span class="number">1</span>;</span><br><span class="line">				k=k-<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(now&gt;key)&#123;</span><br><span class="line">				<span class="comment">//如果mid&gt;key,那么end=mid-1,k=k-1</span></span><br><span class="line">				end=mid-<span class="number">1</span>;</span><br><span class="line">				k=k-<span class="number">1</span>;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;				</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="树表查找"><a href="#树表查找" class="headerlink" title="树表查找"></a>树表查找</h4><h5 id="二叉树查找"><a href="#二叉树查找" class="headerlink" title="二叉树查找"></a>二叉树查找</h5><p>二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 </p>
<p>二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ol>
<li><p>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
</li>
<li><p>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
</li>
<li><p>任意节点的左、右子树也分别为二叉查找树。</p>
</li>
</ol>
<p>二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。</p>
<p>根据二叉查找树的性质，可以从根，根据大小比较到左右孩子，搜索到对应的节点</p>
<p><strong>复杂度</strong></p>
<p>它和二分查找一样，插入和查找的时间复杂度均为O(log2 n)，但是<strong>在最坏的情况下仍然会有O(n)的时间复杂度</strong>。原因在于插入和删除元素的时候，树没有保持平衡。<strong>我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。</strong></p>
<p><strong>实现</strong></p>
<p><a target="_blank" rel="noopener" href="https://pingxin0521.coding.me/2019/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/">https://pingxin0521.coding.me/2019/05/04/数据结构-4/</a></p>
<h5 id="平衡查找树之2-3查找树（2-3-Tree）"><a href="#平衡查找树之2-3查找树（2-3-Tree）" class="headerlink" title="平衡查找树之2-3查找树（2-3 Tree）"></a>平衡查找树之2-3查找树（2-3 Tree）</h5><p>可以参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/xushiyu1996818/article/details/90691966">https://blog.csdn.net/xushiyu1996818/article/details/90691966</a></p>
<p>2-3树的查找效率与树的高度是息息相关的。</p>
<p>在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN</p>
<p>在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN</p>
<p>距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。</p>
<h5 id="平衡查找树之红黑树（Red-Black-Tree）"><a href="#平衡查找树之红黑树（Red-Black-Tree）" class="headerlink" title="平衡查找树之红黑树（Red-Black Tree）"></a>平衡查找树之红黑树（Red-Black Tree）</h5><p>2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgn，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。</p>
<p><strong>基本思想</strong>：红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。</p>
<h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一颗B+树包含根节点、内部节点和叶子节点。B+ 树通常用于数据库和操作系统的文件系统中。 B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。 B+ 树元素自底向上插入。</p>
<p><strong>一个m阶的B树具有如下几个特征：</strong></p>
<p>1.根结点至少有两个子女。</p>
<p>2.每个中间节点都至少包含<code>ceil(m / 2)</code>个孩子，最多有m个孩子。</p>
<p>3.每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m。</p>
<p>4.所有的叶子结点都位于同一层。</p>
<p>5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/11/04/KzJRde.png" alt="KzJRde.png"></p>
<p>每一个父节点都出现在子节点中，是子节点最大或者最小的元素。</p>
<p>在这里，根节点中最大的元素是15，也就是整个树中最大的元素。以后无论插入多少元素要始终保持最大元素在根节点当中。</p>
<p>每个叶子节点都有一个指针，指向下一个数据，形成一个有序链表。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/11/04/KzJ5RI.png" alt="KzJ5RI.png"></p>
<p>而只有叶子节点才会有data，其他都是索引。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Fmuma/article/details/80287924">https://blog.csdn.net/Fmuma/article/details/80287924</a></p>
<h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>要求是顺序表，分块查找又称索引顺序查找，它是顺序查找的一种改进方法。</p>
<p><strong>算法思想</strong></p>
<p>将n个数据元素”按块有序”划分为m块（m ≤ n）。**每一块中的结点不必有序，但块与块之间必须”按块有序”**；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素</p>
<p><strong>算法流程</strong></p>
<pre><code>1、先选取各块中的最大关键字构成一个索引表；
2、查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；
3、在已确定的块中用顺序法进行查找。
</code></pre>
<p><strong>复杂度分析</strong></p>
<p>设表共n个结点，分b块，s=n/b</p>
<p>时间复杂度：O(log(m)+N/m)</p>
<p>平均查找长度=Log2（n/s+1）+s/2</p>
<p><strong>举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/11/04/Kv0bVK.png" alt="Kv0bVK.png"></p>
<p>图中查找表中共 18 个查找关键字，将其平均分为 3 个子表，对每个子表建立一个索引，索引中包含中两部分内容：该子表部分中最大的关键字以及第一个关键字在总表中的位置，即该子表的起始位置。</p>
<blockquote>
<p>建立的索引表要求按照关键字进行升序排序，查找表要么整体有序，要么分块有序。</p>
</blockquote>
<p>分块有序指的是第二个子表中所有关键字都要大于第一个子表中的最大关键字，第三个子表的所有关键字都要大于第二个子表中的最大关键字，依次类推。</p>
<p>块（子表）中各关键字的具体顺序，根据各自可能会被查找到的概率而定。如果各关键字被查找到的概率是相等的，那么可以随机存放；否则可按照被查找概率进行降序排序，以提高算法运行效率。</p>
<p>假设要查找关键字 38 的具体位置。首先将 38 依次和索引表中各最大关键字进行比较，因为 22 &lt; 38 &lt; 48，所以可以确定 38 如果存在，肯定在第二个子表中。</p>
<p>由于索引表中显示第二子表的起始位置在查找表的第 7 的位置上，所以从该位置开始进行顺序查找，一直查找到该子表最后一个关键字（一般将查找表进行等分，具体子表个数根据实际情况而定）。结果在第 10 的位置上确定该关键字即为所找。</p>
<blockquote>
<p>提示：在第一步确定块（子表）时，由于索引表中按照关键字有序，所有可以采用折半查找算法。而在第二步中，由于各子表中关键字没有严格要求有序，所以只能采用顺序查找的方式。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分块查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockSelect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxValue;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> maxValue;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxValue</span><span class="params">(<span class="keyword">int</span> maxValue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.maxValue = maxValue;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.list = list;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#123;块最大值：&quot;</span> + maxValue + <span class="string">&quot;；块内集合：&quot;</span> + list.toString() + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建符合要求的块，按块有序，块内无序</span></span><br><span class="line">        List&lt;Block&gt; list = <span class="keyword">new</span> ArrayList&lt;Block&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            Block block = <span class="keyword">new</span> Block();</span><br><span class="line">            block.setMaxValue((i+<span class="number">1</span>)*<span class="number">5</span>-<span class="number">1</span>);</span><br><span class="line">            List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            list1.add(i*<span class="number">5</span>);list1.add(i*<span class="number">5</span>+<span class="number">2</span>);</span><br><span class="line">            list1.add(i*<span class="number">5</span>+<span class="number">1</span>);list1.add(i*<span class="number">5</span>+<span class="number">4</span>);</span><br><span class="line">            list1.add(i*<span class="number">5</span>+<span class="number">3</span>);</span><br><span class="line">            block.setList(list1);</span><br><span class="line">            list.add(block);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        selectFromBlock(list,<span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 块集合从小到大</span></span><br><span class="line"><span class="comment">     * 在查找块的时候和块内查找的时候均使用的为顺序查找，可更改查找算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selectValue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectFromBlock</span><span class="params">(List&lt;Block&gt; list,<span class="keyword">int</span> selectValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> blockIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (selectValue &lt; list.get(i).getMaxValue())&#123;</span><br><span class="line">                blockIndex = i;</span><br><span class="line">                System.out.println(<span class="string">&quot;查找的值可能在块 &quot;</span> + i + <span class="string">&quot; 中&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (blockIndex &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;块集合中不存在要查找的值！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        List&lt;Integer&gt; blockList = list.get(blockIndex).getList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; blockList.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (blockList.get(i) == selectValue)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;结果：查找的值在块 &quot;</span> + blockIndex + <span class="string">&quot; 中下标为：&quot;</span> + i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结果：查找的值不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分块查找的性能分析</strong></p>
<p>分块查找算法的运行效率受两部分影响：查找块的操作和块内查找的操作。查找块的操作可以采用顺序查找，也可以采用折半查找（更优）；块内查找的操作采用顺序查找的方式。相比于折半查找，分块查找时间效率上更低一些；相比于顺序查找，由于在子表中进行，比较的子表个数会不同程度的减少，所有分块查找算法会更优。</p>
<blockquote>
<p>总体来说，分块查找算法的效率介于顺序查找和折半查找之间。</p>
</blockquote>
<h4 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h4><p>哈希表就是一种以键-值(key-indexed) 存储数据的结构，只要输入待查找的值即key，即可查找到其对应的值。</p>
<p>哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</p>
<p><strong>算法流程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）用给定的哈希函数构造哈希表；</span><br><span class="line">2）根据选择的冲突处理方法解决地址冲突；</span><br><span class="line">常见的解决冲突的方法：拉链法和线性探测法。</span><br><span class="line">3）在哈希表的基础上执行哈希查找。</span><br></pre></td></tr></table></figure>

<p>单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。</p>
<p>实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 用哈希查找在nums数组中查找key的index</span></span><br><span class="line"><span class="comment">	 * 先将nums数组的元素，放入hashmap中，key为值，value为index</span></span><br><span class="line"><span class="comment">	 * 然后根据key查找有没有这个值</span></span><br><span class="line"><span class="comment">	 * 但是这种方法，如果nums数组有重复的元素，只会返回最后的那个index，因为前面的被覆盖了</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 如果数组中没有这个key，返回-1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashSearch</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> length=nums.length;</span><br><span class="line">		HashMap&lt;Integer, Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">			map.put(nums[i], i);</span><br><span class="line">		&#125;</span><br><span class="line">		Integer index=map.get(key);</span><br><span class="line">		<span class="keyword">if</span>(index==<span class="keyword">null</span>)&#123;</span><br><span class="line">			index=-<span class="number">1</span>;</span><br><span class="line">		&#125;				</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找总结"><a href="#查找总结" class="headerlink" title="查找总结"></a>查找总结</h4><p>查找分这样几类：</p>
<p>统统找一遍：顺序查找</p>
<p>二分法：二分查找，插值查找，斐波那契查找</p>
<p>树表：二叉搜索树，2-3树，红黑树，B树，B+树等等</p>
<p>二分+顺序：区块查找</p>
<p>空间换时间（类似区块）：哈希查找</p>
<p><strong>它们的复杂度为</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2019/10/31/KIWxaQ.png" alt="KIWxaQ.png"></p>
<h3 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h3><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32459653/article/details/82557732">KMP算法</a></h4><p>kmp算法，常用于匹配一个字符串是否是另一个字符串的子串，不同于暴力搜索kmp算法的时间复杂度为O(m+n),网上好多对于该算法的讲解代码，但发现有木有，几乎所有的代码全是一模一样，根本没几个是自己写的，给的都是书上标准优化后的代码，直接抄下来，理解困难，原理讲解不清，含糊其词，因此本人自写一遍关于kmp算法的博客，并讲解该kmp算法的原理，以及为什么需要next数组，并证明每次最优移动次数就是next[j]的值，最后依据讲解的原理和思路给出自己的Kmp算法的具体实现</p>
<p>KMP算法是由三个大佬发现的，优点就是在BF朴素算法上进行优化，将o(m*n)的复杂度，通过对模式串对称性做表，变成了o(m+n)。</p>
<p>首先请明白next数组是什么，术语讲就是字符串的前缀和后缀的最长公共长度，比如ABCEFGHRHHABC则最长公共长度就是ABC,使用术语可能会妨碍大家理解，这里我使用图形象描述。如图所示字符串ABCEFGHRHHABC的最长公共前缀是多少呢？很简答，你只需要讲该字符串数组右移，舍得末尾（ABC）能跟开头（ABC）重合的最大长度就是前缀和子缀的最大公共长度（描述起来很麻烦，画图好理解，下定义要描述起来还是麻烦啊）</p>
<p>明白了这个之后，现在我们来证明在匹配失败后最优匹配位置为next[j]的值，怎么证明呢？很简单的证明方法，反正法！！,假设我们移动距离不是next[j]的值，使得移动后也匹配结果，具体看下图分析，我们用X变量代表以匹配的字符变量可以代表任意字符，Y变量代表未匹配的字符，也可以表示任意字符，看下图证明：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/08/24/vAxzrYlNudKykhp.png" alt="image.png"></p>
<p>接下来就是next数组的求法呢？这个可以用动态规划做,假设k=next[t-1],我们怎么求next[t]呢，</p>
<p>分两种情况，若p[t]==p[k],是不是直接到加到后面，就行了，符合next的定义，因此next[t]=k+1;</p>
<p>那如果p[t] !=p[k]呢？怎么求，首先如果p[t]!=p[k]说明不能直接加，那怎样才能加入？,才能符合next[t]的定义呢？</p>
<p>根本就是要找到，j前面有几个数，可以加入，很间单啊，看我下面的图分析，包你搞懂。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/08/24/V38qtacFWPf5mo4.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体 算法如下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getMyNext(String ps) &#123;</span><br><span class="line">    <span class="keyword">char</span>[] p = ps.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[p.length];</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//初始化第0位为0</span></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt; p.length; t++) &#123;  </span><br><span class="line">        k = next[t - <span class="number">1</span>]; <span class="comment">//获取前一位的next</span></span><br><span class="line">        <span class="comment">//  System.out.println(p[k]);</span></span><br><span class="line">        <span class="keyword">if</span> (p[t] == p[k]) &#123;</span><br><span class="line">            next[t] = k + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//不相等则需要递归,这里使用while循环使用</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = next[k];</span><br><span class="line">                <span class="keyword">if</span> (p[t] == p[temp]) &#123;</span><br><span class="line">                    next[t] = temp + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    next[t] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//数组整体右移一位，为什么要右移？因为在kmp算法中我们在加入第j个字符的时候用的是第j-1的next数组，所以求玩后整体右移一位，</span></span><br><span class="line">    moveToRight(next, <span class="number">1</span>);</span><br><span class="line">   next[<span class="number">0</span>]=-<span class="number">1</span>;<span class="comment">//并且我们将0位置为-1，主要是为了标识，匹配到0的情况</span></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">moveToRight</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    System.arraycopy(array, <span class="number">0</span>, array, index, array.length - <span class="number">1</span>);</span><br><span class="line">    System.out.println(array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//既然有了next数组kmp算法也不再话下了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我写的kmp算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ts</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ps</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MyKMP</span><span class="params">(String ts, String ps)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] t = ts.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] p = ps.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 主串的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 模式串的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] next = getMyNext(ps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t[i] == p[j]) &#123; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i不需要回溯了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// i = i - j + 1;</span></span><br><span class="line"></span><br><span class="line">            j = next[j]; <span class="comment">// j回到指定位置</span></span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; <span class="comment">//j==0 了 只能i右移重新从0开始匹配了</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lsqin/p/9342929.html">七大查找算法（Python）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3445be2d9956">常用查找算法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xushiyu1996818/article/details/90604118">查找算法总结-java版</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/05/25/%E7%AE%97%E6%B3%95-1-1/">https://pingxin0521.gitee.io/2019/05/25/%E7%AE%97%E6%B3%95-1-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/05/25/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaEE 模式</div></div></a></div><div class="next-post pull-right"><a href="/2019/05/24/%E7%AE%97%E6%B3%95-1-0/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法入门</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/05/24/算法-1-0/" title="算法入门"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-02-10</div><div class="title">算法入门</div></div></a></div><div><a href="/2020/06/26/算法-1-3-3/" title="常用算法--分治算法 (三)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-06-28</div><div class="title">常用算法--分治算法 (三)</div></div></a></div><div><a href="/2020/06/27/算法-1-3-4/" title="常用算法--分支限界算法 (四)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-06-28</div><div class="title">常用算法--分支限界算法 (四)</div></div></a></div><div><a href="/2020/06/28/算法-1-3-5/" title="常用算法--动态规划算法 (五)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-06-29</div><div class="title">常用算法--动态规划算法 (五)</div></div></a></div><div><a href="/2019/09/24/算法-1-2/" title="经典算法--十大排序算法"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-03-25</div><div class="title">经典算法--十大排序算法</div></div></a></div><div><a href="/2020/06/24/算法-1-3-1/" title="常用算法--贪心算法 (一)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-06-27</div><div class="title">常用算法--贪心算法 (一)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">概念定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">2.</span> <span class="toc-text">顺序查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">二分查找（折半查找）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="toc-number">4.</span> <span class="toc-text">插值查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE"><span class="toc-number">5.</span> <span class="toc-text">斐波那契查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E8%A1%A8%E6%9F%A5%E6%89%BE"><span class="toc-number">6.</span> <span class="toc-text">树表查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE"><span class="toc-number">6.1.</span> <span class="toc-text">二叉树查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91%E4%B9%8B2-3%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%882-3-Tree%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">平衡查找树之2-3查找树（2-3 Tree）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88Red-Black-Tree%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">平衡查找树之红黑树（Red-Black Tree）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">6.4.</span> <span class="toc-text">B+树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="toc-number">7.</span> <span class="toc-text">分块查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE"><span class="toc-number">8.</span> <span class="toc-text">哈希查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93"><span class="toc-number">9.</span> <span class="toc-text">查找总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">常用算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">KMP算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number"></span> <span class="toc-text">参考</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
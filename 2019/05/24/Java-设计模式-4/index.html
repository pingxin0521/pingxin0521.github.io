<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>设计模式--行为型（上） | 平心de小屋</title><meta name="keywords" content="Java,设计模式"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="策略模式在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式--行为型（上）">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/05/24/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="策略模式在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg">
<meta property="article:published_time" content="2019-05-24T06:18:59.000Z">
<meta property="article:modified_time" content="2020-02-12T14:59:59.923Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/05/24/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '设计模式--行为型（上）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-02-12 22:59:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">设计模式--行为型（上）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-05-24T06:18:59.000Z" title="发表于 2019-05-24 14:18:59">2019-05-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-02-12T14:59:59.923Z" title="更新于 2020-02-12 22:59:59">2020-02-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="设计模式--行为型（上）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p>
<p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p>
<span id="more"></span>

<p><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换，<strong>让算法独立于使用它的客户而变化</strong>。 </p>
<p><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护，一般用来替换if-else，个人感觉是面向过程与面向对象思想的 过渡</p>
<p><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。</p>
<p><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。</p>
<p><strong>关键代码：</strong>实现同一个接口。</p>
<p><strong>应用实例：</strong> </p>
<ol>
<li>诸葛亮的锦囊妙计，每一个锦囊就是一个策略。</li>
<li>旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。</li>
<li>JAVA AWT 中的 LayoutManager。</li>
</ol>
<p><strong>优点：</strong> </p>
<ol>
<li>算法可以自由切换。 </li>
<li>避免使用多重条件判断。 </li>
<li>扩展性良好。 </li>
</ol>
<p><strong>缺点：</strong> </p>
<ol>
<li>策略类会增多。 </li>
<li>所有策略类都需要对外暴露。 </li>
</ol>
<p><strong>使用场景：</strong> </p>
<ol>
<li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li>
<li>一个系统需要动态地在几种算法中选择一种。</li>
<li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li>
<li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法<br>与相关的数据结构，可以提高算法的保密性与安全性。 </li>
</ol>
<p><strong>注意事项：</strong>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p>
<p><strong>三个角色</strong></p>
<ul>
<li><strong>Context</strong>: <strong>上下文环境类</strong>，持有抽象策略角色的引用</li>
<li><strong>Strategy</strong>: <strong>抽象策略类</strong>，定义一系列抽象的算法策略</li>
<li><strong>ConcreteStrategy</strong>: <strong>具体策略类</strong>，实现具体的算法策略</li>
</ul>
<p>UML：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/05/5cf75c658840b40677.png" alt="5.png"></p>
<p><strong>与状态模式的比较</strong></p>
<p>状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。</p>
<p>状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>策略模式实现简易计算器</p>
<p>其实就是把if-else涉及到的算法，策略行为抽取出来，统一的接口，然后各自实现，比如这里我们把抽取计算的接口，然后继承分别实现加减乘除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface Compute &#123;</span><br><span class="line">    String compute(int first, int second);</span><br><span class="line">&#125;</span><br><span class="line">public class Add implements Compute&#123;</span><br><span class="line">    @Override public String compute(int first, int second) &#123;</span><br><span class="line">        return &quot;输出结果：&quot; + first + &quot; + &quot; + second + &quot; = &quot; + (first + second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Div implements Compute&#123;</span><br><span class="line">    @Override public String compute(int first, int second) &#123;</span><br><span class="line">        return &quot;输出结果：&quot; + first + &quot; / &quot; + second + &quot; = &quot; + (first / second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Mul implements Compute&#123;</span><br><span class="line">    @Override public String compute(int first, int second) &#123;</span><br><span class="line">        return &quot;输出结果：&quot; + first + &quot; * &quot; + second + &quot; = &quot; + (first * second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Sub implements Compute&#123;</span><br><span class="line">    @Override public String compute(int first, int second) &#123;</span><br><span class="line">        return &quot;输出结果：&quot; + first + &quot; - &quot; + second + &quot; = &quot; + (first - second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写<strong>上下文对象</strong>，<strong>负责与具体的策略类交互</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">    private Compute compute;</span><br><span class="line"></span><br><span class="line">    public Context() &#123; compute = new Add(); &#125;</span><br><span class="line"></span><br><span class="line">    public void setCompute(Compute compute) &#123; this.compute = compute; &#125;</span><br><span class="line"></span><br><span class="line">    public void calc(int first, int second) &#123; System.out.println(compute.compute(first, second)); &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端调用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Context context = new Context();</span><br><span class="line"></span><br><span class="line">        context.setCompute(new Add());</span><br><span class="line">        context.calc(1,2);</span><br><span class="line"></span><br><span class="line">        context.setCompute(new Sub());</span><br><span class="line">        context.calc(3,4);</span><br><span class="line"></span><br><span class="line">        context.setCompute(new Mul());</span><br><span class="line">        context.calc(5,6);</span><br><span class="line"></span><br><span class="line">        context.setCompute(new Div());</span><br><span class="line">        context.calc(7,8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。</p>
<p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p>
<p><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p>
<p><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。</p>
<p><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。</p>
<p><strong>应用实例：</strong> </p>
<ol>
<li>拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。</li>
<li>西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。 </li>
</ol>
<p><strong>优点：</strong> </p>
<ol>
<li>观察者和被观察者是抽象耦合的。 </li>
<li>建立一套触发机制。 </li>
</ol>
<p><strong>缺点：</strong> </p>
<ol>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 </li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 </li>
</ol>
<p><strong>使用场景：</strong> </p>
<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
</ul>
<p><strong>注意事项：</strong> </p>
<ol>
<li>JAVA 中已经有了对观察者模式的支持类。</li>
<li>避免循环引用。</li>
<li>如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。 </li>
</ol>
<p>首先是使用场景，举个最简单的例子，你放学到家，很饿，这个时候你妈在厨房做饭，因为你和妈妈达成了写完作业才可以玩农药的约定，所以你要先写作业，但是你又很饿，你想当饭做好了第一时间能吃到，你可以：</p>
<ul>
<li>每隔一段时间跑去厨房找你妈，问她饭做好没（轮询）</li>
<li>跟你妈说一声，”老妈，饭做好了马上叫我”（订阅或注册），你妈答应了你的请求，等她做完饭后立马通知你，这样你就不可以一心一意的做作业了，等你妈通知你，然后放下手上的作业，去吃饭。</li>
</ul>
<p>上面的场景，使用观察者模式，比起反复的检索，显得更加优雅。</p>
<p>这个模式，有两个主要角色：被观察者 与 观察者，这里的老妈就属于被观察者，而你属于观察者，可能你还有个妹妹和弟弟，一起等饭吃，即：一个被观察者可以对应多个观察者，你妈做好饭的时候，会把你们都通知一遍。</p>
<p>主要角色就这两个，当然，按照设计模式的套路，肯定是会抽象的，所以有了另外的两个抽象被观察者，抽象观察者，四个角色责任如下：</p>
<p><strong>四个角色</strong></p>
<ul>
<li>Subject：抽象被观察者，把所有观察者对象的引用保存到集合中，然后<br>提供添加，移除，和通知观察者对象更新的方法。</li>
<li>ConcreteSubject：被观察者，集合存放观察者，重写增删和通知观察者<br>的方法，当发生变化时通知观察者更新。</li>
<li>Observer：抽象观察者，定义一个更新接口，给被观察者更新的时候调</li>
<li>ConcreteObserver：具体观察者，继承抽象观察者，实现具体的更新方法</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/05/5cf75f06c0a2c89200.png" alt="6.png"></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>有一个微信公众号服务，不定时发布一些消息，关注公众号就可以收到推送消息，取消关注就收不到推送消息。</p>
<ol>
<li><p>定义一个抽象被观察者接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 抽象被观察者接口</span><br><span class="line"> * 声明了添加、删除、通知观察者方法</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public interface Observerable &#123;</span><br><span class="line">    </span><br><span class="line">    public void registerObserver(Observer o);</span><br><span class="line">    public void removeObserver(Observer o);</span><br><span class="line">    public void notifyObserver();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义一个抽象观察者接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 抽象观察者</span><br><span class="line"> * 定义了一个update()方法，当被观察者调用notifyObservers()方法时，观察者的update()方法会被回调。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public interface Observer &#123;</span><br><span class="line">    public void update(String message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义被观察者，实现了Observerable接口，对Observerable接口的三个方法进行了具体实现，同时有一个List集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 被观察者，也就是微信公众号服务</span><br><span class="line"> * 实现了Observerable接口，对Observerable接口的三个方法进行了具体实现</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class WechatServer implements Observerable &#123;</span><br><span class="line">    </span><br><span class="line">    //注意到这个List集合的泛型参数为Observer接口，设计原则：面向接口编程而不是面向实现编程</span><br><span class="line">    private List&lt;Observer&gt; list;</span><br><span class="line">    private String message;</span><br><span class="line">    </span><br><span class="line">    public WechatServer() &#123;</span><br><span class="line">        list = new ArrayList&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void registerObserver(Observer o) &#123;</span><br><span class="line">        </span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void removeObserver(Observer o) &#123;</span><br><span class="line">        if(!list.isEmpty())</span><br><span class="line">            list.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历</span><br><span class="line">    @Override</span><br><span class="line">    public void notifyObserver() &#123;</span><br><span class="line">        for(int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            Observer oserver = list.get(i);</span><br><span class="line">            oserver.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setInfomation(String s) &#123;</span><br><span class="line">        this.message = s;</span><br><span class="line">        System.out.println(&quot;微信服务更新消息： &quot; + s);</span><br><span class="line">        //消息更新，通知所有观察者</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义具体观察者，微信公众号的具体观察者为用户User</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 观察者</span><br><span class="line"> * 实现了update方法</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class User implements Observer &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String message;</span><br><span class="line">    </span><br><span class="line">    public User(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void update(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.println(name + &quot; 收到推送消息： &quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写一个测试类</p>
<p>首先注册了三个用户，ZhangSan、LiSi、WangWu。公众号发布了一条消息”PHP是世界上最好用的语言！”，三个用户都收到了消息。</p>
<p>用户ZhangSan看到消息后颇为震惊，果断取消订阅，这时公众号又推送了一条消息，此时用户ZhangSan已经收不到消息，其他用户还是正常能收到推送消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        WechatServer server = new WechatServer();</span><br><span class="line">        </span><br><span class="line">        Observer userZhang = new User(&quot;ZhangSan&quot;);</span><br><span class="line">        Observer userLi = new User(&quot;LiSi&quot;);</span><br><span class="line">        Observer userWang = new User(&quot;WangWu&quot;);</span><br><span class="line">        </span><br><span class="line">        server.registerObserver(userZhang);</span><br><span class="line">        server.registerObserver(userLi);</span><br><span class="line">        server.registerObserver(userWang);</span><br><span class="line">        server.setInfomation(&quot;PHP是世界上最好用的语言！&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;----------------------------------------------&quot;);</span><br><span class="line">        server.removeObserver(userZhang);</span><br><span class="line">        server.setInfomation(&quot;JAVA是世界上最好用的语言！&quot;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>java内置的观察者模式</strong></p>
<p>在java.util包中包含有基本的Observer接口和Observable抽象类.功能上和Subject接口和Observer接口类似.不过在使用上,就方便多了,因为许多功能比如说注册,删除,通知观察者的那些功能已经内置好了.</p>
<p>使用javaAPI的观察者模式需要明白这么几件事情:</p>
<ol>
<li><p>如何使对象变为观察者?</p>
<p>实现观察者接口(java.util.Observer),然后调用Observable对象的addObserver()方法.不想再当观察者时,调用deleteObserver()就可以了.</p>
</li>
<li><p>被观察者(主题)如何发出通知?</p>
<p>第一步:先调用setChanged()方法,标识状态已经改变的事实.</p>
<p>第二步:调用notifyObservers()方法或者notifyObservers(Object arg),这就牵扯到推(push)和拉(pull)的方式传送数据.如果想用push的方式”推”数据给观察者,可以把数据当做数据对象传送给notifyObservers(Object arg)方法,其中的arg可以为任意对象,意思是你可以将任意对象传送给每一个观察者.如果调用不带参数的notifyObserver()方法,则意味着你要使用pull的方式去主题对象中”拉”来所需要的数据.</p>
</li>
<li><p>观察者如何接收通知?</p>
<p>观察者只需要实现一个update(Observable o,Object arg)方法,第一个参数o,是指定通知是由哪个主题下达的,第二个参数arg就是上面notifyObserver(Object arg)里传入的数据,如果不传该值,arg为null.</p>
</li>
</ol>
<p>这里以师生关系为例,老师和学生是一对多的关系,老师给学生布置作业,这个动作作为主题事件,每当老师布置一道题时,就要自动通知到所有的学生把该题记下来,然后再布置下一道题…</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/05/5cf762222786c58875.png" alt="9.png"></p>
<p>被观察者TeacherSubject:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Observable;</span><br><span class="line"></span><br><span class="line">public class JTeacher extends Observable &#123;</span><br><span class="line">        //布置作业的状态信息字符串</span><br><span class="line">    private String info;</span><br><span class="line">    public void setHomework(String info) &#123;</span><br><span class="line"></span><br><span class="line">        this.info=info;</span><br><span class="line">        System.out.println(&quot;布置的作业是&quot;+info);</span><br><span class="line"></span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    public String getInfo() &#123;</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察者StudentObserver:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Observable;</span><br><span class="line">import java.util.Observer;</span><br><span class="line"></span><br><span class="line">public class JStudent implements Observer&#123;</span><br><span class="line"></span><br><span class="line">    private Observable ob;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public JStudent(String name,Observable ob) &#123;</span><br><span class="line">        this.ob = ob;</span><br><span class="line">        this.name=name;</span><br><span class="line">        ob.addObserver(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(Observable o, Object arg) &#123;</span><br><span class="line">        JTeacher t=(JTeacher)o;</span><br><span class="line">        System.out.println(name+&quot;得到作业信息:&quot;+t.getInfo());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类TestObserver:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        JTeacher teacher=new JTeacher();</span><br><span class="line">        JStudent zhangSan=new JStudent(&quot;张三&quot;, teacher);</span><br><span class="line">        JStudent LiSi=new JStudent(&quot;李四&quot;, teacher);</span><br><span class="line">        JStudent WangWu=new JStudent(&quot;王五&quot;, teacher);</span><br><span class="line"></span><br><span class="line">        teacher.setHomework(&quot;第二页第六题&quot;);</span><br><span class="line">        teacher.setHomework(&quot;第三页第七题&quot;);</span><br><span class="line">        teacher.setHomework(&quot;第五页第八题&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">布置的作业是第二页第六题</span><br><span class="line">王五得到作业信息:第二页第六题</span><br><span class="line">李四得到作业信息:第二页第六题</span><br><span class="line">张三得到作业信息:第二页第六题</span><br><span class="line">布置的作业是第三页第七题</span><br><span class="line">王五得到作业信息:第三页第七题</span><br><span class="line">李四得到作业信息:第三页第七题</span><br><span class="line">张三得到作业信息:第三页第七题</span><br><span class="line">布置的作业是第五页第八题</span><br><span class="line">王五得到作业信息:第五页第八题</span><br><span class="line">李四得到作业信息:第五页第八题</span><br><span class="line">张三得到作业信息:第五页第八题</span><br></pre></td></tr></table></figure>

<p><strong>Java 9起淘汰了Observable及相关接口。</strong></p>
<ul>
<li>如果用Observable写的对象事件订阅机制，推荐用java.beans相关的类来代替。</li>
<li>如果用Observable写的进程间通信机制，文档推荐用java.util.concurrent并行库相关的类来代替。</li>
<li>如果用Observable写的反应式流水线机制，文档推荐用并行库的Flow及Future等类来代替。</li>
<li>如果仅仅是为了实现观察者设计模式，可以写自定义的类…或直接剪贴源码 </li>
</ul>
<h4 id="观察者模式与发布-订阅模式区别"><a href="#观察者模式与发布-订阅模式区别" class="headerlink" title="观察者模式与发布/订阅模式区别"></a>观察者模式与发布/订阅模式区别</h4><p><strong>观察者模式</strong></p>
<p>比较概念的解释是，目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法。</p>
<p>比如有个“天气中心”的具体目标A，专门监听天气变化，而有个显示天气的界面的观察者B，B就把自己注册到A里，当A触发天气变化，就调度B的更新方法，并带上自己的上下文。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/05/5cf760308ee6c45287.png" alt="7.png"></p>
<p><strong>发布/订阅模式</strong></p>
<p>比较概念的解释是，订阅者把自己想订阅的事件注册到调度中心，当该事件触发时候，发布者发布该事件到调度中心（顺带上下文），由调度中心统一调度订阅者注册到调度中心的处理代码。</p>
<p>比如有个界面是实时显示天气，它就订阅天气事件（注册到调度中心，包括处理程序），当天气变化时（定时获取数据），就作为发布者发布天气信息到调度中心，调度中心就调度订阅者的天气处理程序。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/05/5cf760308caaa37728.png" alt="8.png"></p>
<ol>
<li><p>从两张图片可以看到，最大的区别是调度的地方。</p>
<p>虽然两种模式都存在订阅者和发布者（具体观察者可认为是订阅者、具体目标可认为是发布者），但是观察者模式是由具体目标调度的，而发布/订阅模式是统一由调度中心调的，所以观察者模式的订阅者与发布者之间是存在依赖的，而发布/订阅模式则不会。</p>
</li>
<li><p>两种模式都可以用于松散耦合，改进代码管理和潜在的复用。</p>
</li>
</ol>
<h4 id="PUSH和PULL区别"><a href="#PUSH和PULL区别" class="headerlink" title="PUSH和PULL区别"></a>PUSH和PULL区别</h4><p>在观察者模式中，又分为推模型和拉模型两种方式。</p>
<ul>
<li><p>推模型:主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</p>
</li>
<li><p>拉模型:主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</p>
</li>
</ul>
<p>推送(Push)技术是根据用户需要，有目的、按时将用户感兴趣的信息主动发送到用户的计算机中。Push技术的主要优点是对用户要求低，  普遍适用于广大公众，不要求有专门的技术；二是及时性好，信源及时地向用户“推送”不断更新的动态信息。但是，在随后实际应用中，因为存在以下几方面不  足，Push技术并没有取得预期的成功：</p>
<ul>
<li>不能确保发送成功。由于Push技术采用广播方式，当网络信息中心发送信息时，只有接收器打开并正好切换到同一频道上，传输才能发生作用，用户才能获取信息。这对于那些要确保能收到信息的应用领域是不太适合的。</li>
<li>没有信息状态跟踪。Push技术采用的是“开环控制”模式，一个信息发布以后的状态，如用户是否接收，或客户端收到后是否按信息的提示执行了任务等，这些“反馈信息”发布者无从得知。</li>
<li>针对性差。推送的信息内容缺乏针对性，不能满足用户的个性化需求。有价值的重要信息，通常都是要针对一些特定的群组来发送的，即只送给相关的人士。Push技术不能满足上述需求。</li>
<li>信源任务重。信源系统要主动地、快速地、不断地将大量信息推送给用户。 </li>
</ul>
<p>拉取(Pull)技术指用户有目的地在网络上主动查询信息，用户从浏览器给Web发出请求，由Web获取所需信息。面对拥有海量信息的  Internet环境，搜索引擎是有效的网络信息“拉取”(查询)的检索工具。Pull技术的主要优点是针对性强，能满足用户的个性化需求；信息传输量  小，网络上所传输的只是用户的请求和服务器针对该请求所作的响应；信源任务轻，信息系统只是被动接受查询，提供用户所需的部分信息。其主要缺点是及时性  差，由于用户只会基于自己的知识水平(或专业水平)提出请求，当信源中信息更新变化时，用户难以及时拉取新的动态信息，虽然可以通过定时查询来解决这个问  题，但是会浪费大量的网络资源和人力，而且，仍不能保证最好的实时性。对用户要求高，要求用户对信源系统有相应的专业知识，掌握相关的检索技术。</p>
<table>
<thead>
<tr>
<th></th>
<th>push模型</th>
<th>pull模型</th>
</tr>
</thead>
<tbody><tr>
<td>描述</td>
<td>服务端主动发送数据给客户端</td>
<td>客户端主动从服务端拉取数据，通常客户端会定时拉取</td>
</tr>
<tr>
<td>实时性</td>
<td>较好，收到数据后可立即发送给客户端</td>
<td>一般，取决于pull的间隔时间</td>
</tr>
<tr>
<td>服务端状态</td>
<td>需要保存push状态，哪些客户端已经发送成功，哪些发送失败</td>
<td>服务端无状态</td>
</tr>
<tr>
<td>客户端状态</td>
<td>无需额外保存状态</td>
<td>需保存当前拉取的信息的状态，以便在故障或者重启的时候恢复</td>
</tr>
<tr>
<td>状态保存</td>
<td>集中式，集中在服务端</td>
<td>分布式，分散在各个客户端</td>
</tr>
<tr>
<td>负载均衡</td>
<td>服务端统一处理和控制</td>
<td>客户端之间做分配，需要协调机制，如使用zookeeper</td>
</tr>
<tr>
<td>其他</td>
<td>服务端需要做流量控制，无法最大化客户端的处理能力。     其次，在客户端故障情况下，无效的push对服务端有一定负载。</td>
<td>客户端的请求可能很多无效或者没有数据可供传输，浪费带宽和服务器处理能力</td>
</tr>
<tr>
<td>缺点方案</td>
<td>服务器端的状态存储是个难点，可以将这些状态转移到DB或者key-value存储，来减轻server压力。</td>
<td>针对实时性的问题，可以将push加入进来，push小数据的通知信息，让客户端再来主动pull。     针对无效请求的问题，可以设置逐渐延长间隔时间的策略，以及合理设计协议尽量缩小请求数据包来节省带宽。</td>
</tr>
</tbody></table>
<p><strong>PUSH和PULL两种模式结合</strong></p>
<p>将信息推送与拉取两种模式结合能做到取长补短，使二者优势互补。根据推、拉结合顺序及结合方式的差异，又分以下四种不同推拉模式：</p>
<ul>
<li><p>先推后拉——先由信源及时推送公共信息，再由用户有针对性地拉取个性化信息；</p>
</li>
<li><p>先拉后推——根据用户拉取的信息，信源进一步主动提供(推送)与之相关的信息；</p>
</li>
<li><p>推中有拉——在信息推送过程中，允许用户随时中断并定格在感兴趣的网页上，以拉取更有针对性的信息；</p>
</li>
<li><p>拉中有推——根据用户搜索(即拉取)过程中所用的关键字，信源主动推送相关的最新信息。 </p>
</li>
</ul>
<p>在面对大量甚至海量客户端的时候，使用push模型，保存大量的状态信息是个沉重的负担，加上复制N份数据分发的压力，也会使得实时性这唯 一的优点也被放小。使用pull模型，通过将客户端状态保存在客户端，大大减轻了服务器端压力，通过客户端自身做流量控制也更容易，更能发挥客户端的处理 能力，但是需要面对如何在这些客户端之间做协调的难题。</p>
<p>客户端和服务端的交互有推和拉两种方式：如果是客户端拉的话，通常就是Polling；如果是服务端<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Push_technology">推</a>的话，一般就是<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Comet_(programming)">Comet</a>，目前比较流行的Comet实现方式是Long Polling。</p>
<p>注：如果不清楚相关名词含义，可以参考：<a target="_blank" rel="noopener" href="http://josephj.com/entry.php?id=358">Browser 與 Server 持續同步的作法介紹</a>。</p>
<p>先来看看Polling，它其实就是我们平常所说的轮询，大致如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/07/5cfa183e4c68910824.png" alt="2.png"></p>
<p>因为服务端不会主动告诉客户端它是否有新数据，所以Polling的实时性较差。虽然可以通过加快轮询频率的方式来缓解这个问题，但相应付出的代价也不小：一来会使负载居高不下，二来也会让带宽捉襟见肘。</p>
<p>再来说说Long Polling，如果使用传统的LAMP技术去实现的话，大致如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/07/5cfa1906258a198078.png" alt="3.png"></p>
<p>客户端不会频繁的轮询服务端，而是对服务端发起一个长连接，服务端通过轮询数据库来确定是否有新数据，一旦发现新数据便给客户端发出响应，这次交互便结束了。客户端处理好新数据后再重新发起一个长连接，如此周而复始。</p>
<p>在上面这个Long Polling方案里，我们解决了Polling中客户端轮询造成的负载和带宽的问题，但是依然存在服务端轮询，数据库的压力可想而知，此时我们虽然可以通过针对数据库使用主从复制，分片等技术来缓解问题，但那毕竟只是治标不治本。</p>
<p>我们的目标是实现一个简单的服务端推方案，但简单绝对不意味着简陋，轮询数据库是不可以接受的，下面我们来看看如何解决这个问题。在这里我们放弃了传统的LAMP技术，转而使用<a target="_blank" rel="noopener" href="http://huoding.com/2012/08/31/156">Nginx与Lua</a>来实现。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/07/5cfa19272e30923981.png" alt="4.png"></p>
<p>此方案的主要思路是这样的：使用Nginx作为服务端，通过Lua协程来创建长连接，一旦数据库里有新数据，它便主动通知Nginx，并把  相应的标识(比如一个自增的整数ID)保存在Nginx共享内存中，接下来，Nginx不会再去轮询数据库，而是改为轮询本地的共享内存，通过比对标识来  判断是否有新消息，如果有便给客户端发出响应。</p>
<p>​    注：服务端维持大量长连接时内核参数的调整请参考：<a target="_blank" rel="noopener" href="http://blog.lifeibo.com/?p=269">http长连接200万尝试及调优</a>。</p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>
<p>迭代器模式属于行为型模式。</p>
<p><strong>意图：</strong>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p>
<p><strong>主要解决：</strong>不同的方式来遍历整个整合对象。</p>
<p><strong>何时使用：</strong>遍历一个聚合对象。</p>
<p><strong>如何解决：</strong>把在元素之间游走的责任交给迭代器，而不是聚合对象。</p>
<p><strong>关键代码：</strong>定义接口：hasNext, next。</p>
<p><strong>应用实例：</strong>JAVA 中的 iterator。</p>
<p><strong>优点：</strong> </p>
<ol>
<li>它支持以不同的方式遍历一个聚合对象。</li>
<li>迭代器简化了聚合类。</li>
<li>在同一个聚合上可以有多个遍历。 </li>
<li>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。 </li>
</ol>
<p><strong>缺点：</strong>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p>
<p><strong>使用场景：</strong> </p>
<ol>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。 </li>
<li>需要为聚合对象提供多种遍历方式。 </li>
<li>为遍历不同的聚合结构提供一个统一的接口。 </li>
</ol>
<p><strong>注意事项：</strong>迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p>
<p><strong>四个角色</strong>：</p>
<ul>
<li>Iterator：迭代器角色，定义访问和遍历元素的接口；</li>
<li>ConcreteIterator：具体迭代器角色，实现接口中的方法，并且记录遍历的当前位置；</li>
<li>Container：容器角色，提供创建具体迭代器角色的接口；</li>
<li>ConcreteContainer：具体容器角色，具体迭代器角色与容器相关联</li>
</ul>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>这里我们举个遍历歌单的例子，首先是容器中的元素，歌曲</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Song &#123;</span><br><span class="line"></span><br><span class="line">    public Song(String name, String singer) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.singer = singer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private String singer;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123; return name; &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123; this.name = name;&#125;</span><br><span class="line"></span><br><span class="line">    public String getSinger() &#123; return singer; &#125;</span><br><span class="line"></span><br><span class="line">    public void setSinger(String singer) &#123; this.singer = singer; &#125;</span><br><span class="line"></span><br><span class="line">    @Override public String toString() &#123;</span><br><span class="line">        return &quot;【歌名】&quot; + name + &quot; - &quot; + singer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着写个<strong>抽象迭代器</strong>，第一项，下一个，判断是否能下一个，获取当前项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface Iterator &#123;</span><br><span class="line"></span><br><span class="line">    Song first();</span><br><span class="line"></span><br><span class="line">    Song next();</span><br><span class="line"></span><br><span class="line">    boolean hashNext();</span><br><span class="line"></span><br><span class="line">    Song currentItem();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再接着是<strong>抽象容器</strong>，定义一个生成迭代器的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface SongList &#123;</span><br><span class="line">    Iterator getIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义<strong>具体容器</strong>，集成抽象容器，并定义一个<strong>具体迭代器内部类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import sun.rmi.runtime.Log;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class MyStoryList implements SongList&#123;</span><br><span class="line">    private List&lt;Song&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public MyStoryList(List&lt;Song&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public Iterator getIterator() &#123;</span><br><span class="line">        return new SongListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class SongListIterator implements Iterator &#123;</span><br><span class="line"></span><br><span class="line">        private int cursor;</span><br><span class="line"></span><br><span class="line">        @Override public Song first() &#123;</span><br><span class="line">            cursor = 0;</span><br><span class="line">            return list.get(cursor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override public Song next() &#123;</span><br><span class="line">            Song song = null;</span><br><span class="line">            cursor++;</span><br><span class="line">            if(hashNext()) &#123;</span><br><span class="line">                song = list.get(cursor);</span><br><span class="line">            &#125;</span><br><span class="line">            return song;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override public boolean hashNext() &#123;</span><br><span class="line">            return !(cursor == list.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override public Song currentItem() &#123;</span><br><span class="line">            return list.get(cursor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后客户端调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Song&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(new Song(&quot;空白格&quot;,&quot;杨宗纬&quot;));</span><br><span class="line">        list.add(new Song(&quot;那时候的我&quot;,&quot;刘惜君&quot;));</span><br><span class="line">        list.add(new Song(&quot;黑泽明&quot;,&quot;陈奕迅&quot;));</span><br><span class="line">        list.add(new Song(&quot;今天只做一件事&quot;,&quot;陈奕迅&quot;));</span><br><span class="line">        list.add(new Song(&quot;童话镇&quot;,&quot;陈一发儿&quot;));</span><br><span class="line"></span><br><span class="line">        MyStoryList songList = new MyStoryList(list);</span><br><span class="line"></span><br><span class="line">        Iterator iterator = songList.getIterator();</span><br><span class="line"></span><br><span class="line">        while (iterator.hashNext()) &#123;</span><br><span class="line">            System.out.println(iterator.currentItem().toString());</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，迭代器模式的例子就那么简单，其实Java中的容器类已经为我们提供了 相应的迭代器，而不需要我们另外去实现了。比如Util包中的Iterator接口。</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 </p>
<p><strong>意图：</strong>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
<p><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p>
<p><strong>何时使用：</strong>在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p>
<p><strong>如何解决：</strong>通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。</p>
<p><strong>关键代码：</strong>定义三个角色：</p>
<ol>
<li>received 真正的命令执行对象 </li>
<li>Command </li>
<li>invoker 使用命令对象的入口</li>
</ol>
<p><strong>应用实例：</strong>struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。</p>
<p><strong>优点：</strong> </p>
<ol>
<li><p>更松散的耦合，请求者无需知道执行者是谁，如何执行指令。</p>
</li>
<li><p>更动态的控制，将请求封装，可以动态进行参数化，队列化，日志化等操作。</p>
</li>
<li><p>命令可以复合，即一个命令可以由多个命令组合而成，又叫宏命令。</p>
</li>
<li><p>更好的扩展性，因为命令发起者与执行者解耦，扩展新命令，只需实现新的命令对象，在需要的时候把具体的实现对象传入到命令对象中，就可以使用这个命令对象了，已有的实现完全不用变化。</p>
</li>
<li><p>为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。</p>
</li>
</ol>
<p><strong>缺点：</strong>使用命令模式可能会导致某些系统有过多的具体命令类。</p>
<p><strong>使用场景：</strong>认为是命令的地方都可以使用命令模式，比如： </p>
<ol>
<li><p>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求<br>调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。</p>
</li>
<li><p>系统需要在不同的时间指定请求和执行请求。一个命令对象和请求的初始调用者可<br>以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然<br>是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，<br>可以通过请求日志文件等机制来具体实现。</p>
</li>
<li><p>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</p>
</li>
<li><p>系统需要将一组操作组合在一起形成宏命令。</p>
</li>
</ol>
<p><strong>注意事项：</strong>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</p>
<p><strong>四个角色</strong>：</p>
<ul>
<li>Command：命令，声明具体命令的抽象接口。</li>
<li>ConcreteCommand：具体命令，接收者对象绑定与一个动作。</li>
<li>Receiver：接收者，执行与请求相关的操作，具体实现对请求的业务处理。</li>
<li>Invoker：调用者，负责调用命令对象执行请求，相关的方法叫做行动方法。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/05/5cf76904e597d94017.png" alt="10.png"></p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>摆地摊：顾客 –点餐-&gt; 老板 –收到点餐指令-&gt; 制作菜肴</p>
<p>写成代码的话：就是顾客中持有对老板的引用，然后执行指令的时候调用老板中制作菜肴的方法。这里的请求者直接与实现者进行交互，耦合度比较高！</p>
<p>开店：</p>
<p>增加了一个服务员的角色，接收用户指令，处理指令，然后调用老板进行菜肴制作，中途还可以记录命令请求，或者做撤销命令的操作。</p>
<p>这里用命令模式写个简单的播放控制例子吧。</p>
<p>首先创建播放对象，就一个故事名和播放URL的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Story &#123;</span><br><span class="line">    private String sName;</span><br><span class="line">    private String sUrl;</span><br><span class="line"></span><br><span class="line">    public Story(String sName, String sUrl) &#123;</span><br><span class="line">        this.sName = sName;</span><br><span class="line">        this.sUrl = sUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getsUrl() &#123;</span><br><span class="line">        return sUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setsUrl(String sUrl) &#123;</span><br><span class="line">        this.sUrl = sUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getsName() &#123;</span><br><span class="line"></span><br><span class="line">        return sName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setsName(String sName) &#123;</span><br><span class="line">        this.sName = sName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建<strong>命令执行者</strong>，一个音乐播放器，提供设置播放列表，播放，暂停等方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class StoryPlayer &#123;</span><br><span class="line"></span><br><span class="line">    private int cursor = 0; //当前播放项</span><br><span class="line"></span><br><span class="line">    private int pauseCursor = -1;   //暂停播放项</span><br><span class="line"></span><br><span class="line">    private List&lt;Story&gt; playList = new ArrayList&lt;&gt;();   //播放列表</span><br><span class="line"></span><br><span class="line">    public void setPlayList(List&lt;Story&gt; list) &#123;</span><br><span class="line">        this.playList = list;</span><br><span class="line">        cursor = 0;</span><br><span class="line">        System.out.println(&quot;更新播放列表...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void play() &#123;</span><br><span class="line">        cursor = 0;</span><br><span class="line">        play(cursor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void play(int cursor) &#123;</span><br><span class="line">        if(playList.size() == 0) &#123;</span><br><span class="line">            System.out.println(&quot;当前播放列表为空，请先设置播放列表！&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if(pauseCursor == cursor) &#123;</span><br><span class="line">                System.out.println(&quot;继续播放第&quot; + pauseCursor + &quot;个故事: 《&quot; + playList.get(pauseCursor).getsName() + &quot;》&quot;);</span><br><span class="line">            &#125; else  &#123;</span><br><span class="line">                this.cursor = cursor;</span><br><span class="line">                System.out.println(&quot;开始播放第&quot; + cursor + &quot;个故事: 《&quot; + playList.get(cursor).getsName() + &quot;》&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void next() &#123;</span><br><span class="line">        cursor++;</span><br><span class="line">        if(cursor == playList.size()) cursor = 0;</span><br><span class="line">        play(cursor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pre() &#123;</span><br><span class="line">        cursor--;</span><br><span class="line">        if(cursor &lt; 0) cursor = playList.size() - 1;</span><br><span class="line">        play(cursor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pause() &#123;</span><br><span class="line">        pauseCursor = cursor;</span><br><span class="line">        System.out.println(&quot;暂停播放！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着创建<strong>抽象命令接口</strong>，就一个**execute()**的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Command &#123;</span><br><span class="line">   void execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着继承这个接口，写各种<strong>具体命令类</strong>，设置列表，播放，暂停，下一首，上一首 都是照葫芦画瓢，实现execute()方法，调用执行者里面的对应方法而已。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class SetListCommand implements Command &#123;</span><br><span class="line"></span><br><span class="line">    private StoryPlayer mPlayer;</span><br><span class="line"></span><br><span class="line">    private List&lt;Story&gt; mList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public SetListCommand(StoryPlayer mPlayer) &#123;</span><br><span class="line">        this.mPlayer = mPlayer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void execute() &#123;</span><br><span class="line">        mPlayer.setPlayList(mList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPlayList(List&lt;Story&gt; list) &#123;</span><br><span class="line">        this.mList = list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class PlayCommand implements Command &#123;</span><br><span class="line"></span><br><span class="line">    private StoryPlayer mPlayer;</span><br><span class="line"></span><br><span class="line">    public PlayCommand(StoryPlayer mPlayer) &#123;</span><br><span class="line">        this.mPlayer = mPlayer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void execute() &#123;</span><br><span class="line">        mPlayer.play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PauseCommand implements Command &#123;</span><br><span class="line"></span><br><span class="line">    private StoryPlayer mPlayer;</span><br><span class="line"></span><br><span class="line">    public PauseCommand(StoryPlayer mPlayer) &#123;</span><br><span class="line">        this.mPlayer = mPlayer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void execute() &#123;</span><br><span class="line">        mPlayer.pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class NextCommand implements Command &#123;</span><br><span class="line"></span><br><span class="line">    private StoryPlayer mPlayer;</span><br><span class="line"></span><br><span class="line">    public NextCommand(StoryPlayer mPlayer) &#123;</span><br><span class="line">        this.mPlayer = mPlayer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void execute() &#123;</span><br><span class="line">        mPlayer.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class PreCommand implements Command &#123;</span><br><span class="line"></span><br><span class="line">    private StoryPlayer mPlayer;</span><br><span class="line"></span><br><span class="line">    public PreCommand(StoryPlayer mPlayer) &#123;</span><br><span class="line">        this.mPlayer = mPlayer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void execute() &#123;</span><br><span class="line">        mPlayer.pre();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再接着是<strong>请求者类</strong>，低啊用命令对象执行具体的操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class Invoker &#123;</span><br><span class="line">    private SetListCommand setListCommand;</span><br><span class="line">    private PlayCommand playCommand;</span><br><span class="line">    private PauseCommand pauseCommand;</span><br><span class="line">    private NextCommand nextCommand;</span><br><span class="line">    private PreCommand preCommand;</span><br><span class="line"></span><br><span class="line">    public void setSetListCommand(SetListCommand setListCommand) &#123;</span><br><span class="line">        this.setListCommand = setListCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPlayCommand(PlayCommand playCommand) &#123;</span><br><span class="line">        this.playCommand = playCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPauseCommand(PauseCommand pauseCommand) &#123;</span><br><span class="line">        this.pauseCommand = pauseCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNextCommand(NextCommand nextCommand) &#123;</span><br><span class="line">        this.nextCommand = nextCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPreCommand(PreCommand preCommand) &#123;</span><br><span class="line">        this.preCommand = preCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 设置播放列表 */</span><br><span class="line">    public void setPlayList(List&lt;Story&gt; list) &#123;</span><br><span class="line">        setListCommand.setPlayList(list);</span><br><span class="line">        setListCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 播放 */</span><br><span class="line">    public void play() &#123;</span><br><span class="line">        playCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 暂停 */</span><br><span class="line">    public void pause() &#123;</span><br><span class="line">        pauseCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 下一首 */</span><br><span class="line">    public void next() &#123;</span><br><span class="line">        nextCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 上一首 */</span><br><span class="line">    public void pre() &#123;</span><br><span class="line">        preCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后客户端调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //实例化播放列表</span><br><span class="line">        List&lt;Story&gt; mList = new ArrayList&lt;&gt;();</span><br><span class="line">        mList.add(new Story(&quot;白雪公主&quot;,&quot;&quot;));</span><br><span class="line">        mList.add(new Story(&quot;青蛙的愿望&quot;,&quot;&quot;));</span><br><span class="line">        mList.add(new Story(&quot;驴和妈&quot;,&quot;&quot;));</span><br><span class="line">        mList.add(new Story(&quot;小青蛙的烦恼&quot;,&quot;&quot;));</span><br><span class="line">        mList.add(new Story(&quot;三字经&quot;,&quot;&quot;));</span><br><span class="line"></span><br><span class="line">        //实例化接收者</span><br><span class="line">        StoryPlayer mPlayer = new StoryPlayer();</span><br><span class="line"></span><br><span class="line">        //实例化命令对象</span><br><span class="line">        Command setListCommand = new SetListCommand(mPlayer);</span><br><span class="line">        Command playCommand = new PlayCommand(mPlayer);</span><br><span class="line">        Command pauseCommand = new PauseCommand(mPlayer);</span><br><span class="line">        Command nextCommand = new NextCommand(mPlayer);</span><br><span class="line">        Command preCommand = new PreCommand(mPlayer);</span><br><span class="line"></span><br><span class="line">        //实例化请求者</span><br><span class="line">        Invoker invoker = new Invoker();</span><br><span class="line">        invoker.setSetListCommand((SetListCommand) setListCommand);</span><br><span class="line">        invoker.setPlayList(mList);</span><br><span class="line">        invoker.setPlayCommand((PlayCommand) playCommand);</span><br><span class="line">        invoker.setPauseCommand((PauseCommand) pauseCommand);</span><br><span class="line">        invoker.setNextCommand((NextCommand) nextCommand);</span><br><span class="line">        invoker.setPreCommand((PreCommand) preCommand);</span><br><span class="line"></span><br><span class="line">        //测试调用</span><br><span class="line">        invoker.play();</span><br><span class="line">        invoker.next();</span><br><span class="line">        invoker.next();</span><br><span class="line">        invoker.next();</span><br><span class="line">        invoker.next();</span><br><span class="line">        invoker.next();</span><br><span class="line">        invoker.pause();</span><br><span class="line">        invoker.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">更新播放列表...</span><br><span class="line">开始播放第0个故事: 《白雪公主》</span><br><span class="line">开始播放第1个故事: 《青蛙的愿望》</span><br><span class="line">开始播放第2个故事: 《驴和妈》</span><br><span class="line">开始播放第3个故事: 《小青蛙的烦恼》</span><br><span class="line">开始播放第4个故事: 《三字经》</span><br><span class="line">开始播放第0个故事: 《白雪公主》</span><br><span class="line">暂停播放！</span><br><span class="line">继续播放第0个故事: 《白雪公主》</span><br></pre></td></tr></table></figure>

<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</p>
<p><strong>意图：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<p><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p>
<p><strong>何时使用：</strong>很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。</p>
<p><strong>如何解决：</strong>通过一个备忘录类专门存储对象状态。</p>
<p><strong>关键代码：</strong>客户不与备忘录类耦合，与备忘录管理类耦合。</p>
<p><strong>应用实例：</strong> </p>
<ol>
<li>后悔药。</li>
<li>打游戏时的存档。 </li>
<li>Windows 里的 ctri + z。 </li>
<li>IE 中的后退。</li>
<li>数据库的事务管理。 </li>
</ol>
<p><strong>优点：</strong> </p>
<ol>
<li><p><strong>更好的封装性</strong>，不把发起人对象的内部实现细节暴露给外部；</p>
</li>
<li><p><strong>简化了发起人</strong>，把备忘录对象保存到发起人对象之外，让客户来管理请求的状态；</p>
</li>
<li><p><strong>窄接口和宽接口</strong>，窄接口保证了只有发起者才能访问备忘录对象的状态； </p>
</li>
</ol>
<p><strong>缺点：</strong>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p>
<p><strong>使用场景：</strong> </p>
<ol>
<li>需要保存/恢复数据的相关状态场景。 </li>
<li>提供一个可回滚的操作。 </li>
</ol>
<p><strong>注意事项：</strong>  </p>
<ol>
<li>为了符合迪米特原则，还要增加一个管理备忘录的类。 </li>
<li>为了节约内存，可使用原型模式+备忘录模式。 </li>
</ol>
<p><strong>三个角色：</strong></p>
<ul>
<li>Originator：发起人，创建一个备忘录，可以记录，恢复自身的内部状态，还可根据<br>需求决定存储那些内部状态。</li>
<li>Memento：备忘录，存储发起人角色的内部状态，并防止外部对象访问备忘录。</li>
<li>Caretaker：管理者，存储备忘录，不能对备忘录内容进行访问，只能将其传递<br>给其他对象。</li>
</ul>
<p><strong>UML类图</strong></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/05/5cf76ba3f32ad70529.png" alt="11.png"></p>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>这里举个简单的RPG游戏的例子，存档保存当前血量，蓝量，以及有用金币。<br>定义<strong>备忘录类</strong>，即存档的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Memento &#123;</span><br><span class="line">    private int hp;</span><br><span class="line">    private int mp;</span><br><span class="line">    private int money;</span><br><span class="line"></span><br><span class="line">    public Memento(int hp, int mp, int money) &#123;</span><br><span class="line">        this.hp = hp;</span><br><span class="line">        this.mp = mp;</span><br><span class="line">        this.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getHp() &#123;</span><br><span class="line">        return hp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMp() &#123;</span><br><span class="line">        return mp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMoney() &#123;</span><br><span class="line">        return money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着定义一个<strong>角色类</strong>（发起人角色），除了属性定义，还有两件关键的事 要做：<strong>定义保存方法</strong>，保存自身状态；<strong>定义恢复方法</strong>，传入备忘录对象， 自行回复需要回复的项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class Character &#123;</span><br><span class="line">    private int hp;</span><br><span class="line">    private int mp;</span><br><span class="line">    private int money;</span><br><span class="line"></span><br><span class="line">    public Character(int hp, int mp, int money) &#123;</span><br><span class="line">        this.hp = hp;</span><br><span class="line">        this.mp = mp;</span><br><span class="line">        this.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getHp() &#123;</span><br><span class="line">        return hp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHp(int hp) &#123;</span><br><span class="line">        this.hp = hp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMp() &#123;</span><br><span class="line">        return mp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMp(int mp) &#123;</span><br><span class="line">        this.mp = mp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMoney() &#123;</span><br><span class="line">        return money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMoney(int money) &#123;</span><br><span class="line">        this.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showMsg() &#123;</span><br><span class="line">        System.out.println(&quot;当前状态：| HP：&quot; + hp + &quot; | MP：&quot; + mp + &quot; | 金钱：&quot; + money + &quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建一个备忘录，保存当前自身状态</span><br><span class="line">    public Memento save() &#123;</span><br><span class="line">        return new Memento(hp, mp, money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //传入一个备忘录对象，恢复内部状态</span><br><span class="line">    public void restore(Memento memento) &#123;</span><br><span class="line">        this.hp = memento.getHp();</span><br><span class="line">        this.mp = memento.getMp();</span><br><span class="line">        this.money = memento.getMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再接着是备忘录管理者类，<strong>只负责备忘录对象的传递</strong>！<br>PS：如果是多个存档的，<strong>可以用一个集合存备忘录</strong>，然后根据一个索引来获取对应的备忘录！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Caretaker &#123;</span><br><span class="line">    private Memento memento;</span><br><span class="line"></span><br><span class="line">    public Memento getMemento() &#123;</span><br><span class="line">        return memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMemento(Memento memento) &#123;</span><br><span class="line">        this.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，客户端调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Caretaker caretaker= new Caretaker();</span><br><span class="line">        Character character = new Character(2000,1000,500);</span><br><span class="line">        //存档</span><br><span class="line">        System.out.println(&quot;=== 存档中... ===&quot;);</span><br><span class="line">        character.showMsg();</span><br><span class="line">        caretaker.setMemento(character.save());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;=== 单挑Boss，不敌，金钱扣除一半... ===&quot;);</span><br><span class="line">        character.setHp(0);</span><br><span class="line">        character.setHp(0);</span><br><span class="line">        character.setHp(250);</span><br><span class="line">        character.showMsg();</span><br><span class="line"></span><br><span class="line">        //读档</span><br><span class="line">        System.out.println(&quot;=== 读取存档中... ===&quot;);</span><br><span class="line">        character.restore(caretaker.getMemento());</span><br><span class="line">        character.showMsg();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">=== 存档中... ===</span><br><span class="line">当前状态：| HP：2000 | MP：1000 | 金钱：500</span><br><span class="line"></span><br><span class="line">=== 单挑Boss，不敌，金钱扣除一半... ===</span><br><span class="line">当前状态：| HP：250 | MP：1000 | 金钱：500</span><br><span class="line"></span><br><span class="line">=== 读取存档中... ===</span><br><span class="line">当前状态：| HP：2000 | MP：1000 | 金钱：500</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/05/24/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4/">https://pingxin0521.gitee.io/2019/05/24/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/05/24/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-5/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">设计模式--行为型（下）</div></div></a></div><div class="next-post pull-right"><a href="/2019/05/23/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-7/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式--结构型（下）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/05/21/Java-设计模式-1/" title="设计模式入坑"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-06-07</div><div class="title">设计模式入坑</div></div></a></div><div><a href="/2019/05/25/Java-设计模式-6/" title="JavaEE 模式"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-06-06</div><div class="title">JavaEE 模式</div></div></a></div><div><a href="/2019/05/23/Java-设计模式-3/" title="设计模式--结构型（上）"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-02-12</div><div class="title">设计模式--结构型（上）</div></div></a></div><div><a href="/2019/05/22/Java-设计模式-2/" title="设计模式--创造型"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-02-12</div><div class="title">设计模式--创造型</div></div></a></div><div><a href="/2019/05/24/Java-设计模式-5/" title="设计模式--行为型（下）"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-06-05</div><div class="title">设计模式--行为型（下）</div></div></a></div><div><a href="/2019/05/23/Java-设计模式-7/" title="设计模式--结构型（下）"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-06-05</div><div class="title">设计模式--结构型（下）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">2.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">观察者模式与发布&#x2F;订阅模式区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUSH%E5%92%8CPULL%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">PUSH和PULL区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">迭代器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">3.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">命令模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">4.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">备忘录模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">5.1.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
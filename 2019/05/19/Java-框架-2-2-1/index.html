<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JSON框架--Gson 基础使用 | 平心de小屋</title><meta name="keywords" content="Java,框架"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="GSON是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库。可以将一个Json字符转成一个Java对象，或者将一个Java转化为Json字符串。">
<meta property="og:type" content="article">
<meta property="og:title" content="JSON框架--Gson 基础使用">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/05/19/Java-%E6%A1%86%E6%9E%B6-2-2-1/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="GSON是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库。可以将一个Json字符转成一个Java对象，或者将一个Java转化为Json字符串。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg">
<meta property="article:published_time" content="2019-05-19T05:18:59.000Z">
<meta property="article:modified_time" content="2019-07-13T14:03:22.000Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="框架">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/05/19/Java-%E6%A1%86%E6%9E%B6-2-2-1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JSON框架--Gson 基础使用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2019-07-13 22:03:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JSON框架--Gson 基础使用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-05-19T05:18:59.000Z" title="发表于 2019-05-19 13:18:59">2019-05-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-07-13T14:03:22.000Z" title="更新于 2019-07-13 22:03:22">2019-07-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E6%A1%86%E6%9E%B6/">框架</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JSON框架--Gson 基础使用"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>GSON是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库。可以将一个Json字符转成一个Java对象，或者将一个Java转化为Json字符串。</p>
<span id="more"></span>

<p>在开发领域中数据传递有很多形式，通常数据调用交互采用XML，JSON，数据流，纯文本等形式；越来越多数据调用采用JSON，因为JSON数据结构简单，数据字节长度短，既简单又快速何乐而不为呢？</p>
<p>从JSON的结构入手，所有json数据最终分为三种情况：</p>
<ol>
<li>标量（Scalar)，也就是单纯的字符串或则数字形式</li>
<li>序列（Sequence)，也就是若干数据按照一定顺序并列在一起又称“数组”</li>
<li>映射（Mapping)，也就是key/value键值对<br> Json的规格非常简单,此文章就不一一描述</li>
</ol>
<p><strong>特点</strong>：</p>
<ul>
<li>快速、高效</li>
<li>代码量少、简洁</li>
<li>面向对象</li>
<li>数据传递和解析方便</li>
</ul>
<p><strong>基本概念</strong></p>
<ul>
<li>Serialization:序列化，使Java对象到Json字符串的过程。</li>
<li>Deserialization：反序列化，字符串转换成Java对象。</li>
<li>JSON数据中的<code>JsonElement</code>有下面这四种类型：<ul>
<li>JsonPrimitive —— 例如一个字符串或整型</li>
<li> JsonObject—— 一个以 JsonElement 名字（类型为           String）作为索引的集合。也就是说可以把 </li>
<li>JsonObject 看作值为 JsonElement 的键值对集合。</li>
<li> JsonArray—— JsonElement 的集合。注意数组的元素可以是四种类型中的任意一种，或者混合类型都支持。</li>
<li> JsonNull—— 值为null</li>
</ul>
</li>
</ul>
<p><strong>Gson解决的问题</strong></p>
<ol>
<li>提供一种像toString()和构造方法的很简单的机制，来实现Java 对象和Json之间的互相转换。</li>
<li>允许已经存在的无法改变的对象，转换成Json，或者Json转换成已存在的对象。</li>
<li>允许自定义对象的表现形式</li>
<li>支持任意的复杂对象</li>
<li>能够生成可压缩和可读的Json的字符串输</li>
</ol>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><strong>知识点</strong></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/07/13/5d29ac91de61425202.png" alt="1.png"></p>
<p>Gson的pom依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Gson的创建方式</strong></p>
<p>方式一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> gson();</span><br></pre></td></tr></table></figure>

<p>方式二：通过GsonBuilder()，可以配置多种配置，<strong>重要</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> GsonBuilder()</span><br><span class="line">    .registerTypeAdapter(Id.class, <span class="keyword">new</span> IdTypeAdapter()) <span class="comment">//单独对Id类设置了独立解析方式</span></span><br><span class="line">    .setLenient()<span class="comment">// json宽松  </span></span><br><span class="line">    .enableComplexMapKeySerialization()<span class="comment">//支持Map的key为复杂对象的形式  </span></span><br><span class="line">    .serializeNulls() <span class="comment">//智能null  </span></span><br><span class="line">    .setPrettyPrinting()<span class="comment">// 调教格式  </span></span><br><span class="line">    .setDateFormat(DateFormat.LONG)  <span class="comment">//设置时间转换格式</span></span><br><span class="line">    .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)<span class="comment">//会把字段首字母大写</span></span><br><span class="line">    .disableHtmlEscaping() <span class="comment">//默认是GSON把HTML 转义的</span></span><br><span class="line">    .setVersion(<span class="number">1.0</span>)    </span><br><span class="line">    .create();  </span><br></pre></td></tr></table></figure>

<p>GsonBuilder方法解释</p>
<ul>
<li>setFieldNamingPolicy 设置序列字段的命名策略(UPPER_CAMEL_CASE,UPPER_CAMEL_CASE_WITH_SPACES,LOWER_CASE_WITH_UNDERSCORES,LOWER_CASE_WITH_DASHES)</li>
<li>addDeserializationExclusionStrategy 设置反序列化时字段采用策略ExclusionStrategy，如反序列化时不要某字段，当然可以采用@Expore代替。</li>
<li>excludeFieldsWithoutExposeAnnotation 设置没有@Expore则不序列化和反序列化</li>
<li>addSerializationExclusionStrategy 设置序列化时字段采用策略，如序列化时不要某字段，当然可以采用@Expore代替。</li>
<li>registerTypeAdapter 为某特定对象设置固定的序列和反序列方式，实现JsonSerializer和JsonDeserializer接口</li>
<li>setFieldNamingStrategy 设置字段序列和反序列时名称显示，也可以通过@Serializer代替</li>
<li>setPrettyPrinting 设置gson转换后的字符串为一个比较好看的字符串</li>
<li>setDateFormat 设置默认Date解析时对应的format格式</li>
</ul>
<p><strong>几个重要点</strong></p>
<ol>
<li><p>推荐把成员变量都声明称private的</p>
</li>
<li><p>没有必要用注解（@Expose 注解）指明某个字段是否会被序列化或者反序列化，所有包含在当前类（包括父类）中的字段都应该默认被序列化或者反序列化</p>
</li>
<li><p>如果某个字段被 transient 这个Java关键词修饰，就不会被序列化或者反序列化</p>
</li>
<li><p>下面的实现方式能够正确的处理null<br> 1）当序列化的时候，如果对象的某个字段为null，是不会输出到Json字符串中的。<br> 2）当反序列化的时候，某个字段在Json字符串中找不到对应的值，就会被赋值为null</p>
</li>
<li><p>如果一个字段是 synthetic的,他会被忽视，也即是不应该被序列化或者反序列化</p>
</li>
<li><p>内部类（或者anonymous class（匿名类），或者local class(局部类，可以理解为在方法内部声明的类)）的某个字段和外部类的某个字段一样的话，就会被忽视，不会被序列化或者反序列化</p>
</li>
</ol>
<h4 id="Java-JSON的序列化和反序列化"><a href="#Java-JSON的序列化和反序列化" class="headerlink" title="Java-JSON的序列化和反序列化"></a>Java-JSON的序列化和反序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isDeveloper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>java 对象to JSON字符串</strong></p>
<p><em>注意：</em></p>
<p>如果成员变量对象值为空或未赋值，默认不参加转换，基本变量参加转换，若未初始化，则以默认值。</p>
<p>设置serializeNulls()后，则成员变量未赋值时以默认值转换，对象为null，基本数字以0，boolean类型为false，char为<code>&#39;&#39;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;平心&quot;</span>, <span class="number">18</span>, <span class="keyword">new</span> Date(),<span class="keyword">true</span>);</span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        System.out.println(gson.toJson(person));</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">        Gson gson1 = <span class="keyword">new</span> GsonBuilder()</span><br><span class="line">                <span class="comment">//.registerTypeAdapter(Id.class, new IdTypeAdapter()) //单独对Id类设置了独立解析方式</span></span><br><span class="line">                .setLenient()<span class="comment">// json宽松</span></span><br><span class="line">                .enableComplexMapKeySerialization()<span class="comment">//支持Map的key为复杂对象的形式</span></span><br><span class="line">                .serializeNulls() <span class="comment">//智能null</span></span><br><span class="line">                .setPrettyPrinting()<span class="comment">// 调整格式</span></span><br><span class="line">                .setDateFormat(DateFormat.SHORT)  <span class="comment">//设置时间转换格式</span></span><br><span class="line">                .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)<span class="comment">//会把字段首字母大写</span></span><br><span class="line">                .disableHtmlEscaping() <span class="comment">//默认是GSON把HTML 转义的</span></span><br><span class="line">                .create();</span><br><span class="line">       System.out.println(gson1.toJson(person));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//&#123;&quot;name&quot;:&quot;平心&quot;,&quot;age&quot;:18,&quot;birth&quot;:&quot;Jul 13, 2019, 6:19:04 PM&quot;,&quot;isDeveloper&quot;:true&#125;</span></span><br><span class="line"><span class="comment">//---------------</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    &quot;Name&quot;: &quot;平心&quot;,</span></span><br><span class="line"><span class="comment">//        &quot;Age&quot;: 18,</span></span><br><span class="line"><span class="comment">//        &quot;Birth&quot;: &quot;Jul 13, 2019, 6:19:04 PM&quot;,</span></span><br><span class="line"><span class="comment">//        &quot;IsDeveloper&quot;: true</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>JSON字符串 to java 对象</strong></p>
<p>可以这么认为，Gson先将映射类进行初始化，然后将Json字符串转化为类似map的结构，然后通过成员变量字段名或者用户指定字段转化名来进行一一对应，如果可以转化成对应类型变量值，则对对象的字段赋值，不能则不进行赋值。当然Gson的内部实现比这个要更复杂，后面后讲到，这里只是为了更好地理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">        String s1 = <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;平心\&quot;,\&quot;birth\&quot;:\&quot;Jul 13, 2019, 6:19:04 PM\&quot;,\&quot;isDeveloper\&quot;:true&#125;&quot;</span>;</span><br><span class="line">        Person person1 = gson.fromJson(s1, Person.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----&gt;jsonStr convert javaBean \n&quot;</span> + person1);</span><br><span class="line"></span><br><span class="line">        String s2 = <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;平心\&quot;,\&quot;age\&quot;:18,\&quot;birth\&quot;:\&quot;Jul 13, 2019, 6:19:04 PM\&quot;,\&quot;isDeveloper\&quot;:true&#125;&quot;</span>;</span><br><span class="line">        Person person2 = gson.fromJson(s2, Person.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;----&gt;jsonStr convert javaBean \n&quot;</span> + person2);</span><br><span class="line"></span><br><span class="line">        String s3 = <span class="string">&quot;&#123;&#125;&quot;</span>;</span><br><span class="line">        Person person3 = gson.fromJson(s3, Person.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----&gt;jsonStr convert javaBean \n&quot;</span> + person3);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//----&gt;jsonStr convert javaBean</span></span><br><span class="line"><span class="comment">//Person(name=平心, age=0, birth=Sat Jul 13 18:19:04 CST 2019, isDeveloper=true)</span></span><br><span class="line"><span class="comment">//----&gt;jsonStr convert javaBean</span></span><br><span class="line"><span class="comment">//Person(name=平心, age=18, birth=Sat Jul 13 18:19:04 CST 2019, isDeveloper=true)</span></span><br><span class="line"><span class="comment">//----&gt;jsonStr convert javaBean</span></span><br><span class="line"><span class="comment">//Person(name=null, age=0, birth=null, isDeveloper=false)</span></span><br></pre></td></tr></table></figure>

<h4 id="嵌套对象"><a href="#嵌套对象" class="headerlink" title="嵌套对象"></a>嵌套对象</h4><p><strong>java 对象to JSON字符串</strong></p>
<p>现在，我们的user还拥有家庭住址，家庭住址有它自己的类型为UserAddress：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNested</span> </span>&#123;  </span><br><span class="line">    String name;</span><br><span class="line">    String email;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">boolean</span> isDeveloper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new, see below!</span></span><br><span class="line">    UserAddress userAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAddress</span> </span>&#123;  </span><br><span class="line">    String street;</span><br><span class="line">    String houseNumber;</span><br><span class="line">    String city;</span><br><span class="line">    String country;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由UserNested模型来表示user，在这个模型中添加了一个一对一关系的住址对象。住址由UserAddress模型表示。</p>
<p>在Java中，这两个模型可以以类明确分离开来，然后通过创建UserAddress userAddress成员变量以保持一个引用。但是在Json中我们没有类也没有引用。唯一的方式（除了通过IDs然后将数据合并在一起的方式）就只能是将用户住址嵌入到user对象中了，在JSON中我们在域名后创建了一个用{}包围的新对象：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">26</span>,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;norman@futurestud.io&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;isDeveloper&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Norman&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;userAddress&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;Magdeburg&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;country&quot;</span>: <span class="string">&quot;Germany&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;houseNumber&quot;</span>: <span class="string">&quot;42A&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;street&quot;</span>: <span class="string">&quot;Main Street&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不像其他的属性（age，email，…）该新userAddress属性没有一个直接的值。相反，它包含一些子值并用{}包裹。理解域名后出现的大括号是非常重要的，这通常表示<strong>这是一个嵌套对象</strong>。</p>
<p>理论已经足够。是时候了解Gson通过一个UserNested对象创建了什么？你将可能认识该模型。Gson不需要任何的设置。它将会通过传入的class类型自动推断相应的数据结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">UserAddress userAddress = <span class="keyword">new</span> UserAddress(  </span><br><span class="line">    <span class="string">&quot;Main Street&quot;</span>, </span><br><span class="line">    <span class="string">&quot;42A&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Magdeburg&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Germany&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">UserNested userObject = <span class="keyword">new</span> UserNested(  </span><br><span class="line">    <span class="string">&quot;Norman&quot;</span>, </span><br><span class="line">    <span class="string">&quot;norman@futurestud.io&quot;</span>, </span><br><span class="line">    <span class="number">26</span>, </span><br><span class="line">    <span class="keyword">true</span>, </span><br><span class="line">    userAddress</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();  </span><br><span class="line">String userWithAddressJson = gson.toJson(userObject); </span><br></pre></td></tr></table></figure>

<p>userWithAddressJson字符串的值是有趣的：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">26</span>,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;norman@futurestud.io&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;isDeveloper&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Norman&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;userAddress&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;Magdeburg&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;country&quot;</span>: <span class="string">&quot;Germany&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;houseNumber&quot;</span>: <span class="string">&quot;42A&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;street&quot;</span>: <span class="string">&quot;Main Street&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是的，Gson对域按字母重排序了，但结果无疑是我们希望的。Gson正确的创建了包裹着userAddress的JSON对象。当然，我们也可以添加更多的被包裹对象，比如用户的付款方式或者工作地址。同样，被包裹的对象也可以包裹其它对象。</p>
<p>当成员变量未赋值时，仍然符合上面所说的转换方法。</p>
<p><strong>JSON字符串 to java 对象</strong></p>
<p>为了不使你感到啰嗦，我们将不适用user的例子了，而适用一个漂亮的小旅馆。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Future Studio Steak House&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;owner&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Christian&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;address&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;Magdeburg&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;country&quot;</span>: <span class="string">&quot;Germany&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;houseNumber&quot;</span>: <span class="string">&quot;42A&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;street&quot;</span>: <span class="string">&quot;Main Street&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;cook&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Marcus&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;salary&quot;</span>: <span class="number">1500</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;waiter&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Norman&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;salary&quot;</span>: <span class="number">1000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是调用我们的API所得到的结果，我们希望通过使用Gson自动创建匹配的Java对象。首先，你需要模型化一个基本的类，这个基本类包含了所有顶层的域：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> </span>&#123;  </span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Owner owner;</span><br><span class="line">    Cook cook;</span><br><span class="line">    Waiter waiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下，我们是如何为name定义为字符型，而其他三个是如何定义类的？可能你会得出不同的结果。创建Java对象并不总是明确的。例如，基于该JSON，我们可以发现，cook和waiter的嵌套对象拥有相同的结构。你可以为这它们定义不同的类，就行上面那样，或者你也可以它们定义一个共同的类 —— Staff：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Restaurant &#123;  </span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Owner owner;</span><br><span class="line">    Staff cook;</span><br><span class="line">    Staff waiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论哪一种方式都是有效的。如果你不相信，我们通常倾向创建一个额外的类来避免将来的出现问题。比如，如果cook模型改变了但是waiter模型没有改变，那么你可能需要改变大量的代码。因此，现在我们抛弃Staff的解决方法。当然，我们依然需要为第二层的对象创建Java模型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span> </span>&#123;  </span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    UserAddress address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cook</span> </span>&#123;  </span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> </span>&#123;  </span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，我们偷了一点懒，复用了开始的UserAddress。但是这仅仅是因为它能够完美的匹配。</p>
<p>尽管如此，我们希望你能够理解根据JSON字符串创建Java模型类的过程。你需要从最高层一直深入到最底层，直到你的嵌套JSON只剩下常规的类型。</p>
<p>我们已经做了主要的工作，可以放心的将接下来的事情交给Gson了。当然，只有我们正确的做了我们该做的，Gson才会只需要很少的代码就能优雅的创建Java对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String restaurantJson = <span class="string">&quot;&#123; &#x27;name&#x27;:&#x27;Future Studio Steak House&#x27;, &#x27;owner&#x27;:&#123; &#x27;name&#x27;:&#x27;Christian&#x27;, &#x27;address&#x27;:&#123; &#x27;city&#x27;:&#x27;Magdeburg&#x27;, &#x27;country&#x27;:&#x27;Germany&#x27;, &#x27;houseNumber&#x27;:&#x27;42&#x27;, &#x27;street&#x27;:&#x27;Main Street&#x27;&#125;&#125;,&#x27;cook&#x27;:&#123; &#x27;age&#x27;:18, &#x27;name&#x27;: &#x27;Marcus&#x27;, &#x27;salary&#x27;: 1500 &#125;, &#x27;waiter&#x27;:&#123; &#x27;age&#x27;:18, &#x27;name&#x27;: &#x27;Norman&#x27;, &#x27;salary&#x27;: 1000&#125;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">Restaurant restaurantObject = gson.fromJson(restaurantJson, Restaurant.class); </span><br></pre></td></tr></table></figure>

<p>该restaurantObject包含了JSON中的所有信息。</p>
<p><em>提示：根据JSONs创建Java模型类是一件非常繁琐的工作。如果你已经意识到这一点那么你肯定希望有工具可以自动的完成这一流程。这里我们推荐<a target="_blank" rel="noopener" href="http://www.bejson.com/json2javapojo/new/">beJson</a>。</em></p>
<h4 id="Arrays和Lists的映射"><a href="#Arrays和Lists的映射" class="headerlink" title="Arrays和Lists的映射"></a>Arrays和Lists的映射</h4><p><strong>Arrays和Lists之间的不同</strong></p>
<p>在进入正题之前，我们想阐述一下Arrays和Lists这两种Java数据结构。他们的Java实现是不同的并且各有各的优势。在你的用例中采取哪种方式取决于软件需求以及你个人的喜好。有趣的是，什么是选择list还是array结构映射到JSON是无关紧要的。</p>
<p>在JSON的数据格式中，没有lists和arrays。是的，Java的实现造成了二者之间巨大的区别，但在就高层次来说，他们都是代表相同的列表结构。在接下来的博客中，我们将他们成为对象列表，但是在Java中他们又是不同的。如果你对此感到迷惑，不用担心，一些例子将会使你更加清晰。</p>
<p><strong>Arrays或者Lists数据的序列化</strong></p>
<p>这里使用餐馆和菜单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestaurantWithMenu</span> </span>&#123;  </span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    List&lt;RestaurantMenuItem&gt; menu;</span><br><span class="line">    <span class="comment">//RestaurantMenuItem[] menu; // alternative, either one is fine</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestaurantMenuItem</span> </span>&#123;  </span><br><span class="line">    String description;</span><br><span class="line">    <span class="keyword">float</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java处理嵌套对象的方式和JSON是不同的。Java可以将之分离到不同的类中，并由List或者Array的来持有其引用。JSON需要保持一个本地的、嵌套的列表。这意味着在高层次，我们希望JSON像下面这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Future Studio Steak House&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;menu&quot;</span>: [</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像嵌套对象一样，menu并不拥有一个直接的值。相反，JSON为其值定义了一个由[]包裹着的对象列表。如上面提到的，这是array还是list是没有区别的。在JSON的数据结构中它看起来是相同的。</p>
<p>menu由很多对象组成。在我们的例子中，它们是饭店菜单项。让我们运行Gson查看一个完整的JSON会是什么样子。</p>
<p>我们希望你现在已经知道常规步骤了。得到你的Java对象，初始化Gson然后让Gson创建相应的JSON：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;RestaurantMenuItem&gt; menu = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">menu.add(<span class="keyword">new</span> RestaurantMenuItem(<span class="string">&quot;Spaghetti&quot;</span>, <span class="number">7.99f</span>));  </span><br><span class="line">menu.add(<span class="keyword">new</span> RestaurantMenuItem(<span class="string">&quot;Steak&quot;</span>, <span class="number">12.99f</span>));  </span><br><span class="line">menu.add(<span class="keyword">new</span> RestaurantMenuItem(<span class="string">&quot;Salad&quot;</span>, <span class="number">5.99f</span>));</span><br><span class="line"></span><br><span class="line">RestaurantWithMenu restaurant =  </span><br><span class="line">        <span class="keyword">new</span> RestaurantWithMenu(<span class="string">&quot;Future Studio Steak House&quot;</span>, menu);</span><br><span class="line"></span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();  </span><br><span class="line">String restaurantJson = gson.toJson(restaurant);</span><br></pre></td></tr></table></figure>

<p>restaurantJson包含如下内容：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;menu&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Spaghetti&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: <span class="number">7.99</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Steak&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: <span class="number">12.99</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Salad&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: <span class="number">5.99</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Future Studio Steak House&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就跟通常一样，排序有点神奇，列表排在前面是因为按字母来说menu在name的前面。除了排序意外，其他一切都是我们希望的。列表（由[]包裹）包含多个对象（每一个对象由{}包裹）。</p>
<p>然而，我们并不总是发送一个嵌套了列表数据的单独对象，就像上面做的那样。有时候我们也希望发送一个列表。当然，Gson同样支持JSON列表的序列化。例如，如果我们希望序列化如下菜单项列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;RestaurantMenuItem&gt; menu = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">menu.add(<span class="keyword">new</span> RestaurantMenuItem(<span class="string">&quot;Spaghetti&quot;</span>, <span class="number">7.99f</span>));  </span><br><span class="line">menu.add(<span class="keyword">new</span> RestaurantMenuItem(<span class="string">&quot;Steak&quot;</span>, <span class="number">12.99f</span>));  </span><br><span class="line">menu.add(<span class="keyword">new</span> RestaurantMenuItem(<span class="string">&quot;Salad&quot;</span>, <span class="number">5.99f</span>));</span><br><span class="line"></span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();  </span><br><span class="line">String menuJson = gson.toJson(menu);  </span><br></pre></td></tr></table></figure>

<p>将会得到如下结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Spaghetti&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;price&quot;</span>: <span class="number">7.99</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Steak&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;price&quot;</span>: <span class="number">12.99</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Salad&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;price&quot;</span>: <span class="number">5.99</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>让我们指出重要的不同之处：该JSON的首个字符为[，这就提示了接下来是对象列表！到目前为止，我们只看到由{开始的对象。你应该马上记住它们之间的差异。</p>
<p><strong>Arrays或者Lists的序列化和反序列化</strong></p>
<p>JSON数据中作为根列表和嵌套在对象中的列表的重要不同。</p>
<ol>
<li><p>列表作为根对象</p>
<p>让我们做一个练习。考虑这样一种情况，在未来的环境中我们将会开启自己的API，并会提供一个端口GET /founders。该端口将返回三个对象的数组，每个对象包含一个name域和一个flowerCount域。该数组代表我们桌子上的植物。因此如下JSON列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Christian&quot;,</span><br><span class="line">      &quot;flowerCount&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Marcus&quot;,</span><br><span class="line">      &quot;flowerCount&quot;: 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Norman&quot;,</span><br><span class="line">      &quot;flowerCount&quot;: 2</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>是的，你是对的。这个想象的端口直接返回了一个列表。JSON以[]开始和结束。没错，Marcus也喜欢在绿植环绕的办公桌上工作。</p>
<p>因此，我们如何使用Gson将此映射到Java对象呢？第一步是创建模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Founder &#123;  </span><br><span class="line">    String name;</span><br><span class="line">    int flowerCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二部取决于你。你是希望使用Lists还是Arrays作为你的类型呢？</p>
</li>
<li><p>Arrays</p>
<p>如果你想要使用Arrays，那太简单了。跟之前一样直接调用fromJson()方法并且传递数组模型的class，就像：gson.fromJson(founderGson, Founder[].class);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String founderJson = <span class="string">&quot;[&#123;&#x27;name&#x27;: &#x27;Christian&#x27;,&#x27;flowerCount&#x27;: 1&#125;, &#123;&#x27;name&#x27;: &#x27;Marcus&#x27;, &#x27;flowerCount&#x27;: 3&#125;, &#123;&#x27;name&#x27;: &#x27;Norman&#x27;, &#x27;flowerCount&#x27;: 2&#125;]&quot;</span>;</span><br><span class="line"></span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();  </span><br><span class="line">Founder[] founderArray = gson.fromJson(founderJson, Founder[].class); </span><br></pre></td></tr></table></figure>

<p>这将会产生一个founder的Java数组对象，它们的属性都映射正确</p>
</li>
<li><p>Lists<br>鉴于Lists可以扩展容量，因此现在的开发者更喜欢使用Java Lists。不幸的是，你不能直接传递List&lt;Founder&gt;给Gson。为了使Gson知道List的准确结构，你需要得到它的Type。幸运的是，Gson有一个TypeToken类帮助你正确找到任何类的Type。我们的Founder类在一个ArrayList中，让我们看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type founderListType = <span class="keyword">new</span> TypeToken&lt;ArrayList&lt;Founder&gt;&gt;()&#123;&#125;.getType(); </span><br></pre></td></tr></table></figure>

<p>你可以使用该语句的结果作为type供Gson调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String founderJson = <span class="string">&quot;[&#123;&#x27;name&#x27;: &#x27;Christian&#x27;,&#x27;flowerCount&#x27;: 1&#125;, &#123;&#x27;name&#x27;: &#x27;Marcus&#x27;, &#x27;flowerCount&#x27;: 3&#125;, &#123;&#x27;name&#x27;: &#x27;Norman&#x27;, &#x27;flowerCount&#x27;: 2&#125;]&quot;</span>;</span><br><span class="line"></span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">Type founderListType = <span class="keyword">new</span> TypeToken&lt;ArrayList&lt;Founder&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line"></span><br><span class="line">List&lt;Founder&gt; founderList = gson.fromJson(founderJson, founderListType);</span><br></pre></td></tr></table></figure>

<p>结果跟使用Array得到的结果差不多,最后，映射你的数据到Array还是List取决于你的个人偏好和用例情况。</p>
</li>
<li><p>列表作为一个对象的一部分</p>
<p>我们已经扩展了我们想象的未来环境中的API，端口为GET /info。它返回了比founder更多的信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Future Studio Dev Team&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;website&quot;</span>: <span class="string">&quot;https://futurestud.io&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;founders&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Christian&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;flowerCount&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Marcus&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;flowerCount&quot;</span>: <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Norman&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;flowerCount&quot;</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望你已经熟悉流程了。首先我们需要写一个与JSON响应匹配的模型。我们可以复用之前的Founder类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralInfo</span> </span>&#123;  </span><br><span class="line">    String name;</span><br><span class="line">    String website;</span><br><span class="line">    List&lt;Founder&gt; founders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理嵌套在一个对象中的列表是简单的，因为Gson不用使用TypeToken就可以简单地处理了。我们可以直接传入class：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String generalInfoJson = <span class="string">&quot;&#123;&#x27;name&#x27;: &#x27;Future Studio Dev Team&#x27;, &#x27;website&#x27;: &#x27;https://futurestud.io&#x27;, &#x27;founders&#x27;: [&#123;&#x27;name&#x27;: &#x27;Christian&#x27;, &#x27;flowerCount&#x27;: 1 &#125;, &#123;&#x27;name&#x27;: &#x27;Marcus&#x27;,&#x27;flowerCount&#x27;: 3 &#125;, &#123;&#x27;name&#x27;: &#x27;Norman&#x27;,&#x27;flowerCount&#x27;: 2 &#125;]&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">GeneralInfo generalInfoObject = gson.fromJson(generalInfoJson, GeneralInfo.class); </span><br></pre></td></tr></table></figure>

<p>当然，你也可以使用Founder[]数组代替List&lt;Founder&gt;。Gson同样可以处理。</p>
<p><em>注意：你注意到没有，GeneralInfo和Founder模型拥有相同的name属性，但是Gson却没有出现问题？在序列化和反序列化过程中不会出现任何问题。这真是太神奇了。</em></p>
</li>
<li><p>嵌套在列表里面的列表</p>
<p>如果你正好奇，在处理嵌套在列表里面的列表时会不会有问题。例如，下面的模型将不会有问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralInfo</span> </span>&#123;  </span><br><span class="line">    String name;</span><br><span class="line">    String website;</span><br><span class="line">    List&lt;FounderWithPets&gt; founders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FounderWithPets类是由宠物列表扩展而来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FounderWithPets</span> </span>&#123;  </span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> flowerCount;</span><br><span class="line">    List&lt;Pet&gt; pets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pet类又拥有玩具的列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;  </span><br><span class="line">    String name;</span><br><span class="line">    List&lt;Toy&gt; toys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Toy类又包含……好了，循环停止吧。我们希望这个推论可以带给你这样一个观点：你可以在列表中逐层的包含列表而不会有任何问题。Gson就像个冠军一样良好的处理序列化和反序列化。</p>
<p>不过，Gson只能处理包含一致性的对象的列表。如果对象是完全不同的，Gson就不能映射了。尽管可以由多种类型组成列表。</p>
</li>
</ol>
<h4 id="Maps的映射"><a href="#Maps的映射" class="headerlink" title="Maps的映射"></a>Maps的映射</h4><p><strong>Java Maps的序列化</strong></p>
<p>Java maps是一种非常具有弹性数据类型，它可以用于各种各样的场景。它使得我们开发者运用Java程序语言可以实现很多真实世界的场景。因为Java maps的使用范围如此之广，因此这里可能不会和你的用例相同，但方法时适合所有用例的。</p>
<p>让我们从这样一个场景开始，你的App拥有一个雇员姓名列表。你被要求实现这样一个View，它可以显示所有以某个特定字母开头的雇员。例如，用户可以选择字母A，然后你的应用将会返回三个匹配的雇员Andreas，Aden和Arnold。开始的迭代器仅仅是一个可以显示所有名字列表，性能并不良好。因此，我们将采用HashMap代替，它的key是首字母（比如A），它的值时一个名字列表。</p>
<p>我们的创建HashMap的Java代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, List&lt;String&gt;&gt; employees = <span class="keyword">new</span> HashMap&lt;&gt;();  </span><br><span class="line">employees.put(<span class="string">&quot;A&quot;</span>, Arrays.asList(<span class="string">&quot;Andreas&quot;</span>, <span class="string">&quot;Arnold&quot;</span>, <span class="string">&quot;Aden&quot;</span>));  </span><br><span class="line">employees.put(<span class="string">&quot;C&quot;</span>, Arrays.asList(<span class="string">&quot;Christian&quot;</span>, <span class="string">&quot;Carter&quot;</span>));  </span><br><span class="line">employees.put(<span class="string">&quot;M&quot;</span>, Arrays.asList(<span class="string">&quot;Marcus&quot;</span>, <span class="string">&quot;Mary&quot;</span>)); </span><br></pre></td></tr></table></figure>

<p>maps的序列化和其他类型是一样的。你仅仅需要把它扔给Gson，Gson将会执行一切：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();  </span><br><span class="line">String employeeJson = gson.toJson(employees);  </span><br></pre></td></tr></table></figure>

<p>返回的JSON结果为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;M&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;Marcus&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mary&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;C&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;Christian&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Carter&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;A&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;Andreas&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Arnold&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Aden&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个键（A，C和M）都拥有一个名字列表，这正是我们想要的。</p>
<p><strong>反序列化Java Maps</strong></p>
<p>如果你查看之前的JSON结果，或者查看下面的JSON，你可能会提出这样一个问题：你怎样才能发现这是一个集合，还是很多个对象呢？答案是简单粗暴的：你不能。这就是JSON数据的意思是模棱两可的一个例子。让我们看一下下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;1$&quot;: &#123;</span><br><span class="line">    &quot;amount&quot;: 1,</span><br><span class="line">    &quot;currency&quot;: &quot;Dollar&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;2$&quot;: &#123;</span><br><span class="line">    &quot;amount&quot;: 2,</span><br><span class="line">    &quot;currency&quot;: &quot;Dollar&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;3€&quot;: &#123;</span><br><span class="line">    &quot;amount&quot;: 3,</span><br><span class="line">    &quot;currency&quot;: &quot;Euro&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户可以把该JSON假设为三个对象，每个对象的名为1$, 2$, 3€。每个对象有一些值。但另一方面，也可以想象成是一个简单的Map，其中1$, 2$和3€是键。</p>
<p>没有任何简便方法可以使你估计出JSON的数据类型。一些要点可能能帮到你：</p>
<ul>
<li>首要的是：环境信息！如果你由文档或者知道每个对象的描述信息，那么你可能就知道他们是分离的对象，还是一个map数据了。</li>
<li>数据类型是否是一致的？若是则倾向为map。</li>
<li>对象的名称或者是键值是否是动态的并且取名范围较广？这也是倾向为map的。</li>
</ul>
<p>之前的博客中，我们已经向你展示如何映射常规对象，因此在在这篇博客中，我们假设JSON是map数据。那么我们该如何将上面的JSON映射为Java对象呢？</p>
<p>我们使用在列表对象博客中已经提到过的TypeToken方法。通过创建一个新的TypeToken来获得我们所希望的数据类型的type：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmountWithCurrency</span> </span>&#123;  </span><br><span class="line">    String currency;</span><br><span class="line">    <span class="keyword">int</span> amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String dollarJson = <span class="string">&quot;&#123; &#x27;1$&#x27;: &#123; &#x27;amount&#x27;: 1, &#x27;currency&#x27;: &#x27;Dollar&#x27;&#125;, &#x27;2$&#x27;: &#123; &#x27;amount&#x27;: 2, &#x27;currency&#x27;: &#x27;Dollar&#x27;&#125;, &#x27;3€&#x27;: &#123; &#x27;amount&#x27;: 3, &#x27;currency&#x27;: &#x27;Euro&#x27;&#125; &#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">Type amountCurrencyType =  </span><br><span class="line">    <span class="keyword">new</span> TypeToken&lt;HashMap&lt;String, AmountWithCurrency&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line"></span><br><span class="line">HashMap&lt;String, AmountWithCurrency&gt; amountCurrency =  </span><br><span class="line">    gson.fromJson(dollarJson, amountCurrencyType);</span><br></pre></td></tr></table></figure>

<p>amountCurrency变量正确地拥有该集合的所有键值对</p>
<h4 id="Sets的映射"><a href="#Sets的映射" class="headerlink" title="Sets的映射"></a>Sets的映射</h4><p><strong>序列化Java Sets</strong></p>
<p>Java的集合框架包括大量的数据结构。我们已经讨论过lists和maps，它们在JSON的表达中有些许不同。这周，我们探究Sets。HashSet可以使你的数据集合例子中的值保持唯一性。因为sets有其存在的理由并且应用有现实世界，Gson也需要有能力去处理它们。</p>
<p>因此，让我们来看这样一个例子。你的app拥有这样一个功能，可以使得众多的用户可以加入到一个团队中。当然，每一个用户只能加入一次，因此我们使用HashSet去保存用户的名字。</p>
<p>使用Java的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; users = <span class="keyword">new</span> HashSet&lt;&gt;();  </span><br><span class="line">users.add(<span class="string">&quot;Christian&quot;</span>);  </span><br><span class="line">users.add(<span class="string">&quot;Marcus&quot;</span>);  </span><br><span class="line">users.add(<span class="string">&quot;Norman&quot;</span>);  </span><br><span class="line">users.add(<span class="string">&quot;Marcus&quot;</span>); <span class="comment">// would not be added again  </span></span><br></pre></td></tr></table></figure>

<p>sets的序列化和其他类型是一样的。你仅仅需要把它扔给Gson：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();  </span><br><span class="line">String usersJson = gson.toJson(users);  </span><br></pre></td></tr></table></figure>

<p>结果如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">&quot;Marcus&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Christian&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Norman&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，JSON采用和list一样的表达方式来表达set。是的，Java处理二者之间的内在逻辑是完全不同的，但是对于高层来说，它们存储相同的数据。对于如JSON这样的不管如何实现的语言来说，内在细节是无关紧要的。</p>
<p><strong>反序列化Java Sets</strong></p>
<p>正如我们上面所提到的，lists和sets在JSON中的表达都是相同的。因此，因此，Gson乐意将一个宽泛的JSON反序列化为上面的无论哪一种数据类型。在我们可以使用JSON转换为无论哪一种之前，我们先查看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Christian&quot;</span>,</span><br><span class="line">      <span class="string">&quot;flowerCount&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Marcus&quot;</span>,</span><br><span class="line">      <span class="string">&quot;flowerCount&quot;</span>: <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Norman&quot;</span>,</span><br><span class="line">      <span class="string">&quot;flowerCount&quot;</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>和处理lists是一样的。我们为Gson创建一个Type，然后让它来施展它的魔术：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String founderJson = <span class="string">&quot;[&#123;&#x27;name&#x27;: &#x27;Christian&#x27;,&#x27;flowerCount&#x27;: 1&#125;, &#123;&#x27;name&#x27;: &#x27;Marcus&#x27;, &#x27;flowerCount&#x27;: 3&#125;, &#123;&#x27;name&#x27;: &#x27;Norman&#x27;, &#x27;flowerCount&#x27;: 2&#125;]&quot;</span>;</span><br><span class="line"></span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">Type founderSetType = <span class="keyword">new</span> TypeToken&lt;HashSet&lt;Founder&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line"></span><br><span class="line">HashSet&lt;Founder&gt; founderSet = gson.fromJson(founderJson, founderSetType);  </span><br></pre></td></tr></table></figure>

<p>founderSet变量拥有和之前博客中相同的内容，仅仅是数据类型不同而已</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="Gson注解"><a href="#Gson注解" class="headerlink" title="Gson注解"></a>Gson注解</h4><ol>
<li><p>自定义字段的名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SerializedName(&quot;宽度&quot;, alternate = &quot;width&quot;)</span>;</span><br><span class="line"><span class="keyword">int</span> width</span><br></pre></td></tr></table></figure>

<p><strong>SerializeName</strong>接收两个参数：<strong>value</strong>和<strong>alternate</strong>。前者使用了默认的参数。如果你仅仅传入了一个字符串，那么将该字符串设置给<strong>value</strong>而<strong>alternate</strong>设置为空值。但是你可以给这两个参数传递值</p>
<p>强调一遍，<strong>value</strong>改变了序列化和反序列化的默认情况！因此，如果Gson根据你的Java模型类创建了一个JSON，它将会使用<strong>value</strong>作为该属性的名。</p>
<p><strong>alternate</strong>仅仅是作为<strong>反序列化</strong>中的代选项。Gson将会JSON中的所有名称并且尝试映射到被注解了的属性中的某一个。在上面的模型类中，Gson将会检查到来的JSON中是否含有<strong>宽度</strong>或者<strong>width</strong>。无论是哪一个，都会映射到<strong>width</strong>属性</p>
<p>如果有多个域匹配一个属性，Gson会使用最后一个遇到的域。</p>
</li>
<li><p>定义那些字段需要被序列化或者反序列化</p>
<p><strong>注意，在Java中，所有用transient声明的字段，都不会被Gson序列化和反序列化</strong></p>
<p>Gson提供了注解来分别的控制某一个字段是否需要被序列化或者反序列化。对序列化和反序列化分开控制。</p>
<p>使用@Expose注解，我们可以对序列化和反序列化单独控制，该注解有两个值，分别是deserialize和serialize，比如如下的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//声明该字段不参与反序列化</span></span><br><span class="line">  <span class="meta">@Expose(deserialize = false)</span></span><br><span class="line">  <span class="keyword">private</span> String accountNumber;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  <span class="comment">//只要有一个字段使用了Expose注解，所有需要参与序列化和反序列化的字段都要有这个注解</span></span><br><span class="line">  <span class="comment">//因为这个注解要么不生效，如果生效的话，就只会对有Expose注解的字段进行处理。</span></span><br><span class="line">  <span class="meta">@Expose</span></span><br><span class="line">  <span class="keyword">private</span> String iban;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//声明该字段不参与序列化</span></span><br><span class="line">  <span class="meta">@Expose(serialize = false)</span></span><br><span class="line">  <span class="keyword">private</span> String owner;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//声明该字段序列化和反序列化都不参与</span></span><br><span class="line">  <span class="meta">@Expose(serialize = false, deserialize = false)</span></span><br><span class="line">  <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String pin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使该注解生效，必须对Gson进行配置，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GsonBuilder builder = <span class="keyword">new</span> GsonBuilder();</span><br><span class="line">builder.excludeFieldsWithoutExposeAnnotation();</span><br><span class="line">Gson gson = builder.create();</span><br></pre></td></tr></table></figure>

<p>如果我们不对Gson进行配置的话，该注解就不会生效，这样就会默认所有的字段都会被序列化和反序列化。</p>
<p>通过对Gson进行配置，只有带有Expose注解的字段才会被Gson进行序列化或者反序列化。</p>
</li>
<li><p>@Since 和 @Until</p>
<p>这2个注解用于表示数据序列化的最早版本since（自从）,和最晚版本until(直到).<br>也是搭配GsonBuilder使用的。</p>
<p>对Java Bean进行版本控制，这个使用的很少，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoccerPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//表明这个属性是1.2版本之后才加入的,[1.2,+)</span></span><br><span class="line">  <span class="meta">@Since(1.2)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> shirtNumber;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//表明这个属性在0.9版本上已经被移除了,(0,0.9)</span></span><br><span class="line">  <span class="meta">@Until(0.9)</span></span><br><span class="line">  <span class="keyword">private</span> String country;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String teamName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Methods removed for brevity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和Expose一样，要使用这两个注解，也需要对Gson进行配置，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GsonBuilder builder = <span class="keyword">new</span> GsonBuilder();</span><br><span class="line"><span class="comment">//在这里，我们定义版本是1.0，由于shirtNumber在1.2才加入，所以不生效</span></span><br><span class="line"><span class="comment">//country在0.9被移除，所以也不生效</span></span><br><span class="line">builder.setVersion(<span class="number">1.0</span>);</span><br><span class="line">Gson gson = builder.create();</span><br></pre></td></tr></table></figure></li>
<li><p>@JsonAdapter.</p>
<p>这个注解的作用可以自定义序列化和反序列化。比如你想给你的HashMap数据自定义序列化和反序列化。<br>作用范围： class 和 field. 就是说可以放在类和字段上.</p>
</li>
</ol>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><h4 id="GsonBuilder基础以及命名策略"><a href="#GsonBuilder基础以及命名策略" class="headerlink" title="GsonBuilder基础以及命名策略"></a>GsonBuilder基础以及命名策略</h4><p>在之前的示例中，仅仅使用了<strong>Gson gson = new Gson()<strong>方式得到Gson的实例；这在你仅仅需要Gson的基础配置时是完全有效的。然而，你可以改变Gson的设置细节。如果你需要使用Gson的方式和基础配置有略微的不同，那么这将是非常方便的。为了改变某一确定的配置，你可以使用</strong>GsonBuilder</strong>创建Gson实例，并自定义你的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// previously</span><br><span class="line">Gson gson = new Gson();</span><br><span class="line"></span><br><span class="line">// now using GsonBuilder</span><br><span class="line">GsonBuilder gsonBuilder = new GsonBuilder();  </span><br><span class="line">Gson gson = gsonBuilder.create();  </span><br></pre></td></tr></table></figure>

<p><strong>GsonBuilder</strong>类提供了**.Create()**方法，该方法会返回一个Gson实例。该Gson实例可以做任何之前已经向你展示的功能：映射任何从JSON来或者到JSON去的数据。</p>
<p><strong>命名策略</strong></p>
<p>我们想为你展示的第一个<strong>GsonBuilder</strong>的可选项是命名策略。我们经常想象Java模型文件和从API发送请求然后响应回来的JSON拥有一样的命名机制。我们已经向你展示了如何使用@SerializedName在序列化时改变一个单独的属性。然而，如果你的API和Java模型不同意对它进行命名，那么使用**@SerializedName**为100多个属性添加注解将是非常繁琐的。</p>
<p>因此，Gson提供了配置的和自定义的<strong>FieldNamingPolicy</strong>。为了完成指定的目标，我们调整了UserSimple模型，并且为某些属性给定了新名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNaming</span> </span>&#123;  </span><br><span class="line">    String Name;</span><br><span class="line">    String email_of_developer;</span><br><span class="line">    <span class="keyword">boolean</span> isDeveloper;</span><br><span class="line">    <span class="keyword">int</span> _ageOfDeveloper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，我们将所有命名标准都统一在了一个模型里面。这将导致它的JSON结果看起来很滑稽，但是，这很容易使我们发现多钟命名策略是如何影响它们的。你可以在<strong>GsonBuilder</strong>中添加策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GsonBuilder gsonBuilder = <span class="keyword">new</span> GsonBuilder();  </span><br><span class="line">gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.IDENTITY);  </span><br><span class="line">Gson gson = gsonBuilder.create();  </span><br></pre></td></tr></table></figure>

<p>所有用到以上Gson实例的转换，都将会遵循此处的域命名策略<strong>FieldNamingPolicy.IDENTITY</strong>。在下一部分，我们将会探索这究竟是什么意思，以及该预定义的域命名策略是如何起作用的。让我们先从简单的<strong>IDENTITY</strong>开始吧。</p>
<ol>
<li>FieldNamingPolicy - IDENTITY：在序列化一个对象时，<strong>IDENTITY</strong>域命名策略将会使用和Java模型完全一样的名称。不论你使用什么样的命名标准设置你的Java模型，JSON会使用相同的。</li>
<li>FieldNamingPolicy - LOWER_CASE_WITH_UNDERSCORES：将会按照大写字母分离每一个属性名称，并且使用一个对应的小写字母和一个**_**符号代替。</li>
<li>FieldNamingPolicy - LOWER_CASE_WITH_DASHES：这和<strong>LOWER_CASE_WITH_UNDERSCORES</strong>的机制是相同的，但是域名的分隔符为**-**</li>
<li>FieldNamingPolicy - UPPER_CAMEL_CASE：它使得均以大写字母开头，即使是以**_**开头的属性名。尽管该策略并没有改变分隔符。它保留了下划线。</li>
<li>FieldNamingPolicy - UPPER_CAMEL_CASE_WITH_SPACESThe last policy：几乎和<strong>UPPER_CAMEL_CASE</strong>一样，唯一的不同是有两个域名，在它们拥有两个大写字母的单词之间加了多了空格。</li>
</ol>
<p><strong>与@SerializedName进行交互</strong></p>
<p>你可能会好奇，策略是如何和**@SerializedName**进行交互的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNaming</span> </span>&#123;  </span><br><span class="line">    String Name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SerializedName(&quot;emailOfDeveloper&quot;)</span></span><br><span class="line">    String email_of_developer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isDeveloper;</span><br><span class="line">    <span class="keyword">int</span> _ageOfDeveloper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你现在申请命名策略会发生什么呢？答案是，它将不会应用到**@SerializedName<strong>注解的属性上。例如，我们使用</strong>UPPER_CAMEL_CASE**，JSON结果将会：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;Norman&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_AgeOfDeveloper&quot;</span>: <span class="number">26</span>,</span><br><span class="line">  <span class="attr">&quot;emailOfDeveloper&quot;</span>: <span class="string">&quot;norman@futurestud.io&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;IsDeveloper&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>emailOfDeveloper</strong>和**@SerializedName**注解的完全一样，而不会使起始字母大写。</p>
<p><strong>自定义域名</strong></p>
<p>已有的策略以及**@SerializedName<strong>可能还不能满足你的用例的需求。你可以使用</strong>FieldNamingPolicy<strong>实现你自己的版本。因为你只能为</strong>.setFieldNamingPolicy<strong>传递已经预定义的枚举值，因此，Gson为你提供了另一个方法</strong>.setFieldNamingStrategy()**。</p>
<p>你可以传递<strong>FieldNamingStrategy</strong>的实例给相应的方法。<strong>FieldNamingStrategy</strong>类仅仅只有一个方法。例如，如果你想要移除所有的下划线，这没有任何预定义的策略做得到。下面的代码可以帮我们做到这点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FieldNamingStrategy customPolicy = <span class="keyword">new</span> FieldNamingStrategy() &#123;  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">translateName</span><span class="params">(Field f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f.getName().replace(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GsonBuilder gsonBuilder = <span class="keyword">new</span> GsonBuilder();  </span><br><span class="line">gsonBuilder.setFieldNamingStrategy(customPolicy);  </span><br><span class="line">Gson gson = gsonBuilder.create();</span><br><span class="line"></span><br><span class="line">UserNaming user = <span class="keyword">new</span> UserNaming(<span class="string">&quot;Norman&quot;</span>, <span class="string">&quot;norman@futurestud.io&quot;</span>, <span class="keyword">true</span>, <span class="number">26</span>);  </span><br><span class="line">String usersJson = gson.toJson(user);  </span><br></pre></td></tr></table></figure>

<p>结果就不会包含任何下划线了：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;Norman&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;ageOfDeveloper&quot;</span>: <span class="number">26</span>,</span><br><span class="line">  <span class="attr">&quot;emailOfDeveloper&quot;</span>: <span class="string">&quot;norman@futurestud.io&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;isDeveloper&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Gson仅仅只能接受一种策略（Strategy）。因此，你必须使用在单一的<strong>FieldNamingStrategy</strong>实现类中实现你的逻辑。如果你多次调用了以上我们所展示的方法，那么后面的将会覆盖前面的。</p>
<h4 id="强制序列化null值"><a href="#强制序列化null值" class="headerlink" title="强制序列化null值"></a>强制序列化null值</h4><p>忽略空值这一行为对于减少JSON字符串的体积来说通常是个好主意。然而，并不总是如此。有些API会强制要求该域存在或者<strong>null</strong>值对于某一属性来说有特定的含义（换句话说，某值的默认值不是为空；我们需要明确的设置它为空）。</p>
<p>Gson为改变这一默认的行为提供了选择。我们可以使用<strong>GsonBuilder</strong>来为序列化提供<strong>null</strong>值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSimple</span> </span>&#123;  </span><br><span class="line">    String name;</span><br><span class="line">    String email;</span><br><span class="line">    <span class="keyword">boolean</span> isDeveloper;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们为其创建一个email为空的用户实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();  </span><br><span class="line">UserSimple user = <span class="keyword">new</span> UserSimple(<span class="string">&quot;Norman&quot;</span>, <span class="keyword">null</span>, <span class="number">26</span>, <span class="keyword">true</span>);  </span><br><span class="line">String usersJson = gson.toJson(user); </span><br></pre></td></tr></table></figure>

<p>默认设置下，<strong>email</strong>属性将不会在JSON结果中出现：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">26</span>,</span><br><span class="line">  <span class="attr">&quot;isDeveloper&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Norman&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你要求<strong>email</strong>域作为JSON的一部分,你需要调用<strong>GsonBuilder</strong>的**.serializeNulls()**方法。如果你这样做了，Gson将会序列化所有属性，即使属性设置为空：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GsonBuilder gsonBuilder = <span class="keyword">new</span> GsonBuilder();  </span><br><span class="line">gsonBuilder.serializeNulls();  </span><br><span class="line">Gson gson = gsonBuilder.create();</span><br><span class="line"></span><br><span class="line">UserSimple user = <span class="keyword">new</span> UserSimple(<span class="string">&quot;Norman&quot;</span>, <span class="keyword">null</span>, <span class="number">26</span>, <span class="keyword">true</span>);  </span><br><span class="line">String usersJson = gson.toJson(user);  </span><br></pre></td></tr></table></figure>

<p>usersJson现在包括<strong>email</strong>域了：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">26</span>,</span><br><span class="line">  <span class="attr">&quot;email&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">&quot;isDeveloper&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Norman&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Exclusion-Strategies"><a href="#Exclusion-Strategies" class="headerlink" title="Exclusion Strategies"></a>Exclusion Strategies</h4><p>你已经学习了transient以及@Expose了，它们可以改变序列化和反序列化过程中的单个属性。下面我们将探讨更加普遍的方法。Gson称它为ExclusionStrategies。当然，你需要通过GsonBuilder设置它。</p>
<p>在我们开始特定的实现之前，先创建一个测试模型。我们使用一个新的<strong>UserDate</strong>模型，它拥有一些属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDate</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String _name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isDeveloper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date registerDate = <span class="keyword">new</span> Date();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意属性的类型和名称。这将是非常重要的。假设我们需要排除所有类型为<strong>Date</strong>以及<strong>boolean</strong>的属性，使用<strong>ExclusionStrategies</strong>很容易做到。你可以通过<strong>GsonBuilder</strong>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GsonBuilder gsonBuilder = <span class="keyword">new</span> GsonBuilder();  </span><br><span class="line">gsonBuilder.setExclusionStrategies(<span class="keyword">new</span> ExclusionStrategy() &#123;  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldSkipField</span><span class="params">(FieldAttributes f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldSkipClass</span><span class="params">(Class&lt;?&gt; incomingClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> incomingClass == Date.class || incomingClass == <span class="keyword">boolean</span>.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Gson gson = gsonBuilder.create();</span><br><span class="line"></span><br><span class="line">UserDate user = <span class="keyword">new</span> UserDate(<span class="string">&quot;Norman&quot;</span>, <span class="string">&quot;norman@futurestud.io&quot;</span>, <span class="number">26</span>, <span class="keyword">true</span>);  </span><br><span class="line">String usersJson = gson.toJson(user); </span><br></pre></td></tr></table></figure>

<p><strong>ExclusionStrategies</strong>类提供了两个重写方法。上面的例子我们使用了第二个方法。我们检查该类是否是<strong>Date</strong>或者<strong>boolean</strong>之一。如果该属性是其中之一的类型，那么该方法就会返回true，Gson将会忽略该属性。你可以在该方法中检查任意类。JSON结果将只包含字符串型和整型：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">26</span>,</span><br><span class="line">  <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;norman@futurestud.io&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_name&quot;</span>: <span class="string">&quot;Norman&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个方法的排除功能基于属性的声明。例如，如果我们还想排除所有包含下划线**_**的属性，那么可以按如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GsonBuilder gsonBuilder = <span class="keyword">new</span> GsonBuilder();  </span><br><span class="line">gsonBuilder.setExclusionStrategies(<span class="keyword">new</span> ExclusionStrategy() &#123;  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldSkipField</span><span class="params">(FieldAttributes f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f.getName().contains(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldSkipClass</span><span class="params">(Class&lt;?&gt; incomingClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> incomingClass == Date.class || incomingClass == <span class="keyword">boolean</span>.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Gson gson = gsonBuilder.create();</span><br><span class="line"></span><br><span class="line">UserDate user = <span class="keyword">new</span> UserDate(<span class="string">&quot;Norman&quot;</span>, <span class="string">&quot;norman@futurestud.io&quot;</span>, <span class="number">26</span>, <span class="keyword">true</span>);  </span><br><span class="line">String usersJson = gson.toJson(user);  </span><br></pre></td></tr></table></figure>

<p>JSON结果更短了：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">26</span>,</span><br><span class="line">  <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;norman@futurestud.io&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在各种各样不同的场景中运用排除策略。如果你拥有一些具有特殊序列化和反序列化排除的普遍的机制，这将会非常容易。请注意，你可以传递多钟排除策略到一个参数中。</p>
<p>如果你此刻还看不出来排除策略的重要之处，那也没关系！伴随着更加复杂的类型，我们的内容将会更加深入。一旦我们开始书写我们的自定义适配器，那么你将会看到确定值。非常幸运，通过排除策略你可以使Gson忽略<strong>任何类型</strong></p>
<p><strong>排除策略仅作用于序列化或者反序列化</strong></p>
<p>在之前的篇幅中，我们为序列化和反序列化都申请了排除策略。如果你仅仅需要应用于二者之一，你可以使用下面的方法：</p>
<ul>
<li><strong>addSerializationExclusionStrategy()</strong></li>
<li><strong>addDeserializationExclusionStrategy().</strong></li>
</ul>
<p>这二者的效果和之前的<strong>setExclusionStrategies()<strong>是相同的。你同样可以传递和实现</strong>ExclusionStrategy</strong>对象给它们。</p>
<p><strong>基于修饰词排除成员变量</strong></p>
<p>正如我们之前解释的，所有使用<strong>transient</strong>修饰的成员变量在序列化和反序列化过程中都会被忽略。</p>
<p>GsonBuilder允许你改变这一行为。使用**excludeFieldsWithModifiers()**可以选择在序列化和反序列化过程中排除哪些被特定修饰词修饰的成员变量。该方法需要传递<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Modifier.html">java.lang.reflect.Modifier</a>类中的修饰词。</p>
<p>例如，你有下面的模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class UserModifier &#123;  </span><br><span class="line">    private String name;</span><br><span class="line">    private transient String email;</span><br><span class="line">    private static boolean isDeveloper;</span><br><span class="line">    private final int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想排除所有<strong>final</strong>和<strong>static</strong>类型，但包括field，你需要按如下代码配置Gson：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GsonBuilder gsonBuilder = new GsonBuilder();  </span><br><span class="line">gsonBuilder.excludeFieldsWithModifiers(Modifier.STATIC, Modifier.FINAL);  </span><br><span class="line">Gson gson = gsonBuilder.create();</span><br><span class="line"></span><br><span class="line">UserModifier user = new UserModifier(&quot;Norman&quot;, &quot;norman@fs.io&quot;, 26, true);  </span><br><span class="line">String usersJson = gson.toJson(user);</span><br></pre></td></tr></table></figure>

<p>上面的代码将会创建如下JSON：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;email&quot;: &quot;norman@fs.io&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;Norman&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，Gson实例也会包含<strong>email</strong>域的，即使它被设置为<strong>transient</strong>。调用<strong>excludeFieldsWithModifiers()<strong>方法重写它的默认设置。我们仅仅传递了</strong>static</strong>和<strong>final</strong>，因此<strong>transient</strong>修饰词将不会被忽略。如果你想要包含所有域而不管修饰词，仅需要传递空列表参数给**excludeFieldsWithModifiers()**。</p>
<p><strong>排除没有被@Expose注解的域</strong></p>
<p>最后，有一个选择我们没有多大兴趣，但会提示你所有的选项：<strong>excludeFieldsWithoutExposeAnnotation</strong>。正如它的名字所暗示的，它将会排除所有没有被**@Expose**注解的成员变量。</p>
<p>你可以强制你的应用程序模型必须每处都用**@Expose**注解了，这样可以使得开发者思考哪些域需要序列化和反序列化。</p>
<h4 id="轻松使用仁慈的Gson（容错机制）"><a href="#轻松使用仁慈的Gson（容错机制）" class="headerlink" title="轻松使用仁慈的Gson（容错机制）"></a>轻松使用仁慈的Gson（容错机制）</h4><p>JSON内容的格式必须完全遵守一些标准规则。该标准是在<strong>RFC4627</strong>规范描述的。它所依赖的基础是键和值的分离，数组是如何结构化的等等。</p>
<p>首先，当Gson序列化一个Java对象到JSON时，该JSON会100%遵循标准。因此，我们感兴趣的部分是反序列化时Gson会如何行为！</p>
<p>在内部，Gson使用一个<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/google/gson/blob/ee8d6be59ff6f2466d65be746b96ccf07ddb9ddf/gson/docs/javadocs/com/google/gson/stream/JsonReader.html">JsonReader</a>类。该类可以选择是否具有一定的仁慈性。默认情况是不具有的，这意味着只能接收遵循标准的JSON输入。如果JSON违反了任意一条标准规则，<strong>JsonReader</strong>以及随之的Gson将会抛出异常。然而，<strong>JsonReader</strong>也可以设置为具有仁慈性。然后，也仅有如此，它会吞下容忍这些错误，尽自己最大的努力去解析这一有格式问题的JSON。</p>
<p>让我们引用一些没有遵循JSON标准要素的<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/stream/JsonReader.html#method_detail">文档</a></p>
<blockquote>
<p>Streams that start with the non-execute prefix, “)]}’\n”.<br> Streams that include multiple top-level values. With strict parsing, each stream must contain exactly one top-level value.<br> Top-level values of any type. With strict parsing, the top-level value must be an object or an array.<br> Numbers may be NaNs or infinities.<br> End of line comments starting with // or # and ending with a newline character.<br> C-style comments starting with /* and ending with */. Such comments may not be nested.<br> Names that are unquoted or ‘single quoted’.<br> Strings that are unquoted or ‘single quoted’.<br> Array elements separated by ; instead of ,.<br> Unnecessary array separators. These are interpreted as if null was the omitted value.<br> Names and values separated by = or =&gt; instead of :.<br> Name/value pairs separated by ; instead of ,.</p>
</blockquote>
<p>所有这些会如何影响你的Gson呢？理论上，Gson（不像<strong>JsonReader</strong>）默认情况下是仁慈的。所以通常情况下你不需要启动它，即使你的JSON是错误的。不幸的是，Gson在面对这些问题时的行为表现的有点疑惑。</p>
<p>你一定记得Gson可以选择在反序列化JSON的过程中拥有更大的容忍度。如果你需要设置这一点，使用<strong>GsonBuilder</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GsonBuilder gsonBuilder = new GsonBuilder();  </span><br><span class="line">gsonBuilder.setLenient();  </span><br><span class="line">Gson gson = gsonBuilder.create();  </span><br></pre></td></tr></table></figure>

<p>使你的Gson实例具有仁慈性可以解决一些具有结构错误的问题。然而，其仁慈性也仅仅能够如此。如果JSON违背了超过上面我们所实例的所有错误，Gson会抛出<strong>MalformedJsonException</strong>异常。如果是这样，那么你需要检查你的JSON看看它的结构是否合法。大部分情况下，这是你问题的根源。</p>
<p>推荐你使用像<a target="_blank" rel="noopener" href="http://www.bejson.com/">beJson</a>这样的工具检查你的JSON是否合法。</p>
<h4 id="Float和Double类型的特殊值"><a href="#Float和Double类型的特殊值" class="headerlink" title="Float和Double类型的特殊值"></a>Float和Double类型的特殊值</h4><p>在Java中，某些特殊情况下需要将值置为float型和double型。因此，在Java语言刚开始的时候，Float.NEGATIVE_INFINITY，Float.POSITIIVE_INFINITY以及Float.NaN以及他们对应的double型就以及存在了。遗憾的是，JSON标准不知道它们的价值，并没有将它们作为标准的一部分。</p>
<p>让我们引用Gson文档中关于该问题的描述：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.ietf.org/rfc/rfc4627.txt">JSON规范</a>的2.4章节不允许拥有特殊的double值（NaN，Infinity，-Infinity）。然而，<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">Javascript标准</a>（查看章节4.3.20，4.3.22，4.3.23）允许它们作为Javascript的合法值。甚至，大部分的JavaScript引擎接收这些在JSON中的特殊值而不会发生任何问题。因此，从实践层面来看，即使JSON规范不支持它们，但接收这些值作为合法的JSON也是有理可寻的。</p>
</blockquote>
<p>反序列化时Gson对于JSON标准具有很棒的灵活性，而在序列化时又是灵活的。前一部分依然是正确的，但是，这些特殊的float和double值是唯一的意外，它们使得Gson会内在的违反标准。</p>
<p>让我们讲得再透彻一点：如果你传入的JSON使用了一个或多个那样的float或double边缘值，它们会被默认反序列化，而不会有任何问题。</p>
<p>如果你传递一个<strong>Float.POSITIVE_INFINITY</strong>作为值，Gson将会抛出异常，因为Gson不能根据标准来进行转换。如果你需要传递这些特殊值，你需要使用<strong>GsonBuilder</strong>来明确的指定这些值可以转换。Gson为你提供了<strong>serializeSpecialFloatingPointValues</strong>来处理。</p>
<p>是时候来看一个例子了。我们来创建一个用户类，它拥有一个float类型的成员变量weight。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFloat</span> </span>&#123;  </span><br><span class="line">    String name;</span><br><span class="line">    Float weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserFloat</span><span class="params">(String name, Float weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，复活节的巧克力兔女郎对我产生了负面影响，最后我的体重大增，因此我需要像下面那样创建我的用户实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserFloat user = <span class="keyword">new</span> UserFloat(<span class="string">&quot;Norman&quot;</span>, Float.POSITIVE_INFINITY);</span><br></pre></td></tr></table></figure>

<p>如果你将之传递给Gson，它将会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">UserFloat user = <span class="keyword">new</span> UserFloat(<span class="string">&quot;Norman&quot;</span>, Float.POSITIVE_INFINITY);</span><br><span class="line"></span><br><span class="line">String usersJson = gson.toJson(user); <span class="comment">// will throw an exception  </span></span><br></pre></td></tr></table></figure>

<p>Gson将会给你一个<strong>IllegalArgumentException</strong>异常，它的陈述如下：</p>
<blockquote>
<p>Infinity并不是JSON规范的有效double值。想要使用该行为，使用**serializeSpecialFloatingPointValues()**方法。</p>
</blockquote>
<p>异常信息是非常有帮助的，并且已经提供给了我们解决办法。我们需要使用<strong>GsonBuilder</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        Gson gson =</span><br><span class="line">                <span class="keyword">new</span> GsonBuilder()</span><br><span class="line">                        .serializeSpecialFloatingPointValues()</span><br><span class="line">                        .create();</span><br><span class="line">        UserFloat user = <span class="keyword">new</span> UserFloat(<span class="string">&quot;Norman&quot;</span>, Float.POSITIVE_INFINITY);</span><br><span class="line"></span><br><span class="line">        String usersJson = gson.toJson(user); <span class="comment">// will throw an exception</span></span><br><span class="line">        System.out.println(usersJson);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;&quot;name&quot;:&quot;Norman&quot;,&quot;weight&quot;:Infinity&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="模型版本化"><a href="#模型版本化" class="headerlink" title="模型版本化"></a>模型版本化</h4><p>Gson可以通过**@Since<strong>注解以及</strong>@Until**注解来为你的Java对象设置版本控制，如此，则你的模型类里面被以上两个注解标记了的成员变量，将只有符合特定版本范围内时才会被序列化和反序列化。</p>
<p>这两个注解只有在通过GsonBuilder创建的Gson实例上才有效，我们需要通过**GsonBuilder.setVersion(double)**来激活。</p>
<p><strong>@Since</strong></p>
<p>该注解指示出某一成员或类型在这一特定的版本号之后才存在。例如有下面的模板类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String firstName;</span><br><span class="line">   <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//[1.0,+]</span></span><br><span class="line">   <span class="meta">@Since(1.0)</span> <span class="keyword">private</span> String emailAddress;</span><br><span class="line">    <span class="comment">//[1.0,+]</span></span><br><span class="line">   <span class="meta">@Since(1.0)</span> <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">//[1.1,+]</span></span><br><span class="line">   <span class="meta">@Since(1.1)</span> <span class="keyword">private</span> Address address;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>如果你使用<strong>new Gson()<strong>创建Gson实例，那么</strong>toJson()<strong>和</strong>fromJson()<strong>不会使用它们。然而，如果你使用</strong>Gson gson = new GsonBuilder().setVersion(1.0).create()<strong>来创建Gson实例，那么</strong>toJson()<strong>和</strong>fromJson()<strong>方法将排除</strong>address</strong>域，因为它的版本号被设置为了<strong>1.1</strong>。</p>
<p><strong>@Until</strong></p>
<p><strong>@Until</strong>注解为某一成员或类型指定了一个版本号，代表该成员或类型在该版本号之前才存在。<br> 稍微改变User模型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String firstName;</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//[0,1.1)</span></span><br><span class="line">  <span class="meta">@Until(1.1)</span> <span class="keyword">private</span> String emailAddress;</span><br><span class="line">    <span class="comment">//[0,1.1)</span></span><br><span class="line">  <span class="meta">@Until(1.1)</span> <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们使用<strong>Gson gson = new GsonBuilder().setVersion(1.2).create()<strong>来创建Gson实例，</strong>toJson()<strong>和</strong>fromJson()<strong>方将排除</strong>emailAddress</strong>和<strong>password</strong>域，这是因为传入的版本号为<strong>1.2</strong>，超过了我们给定的<strong>1.1</strong>。</p>
<h4 id="格式化日期和时间"><a href="#格式化日期和时间" class="headerlink" title="格式化日期和时间"></a>格式化日期和时间</h4><p>正如你所想到的，该功能也需要配置<strong>GsonBuilder</strong>。Gson为我们提供了三个重载的方法。</p>
<ul>
<li>setDateFormat(String pattern):pattern遵循<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html?is-external=true">SimpleDateFormat</a>类的惯例。</li>
<li>setDateFormat(int style)：style必须是<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/6/docs/api/java/text/DateFormat.html?is-external=true">DateFormat</a>的一个常量。</li>
<li>setDateFormat(int dateStyle, int timeStyle)：类似于上面的，只不过将日期和时间分开了。</li>
</ul>
<h4 id="漂亮输出"><a href="#漂亮输出" class="headerlink" title="漂亮输出"></a>漂亮输出</h4><p>序列化得到的JSON是无空格的，所有字符都密密麻麻挤在了一起，这虽然节约空间，但对于人的理解却不友好。只需相应的设置<strong>GsonBuilder</strong>即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> GsonBuilder().setPrettyPrinting().create();</span><br><span class="line">String jsonOutput = gson.toJson(someObject);</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/75a50aa0cad1">GSON</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/59e5663f51882546b15b92f0">Google-Gson注解使用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/baiqiantao/p/7512336.html">Gson基本用法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/923a9fe78108">Gson完全教程：基础篇</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8cc857583ff4">Gson全解析（中）-TypeAdapter的使用</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jiangjiajian2008/article/category/6530319">Gson的实现原理</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/05/19/Java-%E6%A1%86%E6%9E%B6-2-2-1/">https://pingxin0521.gitee.io/2019/05/19/Java-%E6%A1%86%E6%9E%B6-2-2-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/05/19/Java-%E6%A1%86%E6%9E%B6-2-2-2/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JSON框架--Gson 原理</div></div></a></div><div class="next-post pull-right"><a href="/2019/05/19/Java-%E6%A1%86%E6%9E%B6-2-1/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JSON框架--fastJSON</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/07/12/Java-SpringBoot-1-4-2/" title="Spring boot 数据访问 MongoDB"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-01-25</div><div class="title">Spring boot 数据访问 MongoDB</div></div></a></div><div><a href="/2019/12/10/Java-SpringBoot-1-6-1/" title="Spring boot 消息队列(使用RabbitMQ)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-02-09</div><div class="title">Spring boot 消息队列(使用RabbitMQ)</div></div></a></div><div><a href="/2019/05/30/Java-SpringCloud-0-0/" title="Spring Cloud 入门 (一)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">Spring Cloud 入门 (一)</div></div></a></div><div><a href="/2019/11/01/Java-SpringCloud-3-0/" title="Spring Cloud 组件之Hystrix (五)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">Spring Cloud 组件之Hystrix (五)</div></div></a></div><div><a href="/2019/10/27/Java-SpringCloud-6-0/" title="微服务组件--分布式追踪系统"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">微服务组件--分布式追踪系统</div></div></a></div><div><a href="/2019/11/03/Java-SpringCloud-6-2/" title="SpringCloud组件之Spring Cloud Sleuth (八)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">SpringCloud组件之Spring Cloud Sleuth (八)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-JSON%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">Java-JSON的序列化和反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">嵌套对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arrays%E5%92%8CLists%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">1.3.</span> <span class="toc-text">Arrays和Lists的映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Maps%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">1.4.</span> <span class="toc-text">Maps的映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sets%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">1.5.</span> <span class="toc-text">Sets的映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Gson%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.1.</span> <span class="toc-text">Gson注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA"><span class="toc-number">3.</span> <span class="toc-text">构建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GsonBuilder%E5%9F%BA%E7%A1%80%E4%BB%A5%E5%8F%8A%E5%91%BD%E5%90%8D%E7%AD%96%E7%95%A5"><span class="toc-number">3.1.</span> <span class="toc-text">GsonBuilder基础以及命名策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%BA%8F%E5%88%97%E5%8C%96null%E5%80%BC"><span class="toc-number">3.2.</span> <span class="toc-text">强制序列化null值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exclusion-Strategies"><span class="toc-number">3.3.</span> <span class="toc-text">Exclusion Strategies</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E6%9D%BE%E4%BD%BF%E7%94%A8%E4%BB%81%E6%85%88%E7%9A%84Gson%EF%BC%88%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">轻松使用仁慈的Gson（容错机制）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Float%E5%92%8CDouble%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E6%AE%8A%E5%80%BC"><span class="toc-number">3.5.</span> <span class="toc-text">Float和Double类型的特殊值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E7%89%88%E6%9C%AC%E5%8C%96"><span class="toc-number">3.6.</span> <span class="toc-text">模型版本化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="toc-number">3.7.</span> <span class="toc-text">格式化日期和时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%82%E4%BA%AE%E8%BE%93%E5%87%BA"><span class="toc-number">3.8.</span> <span class="toc-text">漂亮输出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
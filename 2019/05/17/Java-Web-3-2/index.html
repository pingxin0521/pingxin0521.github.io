<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java JSP (二) | 平心de小屋</title><meta name="keywords" content="Java,Web"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="四大作用域我们在定义每一个变量，每一个属性的时候，都会考虑这个变量、属性的作用范围，也就是作用域。我们会根据我们的需求定义最适当作用域内的变量和属性。在写Java，C++等代码的时候，这个作用域问题还比较好理解，无非就是局部变量、全局变量、静态变量等区别。而到了JSP开发中，这个作用域概念就和一些新的名词混在一起，变的模糊，难懂了起来。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java JSP (二)">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/05/17/Java-Web-3-2/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="四大作用域我们在定义每一个变量，每一个属性的时候，都会考虑这个变量、属性的作用范围，也就是作用域。我们会根据我们的需求定义最适当作用域内的变量和属性。在写Java，C++等代码的时候，这个作用域问题还比较好理解，无非就是局部变量、全局变量、静态变量等区别。而到了JSP开发中，这个作用域概念就和一些新的名词混在一起，变的模糊，难懂了起来。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg">
<meta property="article:published_time" content="2019-05-17T00:18:59.000Z">
<meta property="article:modified_time" content="2019-11-03T09:08:12.383Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Web">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/05/17/Java-Web-3-2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java JSP (二)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2019-11-03 17:08:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java JSP (二)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-05-17T00:18:59.000Z" title="发表于 2019-05-17 08:18:59">2019-05-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-11-03T09:08:12.383Z" title="更新于 2019-11-03 17:08:12">2019-11-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/Web/">Web</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java JSP (二)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="四大作用域"><a href="#四大作用域" class="headerlink" title="四大作用域"></a>四大作用域</h3><p>我们在定义每一个变量，每一个属性的时候，都会考虑这个变量、属性的作用范围，也就是作用域。我们会根据我们的需求定义最适当作用域内的变量和属性。在写Java，C++等代码的时候，这个作用域问题还比较好理解，无非就是局部变量、全局变量、静态变量等区别。而到了JSP开发中，这个作用域概念就和一些新的名词混在一起，变的模糊，难懂了起来。</p>
<span id="more"></span>

<p>对于JSP中的四大作用域，主要是指以下四个：</p>
<ul>
<li>page作用域</li>
<li>request作用域</li>
<li>session作用域</li>
<li>application作用域</li>
</ul>
<p>这四个作用域的作用范围，由上到下是一个比一个大。下面就对上述的四个作用域分别进行详细的总结。</p>
<h4 id="page作用域"><a href="#page作用域" class="headerlink" title="page作用域"></a>page作用域</h4><p>page直译就是页面的意思，所以page作用域就比较好理解了——page作用域表示只在当前页面有效。当程序运行跑出了当前的页面，你就无法在其它的页面访问当前页面设置的属性值。</p>
<p>我们都知道，JSP最终会被编译成Servlet文件。在Servlet容器中，每个Servlet都只存在一个实例。但是对于page作用域的属性来说，在当前页面设置的属性只在本次访问该页面有效，当你再次访问该页面时，又会重新初始化页面的属性。例如以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">out.print(pageContext.getAttribute(&quot;SiteName&quot;)); // 输出null</span><br><span class="line">pageContext.setAttribute(&quot;SiteName&quot;, &quot;平心&quot;);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>当我在浏览器访问该页面时会输出<code>null</code>；当我再重新打开一个该页面时，还会输出<code>null</code>，并不会输出”果冻想-一个原创技术文章分享网站”。也就是说，page作用域范围的不会存在线程安全的问题，每一次访问同一个页面，设置的page作用域的属性都是不一样的。</p>
<h4 id="request作用域"><a href="#request作用域" class="headerlink" title="request作用域"></a>request作用域</h4><p>request表示一次客户端的请求。一次请求的生命周期从客户端发起到服务器接收并响应该请求，或者将该请求<code>forward</code>到另一个页面或者Servlet进行处理而结束。在此期间，本次请求的参数，属性都是有效的；一旦客户端刷新浏览器，重新发起请求，则之前的请求参数和属性都将失效。</p>
<p>特别需要注意的是，当我们使用<code>&lt;jsp:forward .../&gt;</code>动作将当前请求转向另一个页面或者Servlet的时候，该请求的参数和属性也一并转过去，并不会因为<code>&lt;jsp:forward .../&gt;</code>动作而丢失request的参数和属性。</p>
<h4 id="session作用域"><a href="#session作用域" class="headerlink" title="session作用域"></a>session作用域</h4><p>我一直都在强调session是一个非常重要的概念。当我们向服务器发送第一个请求开始，只要页面不关闭，或者会话未过期（默认30分钟），或者未调用HttpSession的invalidate()方法，接下来的操作都属于同一次会话的范畴。</p>
<p>在JSP中，每当向服务器发送一个请求，服务器响应这个请求的时候，会在客户端的Cookie中写一个session  id值。每次发送请求的时候，会将该session id值一起发送到服务器端，服务器端根据该session  id值来判断每次请求是否属于同一个session的范畴之内。</p>
<h4 id="application作用域"><a href="#application作用域" class="headerlink" title="application作用域"></a>application作用域</h4><p>application的作用域是最广的，它代表着整个Web应用的全局变量，对每一个页面，每一个Servlet都是有效的。当我们在application中设置属性时，这个属性在任意的一个页面都是可以访问的。</p>
<p>在application作用域中设置的属性如果不手动调用<code>removeAttribute</code>函数进行删除的话，那么application中的属性将永远不会删除，如果Web容器发生重启，此时application范围内的所有属性都将丢失。</p>
<h3 id="JSP自定义标签"><a href="#JSP自定义标签" class="headerlink" title="JSP自定义标签"></a>JSP自定义标签</h3><p>自定义标签库是一种非常优秀的表现层组件技术。通过使用自定义标签库，可以在简单的标签中封装复杂的功能。 </p>
<p>那么为什么需要使用自定义的标签呢？主要是基于以下几个原因：</p>
<ul>
<li>JSP脚本非常不好阅读，而且这些<code>&lt;%! %&gt;</code>、<code>&lt;% %&gt;</code>这些东西也非常不好写；</li>
<li>当JSP脚本和HTML混在一起时，那更痛苦，当需要表现一些复杂数据时，更是如此；</li>
<li>很多公司的美工是直接参与表现层的代码编写的，而相比于HTML来说，JSP代码则更难写。</li>
</ul>
<p>于此，我们需要一种类似于HTML那种简单写法的语法来完成JSP的工作，所以JSP中就有了自定义标签这个强大的功能。</p>
<p>虽然有了JSP自定义标签，我们可以在表现层写起来更轻松，但是底下我们也要做很多其它的工作，还是应了那句老话：要想人前显贵，就得人后受罪。那么到底如何开发JSP自定义标签呢？大体上分为以下三步：</p>
<ol>
<li>开发自定义标签处理类</li>
<li>建立一个<code>*.tld</code>文件，每个<code>*.tld</code>文件对应一个标签库，每个标签库可包含多个标签</li>
<li>在JSP文件中使用自定义标签</li>
</ol>
<p>开发JSP自定义标签无非就是上述三步，下面就对上述的三步进行详细的讲解与分析。</p>
<h4 id="开发自定义标签类"><a href="#开发自定义标签类" class="headerlink" title="开发自定义标签类"></a>开发自定义标签类</h4><p>当我们在表现层使用自定义标签时，你应该拥有最基本的意识，那就是自定义标签最终都得通过Java类来进行处理。是的，自定义标签就是通过Java类处理的，我们通过标签类来封装哪些复杂的功能，对上层提供简单的标签。所以当我们定义我们自己的标签时，工作重点都在编写这个标签类。</p>
<p>自定义标签类都继承一个父类：<code>javax.servlet.jsp.tagext.SimpleTagSupport</code>，除了这个条件以外，自定义标签类还要有如下要求：</p>
<ul>
<li>如果标签类包含属性，每个属性都需要有对应的<code>getter</code>和<code>setter</code>方法</li>
<li>需要重写<code>doTag()</code>方法，这个方法用于生成页面内容；也就是说，当我们在表现层使用自定义标签时，使用标签的地方将使用<code>doTag()</code>输出的内容替代</li>
</ul>
<p>下面就来写一个最简单的标签类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TestTag extends SimpleTagSupport &#123;</span><br><span class="line">    public void doTag() throws JspException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        getJspContext().getOut().write(&quot;baidu--误你终生&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="建立TLD文件"><a href="#建立TLD文件" class="headerlink" title="建立TLD文件"></a>建立TLD文件</h4><p>我们写Servlet的时候，会在web.xml中加入定义的Servlet类和URL之间的映射。同理，我们定义了标签类，也需要一个配置文件，将自定义标签和对应的标签类关联起来。在定义自定义标签时，这个配置文件叫做标签库定义文件，是以<code>tld</code>后缀结尾的，每个TLD文件对应一个标签库，一个标签库中可包含多个标签。</p>
<p>标签库定义文件的根元素是<code>taglib</code>，它可以包含多个tag子元素，每个tag子元素都定义一个标签。我们需要将<code>tld</code>文件保存到Web应用的<code>WEB-INF/</code>路径，或者<code>WEB-INF</code>的任意子路径下。</p>
<p>以下就是我定义的一个简单的<code>tld</code>文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line"></span><br><span class="line">&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot;</span><br><span class="line">        version=&quot;2.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;description&gt;Test 1.0&lt;/description&gt;</span><br><span class="line">    &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;</span><br><span class="line">    &lt;short-name&gt;jtlib&lt;/short-name&gt;</span><br><span class="line">    &lt;uri&gt;http://www.pingxin.com/jtlib/&lt;/uri&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义一个标签 --&gt;</span><br><span class="line">    &lt;tag&gt;</span><br><span class="line">        &lt;!-- 定义标签名 --&gt;</span><br><span class="line">        &lt;name&gt;jtTag&lt;/name&gt;</span><br><span class="line">        &lt;!-- 定义标签处理类 --&gt;</span><br><span class="line">        &lt;tag-class&gt;com.hyp.learn.javaweb.TestTag&lt;/tag-class&gt;</span><br><span class="line">        &lt;!-- 定义标签体内容为空 --&gt;</span><br><span class="line">        &lt;body-content&gt;empty&lt;/body-content&gt;</span><br><span class="line">    &lt;/tag&gt;</span><br><span class="line">&lt;/taglib&gt;</span><br></pre></td></tr></table></figure>

<p>标签库定义文件是一个XML文件，该XML文件的根元素是<code>taglib</code>元素。<code>taglib</code>主要有以下几个子元素：</p>
<ul>
<li><code>description</code>，对该tld文件的一些描述性的信息</li>
<li><code>tlib-version</code>，指定该标签库实现的版本，这是一个作为标识的内部版本号，对程序没有太大的作用</li>
<li><code>short-name</code>，标签库的默认短名，没有太大的作用</li>
<li><code>uri</code>，这个属性非常重要，它指定该标签库的URI，相当于指定该标签库的唯一标识。JSP页面中使用标签库时就是根据该URI属性来定位标签库的</li>
</ul>
<p>接下来，<code>taglib</code>元素下可以包含多个tag元素，每个tag元素定义一个标签，tag元素主要有以下子元素：</p>
<ul>
<li><p><code>name</code>，指定标签的名字，JSP页面中就是根据该名称来使用此标签的，所以该子元素非常重要</p>
</li>
<li><p><code>tag-class</code>，指定标签的处理类，它指定了标签由哪个标签处理类来处理，该子元素极其重要</p>
</li>
<li><p>```<br>body-content</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ，指定标签体的内容，该子元素非常重要，它主要可以取以下几个值： </span><br><span class="line"></span><br><span class="line">  - `tagdependent`，指定标签处理类自己负责处理标签体</span><br><span class="line">  - `empty`，该标签只能作为空标签来使用</span><br><span class="line">  - `scriptless`，指定该标签的标签体可以是静态HTML元素、表达式语言，但不能是JSP脚本</span><br><span class="line">  - `dynamic-attributes`，指明该标签是否支持动态属性。只有定义动态属性标签时才需要该子元素</span><br><span class="line"></span><br><span class="line">以上就是标签库定义文件的编写规范，以及编写过程中需要注意的内容事项。编写好标签库定义文件以后，将标签库文件放在Web应用的WEB-INF路径，或者任意子路径下，Java Web会自动加载该文件，该文件定义的标签库也将生效。</span><br><span class="line"></span><br><span class="line">#### 使用标签库</span><br><span class="line"></span><br><span class="line">标签库处理类定义好了，标签库定义文件也写好了，接下来就该小试牛刀了，看看在JSP中到底该怎么使用我们自定义的标签。</span><br><span class="line"></span><br><span class="line">在JSP页面中使用标签库需要注意以下两点：</span><br><span class="line"></span><br><span class="line">- 标签库URI：确定使用哪个标签库</span><br><span class="line">- 标签名：确定使用哪个标签</span><br><span class="line"></span><br><span class="line">具体使用标签库主要分为以下两个步骤：</span><br><span class="line"></span><br><span class="line">1. 导入标签库；使用`taglib`编译指令导入标签库，就是将标签库和指定前缀关联起来</span><br><span class="line">2. 使用标签；在JSP页面中使用自定义标签</span><br><span class="line"></span><br><span class="line">下面通过一个简单的JSP来说明如何使用自定义标签，JSP页面代码如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;<br>&lt;%@ taglib uri=”<a target="_blank" rel="noopener" href="http://www.pingxin.com/jtlib/&quot;">http://www.pingxin.com/jtlib/&quot;</a> prefix=”jt”%&gt;</p>
<html>
<head>
  <title>Page 6</title>
</head>
<body>
<!-- 使用自定义标签  -->
<jt:jtTag />
<jt:jtTag />
</body>
</html>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">总结到这里，对于如何定义一个简单的标签，以及如何使用这个简单的自定义标签，大家心里应该都有数了，接下来看看自定义标签的一些高级用法，而这些高级用法才是开发中真正经常碰到的。</span><br><span class="line"></span><br><span class="line">#### 带属性的标签</span><br><span class="line"></span><br><span class="line">很多时候，单纯的一个标签根本无法满足我们的需要。我们需要在标签中添加一些属性，通过设置的这些属性值，我们可以进行更丰富的操作，比如执行属性值中指定的SQL语句，从而返回并显示查询结果。下面就来说说如何在自定义标签中添加属性的功能。</span><br><span class="line"></span><br><span class="line">首先，带属性的标签必须要为每个属性提供对应的setter和getter方法；例如，我们的自定义标签将会有三个属性，分别是：name、price和store。那么我们对应的标签处理类会变成下面这个样子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
public class TestTag extends SimpleTagSupport {
  // 标签定义的属性
  private String name;
  private String price;
  private String store;

<p>  // 需要为每个属性定义setter和getter方法<br>  public void setName(String name)<br>  {</p>
<pre><code>  this.name = name;
</code></pre>
<p>  }</p>
<p>  public String getName()<br>  {</p>
<pre><code>  return this.name;
</code></pre>
<p>  }</p>
<p>  public void setPrice(String price)<br>  {</p>
<pre><code>  this.price = price;
</code></pre>
<p>  }</p>
<p>  public String getPrice()<br>  {</p>
<pre><code>  return this.price;
</code></pre>
<p>  }</p>
<p>  public void setStore(String store)<br>  {</p>
<pre><code>  this.store = store;
</code></pre>
<p>  }</p>
<p>  public String getStore()<br>  {</p>
<pre><code>  return this.store;
</code></pre>
<p>  }</p>
<p>  public void doTag() throws JspException, IOException<br>  {</p>
<pre><code>  JspWriter out = getJspContext().getOut();
  out.write(&quot;书名：&quot; + name);
  out.write(&quot;价格：&quot; + price);
  out.write(&quot;书店：&quot; + store);
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">每个属性都必须要有对应的setter和getter方法，这是不能少的。标签对应的处理类进行了对应的变更；同理，对于标签库定义文件也要进行对应的修改，需要为`&lt;tag... /&gt;`元素增加`&lt;attribute... /&gt;`子元素，每个attribute子元素定义一个标签属性。在定义attribute元素时，需要为其指定以下几个子元素：</span><br><span class="line"></span><br><span class="line">- `name`，设置属性名；在使用自定义标签时，就是通过该名指定属性名</span><br><span class="line">- `required`，设置该属性是否为必须属性，取值为true或false</span><br><span class="line">- `fragment`，设置该属性是否支持JSP脚本、表达式等动态内容，取值为true或false</span><br><span class="line"></span><br><span class="line">为此，我们的标签库定义文件就要修改为如下这样：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<?xml version="1.0" encoding="UTF-8" ?></li>
</ul>
<p><taglib xmlns="http://java.sun.com/xml/ns/j2ee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"
        version="2.0"></p>
<pre><code>&lt;description&gt;Test 1.0&lt;/description&gt;
&lt;tlib-version&gt;1.0&lt;/tlib-version&gt;
&lt;short-name&gt;jtlib&lt;/short-name&gt;
&lt;uri&gt;http://www.pingxin.com/jtlib/&lt;/uri&gt;

&lt;!-- 定义一个标签 --&gt;
&lt;tag&gt;
    &lt;!-- 定义标签名 --&gt;
    &lt;name&gt;jtTag&lt;/name&gt;
    &lt;!-- 定义标签处理类 --&gt;
    &lt;tag-class&gt;com.hyp.learn.javaweb.TestTag&lt;/tag-class&gt;
    &lt;!-- 定义标签体内容为空 --&gt;
    &lt;body-content&gt;empty&lt;/body-content&gt;

    &lt;!-- 配置name属性 --&gt;
    &lt;attribute&gt;
        &lt;name&gt;name&lt;/name&gt;
        &lt;required&gt;true&lt;/required&gt;
        &lt;fragment&gt;true&lt;/fragment&gt;
    &lt;/attribute&gt;

    &lt;!-- 配置price属性 --&gt;
    &lt;attribute&gt;
        &lt;name&gt;price&lt;/name&gt;
        &lt;required&gt;true&lt;/required&gt;
        &lt;fragment&gt;true&lt;/fragment&gt;
    &lt;/attribute&gt;

    &lt;!-- 配置store属性 --&gt;
    &lt;attribute&gt;
        &lt;name&gt;store&lt;/name&gt;
        &lt;required&gt;true&lt;/required&gt;
        &lt;fragment&gt;true&lt;/fragment&gt;
    &lt;/attribute&gt;
    
&lt;/tag&gt;
</code></pre>
</taglib>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接下来，我们就可以在JSP中使用这个带有属性定义的自定义标签了，具体代码如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<jt:jtTag name="Java编程思想" price="75.58" store="三味书屋" /> <br/>
<jt:jtTag name="看见" price="25.10" store="书海书屋" /> <br/>
<jt:jtTag name="狼图腾" price="23.00" store="国家图书馆" /> <br/>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这就是带有属性的自定义标签。</span><br><span class="line"></span><br><span class="line">#### 带标签体的标签</span><br><span class="line"></span><br><span class="line">可以看到，上面自定义的标签都是没有任何标签体的，都是一个简单的标签。那么如果我们希望标签中带有标签体，这又如何完成呢？</span><br><span class="line"></span><br><span class="line">对于带标签体的自定义标签，我们可以在标签内嵌入静态的HTML内容和动态的JSP内容，通常用于循环输出一些内容。下面就通过一个简单的例子进行说明。</span><br><span class="line"></span><br><span class="line">标签类的处理代码如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
public class TestTag extends SimpleTagSupport {
    // 标签定义的属性
    private String collection;
    private String item;

<pre><code>public void setCollection(String collection)
&#123;
    this.collection = collection;
&#125;

public String getCollection()
&#123;
    return this.collection;
&#125;

public void setItem(String item)
&#123;
    this.item = item;
&#125;

public String getItem()
&#123;
    return this.item;
&#125;


public void doTag() throws JspException, IOException
&#123;
    JspContext context = getJspContext();

    // 根据属性值，获得设置的对象
    Collection itemList = (Collection)context.getAttribute(collection);
    for (Object s : itemList)
    &#123;
        // 设置属性值，供标签体使用
        context.setAttribute(item, s);

        // 输出标签体，这个是重点
        getJspBody().invoke(null);
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">标签库定义文件：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<?xml version="1.0" encoding="UTF-8" ?>

<p><taglib xmlns="http://java.sun.com/xml/ns/j2ee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"
        version="2.0"></p>
<pre><code>&lt;description&gt;Test 1.0&lt;/description&gt;
&lt;tlib-version&gt;1.0&lt;/tlib-version&gt;
&lt;short-name&gt;jtlib&lt;/short-name&gt;
&lt;uri&gt;http://www.pingxin.com/jtlib/&lt;/uri&gt;

&lt;!-- 定义一个标签 --&gt;
&lt;tag&gt;
    &lt;!-- 定义标签名 --&gt;
    &lt;name&gt;jtTag&lt;/name&gt;
    &lt;!-- 定义标签处理类 --&gt;
    &lt;tag-class&gt;com.hyp.learn.javaweb.TestTag&lt;/tag-class&gt;
    &lt;!-- 定义标签体内容为空 --&gt;
    &lt;body-content&gt;scriptless&lt;/body-content&gt;

    &lt;!-- 配置属性 --&gt;
    &lt;attribute&gt;
        &lt;name&gt;collection&lt;/name&gt;
        &lt;required&gt;true&lt;/required&gt;
        &lt;fragment&gt;true&lt;/fragment&gt;
    &lt;/attribute&gt;

    &lt;attribute&gt;
        &lt;name&gt;item&lt;/name&gt;
        &lt;required&gt;true&lt;/required&gt;
        &lt;fragment&gt;true&lt;/fragment&gt;
    &lt;/attribute&gt;

&lt;/tag&gt;
</code></pre>
</taglib>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对于标签库定义文件来说，主要是`&lt;body-content&gt;`字段的值需要设置为`scriptless`。最重要的是JSP页面里如何使用带有标签体的自定义标签，具体代码如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<%@ page import="java.util.ArrayList" %>
<%@ page import="java.util.List" %><%--
  Created by IntelliJ IDEA.
  User: hyp
  Date: 2019/5/21
  Time: 下午5:19
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="http://www.pingxin.com/jtlib/" prefix="jt"%>
<html>
<head>
    <title>Page 6</title>
</head>
<body>
<%
    // 创建一个List对象
    List<String> obj = new ArrayList<String>();
    obj.add("博客园");
    obj.add("开源中国");
    obj.add("百度");
    pageContext.setAttribute("collection", obj);
%>

<p>&lt;jt:jtTag collection=”collection” item=”item”&gt;<br>    ${pageScope.item} <br /><br></jt:jtTag></p>
</body>
</html>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">由于JSP主要作为表现层，上面只是通过一个简单的例子来说明如何表现数据；很多时候，我们后台返回一个数据集合，我们就可以通过这种方式来表现数据。</span><br><span class="line"></span><br><span class="line">### Filter</span><br><span class="line"></span><br><span class="line">Filter是什么？在工作的过程中，我们经常听到Filter这个词，那这货到底是个什么东西呢？这篇文章将对Java Web开发中遇到的Filter进行详细的分析与总结。</span><br><span class="line"></span><br><span class="line">Filter，译为过滤器；既然是过滤器，那么主要过滤什么呢？Filter主要对客户端的请求和服务器的响应进行过滤。说直白点就是下面这两个意思：</span><br><span class="line"></span><br><span class="line">- 客户端的请求到达服务器，服务器真正开始处理这个请求之前，要经过Filter的过滤</span><br><span class="line">- 服务器真正的处理完这个请求，生成响应之后，要经过Filter的过滤，才能将响应发送给客户端</span><br><span class="line"></span><br><span class="line">也就是说，我们可以通过Filter技术，对web服务器管理的所有web资源，例如JSP、Servlet、静态图片文件或静态 html文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。</span><br><span class="line"></span><br><span class="line">Filter在请求到达服务器之后和服务器生成响应到客户端之前都会发挥它的作用，我通过下图来看看Filter的工作角色：</span><br><span class="line"></span><br><span class="line">![1.png](https://i.loli.net/2019/05/21/5ce3d287cf15494400.png)</span><br><span class="line"></span><br><span class="line">Filter就好比在一条处理链上，依次排开，Request和Response依次经过Filter的处理。这里就使用了《责任链模式》。通过上图，我们可以很清楚的知道Filter的作用位置和角色。明白了这儿以后，接下来看看如何创建Filter，以及如何使用Filter。</span><br><span class="line"></span><br><span class="line">**创建Filter的步骤**</span><br><span class="line"></span><br><span class="line">创建Filter和创建Servlet类似，主要分为以下两步：</span><br><span class="line"></span><br><span class="line">- 创建Filter处理类</span><br><span class="line">- 在web.xml文件中配置Filter</span><br><span class="line"></span><br><span class="line">下面就从上面的两步进行详细的总结，并通过实际的例子进行分析。</span><br><span class="line"></span><br><span class="line">**1.  创建Filter处理类**</span><br><span class="line"></span><br><span class="line">创建Filter类必须要实现`javax.servlet.Filter`接口，在这个接口中主要定义了以下三个方法：</span><br><span class="line"></span><br><span class="line">- `void init(FilterConfig config)`；用于完成Filter的初始化</span><br><span class="line">- `void destroy()`；用于Filter销毁前，完成某些资源的回收</span><br><span class="line">- `void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)`；实现过滤功能，对每个请求及响应进行拦截和处理</span><br><span class="line"></span><br><span class="line">下面就实现一个Filter类，对每个到达服务器的请求、以及服务器的响应进行日志记录。具体的Filter类实现如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class LogFilter implements Filter<br>{<br>    private FilterConfig config;</p>
<pre><code>public void init(FilterConfig config)
&#123;
    this.config = config;
&#125;

public void destroy()
&#123;
    this.config = null;
&#125;

// 这个方法是Filter的核心方法
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
throws IOException, ServletException
&#123;
    // 对用户的请求进行处理
    ServletContext context = this.config.getServletContext();
    long begin = System.currentTimeMillis();

    // 输出过滤信息
    System.out.println(&quot;开始过滤...&quot;);
    HttpServletRequest hRequest = (HttpServletRequest)request;
    System.out.println(&quot;Filter已经截获到用户请求的地址:&quot; + hRequest.getServletPath());

    // 处理完以后，将请求交给下一个Filter或者Servlet处理
    chain.doFilter(request, response);

    // 对服务器的响应进行处理
    long end = System.currentTimeMillis();
    System.out.println(&quot;过滤结束&quot;);
    System.out.println(&quot;请求被定为到:&quot; + hRequest.getRequestURI() + &quot;; 所花费的时间为:&quot; + (end - begin));
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上面的代码中，`doFilter`方法是最重要的，实现该方法就可实现对用户请求进行预处理，也可实现对服务器响应进行后处理——它们的分界线为是否调用了`chain.doFilter()`，执行该方法之前，即对用户请求进行预处理；执行该方法之后，即对服务器响应进行后处理。</span><br><span class="line"></span><br><span class="line">**2. 配置Filter**</span><br><span class="line"></span><br><span class="line">同开发Servlet一样，写完了类，接下来就是配置了，我们需要在web.xml文件中配置Filter。具体的配置和Servlet配置如出一辙。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<filter>
    <filter-name>log</filter-name>
    <filter-class>com.jellythink.practise.LogFilter</filter-class>
  </filter>

  <filter-mapping>
    <filter-name>log</filter-name>
    <url-pattern>/*</url-pattern>
    <dispatcher>REQUEST</dispatcher>
  </filter-mapping>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面配置中比较重要的就是`url-pattern`和`dispatcher`了。</span><br><span class="line"></span><br><span class="line">- 通过配置`url-pattern`，我们就可以控制对哪些URL进行过滤，哪些URL不进行过滤</span><br><span class="line"></span><br><span class="line">- 通过配置</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  dispatcher
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">，可以指定以哪种方式访问资源可以被Filter拦截；对于</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  dispatcher
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  可以配置以下值： </span><br><span class="line"></span><br><span class="line">  - REQUEST，默认为REQUEST；当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过`RequestDispatcher`的`include()`或`forward()`方法访问时，那么该过滤器就不会被调用</span><br><span class="line">  - INCLUDE；如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用；例如：`&lt;jsp:include file=&quot;/..&quot;/&gt;`</span><br><span class="line">  - FORWARD；如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用；例如：`&lt;jsp:forward page=&quot;&quot; /&gt;`或通过page指令的errorPage转发页面`&lt;%@ page errorPage=&quot;error.jsp&quot; %&gt;`</span><br><span class="line">  - ERROR；如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用</span><br><span class="line"></span><br><span class="line">在Web开发中，Filter是一个非常重要的概念；在后续的学习中，我们会发现很多优秀的框架都会用到Filter这个特性，从而实现对客户端请求的拦截。</span><br><span class="line"></span><br><span class="line">### Listener</span><br><span class="line"></span><br><span class="line">Listener就是监听器，监听着某个事件的发生。当监听的事件发生时，则要通知这个监听器去“干”一些事情。这篇文章就要对Java Web开发中的这个Listener说道说道。</span><br><span class="line"></span><br><span class="line">我们都知道，Web应用在Web容器中运行，Web应用内部会不断的产生各种事件，例如Web应用被启动、Web应用被停止、用户Session开始、用户Session结束等；一般情况来说，我们并不在意这些事件的发生，但是有的时候，实现某些需求却要在这些事件上做文章。那么如何做文章呢？</span><br><span class="line"></span><br><span class="line">当这些事件发生时，它需要去通知那些关注这个事件的“人”，这都是基于《观察者模式》实现了该功能。正好Servlet API正好提供了大量监听器来“关注”Web应用的内部事件，从而允许当Web内部事件发生时回调事件监听器内的方法。</span><br><span class="line"></span><br><span class="line">在Servlet API中目前提供的Web事件监听器接口有如下几个：</span><br><span class="line"></span><br><span class="line">| 接口名称                          | 作用                                                  |</span><br><span class="line">| --------------------------------- | ----------------------------------------------------- |</span><br><span class="line">| `ServletContextListener`          | 用于监听Web应用的启动和关闭                           |</span><br><span class="line">| `ServletContextAttributeListener` | 用于监听ServletContext范围（application）内属性的改变 |</span><br><span class="line">| `ServletRequestListener`          | 用于监听用户请求                                      |</span><br><span class="line">| `ServletRequestAttributeListener` | 用于监听ServletRequest范围（request）内属性的改变     |</span><br><span class="line">| `HttpSessionListener`             | 用于监听用户Session的开始和结束                       |</span><br><span class="line">| `HttpSessionAttributeListener`    | 用于监听HttpSession范围（session）内属性的改变        |</span><br><span class="line"></span><br><span class="line">下面就通过实际的代码来总结如何实现监听器接口，以及如何配置它。</span><br><span class="line"></span><br><span class="line">#### 实现Listener类</span><br><span class="line"></span><br><span class="line">使用监听器的功能只需要两步：</span><br><span class="line"></span><br><span class="line">- 定义实现相关Listener接口的类</span><br><span class="line">- 在web.xml文件中配置Listener</span><br><span class="line"></span><br><span class="line">就这些。下面通过实现`ServletContextListener`接口来仔细看看如何定义一个Listener类、以及如何配置这个Listener类。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;

<p>public class ServletContextListenerImpl implements ServletContextListener<br>{<br>    // 应用启动时，该方法会被调用<br>    public void contextInitialized(ServletContextEvent sce)<br>    {<br>        System.out.println(“应用启动……”);<br>    }</p>
<pre><code>// 应用关闭时，该方法会被调用
public void contextDestroyed(ServletContextEvent sce)
&#123;
    System.out.println(&quot;应用关闭......&quot;);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面这个类实现了`ServletContextListener`接口；当应用启动、关闭时，都会回调对应的方法。</span><br><span class="line"></span><br><span class="line">**配置Listener**</span><br><span class="line"></span><br><span class="line">同Servlet、Filter一样，完成了对应的类以后，都需要在Web.xml中配置这个类名，从而让Web容器能够找到对应的类。对于Listener的配置，相对于Servlet和Filter来说更简单一些。具体配置如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<listener>
    <listener-class>com.jellythink.practise.ServletContextListenerImpl</listener-class>
</listener>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**ServletRequestListener代码示例**</span><br><span class="line"></span><br><span class="line">上面对`ServletContextListener`接口进行了简单的说明，下面通过一段代码来演示如何使用`ServletRequestListener`接口。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>import javax.servlet.ServletRequestEvent;<br>import javax.servlet.ServletRequestListener;<br>import javax.servlet.http.HttpServletRequest;</p>
<p>public class ServletRequestListenerImpl implements ServletRequestListener<br>{<br>      // 当用户请求结束、被销毁时触发该方法<br>      public void requestDestroyed(ServletRequestEvent sre)<br>      {<br>          HttpServletRequest req = (HttpServletRequest)sre.getServletRequest();<br>          System.out.println(“++++发向” + req.getRequestURI() + “请求被初始化++++”);<br>      }</p>
<pre><code>  // 当用户请求到达、初始化时触发该方法
  public void requestInitialized(ServletRequestEvent sre)
  &#123;
      HttpServletRequest req = (HttpServletRequest)sre.getServletRequest();
      System.out.println(&quot;++++发向&quot; + req.getRequestURI() + &quot;请求被销毁++++&quot;);
  &#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当实现了`ServletRequestListener`接口以后，每当有请求到达服务器，并正确初始化`HttpServletRequest`对象以后，或者用户结束了请求以后，都会回调对应的监听器方法。</span><br><span class="line"></span><br><span class="line">**ServletRequestAttributeListener代码示例**</span><br><span class="line"></span><br><span class="line">如果实现了`ServletRequestAttributeListener`监听器接口，当在request作用域下的属性发生了变化时，就会回调对应的方法，下面就通过一段代码来实现`ServletRequestAttributeListener`监听器。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class ServletRequestAttributeListenerImpl implements ServletRequestAttributeListener<br>{<br>      // 当向request作用域添加属性时，触发该方法<br>      public void attributeAdded(ServletRequestAttributeEvent srqe)<br>      {<br>          ServletRequest req = srqe.getServletRequest();<br>          String attrName = srqe.getName();<br>          Object attrValue = srqe.getValue();<br>          System.out.println(req + “范围内添加了名为:” + attrName + “, 值为:” + attrValue + “的属性”);<br>      }</p>
<pre><code>  // 当从request作用域删除属性时，触发该方法
  public void attributeRemoved(ServletRequestAttributeEvent srqe)
  &#123;
      ServletRequest req = srqe.getServletRequest();
      String attrName = srqe.getName();
      Object attrValue = srqe.getValue();
      System.out.println(req + &quot;范围内删除名为:&quot; + attrName + &quot;, 值为:&quot; + attrValue + &quot;的属性&quot;);
  &#125;

  // 当修改request作用域属性值时，触发该方法
  public void attributeReplaced(ServletRequestAttributeEvent srqe)
  &#123;
      ServletRequest req = srqe.getServletRequest();
      String attrName = srqe.getName();
      Object attrValue = srqe.getValue();
      System.out.println(req + &quot;范围内名为:&quot; + attrName + &quot;, 值为:&quot; + attrValue + &quot;的属性被修改了&quot;);
  &#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这就是关于属性相关的监听器的用法，就这些。</span><br><span class="line"></span><br><span class="line">Listener是非常重要的东西，可能我在这里说你也不会体会到。有朝一日，你要实现某些需求时，当你想到Listener时，你会发现这个东西太好用了。</span><br><span class="line"></span><br><span class="line">### Servlet实现JSON</span><br><span class="line"></span><br><span class="line">#### 解决HttpServletResponse输出的中文乱码问题</span><br><span class="line"></span><br><span class="line">主要有这三行代码就可以了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>request.setCharacterEncoding(“utf-8”);<br>response.setHeader(“Content-type”, “text/html;charset=UTF-8”);<br>response.setCharacterEncoding(“utf-8”);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用库：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
  &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
  &lt;version&gt;3.0.1&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
  &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
  &lt;version&gt;2.2&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
  &lt;version&gt;1.2.57&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">JSON类：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class ResultCode {<br>    @JSONField(name = “code”, ordinal = 0)<br>    private int code;<br>    @JSONField(name = “err”, ordinal = 1)<br>    private int error;<br>    @JSONField(name = “msg”, ordinal = 2)<br>    private String msg = “”;<br>    @JSONField(name = “data”, ordinal = 3)<br>    private Object data = new ArrayList&lt;&gt;();</p>
<pre><code>public ResultCode() &#123;
&#125;

public ResultCode(int code, int error, String msg, Object data) &#123;
    this.code = code;
    this.error = error;
    if (null != msg) &#123;
        this.msg = msg;
    &#125;
    if (null != data) &#123;
        this.data = data;
    &#125;
&#125;

public int getCode() &#123;
    return code;
&#125;

public void setCode(int code) &#123;
    this.code = code;
&#125;

public int getError() &#123;
    return error;
&#125;

public void setError(int error) &#123;
    this.error = error;
&#125;

public Object getData() &#123;
    return data;
&#125;

public void setData(Object data) &#123;
    this.data = data;
&#125;


public String getMsg() &#123;
    return msg;
&#125;

public void setMsg(String msg) &#123;
    this.msg = msg;
&#125;

@Override
public String toString() &#123;
    return &quot;ResultCode&#123;&quot; +
            &quot;code=&quot; + code +
            &quot;, error=&quot; + error +
            &quot;, msg=&#39;&quot; + msg + &#39;\&#39;&#39; +
            &quot;, data=&quot; + data +
            &#39;&#125;&#39;;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MakeCode接口类：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public interface MakeCode {<br>    public ResultCode code(HttpServletRequest request, HttpServletResponse response);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Servlet基类：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public abstract  class ISIServlet extends HttpServlet implements MakeCode{<br>    protected ResultCode code=null;</p>
<pre><code>protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    request.setCharacterEncoding(&quot;utf-8&quot;);
    response.setHeader(&quot;Content-type&quot;, &quot;text/html;charset=UTF-8&quot;);
    response.setCharacterEncoding(&quot;utf-8&quot;);
    code(request,response);
    PrintWriter out = response.getWriter();
    out.println(JSON.ToJSON(code));
    out.flush();
    out.close();
&#125;

protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    doPost(request,response);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">获取JSON数据Servlet:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class MyServlet extends ISIServlet {</p>
<pre><code>@Override
public ResultCode code(HttpServletRequest request, HttpServletResponse response) &#123;
    List weather=null;
    try &#123;
        //获取数据
        weather= ServicesUtils.getDao().getUseWeather();
        if (null!=weather) &#123;
            code = ServicesUtils.code(1, 0, &quot;&quot;, weather);
        &#125;else &#123;
            code= ServicesUtils.error(&quot;系统错误&quot;);
        &#125;
    &#125; catch (ISIException e) &#123;
        code=ServicesUtils.error(e.getMessage());
    &#125;
    return code;
&#125;
</code></pre>
<p>}</p>
<p>```</p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol>
<li><p>请谈谈，转发和重定向 之间的区别？</p>
<p><strong>转发过程</strong>：客户端首先发送一个请求到服务器，服务器匹配Servlet，并指定执行。当这个Servlet执行完后，它要调用getRequestDispacther()方法，把请求转发给指定的Servlet_list.jsp，整个流程都是在服务端完成的，而且是在同一个请求里面完成的，因此Servlet和jsp共享同一个request，在Servlet里面放的所有东西，在student_list.jsp中都能取出来。因此，student_list.jsp能把结果getAttribute()出来，getAttribute()出来后执行完把结果返回给客户端，整个过程是一个请求，一个响应。</p>
<p><strong>重定向过程：</strong>客户端发送一个请求到服务器端，服务器匹配Servlet，这都和请求转发一样。Servlet处理完之后调用了sendRedirect()这个方法，这个方法是response方法。所以，当这个Servlet处理完后，看到response.sendRedirect()方法，立即向客户端返回个响应，响应行告诉客户端你必须再重新发送一个请求，去访问student_list.jsp，紧接着客户端收到这个请求后，立刻发出一个新的请求，去请求student_list.jsp,在这两个请求互不干扰、相互独立，在前面request里面setAttribute()的任何东西，在后面的request里面都获得不了。因此，在sendRedirect()里面是两个请求，两个响应。</p>
<p> Forward是在服务器端的跳转，就是客户端一个请求给服务器，服务器直接将请求相关参数的信息原封不动的传递到该服务器的其他jsp或Servlet去处理。而sendRedirect()是客户端的跳转，服务器会返回客户端一个响应报头和新的URL地址，原来的参数信息如果服务器没有特殊处理就不存在了，浏览器会访问新的URL所指向的Servlet或jsp，这可能不是原来服务器上的webService了。</p>
<p><strong>总结：</strong></p>
<p>​    1、转发是在服务器端完成的，重定向是在客户端发生的；</p>
<p>​    2、转发的速度快，重定向速度慢；</p>
<p>​    3、转发是同一次请求，重定向是两次请求；</p>
<p>​    4、转发地址栏没有变化，重定向地址栏有变化；</p>
<p>​    5、转发必须是在同一台服务器下完成，重定向可以在不同的服务器下完成。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/05/17/Java-Web-3-2/">https://pingxin0521.gitee.io/2019/05/17/Java-Web-3-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Web/">Web</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/05/17/Java-Web-1-3/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Cookie、Session、token</div></div></a></div><div class="next-post pull-right"><a href="/2019/05/16/Java-Web-3-1/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java JSP (一)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/05/17/Java-Web-1-2/" title="Java Web相关问题"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-12-30</div><div class="title">Java Web相关问题</div></div></a></div><div><a href="/2019/05/17/Java-Web-1-3/" title="Cookie、Session、token"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-02-14</div><div class="title">Cookie、Session、token</div></div></a></div><div><a href="/2019/05/16/Java-Web-2-2/" title="Java servlet (二)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-12-13</div><div class="title">Java servlet (二)</div></div></a></div><div><a href="/2019/05/13/Java-Web-1-1/" title="Java Web入门"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-07-31</div><div class="title">Java Web入门</div></div></a></div><div><a href="/2019/05/30/Java-Web-2-3/" title="Java servlet 源码分析(四)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-12-18</div><div class="title">Java servlet 源码分析(四)</div></div></a></div><div><a href="/2019/05/18/Java-Web-2-4/" title="Java servlet 3.0 (三)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-12-18</div><div class="title">Java servlet 3.0 (三)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.</span> <span class="toc-text">四大作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#page%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.1.</span> <span class="toc-text">page作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#request%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.2.</span> <span class="toc-text">request作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#session%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.3.</span> <span class="toc-text">session作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#application%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.4.</span> <span class="toc-text">application作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSP%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE"><span class="toc-number">2.</span> <span class="toc-text">JSP自定义标签</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">开发自定义标签类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8BTLD%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">建立TLD文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">面试题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java servlet (一) | 平心de小屋</title><meta name="keywords" content="Java,Web"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是Servlet？处理请求和发送响应的过程是由一种叫做Servlet的程序来完成的，并且Servlet是为了解决实现动态页面而衍生的东西。理解这个的前提是了解一些http协议的东西，并且知道B&#x2F;S模式(浏览器&#x2F;服务器)。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java servlet (一)">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/05/15/Java-Web-2-1/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="什么是Servlet？处理请求和发送响应的过程是由一种叫做Servlet的程序来完成的，并且Servlet是为了解决实现动态页面而衍生的东西。理解这个的前提是了解一些http协议的东西，并且知道B&#x2F;S模式(浏览器&#x2F;服务器)。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg">
<meta property="article:published_time" content="2019-05-15T00:18:59.000Z">
<meta property="article:modified_time" content="2019-12-13T05:25:43.738Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Web">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/05/15/Java-Web-2-1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java servlet (一)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2019-12-13 13:25:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java servlet (一)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-05-15T00:18:59.000Z" title="发表于 2019-05-15 08:18:59">2019-05-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-12-13T05:25:43.738Z" title="更新于 2019-12-13 13:25:43">2019-12-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/Web/">Web</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>57分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java servlet (一)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="什么是Servlet？"><a href="#什么是Servlet？" class="headerlink" title="什么是Servlet？"></a>什么是Servlet？</h3><p>处理请求和发送响应的过程是由一种叫做Servlet的程序来完成的，并且Servlet是为了解决实现动态页面而衍生的东西。理解这个的前提是了解一些http协议的东西，并且知道B/S模式(浏览器/服务器)。</p>
<span id="more"></span>

<p>Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势：</p>
<ul>
<li>性能明显更好。</li>
<li>Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。</li>
<li>Servlet 是独立于平台的，因为它们是用 Java 编写的。</li>
<li>服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。</li>
<li>Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。</li>
</ul>
<p>Servlet架构：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/05/21/5ce370cc1b16354955.jpg" alt="2.jpg"></p>
<h5 id="Servlet-任务"><a href="#Servlet-任务" class="headerlink" title="Servlet 任务"></a>Servlet 任务</h5><p>Servlet 执行以下主要任务：</p>
<ul>
<li>读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。</li>
<li>读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。</li>
<li>处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。</li>
<li>发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。</li>
<li>发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。</li>
</ul>
<h5 id="Servlet-包"><a href="#Servlet-包" class="headerlink" title="Servlet 包"></a>Servlet 包</h5><p>Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。</p>
<p>Servlet 可以使用 <strong>javax.servlet</strong> 和 <strong>javax.servlet.http</strong> 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。</p>
<p>这些类实现 Java Servlet 和 JSP 规范。在写本教程的时候，二者相应的版本分别是 Java Servlet 2.5 和 JSP 2.1。</p>
<p>Java Servlet 就像任何其他的 Java 类一样已经被创建和编译。在您安装 Servlet 包并把它们添加到您的计算机上的 Classpath 类路径中之后，您就可以通过 JDK 的 Java 编译器或任何其他编译器来编译 Servlet。</p>
<h4 id="tomcat和servlet的关系"><a href="#tomcat和servlet的关系" class="headerlink" title="tomcat和servlet的关系"></a>tomcat和servlet的关系</h4><p>Tomcat 是Web应用服务器,是一个Servlet/JSP容器. Tomcat 作为Servlet容器,负责处理客户请求,把请求传送给Servlet,并将Servlet的响应传送回给客户.而Servlet是一种运行在支持Java语言的服务器上的组件. Servlet最常见的用途是扩展Java Web服务器功能,提供非常安全的,可移植的,易于使用的CGI替代品.</p>
<p>Java Servlet API 是Servlet容器(tomcat)和servlet之间的接口，它定义了serlvet的各种方法，还定义了Servlet容器传送给Servlet的对象类，其中最重要的就是ServletRequest和ServletResponse。所以说我们在编写servlet时，需要实现Servlet接口，按照其规范进行操作。</p>
<ol>
<li><p>Tomcat将http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象，所有的HTTP头数据读可以通过request对象调用对应的方法查询到。</p>
</li>
<li><p>Tomcat同时会要响应的信息封装为HttpServletResponse类型的response对象，通过设置response属性就可以控制要输出到浏览器的内容，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器</p>
</li>
</ol>
<h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p>
<ul>
<li>Servlet 通过调用 <strong>init ()</strong> 方法进行初始化。</li>
<li>Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。</li>
<li>Servlet 通过调用 <strong>destroy()</strong> 方法终止（结束）。</li>
<li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li>
</ul>
<p>现在让我们详细讨论生命周期的方法。</p>
<h5 id="init-方法"><a href="#init-方法" class="headerlink" title="init() 方法"></a>init() 方法</h5><p>init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。</p>
<p>Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。</p>
<p>当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void init() throws ServletException &#123;</span><br><span class="line">  // 初始化代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="service-方法"><a href="#service-方法" class="headerlink" title="service() 方法"></a>service() 方法</h5><p>service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。</p>
<p>每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP  请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。</p>
<p>下面是该方法的特征：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void service(ServletRequest request, </span><br><span class="line">                    ServletResponse response) </span><br><span class="line">      throws ServletException, IOException&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete  等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。</p>
<p>doGet() 和 doPost() 方法是每次服务请求中最常用的方法。下面是这两种方法的特征。</p>
<h5 id="doGet-方法"><a href="#doGet-方法" class="headerlink" title="doGet() 方法"></a>doGet() 方法</h5><p>GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void doGet(HttpServletRequest request,</span><br><span class="line">                  HttpServletResponse response)</span><br><span class="line">    throws ServletException, IOException &#123;</span><br><span class="line">    // Servlet 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="doPost-方法"><a href="#doPost-方法" class="headerlink" title="doPost() 方法"></a>doPost() 方法</h5><p>POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void doPost(HttpServletRequest request,</span><br><span class="line">                   HttpServletResponse response)</span><br><span class="line">    throws ServletException, IOException &#123;</span><br><span class="line">    // Servlet 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="destroy-方法"><a href="#destroy-方法" class="headerlink" title="destroy() 方法"></a>destroy() 方法</h5><p>destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。</p>
<p>在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。destroy 方法定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void destroy() &#123;</span><br><span class="line">  // 终止化代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p>下图显示了一个典型的 Servlet 生命周期方案。</p>
<ul>
<li>第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。</li>
<li>Servlet 容器在调用 service() 方法之前加载 Servlet。</li>
<li>然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/05/21/5ce372767e79297979.jpg" alt="3.jpg"></p>
<h4 id="HelloWorld示例"><a href="#HelloWorld示例" class="headerlink" title="HelloWorld示例"></a>HelloWorld示例</h4><p>新建maven项目</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/05/21/5ce37f1a006a377056.png"></p>
<p>maven依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.1&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>添加插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<p>ServletTest类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class ServletTest extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init() throws ServletException &#123;</span><br><span class="line">        super.init();</span><br><span class="line">        message = &quot;Hello World , Nect To Meet You: &quot; + System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;servlet初始化……&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        super.doPost(request,response);</span><br><span class="line">        System.out.println(&quot;post&quot;);</span><br><span class="line">        response.setContentType(&quot;text/html&quot;);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        writer.println(&quot;&lt;h2&gt;&quot;+message+&quot;&lt;/h2&gt;&quot;);</span><br><span class="line">        destroy();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">       doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        System.out.println(&quot;servlet销毁！&quot;);</span><br><span class="line">        super.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>web.xml文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE web-app PUBLIC</span><br><span class="line"> &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span><br><span class="line"> &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;web-app&gt;</span><br><span class="line">  &lt;display-name&gt;Servlet test&lt;/display-name&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.hyp.learn.javaweb.ServletTest&lt;/servlet-class&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/HelloWorld&lt;/url-pattern&gt;</span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">  &lt;welcome-file-list&gt;</span><br><span class="line">    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;</span><br><span class="line">  &lt;/welcome-file-list&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开终端，运行使用：<code>mvn tomcat7:run</code></p>
<h3 id="表单数据"><a href="#表单数据" class="headerlink" title="表单数据"></a>表单数据</h3><p>很多情况下，需要传递一些信息，从浏览器到 Web 服务器，最终到后台程序。浏览器使用两种方法可将这些信息传递到 Web 服务器，分别为 GET 方法和 POST 方法。</p>
<h4 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h4><p>GET 方法向页面请求发送已编码的用户信息。页面和已编码的信息中间用 ? 字符分隔，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/hello?key1=value1&amp;key2=value2</span><br></pre></td></tr></table></figure>

<p>GET 方法是默认的从浏览器向 Web 服务器传递信息的方法，它会产生一个很长的字符串，出现在浏览器的地址栏中。如果您要向服务器传递的是密码或其他的敏感信息，请不要使用 GET 方法。GET 方法有大小限制：请求字符串中最多只能有 1024 个字符。</p>
<p>这些信息使用 QUERY_STRING  头传递，并可以通过 QUERY_STRING 环境变量访问，Servlet 使用 <strong>doGet()</strong> 方法处理这种类型的请求。</p>
<h4 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h4><p>另一个向后台程序传递信息的比较可靠的方法是 POST 方法。POST 方法打包信息的方式与 GET 方法基本相同，但是 POST  方法不是把信息作为 URL 中 ?  字符后的文本字符串进行发送，而是把这些信息作为一个单独的消息。消息以标准输出的形式传到后台程序，您可以解析和使用这些标准输出。Servlet  使用 doPost() 方法处理这种类型的请求。</p>
<h4 id="使用-Servlet-读取表单数据"><a href="#使用-Servlet-读取表单数据" class="headerlink" title="使用 Servlet 读取表单数据"></a>使用 Servlet 读取表单数据</h4><p>Servlet 处理表单数据，这些数据会根据不同的情况使用不同的方法自动解析：</p>
<ul>
<li><strong>getParameter()：</strong>您可以调用 request.getParameter() 方法来获取表单参数的值。</li>
<li><strong>getParameterValues()：</strong>如果参数出现一次以上，则调用该方法，并返回多个值，例如复选框。</li>
<li><strong>getParameterNames()：</strong>如果您想要得到当前请求中的所有参数的完整列表，则调用该方法。</li>
</ul>
<h4 id="使用-URL-的-GET-方法实例"><a href="#使用-URL-的-GET-方法实例" class="headerlink" title="使用 URL 的 GET 方法实例"></a>使用 URL 的 GET 方法实例</h4><p>下面是一个简单的 URL，将使用 GET 方法向 HelloForm 程序传递两个值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/javaweb/HelloForm?name=%E5%B9%B3%E5%BF%83&amp;url=www.hanyunpeng0521.github.io</span><br></pre></td></tr></table></figure>

<p>下面是处理 Web 浏览器输入的 <strong>HelloForm.java</strong> Servlet 程序。我们将使用 <strong>getParameter()</strong>  方法，可以很容易地访问传递的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class HelloForm extends HttpServlet &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#HttpServlet()</span><br><span class="line">     */</span><br><span class="line">    public HelloForm() &#123;</span><br><span class="line">        super();</span><br><span class="line">        // TODO Auto-generated constructor stub</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">     */</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = &quot;使用 GET 方法读取表单数据&quot;;</span><br><span class="line">        // 处理中文</span><br><span class="line">        String name =new String(request.getParameter(&quot;name&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;UTF-8&quot;);</span><br><span class="line">        String docType = &quot;&lt;!DOCTYPE html&gt; \n&quot;;</span><br><span class="line">        out.println(docType +</span><br><span class="line">                &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;ul&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;li&gt;&lt;b&gt;站点名&lt;/b&gt;：&quot;</span><br><span class="line">                + name + &quot;\n&quot; +</span><br><span class="line">                &quot;  &lt;li&gt;&lt;b&gt;网址&lt;/b&gt;：&quot;</span><br><span class="line">                + request.getParameter(&quot;url&quot;) + &quot;\n&quot; +</span><br><span class="line">                &quot;&lt;/ul&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理 POST 方法请求的方法</span><br><span class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们在 <strong>web.xml</strong> 文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloForm&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.hyp.learn.javaweb.HelloForm&lt;/servlet-class&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloForm&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/HelloForm&lt;/url-pattern&gt;</span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用表单的-GET-方法实例"><a href="#使用表单的-GET-方法实例" class="headerlink" title="使用表单的 GET 方法实例"></a>使用表单的 GET 方法实例</h4><p>下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 Servlet HelloForm 来处理输入。</p>
<p>保存这个 HTML 到 hello.html 文件中，位于webapp下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Hello From&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;HelloForm&quot; method=&quot;GET&quot;&gt;</span><br><span class="line">    网址名：&lt;label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;</span><br><span class="line">&lt;/label&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    网址：&lt;label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;url&quot;/&gt;</span><br><span class="line">&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>运行，访问如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/javaweb/hello.html</span><br></pre></td></tr></table></figure>

<p>输入数据，提交后就会跳转到上面的页面。查看页面URL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/javaweb/HelloForm?name=%E5%B9%B3%E5%BF%83&amp;url=www.hanyunpeng0521.github.io</span><br></pre></td></tr></table></figure>

<h4 id="使用表单的-POST-方法实例"><a href="#使用表单的-POST-方法实例" class="headerlink" title="使用表单的 POST 方法实例"></a>使用表单的 POST 方法实例</h4><p>让我们对上面的 Servlet 做小小的修改，以便它可以处理 GET 和 POST 方法。下面的 <strong>HelloForm.java</strong> Servlet 程序使用 GET 和 POST 方法处理由 Web 浏览器给出的输入。</p>
<p>注意：如果表单提交的数据中有中文数据则需要转码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name =new String(request.getParameter(&quot;name&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>

<p>更改上面得HelloFrom.java，修改doPost方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = &quot;使用 POST 方法读取表单数据&quot;;</span><br><span class="line">        // 处理中文</span><br><span class="line">        String name =new String(request.getParameter(&quot;name&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;UTF-8&quot;);</span><br><span class="line">        String docType = &quot;&lt;!DOCTYPE html&gt; \n&quot;;</span><br><span class="line">        out.println(docType +</span><br><span class="line">            &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;ul&gt;\n&quot; +</span><br><span class="line">            &quot;  &lt;li&gt;&lt;b&gt;站点名&lt;/b&gt;：&quot;</span><br><span class="line">            + name + &quot;\n&quot; +</span><br><span class="line">            &quot;  &lt;li&gt;&lt;b&gt;网址&lt;/b&gt;：&quot;</span><br><span class="line">            + request.getParameter(&quot;url&quot;) + &quot;\n&quot; +</span><br><span class="line">            &quot;&lt;/ul&gt;\n&quot; +</span><br><span class="line">            &quot;&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>现在，编译部署上述的 Servlet，并使用带有 POST 方法的 hello.html 进行测试，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Hello From&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;HelloForm&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    网址名：&lt;label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;</span><br><span class="line">&lt;/label&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    网址：&lt;label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;url&quot;/&gt;</span><br><span class="line">&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>运行后，访问以下链接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/javaweb/hello.html</span><br></pre></td></tr></table></figure>

<p>填入数据后，提交，查看URL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/javaweb/HelloForm</span><br></pre></td></tr></table></figure>

<h4 id="将复选框数据传递到-Servlet-程序"><a href="#将复选框数据传递到-Servlet-程序" class="headerlink" title="将复选框数据传递到 Servlet 程序"></a>将复选框数据传递到 Servlet 程序</h4><p>当需要选择一个以上的选项时，则使用复选框。</p>
<p>下面是一个 HTML 代码实例 checkbox.html，一个带有两个复选框的表单。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;check box&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;CheckBox&quot; method=&quot;POST&quot; target=&quot;_blank&quot;&gt;</span><br><span class="line">    &lt;label&gt;</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;runoob&quot; checked=&quot;checked&quot; /&gt;</span><br><span class="line">    &lt;/label&gt; 平心</span><br><span class="line">    &lt;label&gt;</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;google&quot;  /&gt;</span><br><span class="line">    &lt;/label&gt; Google</span><br><span class="line">    &lt;label&gt;</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;taobao&quot; checked=&quot;checked&quot; /&gt;</span><br><span class="line">    &lt;/label&gt; 淘宝</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;选择站点&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>新建CheckBox.java文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CheckBox extends HttpServlet &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = &quot;读取复选框数据&quot;;</span><br><span class="line">        String docType = &quot;&lt;!DOCTYPE html&gt; \n&quot;;</span><br><span class="line">        out.println(docType +</span><br><span class="line">                &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;ul&gt;\n&quot; +</span><br><span class="line">                &quot;  &lt;li&gt;&lt;b&gt;平心标识：&lt;/b&gt;: &quot;</span><br><span class="line">                + request.getParameter(&quot;runoob&quot;) + &quot;\n&quot; +</span><br><span class="line">                &quot;  &lt;li&gt;&lt;b&gt;Google 标识：&lt;/b&gt;: &quot;</span><br><span class="line">                + request.getParameter(&quot;google&quot;) + &quot;\n&quot; +</span><br><span class="line">                &quot;  &lt;li&gt;&lt;b&gt;淘宝标识：&lt;/b&gt;: &quot;</span><br><span class="line">                + request.getParameter(&quot;taobao&quot;) + &quot;\n&quot; +</span><br><span class="line">                &quot;&lt;/ul&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理 POST 方法请求的方法</span><br><span class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改web.xml：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;CheckBox&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.hyp.learn.javaweb.CheckBox&lt;/servlet-class&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;CheckBox&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/CheckBox&lt;/url-pattern&gt;</span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>运行后，访问以下链接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/javaweb/checkbox.html</span><br></pre></td></tr></table></figure>

<h4 id="读取所有的表单参数"><a href="#读取所有的表单参数" class="headerlink" title="读取所有的表单参数"></a>读取所有的表单参数</h4><p>以下是通用的实例，使用 HttpServletRequest 的 <strong>getParameterNames()</strong> 方法读取所有可用的表单参数。该方法返回一个枚举，其中包含未指定顺序的参数名。</p>
<p>一旦我们有一个枚举，我们可以以标准方式循环枚举，使用 <em>hasMoreElements()</em> 方法来确定何时停止，使用 <em>nextElement()</em> 方法来获取每个参数的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class ReadParams extends HttpServlet &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#HttpServlet()</span><br><span class="line">     */</span><br><span class="line">    public ReadParams() &#123;</span><br><span class="line">        super();</span><br><span class="line">        // TODO Auto-generated constructor stub</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">     */</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = &quot;读取所有的表单数据&quot;;</span><br><span class="line">        String docType =</span><br><span class="line">                &quot;&lt;!doctype html public \&quot;-//w3c//dtd html 4.0 &quot; +</span><br><span class="line">                        &quot;transitional//en\&quot;&gt;\n&quot;;</span><br><span class="line">        out.println(docType +</span><br><span class="line">                &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;head&gt;&lt;meta charset=\&quot;utf-8\&quot;&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;table width=\&quot;100%\&quot; border=\&quot;1\&quot; align=\&quot;center\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;tr bgcolor=\&quot;#949494\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;th&gt;参数名称&lt;/th&gt;&lt;th&gt;参数值&lt;/th&gt;\n&quot;+</span><br><span class="line">                &quot;&lt;/tr&gt;\n&quot;);</span><br><span class="line"></span><br><span class="line">        Enumeration paramNames = request.getParameterNames();</span><br><span class="line"></span><br><span class="line">        while(paramNames.hasMoreElements()) &#123;</span><br><span class="line">            String paramName = (String)paramNames.nextElement();</span><br><span class="line">            out.print(&quot;&lt;tr&gt;&lt;td&gt;&quot; + paramName + &quot;&lt;/td&gt;\n&quot;);</span><br><span class="line">            String[] paramValues =</span><br><span class="line">                    request.getParameterValues(paramName);</span><br><span class="line">            // 读取单个值的数据</span><br><span class="line">            if (paramValues.length == 1) &#123;</span><br><span class="line">                String paramValue = paramValues[0];</span><br><span class="line">                if (paramValue.length() == 0)</span><br><span class="line">                    out.println(&quot;&lt;td&gt;&lt;i&gt;没有值&lt;/i&gt;&lt;/td&gt;&quot;);</span><br><span class="line">                else</span><br><span class="line">                    out.println(&quot;&lt;td&gt;&quot; + paramValue + &quot;&lt;/td&gt;&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 读取多个值的数据</span><br><span class="line">                out.println(&quot;&lt;td&gt;&lt;ul&gt;&quot;);</span><br><span class="line">                for(int i=0; i &lt; paramValues.length; i++) &#123;</span><br><span class="line">                    out.println(&quot;&lt;li&gt;&quot; + paramValues[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                out.println(&quot;&lt;/ul&gt;&lt;/td&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            out.print(&quot;&lt;/tr&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        out.println(&quot;\n&lt;/table&gt;\n&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">     */</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在，通过下面的表单尝试上面的 Servlet：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;test Form&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=&quot;ReadParams&quot; method=&quot;POST&quot; target=&quot;_blank&quot;&gt;</span><br><span class="line">    &lt;label&gt;</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;maths&quot; checked=&quot;checked&quot; /&gt;</span><br><span class="line">    &lt;/label&gt; 数学</span><br><span class="line">    &lt;label&gt;</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;physics&quot;  /&gt;</span><br><span class="line">    &lt;/label&gt; 物理</span><br><span class="line">    &lt;label&gt;</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;chemistry&quot; checked=&quot;checked&quot; /&gt;</span><br><span class="line">    &lt;/label&gt; 化学</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;选择学科&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>web.xml中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;ReadParams&lt;/servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;com.hyp.learn.javaweb.ReadParams&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;ReadParams&lt;/servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/ReadParams&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>您可以尝试使用上面的 Servlet 来读取其他的表单数据，比如文本框、单选按钮或下拉框等。</p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h4><p>HTTP报文是HTTP应用程序之间传输的数据块，HTTP报文分为HTTP请求报文和HTTP响应报文，但是无论哪种报文，他的整体格式是类似的，大致都是由起始、首部、主体三部分组成，起始说明报文的动作，首部说明报文的属性，主体则是报文的数据。接下来具体说明。</p>
<p><strong>HTTP请求报文</strong></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/27/5d14ba61393f087976.png"></p>
<p>请求报文的起始由请求行构成（有些资料称为状态行，名字不一样而已，都是指的一个东西），用来说明该请求想要做什么，由<code>&lt;Method&gt;、&lt;URL&gt;、&lt;Version&gt;</code> 三个字段组成，注意每个字段之间都有一个空格。</p>
<p>其中&lt;Method&gt;字段有不同的值：</p>
<ul>
<li><p>GET   — 访问服务器的资源</p>
</li>
<li><p>POST  — 向服务器发送要修改的数据</p>
</li>
<li><p>HEAD  — 获取服务器文档的首部</p>
</li>
<li><p>PUT   — 向服务器上传资源</p>
</li>
<li><p>DELETE— 删除服务器的资源</p>
</li>
</ul>
<p> &lt;URL&gt;字段表示服务器的资源目录定位</p>
<p>&lt;Version&gt;字段表示使用的http协议版本</p>
<p>首部部分由多个请求头（也叫首部行）构成，那些首部字段名有如下，不全：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Accept     指定客户端能够接收的内容格式类型</span><br><span class="line">Accept-Language 指定客户端能够接受的语言类型</span><br><span class="line">Accept-Ecoding  指定客户端能够接受的编码类型</span><br><span class="line">User-Agent      用户代理，向服务器说明自己的操作系统、浏览器等信息</span><br><span class="line">Connection      是否开启持久连接（keepalive）</span><br><span class="line">Host            服务器域名</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>主体部分就是报文的具体数据</p>
<p><strong>HTTP响应报文</strong></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/27/5d14bb0c2c08d43836.png"></p>
<p>响应报文的起始由状态行构成，用来说明服务器做了什么，由<code>&lt;Version&gt;、&lt;Status-Code&gt;、&lt;Phrase&gt;</code>三个字段组成，同样的每个字段之间留有空格；</p>
<p>&lt;Status-Code&gt; 上边已经说明； </p>
<p>首部由多个响应头(也叫首部行)组成， 首部字段名如下，不全：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Server    服务器软件名，Apache/Nginx</span><br><span class="line"></span><br><span class="line">Date      服务器发出响应报文的时间</span><br><span class="line"></span><br><span class="line">Last-Modified   请求资源的最后的修改时间</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>主体部分是响应报文的具体数据。</p>
<p>小tips：关于更多请求头和响应头（即首部字段名）的说明请参考<a target="_blank" rel="noopener" href="http://tools.jb51.net/table/http_header">http://tools.jb51.net/table/http_header</a></p>
<h4 id="Servlet-客户端-HTTP-请求"><a href="#Servlet-客户端-HTTP-请求" class="headerlink" title="Servlet 客户端 HTTP 请求"></a>Servlet 客户端 HTTP 请求</h4><p>当浏览器请求网页时，它会向 Web 服务器发送特定信息，这些信息不能被直接读取，因为这些信息是作为 HTTP 请求的头的一部分进行传输的。您可以查看 <a target="_blank" rel="noopener" href="https://www.runoob.com/http/http-tutorial.html">HTTP 协议</a> 了解更多相关信息。</p>
<p>以下是来自于浏览器端的重要头信息，您可以在 Web 编程中频繁使用</p>
<table>
<thead>
<tr>
<th>头信息</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>这个头信息指定浏览器或其他客户端可以处理的 MIME 类型。值 <strong>image/png</strong> 或 <strong>image/jpeg</strong> 是最常见的两种可能值。</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>这个头信息指定浏览器可以用来显示信息的字符集。例如 ISO-8859-1。</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>这个头信息指定浏览器知道如何处理的编码类型。值 <strong>gzip</strong> 或 <strong>compress</strong> 是最常见的两种可能值。</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>这个头信息指定客户端的首选语言，在这种情况下，Servlet 会产生多种语言的结果。例如，en、en-us、ru 等。</td>
</tr>
<tr>
<td>Authorization</td>
<td>这个头信息用于客户端在访问受密码保护的网页时识别自己的身份。</td>
</tr>
<tr>
<td>Connection</td>
<td>这个头信息指示客户端是否可以处理持久 HTTP 连接。持久连接允许客户端或其他浏览器通过单个请求来检索多个文件。值 <strong>Keep-Alive</strong> 意味着使用了持续连接。</td>
</tr>
<tr>
<td>Content-Length</td>
<td>这个头信息只适用于 POST 请求，并给出 POST 数据的大小（以字节为单位）。</td>
</tr>
<tr>
<td>Cookie</td>
<td>这个头信息把之前发送到浏览器的 cookies 返回到服务器。</td>
</tr>
<tr>
<td>Host</td>
<td>这个头信息指定原始的 URL 中的主机和端口。</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>这个头信息表示只有当页面在指定的日期后已更改时，客户端想要的页面。如果没有新的结果可以使用，服务器会发送一个 304 代码，表示 <strong>Not Modified</strong> 头信息。</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>这个头信息是 If-Modified-Since 的对立面，它指定只有当文档早于指定日期时，操作才会成功。</td>
</tr>
<tr>
<td>Referer</td>
<td>这个头信息指示所指向的 Web 页的 URL。例如，如果您在网页 1，点击一个链接到网页 2，当浏览器请求网页 2 时，网页 1 的 URL 就会包含在 Referer 头信息中。</td>
</tr>
<tr>
<td>User-Agent</td>
<td>这个头信息识别发出请求的浏览器或其他客户端，并可以向不同类型的浏览器返回不同的内容。</td>
</tr>
</tbody></table>
<h5 id="读取-HTTP-头的方法"><a href="#读取-HTTP-头的方法" class="headerlink" title="读取 HTTP 头的方法"></a>读取 HTTP 头的方法</h5><p>下面的方法可用在 Servlet 程序中读取 HTTP 头。这些方法通过 <em>HttpServletRequest</em> 对象可用。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>Cookie[] getCookies()</strong> 返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。</td>
</tr>
<tr>
<td>2</td>
<td><strong>Enumeration getAttributeNames()</strong> 返回一个枚举，包含提供给该请求可用的属性名称。</td>
</tr>
<tr>
<td>3</td>
<td><strong>Enumeration getHeaderNames()</strong> 返回一个枚举，包含在该请求中包含的所有的头名。</td>
</tr>
<tr>
<td>4</td>
<td><strong>Enumeration getParameterNames()</strong> 返回一个 String 对象的枚举，包含在该请求中包含的参数的名称。</td>
</tr>
<tr>
<td>5</td>
<td><strong>HttpSession getSession()</strong> 返回与该请求关联的当前 session 会话，或者如果请求没有 session 会话，则创建一个。</td>
</tr>
<tr>
<td>6</td>
<td><strong>HttpSession getSession(boolean create)</strong> 返回与该请求关联的当前 HttpSession，或者如果没有当前会话，且创建是真的，则返回一个新的 session 会话。</td>
</tr>
<tr>
<td>7</td>
<td><strong>Locale getLocale()</strong> 基于 Accept-Language 头，返回客户端接受内容的首选的区域设置。</td>
</tr>
<tr>
<td>8</td>
<td><strong>Object getAttribute(String name)</strong> 以对象形式返回已命名属性的值，如果没有给定名称的属性存在，则返回 null。</td>
</tr>
<tr>
<td>9</td>
<td><strong>ServletInputStream getInputStream()</strong> 使用 ServletInputStream，以二进制数据形式检索请求的主体。</td>
</tr>
<tr>
<td>10</td>
<td><strong>String getAuthType()</strong> 返回用于保护 Servlet 的身份验证方案的名称，例如，”BASIC” 或 “SSL”，如果JSP没有受到保护则返回 null。</td>
</tr>
<tr>
<td>11</td>
<td><strong>String getCharacterEncoding()</strong> 返回请求主体中使用的字符编码的名称。</td>
</tr>
<tr>
<td>12</td>
<td><strong>String getContentType()</strong> 返回请求主体的 MIME 类型，如果不知道类型则返回 null。</td>
</tr>
<tr>
<td>13</td>
<td><strong>String getContextPath()</strong> 返回指示请求上下文的请求 URI 部分。</td>
</tr>
<tr>
<td>14</td>
<td><strong>String getHeader(String name)</strong> 以字符串形式返回指定的请求头的值。</td>
</tr>
<tr>
<td>15</td>
<td><strong>String getMethod()</strong> 返回请求的 HTTP 方法的名称，例如，GET、POST 或 PUT。</td>
</tr>
<tr>
<td>16</td>
<td><strong>String getParameter(String name)</strong> 以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。</td>
</tr>
<tr>
<td>17</td>
<td><strong>String getPathInfo()</strong> 当请求发出时，返回与客户端发送的 URL 相关的任何额外的路径信息。</td>
</tr>
<tr>
<td>18</td>
<td><strong>String getProtocol()</strong> 返回请求协议的名称和版本。</td>
</tr>
<tr>
<td>19</td>
<td><strong>String getQueryString()</strong> 返回包含在路径后的请求 URL 中的查询字符串。</td>
</tr>
<tr>
<td>20</td>
<td><strong>String getRemoteAddr()</strong> 返回发送请求的客户端的互联网协议（IP）地址。</td>
</tr>
<tr>
<td>21</td>
<td><strong>String getRemoteHost()</strong> 返回发送请求的客户端的完全限定名称。</td>
</tr>
<tr>
<td>22</td>
<td><strong>String getRemoteUser()</strong> 如果用户已通过身份验证，则返回发出请求的登录用户，或者如果用户未通过身份验证，则返回 null。</td>
</tr>
<tr>
<td>23</td>
<td><strong>String getRequestURI()</strong> 从协议名称直到 HTTP 请求的第一行的查询字符串中，返回该请求的 URL 的一部分。</td>
</tr>
<tr>
<td>24</td>
<td><strong>String getRequestedSessionId()</strong> 返回由客户端指定的 session 会话 ID。</td>
</tr>
<tr>
<td>25</td>
<td><strong>String getServletPath()</strong> 返回调用 JSP 的请求的 URL 的一部分。</td>
</tr>
<tr>
<td>26</td>
<td><strong>String[] getParameterValues(String name)</strong> 返回一个字符串对象的数组，包含所有给定的请求参数的值，如果参数不存在则返回 null。</td>
</tr>
<tr>
<td>27</td>
<td><strong>boolean isSecure()</strong> 返回一个布尔值，指示请求是否使用安全通道，如 HTTPS。</td>
</tr>
<tr>
<td>28</td>
<td><strong>int getContentLength()</strong> 以字节为单位返回请求主体的长度，并提供输入流，或者如果长度未知则返回 -1。</td>
</tr>
<tr>
<td>29</td>
<td><strong>int getIntHeader(String name)</strong> 返回指定的请求头的值为一个 int 值。</td>
</tr>
<tr>
<td>30</td>
<td><strong>int getServerPort()</strong> 返回接收到这个请求的端口号。</td>
</tr>
<tr>
<td>31</td>
<td><strong>int getParameterMap()</strong> 将参数封装成 Map 类型。</td>
</tr>
</tbody></table>
<h5 id="HTTP-Header-请求实例"><a href="#HTTP-Header-请求实例" class="headerlink" title="HTTP Header 请求实例"></a>HTTP Header 请求实例</h5><p>下面的实例使用 HttpServletRequest 的 <strong>getHeaderNames()</strong> 方法读取 HTTP 头信息。该方法返回一个枚举，包含与当前的 HTTP 请求相关的头信息。</p>
<p>一旦我们有一个枚举，我们可以以标准方式循环枚举，使用 <em>hasMoreElements()</em> 方法来确定何时停止，使用 <em>nextElement()</em> 方法来获取每个参数的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class DisplayHeader extends HttpServlet &#123;</span><br><span class="line">    // 处理 GET 方法请求的方法</span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = &quot;HTTP Header 请求实例&quot;;</span><br><span class="line">        String docType =</span><br><span class="line">                &quot;&lt;!DOCTYPE html&gt; \n&quot;;</span><br><span class="line">        out.println(docType +</span><br><span class="line">                &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;head&gt;&lt;meta charset=\&quot;utf-8\&quot;&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot;+</span><br><span class="line">                &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;table width=\&quot;100%\&quot; border=\&quot;1\&quot; align=\&quot;center\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;tr bgcolor=\&quot;#949494\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;th&gt;Header 名称&lt;/th&gt;&lt;th&gt;Header 值&lt;/th&gt;\n&quot;+</span><br><span class="line">                &quot;&lt;/tr&gt;\n&quot;);</span><br><span class="line"></span><br><span class="line">        Enumeration headerNames = request.getHeaderNames();</span><br><span class="line"></span><br><span class="line">        while(headerNames.hasMoreElements()) &#123;</span><br><span class="line">            String paramName = (String)headerNames.nextElement();</span><br><span class="line">            out.print(&quot;&lt;tr&gt;&lt;td&gt;&quot; + paramName + &quot;&lt;/td&gt;\n&quot;);</span><br><span class="line">            String paramValue = request.getHeader(paramName);</span><br><span class="line">            out.println(&quot;&lt;td&gt; &quot; + paramValue + &quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        out.println(&quot;&lt;/table&gt;\n&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理 POST 方法请求的方法</span><br><span class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上测试实例是位于 javaweb 项目下，对应的 web.xml 配置添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;DisplayHeader&lt;/servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;com.hyp.learn.javaweb.DisplayHeader&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;DisplayHeader&lt;/servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/DisplayHeader&lt;/url-pattern&gt;</span><br></pre></td></tr></table></figure>

<p>访问URL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/javaweb/DisplayHeader</span><br></pre></td></tr></table></figure>

<h4 id="Servlet-服务器-HTTP-响应"><a href="#Servlet-服务器-HTTP-响应" class="headerlink" title="Servlet 服务器 HTTP 响应"></a>Servlet 服务器 HTTP 响应</h4><p>正如前面的章节中讨论的那样，当一个 Web 服务器响应一个 HTTP 请求时，响应通常包括一个状态行、一些响应报头、一个空行和文档。一个典型的响应如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Header2: ...</span><br><span class="line">...</span><br><span class="line">HeaderN: ...</span><br><span class="line">  (Blank Line)</span><br><span class="line">&lt;!doctype ...&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;...&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>状态行包括 HTTP 版本（在本例中为 HTTP/1.1）、一个状态码（在本例中为 200）和一个对应于状态码的短消息（在本例中为 OK）。</p>
<p>下表总结了从 Web 服务器端返回到浏览器的最有用的 HTTP 1.1 响应报头，您会在 Web 编程中频繁地使用它们</p>
<table>
<thead>
<tr>
<th>头信息</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>这个头信息指定服务器支持的请求方法（GET、POST 等）。</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>这个头信息指定响应文档在何种情况下可以安全地缓存。可能的值有：<strong>public、private</strong> 或 <strong>no-cache</strong> 等。Public 意味着文档是可缓存，Private 意味着文档是单个用户私用文档，且只能存储在私有（非共享）缓存中，no-cache 意味着文档不应被缓存。</td>
</tr>
<tr>
<td>Connection</td>
<td>这个头信息指示浏览器是否使用持久 HTTP 连接。值 <strong>close</strong> 指示浏览器不使用持久 HTTP 连接，值 <strong>keep-alive</strong> 意味着使用持久连接。</td>
</tr>
<tr>
<td>Content-Disposition</td>
<td>这个头信息可以让您请求浏览器要求用户以给定名称的文件把响应保存到磁盘。</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>在传输过程中，这个头信息指定页面的编码方式。</td>
</tr>
<tr>
<td>Content-Language</td>
<td>这个头信息表示文档编写所使用的语言。例如，en、en-us、ru 等。</td>
</tr>
<tr>
<td>Content-Length</td>
<td>这个头信息指示响应中的字节数。只有当浏览器使用持久（keep-alive）HTTP 连接时才需要这些信息。</td>
</tr>
<tr>
<td>Content-Type</td>
<td>这个头信息提供了响应文档的 MIME（Multipurpose Internet Mail Extension）类型。</td>
</tr>
<tr>
<td>Expires</td>
<td>这个头信息指定内容过期的时间，在这之后内容不再被缓存。</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>这个头信息指示文档的最后修改时间。然后，客户端可以缓存文件，并在以后的请求中通过 <strong>If-Modified-Since</strong> 请求头信息提供一个日期。</td>
</tr>
<tr>
<td>Location</td>
<td>这个头信息应被包含在所有的带有状态码的响应中。在 300s 内，这会通知浏览器文档的地址。浏览器会自动重新连接到这个位置，并获取新的文档。</td>
</tr>
<tr>
<td>Refresh</td>
<td>这个头信息指定浏览器应该如何尽快请求更新的页面。您可以指定页面刷新的秒数。</td>
</tr>
<tr>
<td>Retry-After</td>
<td>这个头信息可以与 503（Service Unavailable 服务不可用）响应配合使用，这会告诉客户端多久就可以重复它的请求。</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>这个头信息指定一个与页面关联的 cookie。</td>
</tr>
</tbody></table>
<h5 id="设置-HTTP-响应报头的方法"><a href="#设置-HTTP-响应报头的方法" class="headerlink" title="设置 HTTP 响应报头的方法"></a>设置 HTTP 响应报头的方法</h5><p>下面的方法可用于在 Servlet 程序中设置 HTTP 响应报头。这些方法通过 <em>HttpServletResponse</em> 对象可用。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>String encodeRedirectURL(String url)</strong> 为 sendRedirect 方法中使用的指定的 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。</td>
</tr>
<tr>
<td>2</td>
<td><strong>String encodeURL(String url)</strong> 对包含 session 会话 ID 的指定 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。</td>
</tr>
<tr>
<td>3</td>
<td><strong>boolean containsHeader(String name)</strong> 返回一个布尔值，指示是否已经设置已命名的响应报头。</td>
</tr>
<tr>
<td>4</td>
<td><strong>boolean isCommitted()</strong> 返回一个布尔值，指示响应是否已经提交。</td>
</tr>
<tr>
<td>5</td>
<td><strong>void addCookie(Cookie cookie)</strong> 把指定的 cookie 添加到响应。</td>
</tr>
<tr>
<td>6</td>
<td><strong>void addDateHeader(String name, long date)</strong> 添加一个带有给定的名称和日期值的响应报头。</td>
</tr>
<tr>
<td>7</td>
<td><strong>void addHeader(String name, String value)</strong> 添加一个带有给定的名称和值的响应报头。</td>
</tr>
<tr>
<td>8</td>
<td><strong>void addIntHeader(String name, int value)</strong> 添加一个带有给定的名称和整数值的响应报头。</td>
</tr>
<tr>
<td>9</td>
<td><strong>void flushBuffer()</strong> 强制任何在缓冲区中的内容被写入到客户端。</td>
</tr>
<tr>
<td>10</td>
<td><strong>void reset()</strong> 清除缓冲区中存在的任何数据，包括状态码和头。</td>
</tr>
<tr>
<td>11</td>
<td><strong>void resetBuffer()</strong> 清除响应中基础缓冲区的内容，不清除状态码和头。</td>
</tr>
<tr>
<td>12</td>
<td><strong>void sendError(int sc)</strong> 使用指定的状态码发送错误响应到客户端，并清除缓冲区。</td>
</tr>
<tr>
<td>13</td>
<td><strong>void sendError(int sc, String msg)</strong> 使用指定的状态发送错误响应到客户端。</td>
</tr>
<tr>
<td>14</td>
<td><strong>void sendRedirect(String location)</strong> 使用指定的重定向位置 URL 发送临时重定向响应到客户端。</td>
</tr>
<tr>
<td>15</td>
<td><strong>void setBufferSize(int size)</strong> 为响应主体设置首选的缓冲区大小。</td>
</tr>
<tr>
<td>16</td>
<td><strong>void setCharacterEncoding(String charset)</strong> 设置被发送到客户端的响应的字符编码（MIME 字符集）例如，UTF-8。</td>
</tr>
<tr>
<td>17</td>
<td><strong>void setContentLength(int len)</strong> 设置在 HTTP Servlet 响应中的内容主体的长度，该方法设置 HTTP Content-Length 头。</td>
</tr>
<tr>
<td>18</td>
<td><strong>void setContentType(String type)</strong> 如果响应还未被提交，设置被发送到客户端的响应的内容类型。</td>
</tr>
<tr>
<td>19</td>
<td><strong>void setDateHeader(String name, long date)</strong> 设置一个带有给定的名称和日期值的响应报头。</td>
</tr>
<tr>
<td>20</td>
<td><strong>void setHeader(String name, String value)</strong> 设置一个带有给定的名称和值的响应报头。</td>
</tr>
<tr>
<td>21</td>
<td><strong>void setIntHeader(String name, int value)</strong> 设置一个带有给定的名称和整数值的响应报头。</td>
</tr>
<tr>
<td>22</td>
<td><strong>void setLocale(Locale loc)</strong> 如果响应还未被提交，设置响应的区域。</td>
</tr>
<tr>
<td>23</td>
<td><strong>void setStatus(int sc)</strong> 为该响应设置状态码。</td>
</tr>
</tbody></table>
<h5 id="HTTP-Header-响应实例"><a href="#HTTP-Header-响应实例" class="headerlink" title="HTTP Header 响应实例"></a>HTTP Header 响应实例</h5><p>您已经在前面的实例中看到 setContentType() 方法，下面的实例也使用了同样的方法，此外，我们会用 <strong>setIntHeader()</strong> 方法来设置 <strong>Refresh</strong> 头。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Refresh extends HttpServlet &#123;</span><br><span class="line">    // 处理 GET 方法请求的方法</span><br><span class="line">    public void doGet(HttpServletRequest request,</span><br><span class="line">                      HttpServletResponse response)</span><br><span class="line">            throws ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        // 设置刷新自动加载时间为 3 秒</span><br><span class="line">        response.setIntHeader(&quot;Refresh&quot;, 3);</span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">        response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">        //使用默认时区和语言环境获得一个日历  </span><br><span class="line">        Calendar cale = Calendar.getInstance();</span><br><span class="line">        //将Calendar类型转换成Date类型  </span><br><span class="line">        Date tasktime=cale.getTime();</span><br><span class="line">        //设置日期输出的格式  </span><br><span class="line">        SimpleDateFormat df=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        //格式化输出  </span><br><span class="line">        String nowTime = df.format(tasktime);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = &quot;自动刷新 Header 设置&quot;;</span><br><span class="line">        String docType =</span><br><span class="line">                &quot;&lt;!DOCTYPE html&gt;\n&quot;;</span><br><span class="line">        out.println(docType +</span><br><span class="line">                &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot;+</span><br><span class="line">                &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;p&gt;当前时间是：&quot; + nowTime + &quot;&lt;/p&gt;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理 POST 方法请求的方法</span><br><span class="line">    public void doPost(HttpServletRequest request,</span><br><span class="line">                       HttpServletResponse response)</span><br><span class="line">            throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上测试实例是位于 javaweb 项目下，对应的 web.xml 配置添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;Refresh&lt;/servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;com.hyp.learn.javaweb.Refresh&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;Refresh&lt;/servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/Refresh&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>访问URL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/javaweb/Refresh</span><br></pre></td></tr></table></figure>

<h4 id="Servlet-HTTP-状态码"><a href="#Servlet-HTTP-状态码" class="headerlink" title="Servlet HTTP 状态码"></a>Servlet HTTP 状态码</h4><p>HTTP 请求和 HTTP 响应消息的格式是类似的，结构如下：</p>
<ul>
<li>初始状态行 + 回车换行符（回车+换行）</li>
<li>零个或多个标题行+回车换行符</li>
<li>一个空白行，即回车换行符</li>
<li>一个可选的消息主体，比如文件、查询数据或查询输出</li>
</ul>
<p>例如，服务器的响应头如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Header2: ...</span><br><span class="line">...</span><br><span class="line">HeaderN: ...</span><br><span class="line">  (Blank Line)</span><br><span class="line">&lt;!doctype ...&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;...&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>状态行包括 HTTP 版本（在本例中为 HTTP/1.1）、一个状态码（在本例中为 200）和一个对应于状态码的短消息（在本例中为 OK）。</p>
<p>以下是可能从 Web 服务器返回的 HTTP 状态码和相关的信息列表：</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>消息</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue</td>
<td>只有请求的一部分已经被服务器接收，但只要它没有被拒绝，客户端应继续该请求。</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>服务器切换协议。</td>
</tr>
<tr>
<td>200</td>
<td>OK</td>
<td>请求成功。</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>该请求是完整的，并创建一个新的资源。</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>该请求被接受处理，但是该处理是不完整的。</td>
</tr>
<tr>
<td>203</td>
<td>Non-authoritative Information</td>
<td></td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td></td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td></td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td></td>
</tr>
<tr>
<td>300</td>
<td>Multiple Choices</td>
<td>链接列表。用户可以选择一个链接，进入到该位置。最多五个地址。</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>所请求的页面已经转移到一个新的 URL。</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>所请求的页面已经临时转移到一个新的 URL。</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>所请求的页面可以在另一个不同的 URL 下被找到。</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td></td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td></td>
</tr>
<tr>
<td>306</td>
<td><em>Unused</em></td>
<td>在以前的版本中使用该代码。现在已不再使用它，但代码仍被保留。</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>所请求的页面已经临时转移到一个新的 URL。</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>服务器不理解请求。</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>所请求的页面需要用户名和密码。</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td><em>您还不能使用该代码。</em></td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>禁止访问所请求的页面。</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法找到所请求的页面。.</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>在请求中指定的方法是不允许的。</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>服务器只生成一个不被客户端接受的响应。</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>在请求送达之前，您必须使用代理服务器的验证。</td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout</td>
<td>请求需要的时间比服务器能够等待的时间长，超时。</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>请求因为冲突无法完成。</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>所请求的页面不再可用。</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>“Content-Length” 未定义。服务器无法处理客户端发送的不带 Content-Length 的请求信息。</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>请求中给出的先决条件被服务器评估为 false。</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td>服务器不接受该请求，因为请求实体过大。</td>
</tr>
<tr>
<td>414</td>
<td>Request-url Too Long</td>
<td>服务器不接受该请求，因为 URL 太长。当您转换一个 “post” 请求为一个带有长的查询信息的 “get” 请求时发生。</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器不接受该请求，因为媒体类型不被支持。</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td></td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>未完成的请求。服务器遇到了一个意外的情况。</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>未完成的请求。服务器不支持所需的功能。</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>未完成的请求。服务器从上游服务器收到无效响应。</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>未完成的请求。服务器暂时超载或死机。</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout</td>
<td>网关超时。</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version Not Supported</td>
<td>服务器不支持”HTTP协议”版本。</td>
</tr>
</tbody></table>
<h5 id="设置-HTTP-状态代码的方法"><a href="#设置-HTTP-状态代码的方法" class="headerlink" title="设置 HTTP 状态代码的方法"></a>设置 HTTP 状态代码的方法</h5><p>下面的方法可用于在 Servlet 程序中设置 HTTP 状态码。这些方法通过 <em>HttpServletResponse</em> 对象可用。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>public void setStatus ( int statusCode )</strong> 该方法设置一个任意的状态码。setStatus 方法接受一个 int（状态码）作为参数。如果您的响应包含了一个特殊的状态码和文档，请确保在使用 <em>PrintWriter</em> 实际返回任何内容之前调用 setStatus。</td>
</tr>
<tr>
<td>2</td>
<td><strong>public void sendRedirect(String url)</strong> 该方法生成一个 302 响应，连同一个带有新文档 URL 的 <em>Location</em> 头。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public void sendError(int code, String message)</strong> 该方法发送一个状态码（通常为 404），连同一个在 HTML 文档内部自动格式化并发送到客户端的短消息。</td>
</tr>
</tbody></table>
<h5 id="HTTP-状态码实例"><a href="#HTTP-状态码实例" class="headerlink" title="HTTP 状态码实例"></a>HTTP 状态码实例</h5><p>下面的例子把 407 错误代码发送到客户端浏览器，浏览器会显示 “Need authentication!!!” 消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ShowError extends HttpServlet &#123;</span><br><span class="line">    // 处理 GET 方法请求的方法</span><br><span class="line">    public void doGet(HttpServletRequest request,</span><br><span class="line">                      HttpServletResponse response)</span><br><span class="line">            throws ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        // 设置错误代码和原因</span><br><span class="line">        response.sendError(407, &quot;Need authentication!!!&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理 POST 方法请求的方法</span><br><span class="line">    public void doPost(HttpServletRequest request,</span><br><span class="line">                       HttpServletResponse response)</span><br><span class="line">            throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>web.xml添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">   &lt;servlet-name&gt;ShowError&lt;/servlet-name&gt;</span><br><span class="line">   &lt;servlet-class&gt;com.hyp.learn.javaweb.ShowError&lt;/servlet-class&gt;</span><br><span class="line"> &lt;/servlet&gt;</span><br><span class="line"> &lt;servlet-mapping&gt;</span><br><span class="line">   &lt;servlet-name&gt;ShowError&lt;/servlet-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;/ShowError&lt;/url-pattern&gt;</span><br><span class="line"> &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>现在，调用上面的 Servlet 将显示407.</p>
<h3 id="Servlet-编写过滤器"><a href="#Servlet-编写过滤器" class="headerlink" title="Servlet 编写过滤器"></a>Servlet 编写过滤器</h3><p>Servlet 过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。</p>
<p>可以将一个或多个 Servlet 过滤器附加到一个 Servlet 或一组 Servlet。Servlet 过滤器也可以附加到  JavaServer Pages (JSP) 文件和 HTML 页面。调用 Servlet 前调用所有附加的 Servlet 过滤器。</p>
<p>Servlet 过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的：</p>
<ul>
<li>在客户端的请求访问后端资源之前，拦截这些请求。</li>
<li>在服务器的响应发送回客户端之前，处理这些响应。</li>
</ul>
<p>根据规范建议的各种类型的过滤器：</p>
<ul>
<li>身份验证过滤器（Authentication Filters）。</li>
<li>数据压缩过滤器（Data compression Filters）。</li>
<li>加密过滤器（Encryption Filters）。</li>
<li>触发资源访问事件过滤器。</li>
<li>图像转换过滤器（Image Conversion Filters）。</li>
<li>日志记录和审核过滤器（Logging and Auditing Filters）。</li>
<li>MIME-TYPE 链过滤器（MIME-TYPE Chain Filters）。</li>
<li>标记化过滤器（Tokenizing Filters）。</li>
<li>XSL/T 过滤器（XSL/T Filters），转换 XML 内容。</li>
</ul>
<p>过滤器通过 Web 部署描述符（web.xml）中的 XML 标签来声明，然后映射到您的应用程序的部署描述符中的 Servlet 名称或 URL 模式。</p>
<p>当 Web 容器启动 Web 应用程序时，它会为您在部署描述符中声明的每一个过滤器创建一个实例。</p>
<p>Filter的执行顺序与在web.xml配置文件中的配置顺序一致，一般把Filter配置在所有的Servlet之前。</p>
<h4 id="Servlet-过滤器方法"><a href="#Servlet-过滤器方法" class="headerlink" title="Servlet 过滤器方法"></a>Servlet 过滤器方法</h4><p>过滤器是一个实现了 javax.servlet.Filter 接口的 Java 类。javax.servlet.Filter 接口定义了三个方法：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>public void doFilter (ServletRequest, ServletResponse, FilterChain)</strong> 该方法完成实际的过滤操作，当客户端请求方法与过滤器设置匹配的URL时，Servlet容器将先调用过滤器的doFilter方法。FilterChain用户访问后续过滤器。</td>
</tr>
<tr>
<td>2</td>
<td><strong>public void init(FilterConfig filterConfig)</strong> web  应用程序启动时，web 服务器将创建Filter  的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public void destroy()</strong> Servlet容器在销毁过滤器实例前调用该方法，在该方法中释放Servlet过滤器占用的资源。</td>
</tr>
</tbody></table>
<h4 id="FilterConfig-使用"><a href="#FilterConfig-使用" class="headerlink" title="FilterConfig 使用"></a>FilterConfig 使用</h4><p>Filter 的 init 方法中提供了一个 FilterConfig 对象。</p>
<p>如 web.xml 文件配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;com.runoob.test.LogFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;Site&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;pingxin&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br></pre></td></tr></table></figure>

<p>在 init 方法使用 FilterConfig 对象获取参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void  init(FilterConfig config) throws ServletException &#123;</span><br><span class="line">    // 获取初始化参数</span><br><span class="line">    String site = config.getInitParameter(&quot;Site&quot;); </span><br><span class="line">    // 输出初始化参数</span><br><span class="line">    System.out.println(&quot;网站名称: &quot; + site); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FilterConfig接口</strong></p>
<p>用户在配置filter时，可以使用为filter配置一些初始化参数，当web容器实例化Filter对象，调用其init方法时，会把封装了filter初始化参数的filterConfig对象传递进来。因此开发人员在编写filter时，通过filterConfig对象的方法，就可获得：</p>
<ul>
<li>　　String getFilterName()：得到filter的名称。</li>
<li>　　String getInitParameter(String name)： 返回在部署描述中指定名称的初始化参数的值。如果不存在返回null.</li>
<li>　　Enumeration getInitParameterNames()：返回过滤器的所有初始化参数的名字的枚举集合。</li>
<li>　　public ServletContext getServletContext()：返回Servlet上下文对象的引用。<br>范例：利用FilterConfig得到filter配置信息</li>
</ul>
<h4 id="Servlet-过滤器实例"><a href="#Servlet-过滤器实例" class="headerlink" title="Servlet 过滤器实例"></a>Servlet 过滤器实例</h4><p>以下是 Servlet 过滤器的实例，将输出网站名称和地址。本实例让您对 Servlet 过滤器有基本的了解，您可以使用相同的概念编写更复杂的过滤器应用程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class LogFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">        // 获取初始化参数</span><br><span class="line">        String site = filterConfig.getInitParameter(&quot;Site&quot;);</span><br><span class="line"></span><br><span class="line">        // 输出初始化参数</span><br><span class="line">        System.out.println(&quot;网站名称: &quot; + site);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        // 输出站点名称</span><br><span class="line">        System.out.println(&quot;站点网址：http://hanyunpeng0521.github.io&quot;);</span><br><span class="line"></span><br><span class="line">        // 把请求传回过滤链</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        /* 在 Filter 实例被 Web 容器从服务移除之前调用 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边使用前文提到的 DisplayHeader.java 为例子</p>
<h5 id="Web-xml-中的-Servlet-过滤器映射（Servlet-Filter-Mapping）"><a href="#Web-xml-中的-Servlet-过滤器映射（Servlet-Filter-Mapping）" class="headerlink" title="Web.xml 中的 Servlet 过滤器映射（Servlet Filter Mapping）"></a>Web.xml 中的 Servlet 过滤器映射（Servlet Filter Mapping）</h5><p>定义过滤器，然后映射到一个 URL 或 Servlet，这与定义 Servlet，然后映射到一个 URL 模式方式大致相同。在部署描述符文件 <strong>web.xml</strong> 中为 filter 标签创建下面的条目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;com.hyp.learn.javaweb.LogFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;Site&lt;/param-name&gt;</span><br><span class="line">      &lt;param-value&gt;pingxin&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">  &lt;/filter&gt;</span><br><span class="line">  &lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">  &lt;/filter-mapping&gt;</span><br><span class="line">  &lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;DisplayHeader&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.hyp.learn.javaweb.DisplayHeader&lt;/servlet-class&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;DisplayHeader&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/DisplayHeader&lt;/url-pattern&gt;</span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述过滤器适用于所有的 Servlet，因为我们在配置中指定 <strong>/*</strong> 。如果您只想在少数的 Servlet 上应用过滤器，您可以指定一个特定的 Servlet 路径。</p>
<p>现在试着以常用的方式调用任何 Servlet，您将会看到在 Web 服务器中生成的日志。您也可以使用 Log4J 记录器来把上面的日志记录到一个单独的文件中。</p>
<p>接下来我们访问这个实例地址 <strong><a target="_blank" rel="noopener" href="http://localhost:8080/javaweb/DisplayHeader">http://localhost:8080/javaweb/DisplayHeader</a></strong>, 然后在控制台看下输出内容.</p>
<h4 id="使用多个过滤器"><a href="#使用多个过滤器" class="headerlink" title="使用多个过滤器"></a>使用多个过滤器</h4><p>Web 应用程序可以根据特定的目的定义若干个不同的过滤器。假设您定义了两个过滤器 <em>AuthenFilter</em> 和 <em>LogFilter</em>。您需要创建一个如下所述的不同的映射，其余的处理与上述所讲解的大致相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">   &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;filter-class&gt;com.hyp.learn.javaweb.LogFilter&lt;/filter-class&gt;</span><br><span class="line">   &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;test-param&lt;/param-name&gt;</span><br><span class="line">      &lt;param-value&gt;Initialization Paramter&lt;/param-value&gt;</span><br><span class="line">   &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter&gt;</span><br><span class="line">   &lt;filter-name&gt;AuthenFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;filter-class&gt;com.hyp.learn.javaweb.AuthenFilter&lt;/filter-class&gt;</span><br><span class="line">   &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;test-param&lt;/param-name&gt;</span><br><span class="line">      &lt;param-value&gt;Initialization Paramter&lt;/param-value&gt;</span><br><span class="line">   &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">   &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">   &lt;filter-name&gt;AuthenFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<h4 id="过滤器的应用顺序"><a href="#过滤器的应用顺序" class="headerlink" title="过滤器的应用顺序"></a>过滤器的应用顺序</h4><p>web.xml 中的 filter-mapping 元素的顺序决定了 Web 容器应用过滤器到 Servlet 的顺序。若要反转过滤器的顺序，您只需要在 web.xml 文件中反转 filter-mapping 元素即可。</p>
<p>例如，上面的实例将先应用 LogFilter，然后再应用 AuthenFilter，但是下面的实例将颠倒这个顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">   &lt;filter-name&gt;AuthenFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">   &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>过滤器中我们可以根据 doFilte() 方法中的 request 对象获取表单参数信息，例如我们可以获取到请求的用户名和密码进行逻辑处理，也可以通过 response 对用户做出回应。比如如果验证用户名不正确，禁止用户访问 web 资源，并且向浏览器输出提示，告诉用户用户名或者密码不正确等等；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void doFilter(ServletRequest req, ServletResponse resp,</span><br><span class="line">FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    //获取请求信息(测试时可以通过get方式在URL中添加name)</span><br><span class="line">    //http://localhost:8080/servlet_demo/helloword?name=123</span><br><span class="line">    String name = req.getParameter(&quot;name&quot;);</span><br><span class="line"></span><br><span class="line">    // 过滤器核心代码逻辑</span><br><span class="line">    System.out.println(&quot;过滤器获取请求参数:&quot;+name);</span><br><span class="line">    System.out.println(&quot;第二个过滤器执行--网站名称：www.runoob.com&quot;);</span><br><span class="line"></span><br><span class="line">    if(&quot;123&quot;.equals(name))&#123;</span><br><span class="line">        // 把请求传回过滤链</span><br><span class="line">        chain.doFilter(req, resp);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //设置返回内容类型</span><br><span class="line">        resp.setContentType(&quot;text/html;charset=GBK&quot;);</span><br><span class="line"></span><br><span class="line">        //在页面输出响应信息</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.print(&quot;&lt;b&gt;name不正确，请求被拦截，不能访问web资源&lt;/b&gt;&quot;);</span><br><span class="line">        System.out.println(&quot;name不正确，请求被拦截，不能访问web资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="web-xml配置各节点说明"><a href="#web-xml配置各节点说明" class="headerlink" title="web.xml配置各节点说明"></a>web.xml配置各节点说明</h4><ul>
<li><p><code>&lt;filter&gt;</code></p>
<p>指定一个过滤器。  </p>
<ul>
<li><code>&lt;filter-name&gt;</code>用于为过滤器指定一个名字，该元素的内容不能为空。</li>
<li><code>&lt;filter-class&gt;</code>元素用于指定过滤器的完整的限定类名。</li>
<li><code>&lt;init-param&gt;</code>元素用于为过滤器指定初始化参数，它的子元素<code>&lt;param-name&gt;</code>指定参数的名字，<code>&lt;param-value&gt;</code>指定参数的值。</li>
<li>在过滤器中，可以使用<code>FilterConfig</code>接口对象来访问初始化参数。</li>
</ul>
</li>
<li><p><code>&lt;filter-mapping&gt;</code></p>
<p>元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径  </p>
<ul>
<li><code>&lt;filter-name&gt;</code>子元素用于设置filter的注册名称。该值必须是在<code>&lt;filter&gt;</code>元素中声明过的过滤器的名字</li>
<li><code>&lt;url-pattern&gt;</code>设置 filter 所拦截的请求路径(过滤器关联的URL样式)</li>
</ul>
</li>
<li><p><code>&lt;servlet-name&gt;</code>指定过滤器所拦截的Servlet名称。</p>
</li>
<li><p><code>&lt;dispatcher&gt;</code>指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是<code>REQUEST</code>,<code>INCLUDE</code>,<code>FORWARD</code>和<code>ERROR</code>之一，默认<code>REQUEST</code>。用户可以设置多个<code>&lt;dispatcher&gt;</code>子元素用来指定 Filter 对资源的多种调用方式进行拦截。</p>
</li>
<li><p><code>&lt;dispatcher&gt;</code></p>
<p>子元素可以设置的值及其意义  </p>
<ul>
<li><code>REQUEST</code>：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。</li>
<li><code>INCLUDE</code>：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。</li>
<li><code>FORWARD</code>：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。</li>
<li><code>ERROR</code>：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。</li>
</ul>
</li>
</ul>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol>
<li><p>Http与Https的区别：</p>
<ul>
<li><p>HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头</p>
</li>
<li><p>HTTP 是不安全的，而 HTTPS 是安全的</p>
</li>
<li><p>HTTP 标准端口是80 ，而 HTTPS 的标准端口是443</p>
</li>
<li><p>在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层</p>
</li>
<li><p>HTTP 无法加密，而HTTPS 对传输的数据进行加密</p>
</li>
<li><p>HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书</p>
</li>
</ul>
</li>
<li><p>什么是Http协议无状态协议?怎么解决Http协议无状态协议?</p>
<p>无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息</p>
<p> 也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。</p>
<p>可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。</p>
</li>
<li><p>URI和URL的区别</p>
<p><strong>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。</strong></p>
<ul>
<li><p>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的</p>
</li>
<li><p>URI一般由三部组成：</p>
<ul>
<li><p>访问资源的命名机制</p>
</li>
<li><p>存放资源的主机名</p>
</li>
<li><p>资源自身的名称，由路径表示，着重强调于资源。</p>
</li>
</ul>
</li>
</ul>
<p><strong>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</strong></p>
<ul>
<li><p>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。</p>
</li>
<li><p>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：</p>
<ul>
<li><p>协议(或称为服务方式)</p>
</li>
<li><p>存有该资源的主机IP地址(有时也包括端口号)</p>
</li>
<li><p>主机资源的具体地址。如目录和文件名等</p>
</li>
</ul>
</li>
</ul>
<p><strong>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:<a href="mailto:&#106;&#x61;&#x76;&#x61;&#45;&#110;&#101;&#x74;&#x40;&#106;&#x61;&#118;&#x61;&#x2e;&#115;&#117;&#x6e;&#46;&#99;&#111;&#x6d;">&#106;&#x61;&#x76;&#x61;&#45;&#110;&#101;&#x74;&#x40;&#106;&#x61;&#118;&#x61;&#x2e;&#115;&#117;&#x6e;&#46;&#99;&#111;&#x6d;</a>。</strong></p>
<ul>
<li>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个  URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称  (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。</li>
</ul>
<p>在Java的URI中，<strong>一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。</strong></p>
<p><strong>在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。</strong></p>
<p><strong>相反的是，URL类可以打开一个到达资源的流。</strong></p>
</li>
<li><p>常用的HTTP方法有哪些？</p>
<ul>
<li>GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li>
<li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</li>
<li>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。</li>
<li>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li>
<li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。</li>
<li>OPTIONS：查询相应URI支持的HTTP方法。</li>
</ul>
</li>
<li><p>HTTPS工作原理</p>
<ul>
<li>一、首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；</li>
<li>二、客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；</li>
<li>三、消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；</li>
<li>四、发送给服务端，此时只有服务端（RSA私钥）能解密。</li>
<li>五、解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/27/5d14bda97ed8137950.png" alt="1.png"></p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/05/15/Java-Web-2-1/">https://pingxin0521.gitee.io/2019/05/15/Java-Web-2-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Web/">Web</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/05/15/Java-%E6%A1%86%E6%9E%B6-6-0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">注解框架--lombok</div></div></a></div><div class="next-post pull-right"><a href="/2019/05/14/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-6/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL SQL 触发器和索引(七)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/05/17/Java-Web-1-2/" title="Java Web相关问题"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-12-30</div><div class="title">Java Web相关问题</div></div></a></div><div><a href="/2019/05/17/Java-Web-1-3/" title="Cookie、Session、token"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-02-14</div><div class="title">Cookie、Session、token</div></div></a></div><div><a href="/2019/05/16/Java-Web-2-2/" title="Java servlet (二)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-12-13</div><div class="title">Java servlet (二)</div></div></a></div><div><a href="/2019/05/13/Java-Web-1-1/" title="Java Web入门"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-07-31</div><div class="title">Java Web入门</div></div></a></div><div><a href="/2019/05/30/Java-Web-2-3/" title="Java servlet 源码分析(四)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-12-18</div><div class="title">Java servlet 源码分析(四)</div></div></a></div><div><a href="/2019/05/18/Java-Web-2-4/" title="Java servlet 3.0 (三)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-12-18</div><div class="title">Java servlet 3.0 (三)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFServlet%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是Servlet？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Servlet-%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.0.1.</span> <span class="toc-text">Servlet 任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Servlet-%E5%8C%85"><span class="toc-number">1.0.2.</span> <span class="toc-text">Servlet 包</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tomcat%E5%92%8Cservlet%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.</span> <span class="toc-text">tomcat和servlet的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.</span> <span class="toc-text">Servlet生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#init-%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.1.</span> <span class="toc-text">init() 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#service-%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.2.</span> <span class="toc-text">service() 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#doGet-%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.3.</span> <span class="toc-text">doGet() 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#doPost-%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.4.</span> <span class="toc-text">doPost() 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#destroy-%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.5.</span> <span class="toc-text">destroy() 方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">2.1.</span> <span class="toc-text">架构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HelloWorld%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.</span> <span class="toc-text">HelloWorld示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE"><span class="toc-number">3.</span> <span class="toc-text">表单数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GET-%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">GET 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#POST-%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">POST 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Servlet-%E8%AF%BB%E5%8F%96%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE"><span class="toc-number">3.3.</span> <span class="toc-text">使用 Servlet 读取表单数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-URL-%E7%9A%84-GET-%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.4.</span> <span class="toc-text">使用 URL 的 GET 方法实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A1%A8%E5%8D%95%E7%9A%84-GET-%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.5.</span> <span class="toc-text">使用表单的 GET 方法实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A1%A8%E5%8D%95%E7%9A%84-POST-%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.6.</span> <span class="toc-text">使用表单的 POST 方法实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E5%A4%8D%E9%80%89%E6%A1%86%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E5%88%B0-Servlet-%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.7.</span> <span class="toc-text">将复选框数据传递到 Servlet 程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%89%80%E6%9C%89%E7%9A%84%E8%A1%A8%E5%8D%95%E5%8F%82%E6%95%B0"><span class="toc-number">3.8.</span> <span class="toc-text">读取所有的表单参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP"><span class="toc-number">4.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">HTTP报文格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet-%E5%AE%A2%E6%88%B7%E7%AB%AF-HTTP-%E8%AF%B7%E6%B1%82"><span class="toc-number">4.2.</span> <span class="toc-text">Servlet 客户端 HTTP 请求</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-HTTP-%E5%A4%B4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">读取 HTTP 头的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP-Header-%E8%AF%B7%E6%B1%82%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.2.2.</span> <span class="toc-text">HTTP Header 请求实例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet-%E6%9C%8D%E5%8A%A1%E5%99%A8-HTTP-%E5%93%8D%E5%BA%94"><span class="toc-number">4.3.</span> <span class="toc-text">Servlet 服务器 HTTP 响应</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-HTTP-%E5%93%8D%E5%BA%94%E6%8A%A5%E5%A4%B4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.1.</span> <span class="toc-text">设置 HTTP 响应报头的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP-Header-%E5%93%8D%E5%BA%94%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.3.2.</span> <span class="toc-text">HTTP Header 响应实例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet-HTTP-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">4.4.</span> <span class="toc-text">Servlet HTTP 状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-HTTP-%E7%8A%B6%E6%80%81%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.1.</span> <span class="toc-text">设置 HTTP 状态代码的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP-%E7%8A%B6%E6%80%81%E7%A0%81%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.4.2.</span> <span class="toc-text">HTTP 状态码实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet-%E7%BC%96%E5%86%99%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">Servlet 编写过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">Servlet 过滤器方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FilterConfig-%E4%BD%BF%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">FilterConfig 使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.3.</span> <span class="toc-text">Servlet 过滤器实例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Web-xml-%E4%B8%AD%E7%9A%84-Servlet-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%98%A0%E5%B0%84%EF%BC%88Servlet-Filter-Mapping%EF%BC%89"><span class="toc-number">5.3.1.</span> <span class="toc-text">Web.xml 中的 Servlet 过滤器映射（Servlet Filter Mapping）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">5.4.</span> <span class="toc-text">使用多个过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.5.</span> <span class="toc-text">过滤器的应用顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#web-xml%E9%85%8D%E7%BD%AE%E5%90%84%E8%8A%82%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="toc-number">5.6.</span> <span class="toc-text">web.xml配置各节点说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">面试题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
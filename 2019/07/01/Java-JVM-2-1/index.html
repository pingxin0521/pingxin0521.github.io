<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java 四种引用 | 平心de小屋</title><meta name="keywords" content="Java"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="java四种引用我们知道java相比C，C++中没有令人头痛的指针，但是却有和指针作用相似的引用对象（Reference），就是常说的引用，比如，Object obj &#x3D; new Object()；这个obj就是引用，它指向的是真正的对象Object的地址，不过今天要说的是java中的四种引用。有人可能比较懵逼，四种引用？是的，从JDK1.2之后，java对引用这块的概念进行了扩充，按照引用的强度">
<meta property="og:type" content="article">
<meta property="og:title" content="java 四种引用">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/07/01/Java-JVM-2-1/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="java四种引用我们知道java相比C，C++中没有令人头痛的指针，但是却有和指针作用相似的引用对象（Reference），就是常说的引用，比如，Object obj &#x3D; new Object()；这个obj就是引用，它指向的是真正的对象Object的地址，不过今天要说的是java中的四种引用。有人可能比较懵逼，四种引用？是的，从JDK1.2之后，java对引用这块的概念进行了扩充，按照引用的强度">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg">
<meta property="article:published_time" content="2019-07-01T11:18:59.000Z">
<meta property="article:modified_time" content="2019-11-07T06:08:35.877Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/07/01/Java-JVM-2-1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java 四种引用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2019-11-07 14:08:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java 四种引用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-07-01T11:18:59.000Z" title="发表于 2019-07-01 19:18:59">2019-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-11-07T06:08:35.877Z" title="更新于 2019-11-07 14:08:35">2019-11-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java 四种引用"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="java四种引用"><a href="#java四种引用" class="headerlink" title="java四种引用"></a>java四种引用</h4><p>我们知道java相比C，C++中没有令人头痛的指针，但是却有和指针作用相似的引用对象（Reference），就是常说的引用，比如，Object obj = new Object()；这个obj就是引用，它指向的是真正的对象Object的地址，不过今天要说的是java中的四种引用。有人可能比较懵逼，四种引用？是的，从JDK1.2之后，java对引用这块的概念进行了扩充，按照引用的强度分为了四种引用：强引用，软引用，弱引用，虚引用。下面就让我们来看看这四种引用都具体的情况吧。</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>我们平时代码中使用得最多的引用，对象的类是：StrongReference。就比如上面说的Object obj = new Object()；我们再熟悉不过了，作为最强的引用，只要引用还存在着，垃圾收集器就不会将该引用给回收，即使会出现OOM（内存溢出）。就是说这种引用只要引用还一直指向的对象，垃圾收集器是不会去管它的，所以它被称为强引用。不过如果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">obj = null;</span><br></pre></td></tr></table></figure>

<p>obj被赋值为了null，该引用就断了，垃圾收集器会在合适的时候回收改引用的内存。</p>
<p>还有一种情况就是obj是成员变量，方法执行完了，obj随着被栈帧被回收了，obj引用也是一起被回收了。强引用的使用就不介绍了，地球人都知道。</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用是用来描述一些有用但是非必须的对象。对应的类是SoftReference，它被回收的时机是系统内存不足的时候，如果内存足够，它不会被回收，内存不足了，可能会发生OOM了，软引用的对象就会被回收。这样的特性是不是就像缓存？是的，软引用可以用来存放缓存的数据，内存足够的时候一直可以访问，内存不足的时候，需要重新创建或者访问原对象。</p>
<p>其实不管是软引用，弱引用，还是虚引用，代码中使用方式都是像下面这样，使用对应的Reference将对象放入到构造函数当中，然后使用的地方reference.get()来调用具体对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(obj);</span><br><span class="line">softReference.get();</span><br></pre></td></tr></table></figure>

<p>同时可以使用ReferenceQueue来把引用和引用队列给关联起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">ReferenceQueue&lt;Object&gt; refQueue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(obj, refQueue);</span><br></pre></td></tr></table></figure>

<p><strong>所谓关联起来，其实就是当引用被回收的时候，会被添加到ReferenceQueue中，使用ReferenceQueue.poll()方法可以返回当前可用的引用，并从队列冲删除。</strong>简单来说就是引用和引用队列关联起来（引用的构造函数传入队列），然后引用被回收的时候会被添加到队列中，然后使用poll()方法可以返回引用。</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用比上面两个引用就更菜了，只要垃圾收集器扫描到了它，被弱引用关联的对象就会被回收。被弱引用关联对象的生命周期其实就是从对象创建到下一次垃圾回收。对应的类是WeakReference。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">      ReferenceQueue&lt;Object&gt; refQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">      WeakReference&lt;Object&gt; weakRef = <span class="keyword">new</span> WeakReference&lt;&gt;(obj, refQueue);</span><br><span class="line">      System.out.println(<span class="string">&quot;引用：&quot;</span> + weakRef.get());</span><br><span class="line">      System.out.println(<span class="string">&quot;队列中的东西：&quot;</span> + refQueue.poll());</span><br><span class="line">      <span class="comment">// 清除强引用, 触发GC</span></span><br><span class="line">      obj = <span class="keyword">null</span>;</span><br><span class="line">      System.gc();</span><br><span class="line">      Thread.sleep(<span class="number">200</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;引用：&quot;</span> + weakRef.get());</span><br><span class="line">      System.out.println(<span class="string">&quot;引用加入队列了吗？ &quot;</span> + weakRef.isEnqueued());</span><br><span class="line">      System.out.println(<span class="string">&quot;队列中的东西：&quot;</span> + refQueue.poll());</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 输出结果</span></span><br><span class="line"><span class="comment">       * 引用：java.lang.Object@7bb11784</span></span><br><span class="line"><span class="comment">       * 队列中的东西：null</span></span><br><span class="line"><span class="comment">       * 引用：null</span></span><br><span class="line"><span class="comment">       * 引用加入队列了吗？ true</span></span><br><span class="line"><span class="comment">       * 队列中的东西：java.lang.ref.WeakReference@33a10788</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到当强引用被清除，手动触发GC后，弱引用回收，被加入到队列中了。</p>
<p>WeakHashMap跟hashMap很像，差别就在于，当WeakHashMap的key（弱引用），指向的对象被回收了，weakhashMap中的对象也就消失了。不会和HashMap一样一直持有该对象，导致无法回收。</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用是最弱的一种引用，它不会影响对象的生命周期，对象被回收跟它没啥关系。它引用的对象可以在任何时候被回收，而且也无法根据虚引用来取得一个对象的实例。仅仅当它指向的对象被回收的时候，它会受到一个通知。对应的类是PhantomReference。</p>
<p>有人就要问既然对对象回收没影响，那它有啥用（其实用处很少），我查阅网上的资料说是，可以用来监控对象的回收，和记录日志。简单点说就是对象被回收的时候，和虚引用相关的队列知道了实例对象被回收了。这个时候我们可以记录下来，知道对象是什么时候被回收的。</p>
<p>从而起到监控的作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       Object abc = <span class="keyword">new</span> Object();</span><br><span class="line">       ReferenceQueue&lt;Object&gt; refQueue = <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;();</span><br><span class="line">       PhantomReference&lt;Object&gt; abcRef = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(abc, refQueue);</span><br><span class="line">       System.out.println(<span class="string">&quot;队列中的东西：&quot;</span> + refQueue.poll());</span><br><span class="line">       abc = <span class="keyword">null</span>;</span><br><span class="line">       System.gc();</span><br><span class="line">       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;引用加入队列了吗？ &quot;</span> + abcRef.isEnqueued());</span><br><span class="line">       System.out.println(<span class="string">&quot;队列中的东西：&quot;</span> + refQueue.poll());</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 输出：</span></span><br><span class="line"><span class="comment">        * 队列中的东西：null</span></span><br><span class="line"><span class="comment">        * 引用加入队列了吗？ true</span></span><br><span class="line"><span class="comment">        * 队列中的东西：java.lang.ref.PhantomReference@7bb11784</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现队列中有引用了，就可以添加日志记录了。</p>
<h4 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h4><p>好了，理论说完了，下面我们来实践一下：我们新建一个 Java 工程，在里面新建一个类 <code>Main</code> 并添加实践代码（请谨慎尝试）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 引用测试类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceTest</span> </span>&#123;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1M = <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">// 引用队列，当某个引用所指向的对象被回收时这个引用本身会被添加到其对应的引用队列中</span></span><br><span class="line">        <span class="comment">// 其泛型为其中存放的引用要指向的对象类型</span></span><br><span class="line">		ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 强引用测试</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">testStrongReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			ArrayList&lt;<span class="keyword">byte</span>[]&gt; strongReferences = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					strongReferences.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_1M]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 软引用测试</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">testSoftReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			ArrayList&lt;SoftReference&gt; softReferences = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					softReferences.add(<span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_1M], referenceQueue));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 弱引用测试</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">testWeakReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			ArrayList&lt;WeakReference&gt; weakReferences = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					weakReferences.add(<span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_1M], referenceQueue));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 虚引用测试</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">testPhantomReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			ArrayList&lt;PhantomReference&lt;<span class="keyword">byte</span>[]&gt;&gt; phantomReferences = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					phantomReferences.add(<span class="keyword">new</span> PhantomReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_1M], referenceQueue));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ReferenceTest test = <span class="keyword">new</span> ReferenceTest();</span><br><span class="line">		test.testStrongReference();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在 <code>Main</code> 类中创建了一个静态内部类 <code>ReferenceTest</code>，并在其中提供了 4 个方法，方法很简单，就是不断创建新的 <code>byte</code> 数组，并且用不同类型的引用对象指向它。直到发生 <code>OutOfMemoryError</code> 异常。</p>
<p>运行过程中你会看到电脑内存占用飙升，最后会抛出 <code>OutOfMemoryError</code> 异常，这个结果是显而易见的，现在来看看对软引用的测试，修改一下 <code>main</code> 方法中的代码：<code>test.testSoftReference();</code></p>
<p>同样的你会看到电脑占用内存飙升，但是最终会稳定一个值：因为我们现在用的是软引用来指向一个个 byte 数组。在 JVM 抛出 OutOfMemoryError 异常之前会将只被软引用指向的对象回收掉（通过执行垃圾回收动作），因此不会抛出 OutOfMemoryError 异常。下面来看看对弱引用的测试，我们改一下 main 方法中的一行代码：test.testWeakReference();</p>
<p>同样的你会看到相同的结果，原因也正如上文所说：JVM 的垃圾回收动作会回收掉所有只被弱引用指向的对象。最后来看看虚引用的测试，同样的修改 <code>main</code> 方法中的一行代码：<code>test.testPhantomReference();</code></p>
<p>你会看到和强引用测试一样的结果：JVM 最终会抛出一个 OutOfMemoryError 异常。可能有些小伙伴们会问了：虚引用不是引用强度最弱的的吗，怎么会因为它而抛出 OutOfMemoryError 异常呢？其实仔细一想：**虚引用确实是引用强度最弱的，但是还有一点是虚引用根本不会影响对象的声明周期，也就是说某个对象是否被 JVM 的垃圾回收动作回收和这个对象是否被虚引用所指向和被多少个虚引用所指向没有任何关系，既然其不会影响对象的生命周期，那么使用和不使用虚引用指向对象对这个对象是否被 JVM 回收是没有任何区别的，那么我们就可以将其看做没有使用虚引用时的代码，此时效果自然和直接使用强引用一样。关于这个，可以参考 PhantomReference 类的源码注释：</p>
<p><code>Unlike soft and weak references, phantom references are not automatically cleared by the garbage collector as they are enqueued. An object that is reachable via phantom references will remain so until all such references are cleared or themselves become unreachable.</code></p>
<h4 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h4><p>在上节的代码中，我们新建了一个引用队列（ReferenceQueue）对象，并且在创建软引用、弱引用和虚引用对象时将其作为参数传入对应引用的构造方法中。在文章的开头提到过可以利用引用队列来检测某个引用指向的对象是否被垃圾回收器回收，那么具体应该怎么做呢。我们可以看一下 3 类引用的源码，这里以弱引用为例（剩余两种可以类比）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class WeakReference&lt;T&gt; extends Reference&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    public WeakReference(T referent) &#123;</span><br><span class="line">        super(referent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123;</span><br><span class="line">        super(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到 <code>WeakReference</code> 类继承了 <code>Reference</code> 类，可以猜到 <code>Reference</code> 类是 3 种引用的基类，我们看看这个类的源码 <code>Reference.java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T referent;         <span class="comment">/* Treated specially by GC */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When active:   NULL</span></span><br><span class="line"><span class="comment">     *     pending:   this</span></span><br><span class="line"><span class="comment">     *    Enqueued:   next reference in queue (or this if last)</span></span><br><span class="line"><span class="comment">     *    Inactive:   this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Reference next; <span class="comment">// 引用所处的状态不同时，该属性保存了不同的信息</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前引用所指向的对象的方法，如果所指向对象已经被 GC 回收，那么返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.referent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除该引用所指向的对象，该方法会在 GC 回收该引用指向的对象后被 GC 调用，</span></span><br><span class="line"><span class="comment">     * 之后，通过该引用对象的 get 方法得到的返回值为 null, 该方法不应该被程序员主动调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.referent = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* -- Queue operations -- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前引用是否已经进入对应的引用队列，</span></span><br><span class="line"><span class="comment">     * 如果构造该引用对象时没有指定对应的引用队列，那么该方法始终返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnqueued</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.queue == ReferenceQueue.ENQUEUED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前引用对象的引用队列属性（构造时由参数指定）不为 null, </span></span><br><span class="line"><span class="comment">     * 那么当这个引用所指向的对象被 GC 回收之后会由 GC 调用这个方法，</span></span><br><span class="line"><span class="comment">     * 代表将该引用进入对应的引用队列（即该引用指向的对象被回收）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.queue.enqueue(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* -- Constructors -- */</span></span><br><span class="line">    Reference(T referent) &#123;</span><br><span class="line">        <span class="keyword">this</span>(referent, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.referent = referent;</span><br><span class="line">        <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在 <code>Reference</code> 类中的 <code>enqueue</code> 方法（这个方法本身会被 GC 线程调用）中发现其直接调用了对应引用队列（<code>ReferenceQueue</code>）的 <code>enqueue</code> 方法，我们来看看 <code>ReferenceQueue</code> 类的这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new reference-object queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceQueue</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Reference&lt;? extends T&gt; head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> queueLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用对象本身入队列的过程就是一个向单向链表中插入节点的过程</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Reference&lt;? extends T&gt; r)</span> </span>&#123; <span class="comment">/* Called only by Reference class */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 保证线程安全</span></span><br><span class="line">            <span class="comment">// Check that since getting the lock this reference hasn&#x27;t already been</span></span><br><span class="line">            <span class="comment">// enqueued (and even then removed)</span></span><br><span class="line">            ReferenceQueue&lt;?&gt; queue = r.queue;</span><br><span class="line">            <span class="keyword">if</span> ((queue == NULL) || (queue == ENQUEUED)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> queue == <span class="keyword">this</span>;</span><br><span class="line">            r.queue = ENQUEUED; <span class="comment">// 更新引用入队状态</span></span><br><span class="line">           	<span class="comment">// 前插法插入链表节点</span></span><br><span class="line">            r.next = (head == <span class="keyword">null</span>) ? r : head;</span><br><span class="line">            head = r;</span><br><span class="line">            queueLength++;</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FinalReference) &#123;</span><br><span class="line">                sun.misc.VM.addFinalRefCount(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前引用队列中的第一个引用对象，如果不存在则返回 null</span></span><br><span class="line"><span class="comment">     * 该方法不会阻塞线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Reference&lt;? extends T&gt; poll() &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> reallyPoll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前引用队列中第一个可用的引用对象，如果没有，则阻塞线程一定时间（参数指定）</span></span><br><span class="line"><span class="comment">     * 阻塞时间过后，如果当前队列中仍然没有可用的引用对象，那么抛出中断异常（InterruptedException）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Reference&lt;? extends T&gt; remove(<span class="keyword">long</span> timeout)</span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException, InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Negative timeout value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            Reference&lt;? extends T&gt; r = reallyPoll();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) <span class="keyword">return</span> r;</span><br><span class="line">            <span class="keyword">long</span> start = (timeout == <span class="number">0</span>) ? <span class="number">0</span> : System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                lock.wait(timeout);</span><br><span class="line">                r = reallyPoll();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) <span class="keyword">return</span> r;</span><br><span class="line">                <span class="keyword">if</span> (timeout != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">                    timeout -= (end - start) / <span class="number">1000_000</span>;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    start = end;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞调用线程，直到当前引用队列中存在可用的引用对象，将该引用对象从引用队列中移除并返回该引用对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Reference&lt;? extends T&gt; remove() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用注释和源代码，我们就可以将整个过程的逻辑串起来了：</p>
<p><strong>GC 线程回收对象 -&gt; 将相关指向这个对象的引用加入到其引用队列（如果有）-&gt; 更新引用入队状态（isEnqueued 方法返回 true）-&gt; 在 Java 代码中可以得到引用队列中的已经入队的引用（即得到要回收对象的对应引用对象，作为对象回收的一个通知）。</strong></p>
<p>下面看一个小例子，利用引用队列来得知回收的对象，我们在上一节的代码中新建一个静态内部类 ReferenceQueueTest：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用队列测试类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对象回收时的引用通知测试</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">testReferenceNotify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		WeakReference&lt;<span class="keyword">byte</span>[]&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>], referenceQueue);</span><br><span class="line">            <span class="comment">// 后面的 ReferenceQueue.remove 方法会阻塞调用线程，因此开子线程进行操作</span></span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> (Reference pr; (pr = referenceQueue.remove()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">					System.out.println(pr + <span class="string">&quot; 引用所指向的对象被回收!&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">/* </span></span><br><span class="line"><span class="comment">		 因为 ReferenceQueue 对象的 remove 方法是阻塞线程的，因此子线程需设置守护线程，</span></span><br><span class="line"><span class="comment">		 否则如果 ReferenceQueue 中没有可取出的引用对象会导致线程一直阻塞，程序不能退出</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		thread.start();</span><br><span class="line">		<span class="comment">// 启动垃圾回收动作，将弱引用指向的对象回收</span></span><br><span class="line">		System.gc();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 <code>main</code> 方法中新建该内部类对象并且调用 <code>testReferenceNotify</code> 方法</p>
<p>可以看到，当弱引用指向的对象被回收之后，我们成功的从该弱引用对象中的引用对象中得到了该弱引用对象，即完成了对象回收的监视过程。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>将人比作垃圾收集器，引用比作食物，我们来总结下四种引用：</p>
<ul>
<li>强引用是毒药，即使你很饿了你也不会去吃它；</li>
<li>软引用是零食，不饿的时候不吃，饿了饥不择食，零食也能填饱肚子；</li>
<li>弱引用是饭菜，到了吃饭时间（垃圾回收），就吃饭菜；</li>
<li>虚引用是剩菜，当你吃完东西（回收完对象），就回剩下剩菜，别人就知道你吃过饭了。</li>
</ul>
<table>
<thead>
<tr>
<th>引用</th>
<th>回收时机</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>强</td>
<td>不会被回收</td>
<td>正常编码使用</td>
</tr>
<tr>
<td>软</td>
<td>内存不够了，被GC</td>
<td>可作为缓存</td>
</tr>
<tr>
<td>弱</td>
<td>GC发生时</td>
<td>可作为缓存（WeakHashMap）</td>
</tr>
<tr>
<td>虚</td>
<td>任何时候</td>
<td>监控对象回收，记录日志</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/07/01/Java-JVM-2-1/">https://pingxin0521.gitee.io/2019/07/01/Java-JVM-2-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/07/03/Java-SpringBoot-1-5-1/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring boot 安全框架</div></div></a></div><div class="next-post pull-right"><a href="/2019/07/01/node-2-2/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Node.JS 再深入 -- http</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/07/12/Java-SpringBoot-1-4-2/" title="Spring boot 数据访问 MongoDB"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-01-25</div><div class="title">Spring boot 数据访问 MongoDB</div></div></a></div><div><a href="/2019/12/10/Java-SpringBoot-1-6-1/" title="Spring boot 消息队列(使用RabbitMQ)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-02-09</div><div class="title">Spring boot 消息队列(使用RabbitMQ)</div></div></a></div><div><a href="/2019/05/30/Java-SpringCloud-0-0/" title="Spring Cloud 入门 (一)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">Spring Cloud 入门 (一)</div></div></a></div><div><a href="/2019/11/01/Java-SpringCloud-3-0/" title="Spring Cloud 组件之Hystrix (五)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">Spring Cloud 组件之Hystrix (五)</div></div></a></div><div><a href="/2019/10/27/Java-SpringCloud-6-0/" title="微服务组件--分布式追踪系统"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">微服务组件--分布式追踪系统</div></div></a></div><div><a href="/2019/11/03/Java-SpringCloud-6-2/" title="SpringCloud组件之Spring Cloud Sleuth (八)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">SpringCloud组件之Spring Cloud Sleuth (八)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">java四种引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">虚引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">实验代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">引用队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
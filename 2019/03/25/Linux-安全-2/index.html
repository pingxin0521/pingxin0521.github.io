<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ssL原理与实现 | 平心de小屋</title><meta name="keywords" content="Linux,安全"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言跨主机网络通信实质上是不同主机上的进程之间的通信，现在网络通信协议是五层协议一种实现，但是不提供安全保护，所以需要对网络连接进行加密。SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。 SSL协议位于TCP&#x2F;IP">
<meta property="og:type" content="article">
<meta property="og:title" content="ssL原理与实现">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/03/25/Linux-%E5%AE%89%E5%85%A8-2/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="前言跨主机网络通信实质上是不同主机上的进程之间的通信，现在网络通信协议是五层协议一种实现，但是不提供安全保护，所以需要对网络连接进行加密。SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。 SSL协议位于TCP&#x2F;IP">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg">
<meta property="article:published_time" content="2019-03-25T01:18:59.000Z">
<meta property="article:modified_time" content="2019-10-17T10:48:03.000Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="安全">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/03/25/Linux-%E5%AE%89%E5%85%A8-2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ssL原理与实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2019-10-17 18:48:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ssL原理与实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-03-25T01:18:59.000Z" title="发表于 2019-03-25 09:18:59">2019-03-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-10-17T10:48:03.000Z" title="更新于 2019-10-17 18:48:03">2019-10-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/%E5%AE%89%E5%85%A8/">安全</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ssL原理与实现"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>跨主机网络通信实质上是不同主机上的进程之间的通信，现在网络通信协议是五层协议一种实现，但是不提供安全保护，所以需要对网络连接进行加密。SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</p>
<p>SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
<p>提供服务：</p>
<p>1）认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
<p>2）加密数据以防止数据中途被窃取；</p>
<p>3）维护数据的完整性，确保数据在传输过程中不被改变。</p>
<span id="more"></span>

<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>SSL协议实现的安全机制包含：</p>
<ul>
<li><p>传输数据的机密性：利用对称密钥算法对传输的数据进行加密。</p>
</li>
<li><p>身份验证机制：基于证书利用数字签名方法对server和client进行身份验证，当中client的身份验证是可选的。</p>
</li>
<li><p>消息完整性验证：消息传输过程中使用MAC算法来检验消息的完整性。</p>
</li>
</ul>
<h4 id="传输数据的机密性"><a href="#传输数据的机密性" class="headerlink" title="传输数据的机密性"></a>传输数据的机密性</h4><p>网络上传输的数据非常easy被非法用户窃取，SSL採用在通信两方之间建立加密通道的方法保证传输数据的机密性。</p>
<p>所谓加密通道，是指发送方在发送数据前，使用加密算法和加密密钥对数据进行加密，然后将数据发送给对方。接收方接收到数据后，利用解密算法和解密密钥从密文中获取明文。没有解密密钥的第三方，无法将密文恢复为明文，从而保证传输数据的机密性。</p>
<p>加解密算法分为两类：</p>
<ul>
<li><p> 对称密钥算法：数据加密和解密时使用同样的密钥。</p>
</li>
<li><p> 非对称密钥算法：数据加密和解密时使用不同的密钥，一个是公开的公钥，一个是由用户秘密保存的私钥。</p>
</li>
</ul>
<p>利用公钥（或私钥）加密的数据仅仅能用对应的私钥（或公钥）才干解密。</p>
<p>与非对称密钥算法相比。对称密钥算法具有计算速度快的长处，通经常使用于对大量信息进行加密（如对全部报文加密）；而非对称密钥算法，一般用于数字签名和对较少的信息进行加密。</p>
<p>SSL加密通道上的数据加解密使用对称密钥算法。眼下主要支持的算法有DES、3DES、AES等，这些算法都能够有效地防止交互数据被窃听。</p>
<p>对称密钥算法要求解密密钥和加密密钥全然一致。因此，利用对称密钥算法加密数据传输之前。须要在通信两端部署同样的密钥。</p>
<h4 id="身份验证机制"><a href="#身份验证机制" class="headerlink" title="身份验证机制"></a>身份验证机制</h4><p>电子商务和网上银行等应用中必须保证要登录的Webserver是真实的，以免重要信息被非法窃取。SSL利用数字签名来验证通信对端的身份。</p>
<p>非对称密钥算法能够用来实现数字签名。因为通过私钥加密后的数据仅仅能利用相应的公钥进行解密，因此依据解密是否成功，就能够推断发送者的身份。如同发送者对数据进行了“签名”。比如。Alice使用自己的私钥对一段固定的信息加密后发给Bob，Bob利用Alice的公钥解密，假设解密结果与固定信息同样。那么就能够确认信息的发送者为Alice，这个过程就称为数字签名。</p>
<p>SSLclient必须验证SSLserver的身份，SSLserver是否验证SSLclient的身份。则由SSLserver决定。SSLclient和SSLserver的身份验证过程。</p>
<p>使用数字签名验证身份时。须要确保被验证者的公钥是真实的，否则。非法用户可能会冒充被验证者与验证者通信。如图1所看到的。Cindy冒充Bob，将自己的公钥发给Alice，并利用自己的私钥计算出签名发送给Alice，Alice利用“Bob”的公钥（实际上为Cindy的公钥）成功验证该签名，则Alice觉得Bob的身份验证成功，而实际上与Alice通信的是冒充Bob的Cindy。SSL利用PKI提供的机制保证公钥的真实性。</p>
<h4 id="消息完整性验证"><a href="#消息完整性验证" class="headerlink" title="消息完整性验证"></a>消息完整性验证</h4><p>为了避免网络中传输的数据被非法篡改，SSL利用基于MD5或SHA的MAC算法来保证消息的完整性。</p>
<p>MAC算法是在密钥參与下的数据摘要算法，能将密钥和随意长度的数据转换为固定长度的数据。利用MAC算法验证消息完整性的过程如图2所看到的。</p>
<p>发送者在密钥的參与下，利用MAC算法计算出消息的MAC值。并将其加在消息之后发送给接收者。接收者利用相同的密钥和MAC算法计算出消息的MAC值。并与接收到的MAC值比較。假设二者相同。则报文没有改变；否则，报文在传输过程中被改动，接收者将丢弃该报文。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://ws1.sinaimg.cn/large/006KyevZgy1g1euuztx61j30dm03zdfp.jpg"></p>
<p>MAC算法具有例如以下特征，使其可以用来验证消息的完整性：</p>
<ul>
<li><p>消息的不论什么改变，都会引起输出的固定长度数据产生变化。通过比較MAC值，可以保证接收者可以发现消息的改变。</p>
</li>
<li><p>MAC算法须要密钥的參与。因此没有密钥的非法用户在改变消息的内容后，无法加入正确的MAC值。从而保证非法用户无法任意改动消息内容。</p>
</li>
</ul>
<p>MAC算法要求通信两方具有同样的密钥，否则MAC值验证将会失败。因此，利用MAC算法验证消息完整性之前，须要在通信两端部署同样的密钥。</p>
<h4 id="利用非对称密钥算法保证密钥本身的安全"><a href="#利用非对称密钥算法保证密钥本身的安全" class="headerlink" title="利用非对称密钥算法保证密钥本身的安全"></a>利用非对称密钥算法保证密钥本身的安全</h4><p>对称密钥算法和MAC算法要求通信两方具有同样的密钥。否则解密或MAC值验证将失败。因此。要建立加密通道或验证消息完整性，必须先在通信两方部署一致的密钥。</p>
<p>SSL利用非对称密钥算法加密密钥的方法实现密钥交换，保证第三方无法获取该密钥。如图所看到的，SSLclient（如Web浏览器）利用SSLserver（如Webserver）的公钥加密密钥，将加密后的密钥发送给SSLserver。仅拥有相应私钥的SSLserver才干从密文中获取原始的密钥。SSL通常採用RSA算法加密传输密钥。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://ws1.sinaimg.cn/large/006KyevZgy1g1euzrrys1j30by038745.jpg"></p>
<p>实际上，SSLclient发送给SSLserver的密钥不能直接用来加密数据或计算MAC值。该密钥是用来计算对称密钥和MAC密钥的信息，称为premaster secret。SSLclient和SSLserver利用premaster secret计算出同样的主密钥（master secret）。再利用master secret生成用于对称密钥算法、MAC算法等的密钥。premaster secret是计算对称密钥、MAC算法密钥的关键。</p>
<p> 用来实现密钥交换的算法称为密钥交换算法。非对称密钥算法RSA用于密钥交换时，也能够称之为密钥交换算法。</p>
<p>利用非对称密钥算法加密密钥之前，发送者须要获取接收者的公钥，并保证该公钥确实属于接收者。否则。密钥可能会被非法用户窃取。Cindy冒充Bob，将自己的公钥发给Alice。Alice利用Cindy的公钥加密发送给Bob的数据。Bob因为没有相应的私钥无法解密该数据，而Cindy截取数据后，能够利用自己的私钥解密该数据。SSL利用PKI提供的机制保证公钥的真实性，</p>
<h4 id="利用PKI保证公钥的真实性"><a href="#利用PKI保证公钥的真实性" class="headerlink" title="利用PKI保证公钥的真实性"></a>利用PKI保证公钥的真实性</h4><p>PKI通过数字证书来公布用户的公钥，并提供了验证公钥真实性的机制。数字证书（简称证书）是一个包括用户的公钥及其身份信息的文件，证明了用户与公钥的关联。</p>
<p>数字证书由权威机构——CA签发，并由CA保证数字证书的真实性。</p>
<p>SSLclient把密钥加密传递给SSLserver之前，SSLserver须要将从CA获取的证书发送给SSLclient，SSLclient通过PKI推断该证书的真实性。假设该证书确实属于SSLserver，则利用该证书中的公钥加密密钥，发送给SSLserver。</p>
<p>验证SSLserver/SSLclient的身份之前，SSLserver/SSLclient须要将从CA获取的证书发送给对端。对端通过PKI推断该证书的真实性。</p>
<p>假设该证书确实属于SSLserver/SSLclient，则对端利用该证书中的公钥验证SSLserver/SSLclient的身份。</p>
<h1 id="协议工作过程"><a href="#协议工作过程" class="headerlink" title="协议工作过程"></a>协议工作过程</h1><h2 id="3-1-SSL的分层结构"><a href="#3-1-SSL的分层结构" class="headerlink" title="3.1  SSL的分层结构"></a>3.1  SSL的分层结构</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://www.h3c.com.cn/res/200812/12/20081212_705431_image005_622834_30003_0.png" alt="img"></p>
<p>图4 SSL协议分层</p>
<p>如图4所看到的，SSL位于应用层和传输层之间，它能够为不论什么基于TCP等可靠连接的应用层协议提供安全性保证。SSL协议本身分为两层：</p>
<p>l              上层为SSL握手协议（SSL handshake protocol）、SSLpassword变化协议（SSL change cipher spec protocol）和SSL警告协议（SSL alert protocol）。</p>
<p>l              底层为SSL记录协议（SSL record protocol）。</p>
<p>当中：</p>
<p>l              SSL握手协议：是SSL协议很重要的组成部分。用来协商通信过程中使用的加密套件（加密算法、密钥交换算法和MAC算法等）、在server和client之间安全地交换密钥、实现server和client的身份验证。</p>
<p>l              SSLpassword变化协议：client和server端通过password变化协议通知对端。随后的报文都将使用新协商的加密套件和密钥进行保护和传输。</p>
<p>l              SSL警告协议：用来向通信对端报告告警信息，消息中包括告警的严重级别和描写叙述。</p>
<p>l              SSL记录协议：主要负责对上层的数据（SSL握手协议、SSLpassword变化协议、SSL警告协议和应用层协议报文）进行分块、计算并加入MAC值、加密。并把处理后的记录块传输给对端。</p>
<h3 id="SSL握手过程"><a href="#SSL握手过程" class="headerlink" title="SSL握手过程"></a>SSL握手过程</h3><p>SSL通过握手过程在client和server之间协商会话參数，并建立会话。会话包括的主要參数有会话ID、对方的证书、加密套件（密钥交换算法、数据加密算法和MAC算法等）以及主密钥（master secret）。通过SSL会话传输的数据，都将採用该会话的主密钥和加密套件进行加密、计算MAC等处理。</p>
<p>不同情况下，SSL握手过程存在差异。</p>
<p>以下将分别描写叙述以下三种情况下的握手过程：</p>
<ul>
<li><p>仅仅验证server的SSL握手过程</p>
</li>
<li><p>验证server和client的SSL握手过程</p>
</li>
<li><p> 恢复原有会话的SSL握手过程</p>
</li>
</ul>
<h4 id="验证server的SSL握手过程"><a href="#验证server的SSL握手过程" class="headerlink" title="验证server的SSL握手过程"></a>验证server的SSL握手过程</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://ws1.sinaimg.cn/large/006KyevZgy1g1ev9tve3cj308m091aa3.jpg"></p>
<p>如上图所看到的，仅仅须要验证SSLserver身份，不须要验证SSLclient身份时，SSL的握手过程为：</p>
<ol>
<li><p>SSLclient通过Client Hello消息将它支持的SSL版本号、加密算法、密钥交换算法、MAC算法等信息发送给SSLserver。</p>
</li>
<li><p>SSLserver确定本次通信採用的SSL版本号和加密套件，并通过Server Hello消息通知给SSLclient。 设SSLserver同意SSLclient在以后的通信中重用本次会话，则SSLserver会为本次会话分配会话ID。并通过Server Hello消息发送给SSLclient。</p>
</li>
<li><p>SSLserver将携带自己公钥信息的数字证书通过Certificate消息发送给SSLclient。</p>
</li>
<li><p>SSLserver发送Server Hello Done消息。通知SSLclient版本号和加密套件协商结束。開始进行密钥交换。</p>
</li>
<li><p>SSLclient验证SSLserver的证书合法后，利用证书中的公钥加密SSLclient随机生成的premaster secret，并通过Client Key Exchange消息发送给SSLserver。</p>
</li>
<li><p>SSLclient发送Change Cipher Spec消息，通知SSLserver兴许报文将採用协商好的密钥和加密套件进行加密和MAC计算。</p>
</li>
<li><p>SSLclient计算已交互的握手消息（除Change Cipher Spec消息外全部已交互的消息）的Hash值，利用协商好的密钥和加密套件处理Hash值（计算并加入MAC值、加密等），并通过Finished消息发送给SSLserver。SSLserver利用相同的方法计算已交互的握手消息的Hash值，并与Finished消息的解密结果比較，假设二者相同，且MAC值验证成功，则证明密钥和加密套件协商成功。</p>
</li>
<li><p>相同地。SSLserver发送Change Cipher Spec消息，通知SSLclient兴许报文将採用协商好的密钥和加密套件进行加密和MAC计算。</p>
</li>
<li><p>SSLserver计算已交互的握手消息的Hash值，利用协商好的密钥和加密套件处理Hash值（计算并加入MAC值、加密等），并通过Finished消息发送给SSLclient。SSLclient利用相同的方法计算已交互的握手消息的Hash值，并与Finished消息的解密结果比較，假设二者相同。且MAC值验证成功。则证明密钥和加密套件协商成功。</p>
</li>
</ol>
<p>SSLclient接收到SSLserver发送的Finished消息后。假设解密成功，则能够推断SSLserver是数字证书的拥有者，即SSLserver身份验证成功，由于仅仅有拥有私钥的SSLserver才干从Client Key Exchange消息中解密得到premaster secret，从而间接地实现了SSLclient对SSLserver的身份验证。</p>
<blockquote>
<p>Change Cipher Spec消息属于SSLpassword变化协议，其它握手过程交互的消息均属于SSL握手协议，统称为SSL握手消息。</p>
<p>计算Hash值。指的是利用Hash算法（MD5或SHA）将随意长度的数据转换为固定长度的数据。</p>
</blockquote>
<h4 id="验证server和client的SSL握手过程"><a href="#验证server和client的SSL握手过程" class="headerlink" title="验证server和client的SSL握手过程"></a>验证server和client的SSL握手过程</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://ws1.sinaimg.cn/large/006KyevZgy1g1ev9xx9hrj308m0bkwel.jpg"></p>
<p>SSLclient的身份验证是可选的，由SSLserver决定是否验证SSLclient的身份。</p>
<p>图中蓝色部分标识的内容所看到的，假设SSLserver验证SSLclient身份。则SSLserver和SSLclient除了交互中的消息协商密钥和加密套件外，还须要进行下面操作：</p>
<ol>
<li><p>SSLserver发送Certificate Request消息。请求SSLclient将其证书发送给SSLserver。</p>
</li>
<li><p>SSLclient通过Certificate消息将携带自己公钥的证书发送给SSLserver。SSLserver验证该证书的合法性。</p>
</li>
<li><p>SSLclient计算已交互的握手消息、主密钥的Hash值。利用自己的私钥对其进行加密，并通过Certificate Verify消息发送给SSLserver。</p>
</li>
<li><p> SSLserver计算已交互的握手消息、主密钥的Hash值。利用SSLclient证书中的公钥解密Certificate Verify消息，并将解密结果与计算出的Hash值比較。假设二者同样，则SSLclient身份验证成功。</p>
</li>
</ol>
<h4 id="恢复原有会话的SSL握手过程"><a href="#恢复原有会话的SSL握手过程" class="headerlink" title="恢复原有会话的SSL握手过程"></a>恢复原有会话的SSL握手过程</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://ws1.sinaimg.cn/large/006KyevZgy1g1eva04881j308m06jt8o.jpg"></p>
<p>协商会话參数、建立会话的过程中。须要使用非对称密钥算法来加密密钥、验证通信对端的身份。计算量较大，占用了大量的系统资源。</p>
<p>为了简化SSL握手过程。SSL同意重用已经协商过的会话，详细过程为：</p>
<ol>
<li><p>SSLclient发送Client Hello消息，消息中的会话ID设置为计划重用的会话的ID。</p>
</li>
<li><p>SSLserver假设同意重用该会话，则通过在Server Hello消息中设置同样的会话ID来应答。这样，SSLclient和SSLserver就能够利用原有会话的密钥和加密套件。不必又一次协商。</p>
</li>
<li><p> SSLclient发送Change Cipher Spec消息，通知SSLserver兴许报文将採用原有会话的密钥和加密套件进行加密和MAC计算。</p>
</li>
<li><p>SSLclient计算已交互的握手消息的Hash值，利用原有会话的密钥和加密套件处理Hash值，并通过Finished消息发送给SSLserver，以便SSLserver推断密钥和加密套件是否正确。</p>
</li>
<li><p>相同地。SSLserver发送Change Cipher Spec消息，通知SSLclient兴许报文将採用原有会话的密钥和加密套件进行加密和MAC计算。</p>
</li>
<li><p>SSLserver计算已交互的握手消息的Hash值，利用原有会话的密钥和加密套件处理Hash值，并通过Finished消息发送给SSLclient。以便SSLclient推断密钥和加密套件是否正确。</p>
</li>
</ol>
<h3 id="OpenSSL使用"><a href="#OpenSSL使用" class="headerlink" title="OpenSSL使用"></a>OpenSSL使用</h3><p>在计算机网络上，OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个包广泛被应用在互联网的网页服务器上。</p>
<p>OpenSSL整个软件包大概可以分成三个主要的功能部分：SSL协议库、应用程序以及密码算法库。OpenSSL的目录结构自然也是围绕这三个功能部分进行规划的。作为一个基于密码学的安全开发包，OpenSSL提供的功能相当强大和全面，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。</p>
<p>其组成主要包括一下三个组件：</p>
<ul>
<li>openssl：多用途的命令行工具</li>
<li>libcrypto：加密算法库</li>
<li>libssl：加密模块应用库，实现了ssl及tls</li>
</ul>
<h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>对称加密需要使用的标准命令为 enc ，用法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl enc -ciphername [-in filename] [-out filename] [-pass arg] \</span><br><span class="line">[-e] [-d] [-a/-base64] [-A] [-k password] [-kfile filename] [-K key] \</span><br><span class="line">[-iv IV] [-S salt] [-salt] [-nosalt] [-z] [-md] [-p] [-P] \</span><br><span class="line">[-bufsize number] [-nopad] [-debug] [-none] [-engine id]</span><br></pre></td></tr></table></figure>

<p>常用选项有：</p>
<p>-in filename：指定要加密的文件存放路径</p>
<p>-out filename：指定加密后的文件存放路径</p>
<p>-salt：自动插入一个随机数作为文件内容加密，默认选项</p>
<p>-e：可以指明一种加密算法，若不指的话将使用默认加密算法</p>
<p>-d：解密，解密时也可以指定算法，若不指定则使用默认算法，但一定要与加密时的算法一致</p>
<p>-a/-base64：使用-base64位编码格式</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加密：]# openssl enc -e -des3 -a -salt -in fstab -out jiami</span><br><span class="line">解密：]# openssl enc -d -des3 -a -salt -in fstab -out jiami</span><br></pre></td></tr></table></figure>

<h4 id="单向加密"><a href="#单向加密" class="headerlink" title="单向加密"></a>单向加密</h4><p>单向加密需要使用的标准命令为 dgst ，用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl dgst [-md5|-md4|-md2|-sha1|-sha|-mdc2|-ripemd160|-dss1] \</span><br><span class="line">[-c] [-d] [-hex] [-binary] [-out filename] [-sign filename] \</span><br><span class="line">[-keyform arg] [-passin arg] [-verify filename] [-prverify filename] \</span><br><span class="line">[-signature filename] [-hmac key] [file...]</span><br></pre></td></tr></table></figure>

<p>常用选项有：</p>
<p>[-md5|-md4|-md2|-sha1|-sha|-mdc2|-ripemd160|-dss1] ：指定一种加密算法</p>
<p>-out filename：将加密的内容保存到指定文件中</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[hyp@localhost ~]$ openssl dgst -md5 /etc/fstab</span><br><span class="line">MD5(/etc/fstab)= 90bdb6bf9d7e644cea6e7602913afb75</span><br><span class="line">[hyp@localhost ~]$ openssl dgst -md5 /etc/mtab</span><br><span class="line">MD5(/etc/mtab)= 1b963956716d73980eaec0f0f324180b</span><br></pre></td></tr></table></figure>

<p>单向加密除了 openssl dgst 工具还有：</p>
<p>md5sum，sha1sum，sha224sum，sha256sum ，sha384sum，sha512sum</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[hyp@localhost ~]$ md5sum /etc/fstab</span><br><span class="line">90bdb6bf9d7e644cea6e7602913afb75  /etc/fstab</span><br><span class="line">[hyp@localhost ~]$ sha512sum /etc/fstab</span><br><span class="line">f21432b91d805e877fff94a2b7ed91dde4f7dd008e7629a1ba97d47e07f3c25debc38934854bb4aeb8966952bb4f1165a684f319fb75fe5412e2ad246ec5bb54  /etc/fstab</span><br></pre></td></tr></table></figure>

<h4 id="生成密码"><a href="#生成密码" class="headerlink" title="生成密码"></a>生成密码</h4><p>生成密码需要使用的标准命令为 passwd ，用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl passwd [-crypt] [-1] [-apr1] [-salt string] [-in file] [-stdin] [-noverify] [-quiet] [-table] &#123;password&#125;</span><br></pre></td></tr></table></figure>

<p>常用选项有：</p>
<p>-1：使用md5加密算法</p>
<p>-salt string：加入随机数，最多8位随机数</p>
<p>-in file：对输入的文件内容进行加密</p>
<p>-stdion：对标准输入的内容进行加密</p>
<p>示例如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[hyp@localhost ~]$ openssl passwd  970603</span><br><span class="line">.F1Eg5Xr2f9Ak</span><br><span class="line">[hyp@localhost ~]$ openssl passwd  -salt 16  970603</span><br><span class="line">16K52.tSElFgg</span><br><span class="line">[hyp@localhost ~]$ openssl passwd  -salt 16  970603</span><br><span class="line">16K52.tSElFgg</span><br></pre></td></tr></table></figure>

<h4 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h4><p>生成随机数需要用到的标准命令为 rand ，用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rand [-out file] [-rand file(s)] [-base64] [-hex] num</span><br></pre></td></tr></table></figure>

<p>常用选项有：</p>
<p>-out file：将生成的随机数保存至指定文件中</p>
<p>-base64：使用base64 编码格式</p>
<p>-hex：使用16进制编码格式</p>
<p>示例如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[hyp@localhost ~]$ openssl rand -hex 2</span><br><span class="line">14d4</span><br><span class="line">[hyp@localhost ~]$ openssl rand -base64 2</span><br><span class="line">41c=</span><br></pre></td></tr></table></figure>

<h4 id="生成秘钥对"><a href="#生成秘钥对" class="headerlink" title="生成秘钥对"></a>生成秘钥对</h4><p>首先需要先使用 genrsa 标准命令生成私钥，然后再使用 rsa 标准命令从私钥中提取公钥。</p>
<p>genrsa 的用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa [-out filename] [-passout arg] [-des] [-des3] [-idea] [-f4] [-3] [-rand file(s)] [-engine id] [numbits]</span><br></pre></td></tr></table></figure>

<p>常用选项有：</p>
<p>-out filename：将生成的私钥保存至指定的文件中</p>
<p>-des|-des3|-idea：不同的加密算法</p>
<p>numbits：指定生成私钥的大小，默认是2048</p>
<p>一般情况下秘钥文件的权限一定要控制好，只能自己读写，因此可以使用 umask 命令设置生成的私钥权限，示例如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hyp@localhost ~]$ (umask 077; openssl genrsa -out rsa_pri.key 2048)</span><br><span class="line">Generating RSA private key, 2048 bit long modulus</span><br><span class="line">...................+++</span><br><span class="line">......................................................+++</span><br><span class="line">e is 65537 (0x10001)</span><br></pre></td></tr></table></figure>

<p>ras 的用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa [-inform PEM|NET|DER] [-outform PEM|NET|DER] [-in filename] [-passin arg] [-out filename] [-passout arg]</span><br><span class="line">       [-sgckey] [-des] [-des3] [-idea] [-text] [-noout] [-modulus] [-check] [-pubin] [-pubout] [-engine id]</span><br></pre></td></tr></table></figure>

<p>常用选项：</p>
<p>-in filename：指明私钥文件</p>
<p>-out filename：指明将提取出的公钥保存至指定文件中</p>
<p>-pubout：根据私钥提取出公钥</p>
<p>示例如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[hyp@localhost ~]$ openssl rsa -in rsa_pri.key  -out rsa_pub.key -pubout</span><br><span class="line">writing RSA key</span><br><span class="line">[hyp@localhost ~]$ cat rsa_pub.key</span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA6atn/OguE905kVkGsQLi</span><br><span class="line">fsNMw501ylNBG4f7ZfyJ88Iw8+lW7WC1/5bOZOXVt4z9AA+CfZlHDE8n4qUbPEOk</span><br><span class="line">k1k0sBhzkESwcEWDaykzcRNg4XjmUerDOkffLct6VxavYFMm4bni58E63NmjrM7e</span><br><span class="line">Wkz0T1lbDOo28b2KYS/tqxRZ7r8JrBxMPxJCbtpeAcZitfm/EqADwzdzPWpsZDmq</span><br><span class="line">r9gH19POhnOgvc180JetQM+MiA2+IlLSD9M5QCcGj+94gy847rnvqwtLm2XWP0ai</span><br><span class="line">PCeS3dUWW7ungDHymbAuCCR4qanyC+vQXQoCqamuDteFvsyikahdJoCWAMkoA8DJ</span><br><span class="line">LwIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>

<h4 id="创建CA和申请证书"><a href="#创建CA和申请证书" class="headerlink" title="创建CA和申请证书"></a>创建CA和申请证书</h4><p>使用openssl工具创建CA证书和申请证书时，需要先查看配置文件，因为配置文件中对证书的名称和存放位置等相关信息都做了定义，具体可参考 /etc/pki/tls/openssl.cnf 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. PKC：Public-Key Certificate，公钥证书，简称证书。</span><br><span class="line">2. CA：Certification Authority，认证机构。对证书进行管理，负责 1.生成密钥对、2. 注册公钥时对身份进行认证、3. 颁发证书、4. 作废证书。其中负责注册公钥和身份认证的，称为 RA（Registration Authority 注册机构）</span><br><span class="line">3. PKI：Public-Key Infrastructure，公钥基础设施，是为了更高效地运用公钥而制定的一系列规范和规格的总称。比较著名的有PKCS（Public-Key Cryptography Standards，公钥密码标准，由 RSA 公司制定）、X.509 等。PKI 是由使用者、认证机构 CA、仓库（保存证书的数据库）组成。</span><br><span class="line">CRL：Certificate Revocation List 证书作废清单，是 CA 宣布作废的证书一览表，会带有 CA 的数字签名。一般由处理证书的软件更新 CRL 表，并查询证书是否有效。</span><br><span class="line">4.证书的编码格式:pem,der</span><br></pre></td></tr></table></figure>

<p>  在要生成证书的目录下建立几个文件和文件夹，有./demoCA/ ./demoCA/newcerts/  ./demoCA/index.txt ./demoCA/serial，在serial文件中写入第一个序列号“01”</p>
<p>1.生成X509格式的CA自签名证书</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$openssl req -new -x509 -keyout ca.key -out ca.crt</span><br></pre></td></tr></table></figure>

<p>2.生成服务端的私钥(key文件)及csr文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$openssl genrsa -des3 -out server.key 1024</span><br><span class="line">$openssl req -new -key server.key -out server.csr</span><br></pre></td></tr></table></figure>

<p>3.生成客户端的私钥(key文件)及csr文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$openssl genrsa -des3 -out client.key 1024</span><br><span class="line">$openssl req -new -key client.key -out client.csr</span><br></pre></td></tr></table></figure>

<p>4.用生成的CA的证书为刚才生成的server.csr,client.csr文件签名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key</span><br><span class="line">$openssl ca -in client.csr -out client.crt -cert ca.crt -keyfile ca.key</span><br></pre></td></tr></table></figure>

<p>5.生成p12格式证书</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$openssl pkcs12 -export -inkey client.key -in client.crt -out client.pfx</span><br><span class="line">$openssl pkcs12 -export -inkey server.key -in server.crt -out server.pfx</span><br></pre></td></tr></table></figure>

<p>6.生成pem格式证书<br>有时需要用到pem格式的证书，可以用以下方式合并证书文件（crt）和私钥文件（key）来生成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cat client.crt client.key&gt; client.pem</span><br><span class="line">$cat server.crt server.key &gt; server.pem</span><br></pre></td></tr></table></figure>

<p>7.PFX文件转换为X509证书文件和RSA密钥文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$openssl pkcs12 -in server.pfx -nodes -out server.pem</span><br><span class="line">$openssl rsa -in server.pem -out server2.key</span><br><span class="line">$openssl x509 -in server.pem -out server2.crt</span><br></pre></td></tr></table></figure>

<p>这样生成服务端证书：ca.crt, server.key, server.crt, server.pem, server.pfx，客户端证书：ca.crt, client.key, client.crt, client.pem, client.pfx  </p>
<h4 id="吊销证书"><a href="#吊销证书" class="headerlink" title="吊销证书"></a>吊销证书</h4><p>吊销证书的步骤也是在CA服务器上执行的，以刚才新建的 httpd.crt 证书为例，吊销步骤如下：</p>
<p>第一步：在客户机上获取要吊销证书的 serial 和 subject 信息</p>
<p>第二步：根据客户机提交的 serial 和 subject 信息，对比其余本机数据库 index.txt 中存储的是否一致</p>
<p>第三步：执行吊销操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[hyp@localhost CA]$ sudo openssl ca -revoke /etc/pki/CA/newcerts/01.pem</span><br><span class="line">Using configuration from /etc/pki/tls/openssl.cnf</span><br><span class="line">Revoking Certificate 01.</span><br><span class="line">Data Base Updated</span><br></pre></td></tr></table></figure>

<p>第四步：生成吊销证书的吊销编号 （第一次吊销证书时执行）</p>
<p>]# echo 01 &gt; /etc/pki/CA/crlnumber</p>
<p>第五步：更新证书吊销列表</p>
<p>]# openssl ca -gencrl -out /etc/pki/CA/crl/ca.crl</p>
<p>查看 crl 文件命令：</p>
<p>]# openssl crl -in /etc/pki/CA/crl/ca.crl -noout -text</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.e-learn.cn/content/linux/1448064">openssl命令使用</a></p>
<h3 id="OpenSSH使用"><a href="#OpenSSH使用" class="headerlink" title="OpenSSH使用"></a>OpenSSH使用</h3><p>OpenSSH 是 SSH （Secure SHell） 协议的免费开源实现。SSH协议族可以用来进行远程控制， 或在计算机之间传送文件。而实现此功能的传统方式，如telnet(终端仿真协议)、 rcp ftp、 rlogin、rsh都是极为不安全的，并且会使用明文传送密码。OpenSSH提供了服务端后台程序和客户端工具，用来加密远程控制和文件传输过程中的数据，并由此来代替原来的类似服务。</p>
<p>OpenSSH服务，sshd，是一个典型的独立守护进程(standalone daemon)，但也可以根据需要通过网络守护进程(Internet Daemon)-inetd或Ineternet Daemon’s more modern-xinted加载。OpenSSH服务可以通过/etc/ssh/sshd_config文件进行配置。</p>
<p>程序主要包括了几个部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ssh</span><br><span class="line">	rlogin与Telnet的替代方案。</span><br><span class="line">scp、sftp</span><br><span class="line">	rcp的替代方案，将文件复制到其他电脑上。</span><br><span class="line">sshd</span><br><span class="line">	SSH服务器。</span><br><span class="line">ssh-keygen</span><br><span class="line">	产生RSA或DSA密钥，用来认证用。</span><br><span class="line">ssh-agent、ssh-add</span><br><span class="line">	帮助用户不需要每次都要输入密钥密码的工具。</span><br><span class="line">ssh-keyscan</span><br><span class="line">	扫描一群机器，并记录其公钥。</span><br></pre></td></tr></table></figure>

<p><strong>服务器端安装</strong></p>
<p>需要安装的软件:<br>openssh-server：服务器端<br>openssh：服务器端与客户端核心文件</p>
<p><strong>客户端安装</strong></p>
<p>需要安装的软件：<br>openssh：服务器端与客户端核心文件<br>openssh-clients : 客户端</p>
<p><strong>注意：</strong> 如果一台机器既要做客户端又要做服务器端，就需要在该系统中安装上述三个软件包；CentOS 7中默认已安装好上述三个软件包。</p>
<h4 id="免密远程登陆及免密远程拷贝设置"><a href="#免密远程登陆及免密远程拷贝设置" class="headerlink" title="免密远程登陆及免密远程拷贝设置"></a>免密远程登陆及免密远程拷贝设置</h4><p>为什么设置免密登录及远程拷贝？</p>
<p>方便操作，处理快速；<br>计算机集群中机器之间有频繁的数据交换需求。<br>设置方法：（假设A、B计算机要进行加密通信）</p>
<p>A计算机用户的命令行输入ssh-keygen –t rsa，生成密钥对；<br>若B计算机授权给A免密钥登录B，则将A计算机的公钥放入B计算机的authorized_keys文件中。</p>
<p>通俗理解设置：将计算机的信任关系与人之间的信任关系作类比。张三若信任李四，则表示李四在张三的受信任名单的列表中（类比A计算机的公钥放到B计算机的authorized_keys文件中）。</p>
<p>A计算机上操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">]# ssh-keygen -t rsa #默认就好</span><br><span class="line">#生成后复制id_rsa.pub里面的内容，使用PUTTY或其他远程连接工具，连接B计算机，</span><br><span class="line">#创建~/.ssh/authorized_keys，</span><br><span class="line">#使用vi ~/.ssh/authorized_keys，将复制公钥粘贴到该文件内,保存退出。</span><br></pre></td></tr></table></figure>

<p>B计算机上配置：</p>
<p>更改/etc/ssh/sshd_config文件中配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile      .ssh/authorized_keys</span><br><span class="line">PasswordAuthentication yes</span><br></pre></td></tr></table></figure>

<p>更改~/.ssh的权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hyp@localhost ~]$ sudo chmod 700 ~/.ssh</span><br><span class="line">[hyp@localhost ~]$ chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>这样A就可以无秘登录到B。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/03/25/Linux-%E5%AE%89%E5%85%A8-2/">https://pingxin0521.gitee.io/2019/03/25/Linux-%E5%AE%89%E5%85%A8-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E5%AE%89%E5%85%A8/">安全</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/03/25/%E5%B7%A5%E5%85%B7-MATLAB-1/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MATLAB入门</div></div></a></div><div class="next-post pull-right"><a href="/2019/03/24/Linux-%E5%9F%BA%E7%A1%80-11/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux-磁盘和文件系统管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/03/25/Linux-安全-3/" title="iptables和Firewalld防火墙"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-10-30</div><div class="title">iptables和Firewalld防火墙</div></div></a></div><div><a href="/2019/05/22/Linux-Ubuntu-4/" title="Ubuntu 点滴笔记"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-10-18</div><div class="title">Ubuntu 点滴笔记</div></div></a></div><div><a href="/2019/03/23/Linux-基础-12/" title="Linux-服务管理"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-04-03</div><div class="title">Linux-服务管理</div></div></a></div><div><a href="/2019/03/20/Linux-基础-5/" title="Linux-文本处理三剑客--grep"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-10-10</div><div class="title">Linux-文本处理三剑客--grep</div></div></a></div><div><a href="/2019/03/20/Linux-基础-6/" title="Linux-文本处理三剑客--sed"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-10-10</div><div class="title">Linux-文本处理三剑客--sed</div></div></a></div><div><a href="/2019/03/20/Linux-基础-7/" title="Linux-文本处理三剑客--awk"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-10-10</div><div class="title">Linux-文本处理三剑客--awk</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%AF%86%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">传输数据的机密性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">身份验证机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%AE%8C%E6%95%B4%E6%80%A7%E9%AA%8C%E8%AF%81"><span class="toc-number">2.3.</span> <span class="toc-text">消息完整性验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E7%AE%97%E6%B3%95%E4%BF%9D%E8%AF%81%E5%AF%86%E9%92%A5%E6%9C%AC%E8%BA%AB%E7%9A%84%E5%AE%89%E5%85%A8"><span class="toc-number">2.4.</span> <span class="toc-text">利用非对称密钥算法保证密钥本身的安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8PKI%E4%BF%9D%E8%AF%81%E5%85%AC%E9%92%A5%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%80%A7"><span class="toc-number">2.5.</span> <span class="toc-text">利用PKI保证公钥的真实性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">协议工作过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-SSL%E7%9A%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">3.1  SSL的分层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSL%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">SSL握手过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81server%E7%9A%84SSL%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">验证server的SSL握手过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81server%E5%92%8Cclient%E7%9A%84SSL%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">验证server和client的SSL握手过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E5%8E%9F%E6%9C%89%E4%BC%9A%E8%AF%9D%E7%9A%84SSL%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">恢复原有会话的SSL握手过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenSSL%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">OpenSSL使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">2.1.</span> <span class="toc-text">对称加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E5%8A%A0%E5%AF%86"><span class="toc-number">2.2.</span> <span class="toc-text">单向加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%AF%86%E7%A0%81"><span class="toc-number">2.3.</span> <span class="toc-text">生成密码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">生成随机数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E7%A7%98%E9%92%A5%E5%AF%B9"><span class="toc-number">2.5.</span> <span class="toc-text">生成秘钥对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BACA%E5%92%8C%E7%94%B3%E8%AF%B7%E8%AF%81%E4%B9%A6"><span class="toc-number">2.6.</span> <span class="toc-text">创建CA和申请证书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8A%E9%94%80%E8%AF%81%E4%B9%A6"><span class="toc-number">2.7.</span> <span class="toc-text">吊销证书</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenSSH%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">OpenSSH使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%8D%E5%AF%86%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%E5%8F%8A%E5%85%8D%E5%AF%86%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.1.</span> <span class="toc-text">免密远程登陆及免密远程拷贝设置</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
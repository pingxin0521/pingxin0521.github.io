<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java 网络编程（三） | 平心de小屋</title><meta name="keywords" content="Java,基础"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="多任务处理基本的TCP相应服务器是一次只能处理一个客户端请求，无法处理同时多个客户端请求，Java中多线程技术解决这一问题。多线程有两种方式：一是一客户一线程；二是线程池；">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 网络编程（三）">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/04/07/Java-%E5%9F%BA%E7%A1%80-7-3/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="多任务处理基本的TCP相应服务器是一次只能处理一个客户端请求，无法处理同时多个客户端请求，Java中多线程技术解决这一问题。多线程有两种方式：一是一客户一线程；二是线程池；">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg">
<meta property="article:published_time" content="2019-04-07T00:58:59.000Z">
<meta property="article:modified_time" content="2019-06-27T06:48:12.000Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/04/07/Java-%E5%9F%BA%E7%A1%80-7-3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 网络编程（三）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2019-06-27 14:48:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java 网络编程（三）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-04-07T00:58:59.000Z" title="发表于 2019-04-07 08:58:59">2019-04-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-06-27T06:48:12.000Z" title="更新于 2019-06-27 14:48:12">2019-06-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E5%9F%BA%E7%A1%80/">基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java 网络编程（三）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="多任务处理"><a href="#多任务处理" class="headerlink" title="多任务处理"></a>多任务处理</h4><p>基本的TCP相应服务器是一次只能处理一个客户端请求，无法处理同时多个客户端请求，Java中多线程技术解决这一问题。多线程有两种方式：一是一客户一线程；二是线程池；</p>
<span id="more"></span>

<h5 id="服务器协议"><a href="#服务器协议" class="headerlink" title="服务器协议"></a>服务器协议</h5><p>既然我们将要介组的多任务服务器方法与特定的客户/服务器协议相互独立，我们希望能够实现一个同时满足两者的协议。EchoProtocol中给出了回显协议的代码，这个类的静态方法handleEchoCI1ent()中封装了对每个客户端的处理过程。除添加了写日志功能外，这段代码与TCPEchoServer.Java中的连接处理部分几乎完全一致。该方法的参数客户端Socket实例和Logger对象的引用，EchoProtocol类实现了Runnable接口（run()方法只根锯该实例的Socket和Logger引用，简单地调用harulleEchoCIfenU)方法）,因此我们可以戗建一个独立执行run()方法的线程。另外，服务器端的协议执行过程可以通过直接调用这个静态方法实现（为其传入Socket和Logger实例的引用）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoProtocol</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFSIZE = <span class="number">32</span>; <span class="comment">// Size (in bytes) of I/O buffer</span></span><br><span class="line">  <span class="keyword">private</span> Socket clntSock;               <span class="comment">// Socket connect to client</span></span><br><span class="line">  <span class="keyword">private</span> Logger logger;                 <span class="comment">// Server logger</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">EchoProtocol</span><span class="params">(Socket clntSock, Logger logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.clntSock = clntSock;</span><br><span class="line">    <span class="keyword">this</span>.logger = logger;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleEchoClient</span><span class="params">(Socket clntSock, Logger logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Get the input and output I/O streams from socket</span></span><br><span class="line">      InputStream in = clntSock.getInputStream();</span><br><span class="line">      OutputStream out = clntSock.getOutputStream();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> recvMsgSize; <span class="comment">// Size of received message</span></span><br><span class="line">      <span class="keyword">int</span> totalBytesEchoed = <span class="number">0</span>; <span class="comment">// Bytes received from client</span></span><br><span class="line">      <span class="keyword">byte</span>[] echoBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFSIZE]; <span class="comment">// Receive Buffer</span></span><br><span class="line">      <span class="comment">// Receive until client closes connection, indicated by -1</span></span><br><span class="line">      <span class="keyword">while</span> ((recvMsgSize = in.read(echoBuffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        out.write(echoBuffer, <span class="number">0</span>, recvMsgSize);</span><br><span class="line">        totalBytesEchoed += recvMsgSize;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      logger.info(<span class="string">&quot;Client &quot;</span> + clntSock.getRemoteSocketAddress() + <span class="string">&quot;, echoed &quot;</span></span><br><span class="line">          + totalBytesEchoed + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      logger.log(Level.WARNING, <span class="string">&quot;Exception in echo protocol&quot;</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        clntSock.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    handleEchoClient(clntSock, logger);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><ul>
<li><p>一客户一线程：即为每个连接创建一个线程来处理，服务器端会循环执行，监听指定端口的连接，反复接收来自客户端的连接请求，并为每个连接创建一个新线程来对其处理。</p>
<p>缺点：一客户一线程的方式虽然处理可以多个客户端请求，但每个新线程都会消耗系统资源（如CPU）,并且每个线程独有自己的数据结构（如栈）也要消耗系统内存。另外一个线程阻塞是，JVM会保存其状态，选择另外一个线程运行，并在上下文转换时恢复阻塞线程的状态。随着线程数的增加，线程将消耗越来越多的资源。这会导致系统将花费更多时间来处理上下文的转换和线程管理，更少的时间来对连接服务，加入额外的线程实际上可能会增加客户端总服务时间。</p>
<p>解决：通过限制总线程数并重复使用线程来避免一客户一线程的缺陷。</p>
<p>TCPEchoServerThread.Java实现了这种一客户一线程的服务结构。它与迭代服务器非常相似，也用一个循环来接收和处理客户的请求。主要不同点在于这种服务器为每个连接创建了一个新的线程来处理，而不是直接处理。这是可行的，因为EchoProtocol类实现了Runnable接口）因此，当多个户端几乎同时连接服务器时，后请求的客户端不需要等服务器对前面的客户端处理结束后才获得服务，相反，它们看起来是同时接受的服务（虽然比对单一客户端进行服务要稍微慢一些)，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPEchoServerThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123; <span class="comment">// Test for correct # of args</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Parameter(s): &lt;Port&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> echoServPort = Integer.parseInt(args[<span class="number">0</span>]); <span class="comment">// Server port</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a server socket to accept client connection requests</span></span><br><span class="line">    ServerSocket servSock = <span class="keyword">new</span> ServerSocket(echoServPort);</span><br><span class="line"></span><br><span class="line">    Logger logger = Logger.getLogger(<span class="string">&quot;practical&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run forever, accepting and spawning a thread for each connection</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      Socket clntSock = servSock.accept(); <span class="comment">// Block waiting for connection</span></span><br><span class="line">      <span class="comment">// Spawn thread to handle new connection</span></span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> EchoProtocol(clntSock, logger));</span><br><span class="line">      thread.start();</span><br><span class="line">      logger.info(<span class="string">&quot;Created and started Thread &quot;</span> + thread.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* NOT REACHED */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>使用线程池：与为每个线程创建新的线程不同，服务器在启动时创建固定数量的线程组成的线程池。当有一个客户端请求过来时，线程池将分配一个线程处理，线程在处理完请求后将会返回线程池，为下一次请求处理做好准备。如果连接请求到达服务器端，线程池中所有的线程都已被占用，它们则在一个队列中等待，直到有空闲的线程可用。</p>
<p>线程池服务端具体实现的步骤：</p>
<ol>
<li><p>服务器端创建一个ServerSocket实例。</p>
</li>
<li><p>创建N个线程，每个线程都反复循环，从（共享的）ServerSocket实例中接收客户端连接。当多个线程同时调用同一个ServerSocket实例的accept()方法将会阻塞等待，直到一个新连接创建成功。</p>
</li>
<li><p>新建立连接对应Socket实例则只在选中的线程中返回。其他线程将阻塞，直到成功建立下一个连接和选中下一个幸运的线程。</p>
</li>
</ol>
<p>缺点：创建的线程池太少，客户端可能等待很长时间才能获取服务，线程池大小不能根据客户端请求数量进行调整。</p>
<p>解决：Java中提供一个调度工具（系统管理调用接口Executor），可以在系统负载时扩展线程池的大小，负载较轻时缩减线程池的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPEchoServerPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123; <span class="comment">// Test for correct # of args</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Parameter(s): &lt;Port&gt; &lt;Threads&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> echoServPort = Integer.parseInt(args[<span class="number">0</span>]); <span class="comment">// Server port</span></span><br><span class="line">    <span class="keyword">int</span> threadPoolSize = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a server socket to accept client connection requests</span></span><br><span class="line">    <span class="keyword">final</span> ServerSocket servSock = <span class="keyword">new</span> ServerSocket(echoServPort);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Logger logger = Logger.getLogger(<span class="string">&quot;practical&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spawn a fixed number of threads to service clients</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadPoolSize; i++) &#123;</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              Socket clntSock = servSock.accept(); <span class="comment">// Wait for a connection</span></span><br><span class="line">              EchoProtocol.handleEchoClient(clntSock, logger); <span class="comment">// Handle it</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">              logger.log(Level.WARNING, <span class="string">&quot;Client accept failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      thread.start();</span><br><span class="line">      logger.info(<span class="string">&quot;Created and started Thread = &quot;</span> + thread.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>系统管理调度：接口Executor</p>
<p>Executor接口代表了一个根据某种策略来执行Runnable实例的对象，其中包含了排队和调度的细节，或者如何选择要执行的任务。Executor接口只定义了一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java中内置了大量的Executor接口实现，很简单使用，也可以进行扩展性配置。其中一些还提供了处理维护线程等繁琐细节的功能。ExecutorService接口继承于Executor接口，提供了一个更高级的工具来关闭服务器，包括正常关闭和突然关闭。ExecutorService还允许在完成任务后返回一个结果，这需要用到Callable接口，它和Runnable接口很像，只是多了一个返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPEchoServerExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123; <span class="comment">// Test for correct # of args</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Parameter(s): &lt;Port&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> echoServPort = Integer.parseInt(args[<span class="number">0</span>]); <span class="comment">// Server port</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a server socket to accept client connection requests</span></span><br><span class="line">    ServerSocket servSock = <span class="keyword">new</span> ServerSocket(echoServPort);</span><br><span class="line"></span><br><span class="line">    Logger logger = Logger.getLogger(<span class="string">&quot;practical&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Executor service = Executors.newCachedThreadPool();  <span class="comment">// Dispatch svc</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run forever, accepting and spawning threads to service each connection</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      Socket clntSock = servSock.accept(); <span class="comment">// Block waiting for connection</span></span><br><span class="line">      service.execute(<span class="keyword">new</span> EchoProtocol(clntSock, logger));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* NOT REACHED */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="阻塞和超时"><a href="#阻塞和超时" class="headerlink" title="阻塞和超时"></a>阻塞和超时</h4><p>socket的调用可能存多种原因而阻塞。</p>
<ol>
<li><p>read()，receive()方法在没有数据可读时会阻塞。ServerSocket的accept()方法和Socket构造方法会阻塞等待，直到建立连接。</p>
<p>解决:使用socket,ServerSocket,以及DatagramSocket类的setSoTimeout()方法，来设置其阻塞的最长时间。指定时间内方法没有返回将会抛出异常InterruptedIOException。对于Socket实例，可以在read()方法前，在套接字的InputStream上调用available()方法检测是否有可读数据。</p>
</li>
<li><p>连接和写数据</p>
<p>Socket类的构造函数会尝试根据参数中指定的主机和端口来建立连接，并阻塞等待，直到连接成功建立或发生了系统定义的超时。不幸的是，系统定义的超时时间很长，而Java又没有提供任何缩短它的方法。要改变这种情况，可以使用Socket类的无参数构造函数，它返回的是一个没有建立连接的Socket实例。需要建立连接时，调用该实例的connect()方法，并指定一个远程终端和超时时间。</p>
<p>write()方法调用也会阻塞等待，直到最后一个字节成功写入到了TCP实现的本地缓存中。如果可用的缓存空间比要写入的数据小，在write()方法调用返回前，必须把一些数据成功传输到连接的另一端。</p>
</li>
<li><p>限制客户端的时间</p>
<p>通过服务期限和当前计算出截止时间，每次调用read()结束后，重新计算当前和截止时间的差值，即服务截止时间，并将套接字的超时时间设置为该剩余时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeLimitEchoProtocol</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFSIZE = <span class="number">32</span>;  <span class="comment">// Size (bytes) buffer</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TIMELIMIT = <span class="string">&quot;10000&quot;</span>;  <span class="comment">// Default limit (ms)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TIMELIMITPROP = <span class="string">&quot;Timelimit&quot;</span>;  <span class="comment">// Thread property</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> timelimit;</span><br><span class="line">  <span class="keyword">private</span> Socket clntSock;</span><br><span class="line">  <span class="keyword">private</span> Logger logger;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TimeLimitEchoProtocol</span><span class="params">(Socket clntSock, Logger logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.clntSock = clntSock;</span><br><span class="line">    <span class="keyword">this</span>.logger = logger;</span><br><span class="line">    <span class="comment">// Get the time limit from the System properties or take the default</span></span><br><span class="line">    timelimit = Integer.parseInt(System.getProperty(TIMELIMITPROP,TIMELIMIT));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleEchoClient</span><span class="params">(Socket clntSock, Logger logger)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Get the input and output I/O streams from socket</span></span><br><span class="line">      InputStream in = clntSock.getInputStream();</span><br><span class="line">      OutputStream out = clntSock.getOutputStream();</span><br><span class="line">      <span class="keyword">int</span> recvMsgSize;                        <span class="comment">// Size of received message</span></span><br><span class="line">      <span class="keyword">int</span> totalBytesEchoed = <span class="number">0</span>;               <span class="comment">// Bytes received from client</span></span><br><span class="line">      <span class="keyword">byte</span>[] echoBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFSIZE];  <span class="comment">// Receive buffer</span></span><br><span class="line">      <span class="keyword">long</span> endTime = System.currentTimeMillis() + timelimit;</span><br><span class="line">      <span class="keyword">int</span> timeBoundMillis = timelimit;</span><br><span class="line"></span><br><span class="line">      clntSock.setSoTimeout(timeBoundMillis);</span><br><span class="line">      <span class="comment">// Receive until client closes connection, indicated by -1</span></span><br><span class="line">      <span class="keyword">while</span> ((timeBoundMillis &gt; <span class="number">0</span>) &amp;&amp;     <span class="comment">// catch zero values</span></span><br><span class="line">             ((recvMsgSize = in.read(echoBuffer)) != -<span class="number">1</span>)) &#123;</span><br><span class="line">        out.write(echoBuffer, <span class="number">0</span>, recvMsgSize);</span><br><span class="line">        totalBytesEchoed += recvMsgSize;</span><br><span class="line">        timeBoundMillis = (<span class="keyword">int</span>) (endTime - System.currentTimeMillis()) ;</span><br><span class="line">        clntSock.setSoTimeout(timeBoundMillis);</span><br><span class="line">      &#125;</span><br><span class="line">      logger.info(<span class="string">&quot;Client &quot;</span> + clntSock.getRemoteSocketAddress() +</span><br><span class="line">		  <span class="string">&quot;, echoed &quot;</span> + totalBytesEchoed + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      logger.log(Level.WARNING, <span class="string">&quot;Exception in echo protocol&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    handleEchoClient(<span class="keyword">this</span>.clntSock, <span class="keyword">this</span>.logger);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="多接受者"><a href="#多接受者" class="headerlink" title="多接受者"></a>多接受者</h4><ol>
<li><p>广播和多播：TCP套接字中客户端只能接收和发送指定服务器端过来的数据，这种一对一的通信方式叫单播，而UDP套接字可以容许一个发送端和多个接收端情况，一对多的类型有：广播和多播。</p>
<ul>
<li><p>广播：本地网络中所有的主机都会接收到一份数据副本。IPv4广播地址（255.255.255.255）将消息发送到同一个广播网络中上的所有主机，本地广播信息不回被路由器转发。广播不能使用连接，有些操作系统不支持普通用户进行广播操作。</p>
</li>
<li><p>多播：网络只分发数据给想要接收数据的多播地址的主机。一个多播地址指示了一组接收者，IP协议的设计者为多播分配了一定范围的地址空间，IPv4中多播地址是224.0.0.0到239.255.255.255，IPv6中多播地址是FF开头的地址。多播报文会初始化一个TTL值（Time To Live，生命周期），当存在路由器转发便会减1，TTL值为0时，丢弃该数据报文。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.MulticastSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoteMulticastSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANDIDATEID = <span class="number">475</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((args.length &lt; <span class="number">2</span>) || (args.length &gt; <span class="number">3</span>)) &#123; <span class="comment">// Test # of args</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Parameter(s): &lt;Multicast Addr&gt; &lt;Port&gt; [&lt;TTL&gt;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InetAddress destAddr = InetAddress.getByName(args[<span class="number">0</span>]); <span class="comment">// Destination</span></span><br><span class="line">    <span class="keyword">if</span> (!destAddr.isMulticastAddress()) &#123; <span class="comment">// Test if multicast address</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Not a multicast address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> destPort = Integer.parseInt(args[<span class="number">1</span>]); <span class="comment">// Destination port</span></span><br><span class="line">    <span class="keyword">int</span> TTL = (args.length == <span class="number">3</span>) ? Integer.parseInt(args[<span class="number">2</span>]) : <span class="number">1</span>; <span class="comment">// Set TTL</span></span><br><span class="line"></span><br><span class="line">    MulticastSocket sock = <span class="keyword">new</span> MulticastSocket();</span><br><span class="line">    sock.setTimeToLive(TTL); <span class="comment">// Set TTL for all datagrams</span></span><br><span class="line">    </span><br><span class="line">    VoteMsgCoder coder = <span class="keyword">new</span> VoteMsgTextCoder();</span><br><span class="line">    </span><br><span class="line">    VoteMsg vote = <span class="keyword">new</span> VoteMsg(<span class="keyword">true</span>, <span class="keyword">true</span>, CANDIDATEID, <span class="number">1000001L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and send a datagram</span></span><br><span class="line">    <span class="keyword">byte</span>[] msg = coder.toWire(vote);</span><br><span class="line">    DatagramPacket message = <span class="keyword">new</span> DatagramPacket(msg, msg.length, destAddr, destPort);</span><br><span class="line">    System.out.println(<span class="string">&quot;Sending Text-Encoded Request (&quot;</span> + msg.length + <span class="string">&quot; bytes): &quot;</span>);</span><br><span class="line">    System.out.println(vote);</span><br><span class="line">    sock.send(message);</span><br><span class="line"></span><br><span class="line">    sock.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.MulticastSocket;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoteMulticastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123; <span class="comment">// Test for correct # of args</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Parameter(s): &lt;Multicast Addr&gt; &lt;Port&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InetAddress address = InetAddress.getByName(args[<span class="number">0</span>]); <span class="comment">// Multicast address</span></span><br><span class="line">    <span class="keyword">if</span> (!address.isMulticastAddress()) &#123; <span class="comment">// Test if multicast address</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Not a multicast address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]); <span class="comment">// Multicast port</span></span><br><span class="line">    MulticastSocket sock = <span class="keyword">new</span> MulticastSocket(port); <span class="comment">// for receiving</span></span><br><span class="line">    sock.joinGroup(address); <span class="comment">// Join the multicast group</span></span><br><span class="line"></span><br><span class="line">    VoteMsgTextCoder coder = <span class="keyword">new</span> VoteMsgTextCoder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Receive a datagram</span></span><br><span class="line">    DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[VoteMsgTextCoder.MAX_WIRE_LENGTH],</span><br><span class="line">        VoteMsgTextCoder.MAX_WIRE_LENGTH);</span><br><span class="line">    sock.receive(packet);</span><br><span class="line"></span><br><span class="line">    VoteMsg vote = coder.fromWire(Arrays.copyOfRange(packet.getData(), <span class="number">0</span>, packet</span><br><span class="line">        .getLength()));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Received Text-Encoded Request (&quot;</span> + packet.getLength()</span><br><span class="line">        + <span class="string">&quot; bytes): &quot;</span>);</span><br><span class="line">    System.out.println(vote);</span><br><span class="line"></span><br><span class="line">    sock.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Keep-Alive:TCP协议提供了一种Keep-alive机制，发送端和接收端一段时间内没有数据交换时，发送端会向终端发送探测消息，终端如果处于活跃状态会回复一个确认消息。几次尝试后依然没有收到终端消息，则会终止发送探测消息，关闭套接字，下次IO操作时会抛出异常。</p>
</li>
<li><p>发送和接收缓存区的大小：当创建了Socket或者DatagramSocket实例的时候，操作系统就必须为其分配缓存区以存放接收的和要发送的数据。方法setReceiveBufferSize(int size)和setSendBufferSize(int size);</p>
</li>
<li><p>超时：很多IO操作如果不能立即完成就会阻塞等待，读操作会阻塞等待直到至少一个字节可读；接收操作将阻塞等待直到成功建立连接。通过调用setSoTimeout()方法设置读，接收数据以及accept()方法的最长阻塞时间。</p>
</li>
<li><p>地址重用：某些情况下，希望能将多个套接字绑定到同一个套接字地址，对于UDP多播情况，同一个主机上可能有多个应用程序加入相同的多播组。对于TCP来说，当一个连接关闭后，通信的一端必须在“Time-Wait”状态上等一段时间，以对传输途中丢失的数据包进行清理，但通信终端可能无法等待Time-Wait结束。这两种情况需要能够与正在使用的地址进行绑定的能力，实现地址的重用。</p>
</li>
<li><p>消除缓冲延迟：TCP协议将数据缓存起来直到足够多时一次发送，以避免发送过小的数据包而浪费网络资源。虽然这个功能有利于网络，但是应用程序可能对所造成的缓冲延迟无法容忍，可以禁用缓存功能，调用方法setTcpNoDelay(true).</p>
</li>
<li><p>紧急数据：TCP协议中包含了紧急数据的概念，如果需要发送一条紧急数据，但是前面已经有很多其他数据，要求能够绕过这些常规数据（频道外数据）。但Java中紧急数据几乎没有什么用，因为常规数据与紧急数据顺序混在一起，接收者无法区别。</p>
</li>
<li><p>关闭后停留：调用套接字的close()方法后，即使套接字的缓冲区中还存在没有发送的数据，它也会立即返回。这样不发送完所有数可能导致的问题是主机将在后面的某个时刻发生故障。其实可以选择然close()方法“停留”或者阻塞一段时间，直到发送所有数据都已经发送并确认，或者发生了超时。调用方法setSoLinger(boolean on, int linger)。</p>
</li>
<li><p>广播许可：一些操作系统要求显式地对广播许可进行请求，可以对广播许可进行控制。调用方法，setBroadcast（true）,true表示允许广播</p>
</li>
<li><p>通信等级：有的网络对满足服务条件的数据报提供了增强的服务或者额外的保险。一个数据报的通信登记由数据包在网络中传输时其内部的一个值来指定。但是通信等级会收到网络提供者的限制，不能保证这项功能可用。（方法setTrafficClass(int tc)）</p>
</li>
<li><p>基于性能的协议选择：TCP协议不是套接字唯一可选的协议，Java允许开发者根据不同的性能特征对于应用程序的重要程序，为具体实现给出建议，底层网络系统可能会根据这些建议，在一组能够提供同等的数据流服务，同时有具有不同的性能特征的不同协议中做出选择。方法setPerformancePreferences(int connectionTime,int latency,int bandwidth)设置连接时间，延迟和带宽，底层会根据这些参数设置选择合适的协议。</p>
</li>
<li><p>关闭连接：网络协议通常明确指定了谁来关闭连接。但直接调用Socket的close()将会同时终止输出和输入两个方向的数据流，如客户端发送完数据后调用close()方法就会导致接收不到数据，需要一种方法来告诉连接的另一端我已经发送完所有数据，并且保持能够接收数据的能力。套接字里面就提供了这样的功能，Socket类的shutdonwInput()和shutdownOutput()方法能够将输入输出流单独关闭。</p>
<ul>
<li><p>调用shutdownInput()后，套接字的输入流将无法使用，任何没有发送的数据都将被丢弃，任何想从套接字的输入流读取数据的操作都将返回-1。</p>
</li>
<li><p>调用shutdownOutput()方法时，套接字的输出流将无法再发送数据，任何尝试向输出流写数据的操作都将抛出异常IOException异常。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/27/5d145d77082d971237.png"></p>
</li>
</ul>
</li>
</ol>
<p>下面考虑另一种协议：假设你需要一个压缩服务器，将接收到的字节流压缩后，发回给客户端。这种情况下应该由哪一端来关闭连接呢？</p>
<p>由于从客户端发来的字节流的长度是任意的，客户端需要关闭连接以通知服务器要压缩的字节流已经发送完毕，那么客户端应该什么时候调用close()方法呢？</p>
<p>如果客户端在其发送完最后一个字节后立即调用套接字的c1ose(),它将无法接收到压缩后数据的最后一些字节，或许客户端可以像回显协议那样，在接收完所有压缩后的数据才关闭连接，但不幸的是，这样一来服务器和客户端都不知道到底有多少数据要接收，因此这也不可行。我们需要一种方法来告诉连接的另一端“我已经发送完所有数据”同时还要保持接收数据的能力。</p>
<p>幸运的是套接字提供了一种实现这个功能的方法，Socket类的shutdownInput()和shutdownOutput()方法能够将綸入输出流相互独立地关闭。调用shutdownInput()后，套接字的输人流将无法使用。任何没有发送的数据都将毫无提示地被丢弃，任何想从套接字的输人流读取数据的搡作都将返回-1，当Socket调用shutdownOutputO方法后，套接字的输出流将无法再发送数据，任何尝试向输出流写数据的操作都将抛出一个IOExceptlon异常，在调用shutdownOutput()之前写出的敫据可能能够被远程套接字读取，之后，在远程套接字输入流上的读操作将返回应用程序调用shutdownOutputO后还能继续从套接字读取数据，类似的，在调用shutdownlnputO后也能够继续写数据。</p>
<p>在压缩协议中，客户端向服务器发送待压缩的字节，发送完成后调用shutdownOutput()关闭输出流，并从服务器读取压缩后的字节流，脤务器反复地获取未压缩的数据，并将压缩后的数据发回给客户端，直到客户端执行了停机操作，导致脤务器的read操作返回-1，这表示数据流的结束，然后脤务器关闭连接并退出。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/06/27/5d145ec99b8f675751.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* WARNING: this code can deadlock if a large file (more than a few</span></span><br><span class="line"><span class="comment"> * 10&#x27;s of thousands of bytes) is sent.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompressClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFSIZE = <span class="number">256</span>;  <span class="comment">// Size of read buffer</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.length != <span class="number">3</span>) &#123; <span class="comment">// Test for correct # of args</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Parameter(s): &lt;Server&gt; &lt;Port&gt; &lt;File&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String server = args[<span class="number">0</span>];               <span class="comment">// Server name or IP address</span></span><br><span class="line">    <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);  <span class="comment">// Server port</span></span><br><span class="line">    String filename = args[<span class="number">2</span>];             <span class="comment">// File to read data from</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open input and output file (named input.gz)</span></span><br><span class="line">    FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line">    FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(filename + <span class="string">&quot;.gz&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Create socket connected to server on specified port</span></span><br><span class="line">    Socket sock = <span class="keyword">new</span> Socket(server, port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send uncompressed byte stream to server</span></span><br><span class="line">    sendBytes(sock, fileIn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Receive compressed byte stream from server</span></span><br><span class="line">    InputStream sockIn = sock.getInputStream();</span><br><span class="line">    <span class="keyword">int</span> bytesRead;                      <span class="comment">// Number of bytes read</span></span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFSIZE];  <span class="comment">// Byte buffer</span></span><br><span class="line">    <span class="keyword">while</span> ((bytesRead = sockIn.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">      fileOut.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">      System.out.print(<span class="string">&quot;R&quot;</span>);   <span class="comment">// Reading progress indicator</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();      <span class="comment">// End progress indicator line</span></span><br><span class="line"></span><br><span class="line">    sock.close();     <span class="comment">// Close the socket and its streams</span></span><br><span class="line">    fileIn.close();   <span class="comment">// Close file streams</span></span><br><span class="line">    fileOut.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendBytes</span><span class="params">(Socket sock, InputStream fileIn)</span> </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    OutputStream sockOut = sock.getOutputStream();</span><br><span class="line">    <span class="keyword">int</span> bytesRead;                      <span class="comment">// Number of bytes read</span></span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFSIZE];  <span class="comment">// Byte buffer</span></span><br><span class="line">    <span class="keyword">while</span> ((bytesRead = fileIn.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">      sockOut.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">      System.out.print(<span class="string">&quot;W&quot;</span>);   <span class="comment">// Writing progress indicator</span></span><br><span class="line">    &#125;</span><br><span class="line">    sock.shutdownOutput();     <span class="comment">// Finished sending</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>压缩协议</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.GZIPOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompressProtocol</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFSIZE = <span class="number">1024</span>;   <span class="comment">// Size of receive buffer</span></span><br><span class="line">  <span class="keyword">private</span> Socket clntSock;</span><br><span class="line">  <span class="keyword">private</span> Logger logger;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CompressProtocol</span><span class="params">(Socket clntSock, Logger logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.clntSock = clntSock;</span><br><span class="line">    <span class="keyword">this</span>.logger = logger;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCompressClient</span><span class="params">(Socket clntSock, Logger logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Get the input and output streams from socket</span></span><br><span class="line">      InputStream in = clntSock.getInputStream();</span><br><span class="line">      GZIPOutputStream out = <span class="keyword">new</span> GZIPOutputStream(clntSock.getOutputStream());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFSIZE];   <span class="comment">// Allocate read/write buffer</span></span><br><span class="line">      <span class="keyword">int</span> bytesRead;                       <span class="comment">// Number of bytes read</span></span><br><span class="line">      <span class="comment">// Receive until client closes connection, indicated by -1 return</span></span><br><span class="line">      <span class="keyword">while</span> ((bytesRead = in.read(buffer)) != -<span class="number">1</span>)</span><br><span class="line">        out.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">      out.finish();      <span class="comment">// Flush bytes from GZIPOutputStream</span></span><br><span class="line"></span><br><span class="line">      logger.info(<span class="string">&quot;Client &quot;</span> + clntSock.getRemoteSocketAddress() + <span class="string">&quot; finished&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      logger.log(Level.WARNING, <span class="string">&quot;Exception in echo protocol&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;  <span class="comment">// Close socket</span></span><br><span class="line">      clntSock.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      logger.info(<span class="string">&quot;Exception = &quot;</span> +  e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    handleCompressClient(<span class="keyword">this</span>.clntSock, <span class="keyword">this</span>.logger);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO使用请参看<a target="_blank" rel="noopener" href="https://hanyunpeng0521.github.io/2019/04/Java-%E9%AB%98%E7%BA%A7-3/">NIO章节</a></p>
<p>示例：</p>
<p>协议接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TCPProtocol</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EchoSelector协议实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoSelectorProtocol</span> <span class="keyword">implements</span> <span class="title">TCPProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> bufSize; <span class="comment">// Size of I/O buffer</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">EchoSelectorProtocol</span><span class="params">(<span class="keyword">int</span> bufSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bufSize = bufSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SocketChannel clntChan = ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">    clntChan.configureBlocking(<span class="keyword">false</span>); <span class="comment">// Must be nonblocking to register</span></span><br><span class="line">    <span class="comment">// Register the selector with new channel for read and attach byte buffer</span></span><br><span class="line">    clntChan.register(key.selector(), SelectionKey.OP_READ, ByteBuffer</span><br><span class="line">        .allocate(bufSize));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Client socket channel has pending data</span></span><br><span class="line">    SocketChannel clntChan = (SocketChannel) key.channel();</span><br><span class="line">    ByteBuffer buf = (ByteBuffer) key.attachment();</span><br><span class="line">    <span class="keyword">long</span> bytesRead = clntChan.read(buf);</span><br><span class="line">    <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123; <span class="comment">// Did the other end close?</span></span><br><span class="line">      clntChan.close();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Indicate via key that reading/writing are both of interest now.</span></span><br><span class="line">      key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Channel is available for writing, and key is valid (i.e., client channel</span></span><br><span class="line"><span class="comment">     * not closed).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// Retrieve data read earlier</span></span><br><span class="line">    ByteBuffer buf = (ByteBuffer) key.attachment();</span><br><span class="line">    buf.flip(); <span class="comment">// Prepare buffer for writing</span></span><br><span class="line">    SocketChannel clntChan = (SocketChannel) key.channel();</span><br><span class="line">    clntChan.write(buf);</span><br><span class="line">    <span class="keyword">if</span> (!buf.hasRemaining()) &#123; <span class="comment">// Buffer completely written?</span></span><br><span class="line">      <span class="comment">// Nothing left, so no longer interested in writes</span></span><br><span class="line">      key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">    &#125;</span><br><span class="line">    buf.compact(); <span class="comment">// Make room for more data to be read in</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TCP的非阻塞客户端实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPEchoClientNonblocking</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((args.length &lt; <span class="number">2</span>) || (args.length &gt; <span class="number">3</span>)) <span class="comment">// Test for correct # of args</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Parameter(s): &lt;Server&gt; &lt;Word&gt; [&lt;Port&gt;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String server = args[<span class="number">0</span>]; <span class="comment">// Server name or IP address</span></span><br><span class="line">    <span class="comment">// Convert input String to bytes using the default charset</span></span><br><span class="line">    <span class="keyword">byte</span>[] argument = args[<span class="number">1</span>].getBytes();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> servPort = (args.length == <span class="number">3</span>) ? Integer.parseInt(args[<span class="number">2</span>]) : <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create channel and set to nonblocking</span></span><br><span class="line">    SocketChannel clntChan = SocketChannel.open();</span><br><span class="line">    clntChan.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initiate connection to server and repeatedly poll until complete</span></span><br><span class="line">    <span class="keyword">if</span> (!clntChan.connect(<span class="keyword">new</span> InetSocketAddress(server, servPort))) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!clntChan.finishConnect()) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;.&quot;</span>);  <span class="comment">// Do something else</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ByteBuffer writeBuf = ByteBuffer.wrap(argument);</span><br><span class="line">    ByteBuffer readBuf = ByteBuffer.allocate(argument.length);</span><br><span class="line">    <span class="keyword">int</span> totalBytesRcvd = <span class="number">0</span>; <span class="comment">// Total bytes received so far</span></span><br><span class="line">    <span class="keyword">int</span> bytesRcvd; <span class="comment">// Bytes received in last read</span></span><br><span class="line">    <span class="keyword">while</span> (totalBytesRcvd &lt; argument.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (writeBuf.hasRemaining()) &#123;</span><br><span class="line">        clntChan.write(writeBuf);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((bytesRcvd = clntChan.read(readBuf)) == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">&quot;Connection closed prematurely&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      totalBytesRcvd += bytesRcvd;</span><br><span class="line">      System.out.print(<span class="string">&quot;.&quot;</span>);   <span class="comment">// Do something else</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Received: &quot;</span> +  <span class="comment">// convert to String per default charset</span></span><br><span class="line">         <span class="keyword">new</span> String(readBuf.array(), <span class="number">0</span>, totalBytesRcvd));</span><br><span class="line">    clntChan.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TCP的Selector服务端实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServerSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFSIZE = <span class="number">256</span>;  <span class="comment">// Buffer size (bytes)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">3000</span>; <span class="comment">// Wait timeout (milliseconds)</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.length &lt; <span class="number">1</span>) &#123; <span class="comment">// Test for correct # of args</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Parameter(s): &lt;Port&gt; ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a selector to multiplex listening sockets and connections</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create listening socket channel for each port and register selector</span></span><br><span class="line">    <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">      ServerSocketChannel listnChannel = ServerSocketChannel.open();</span><br><span class="line">      listnChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(Integer.parseInt(arg)));</span><br><span class="line">      listnChannel.configureBlocking(<span class="keyword">false</span>); <span class="comment">// must be nonblocking to register</span></span><br><span class="line">      <span class="comment">// Register selector with channel. The returned key is ignored</span></span><br><span class="line">      listnChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a handler that will implement the protocol</span></span><br><span class="line">    TCPProtocol protocol = <span class="keyword">new</span> EchoSelectorProtocol(BUFSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// Run forever, processing available I/O operations</span></span><br><span class="line">      <span class="comment">// Wait for some channel to be ready (or timeout)</span></span><br><span class="line">      <span class="keyword">if</span> (selector.select(TIMEOUT) == <span class="number">0</span>) &#123; <span class="comment">// returns # of ready chans</span></span><br><span class="line">        System.out.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Get iterator on set of keys with I/O to process</span></span><br><span class="line">      Iterator&lt;SelectionKey&gt; keyIter = selector.selectedKeys().iterator();</span><br><span class="line">      <span class="keyword">while</span> (keyIter.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIter.next(); <span class="comment">// Key is bit mask</span></span><br><span class="line">        <span class="comment">// Server socket channel has pending connection requests?</span></span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">          protocol.handleAccept(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Client socket channel has pending data?</span></span><br><span class="line">        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">          protocol.handleRead(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Client socket channel is available for writing and</span></span><br><span class="line">        <span class="comment">// key is valid (i.e., channel not closed)?</span></span><br><span class="line">        <span class="keyword">if</span> (key.isValid() &amp;&amp; key.isWritable()) &#123;</span><br><span class="line">          protocol.handleWrite(key);</span><br><span class="line">        &#125;</span><br><span class="line">        keyIter.remove(); <span class="comment">// remove from set of selected keys</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>UDP的服务端实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPEchoServerSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">3000</span>; <span class="comment">// Wait timeout (milliseconds)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ECHOMAX = <span class="number">255</span>; <span class="comment">// Maximum size of echo datagram</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.length != <span class="number">1</span>) <span class="comment">// Test for correct argument list</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Parameter(s): &lt;Port&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> servPort = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a selector to multiplex client connections.</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">    DatagramChannel channel = DatagramChannel.open();</span><br><span class="line">    channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(servPort));</span><br><span class="line">    channel.register(selector, SelectionKey.OP_READ, <span class="keyword">new</span> ClientRecord());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// Run forever, receiving and echoing datagrams</span></span><br><span class="line">      <span class="comment">// Wait for task or until timeout expires</span></span><br><span class="line">      <span class="keyword">if</span> (selector.select(TIMEOUT) == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Get iterator on set of keys with I/O to process</span></span><br><span class="line">      Iterator&lt;SelectionKey&gt; keyIter = selector.selectedKeys().iterator();</span><br><span class="line">      <span class="keyword">while</span> (keyIter.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIter.next(); <span class="comment">// Key is bit mask</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Client socket channel has pending data?</span></span><br><span class="line">        <span class="keyword">if</span> (key.isReadable())</span><br><span class="line">          handleRead(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Client socket channel is available for writing and</span></span><br><span class="line">        <span class="comment">// key is valid (i.e., channel not closed).</span></span><br><span class="line">        <span class="keyword">if</span> (key.isValid() &amp;&amp; key.isWritable())</span><br><span class="line">          handleWrite(key);</span><br><span class="line"></span><br><span class="line">        keyIter.remove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramChannel channel = (DatagramChannel) key.channel();</span><br><span class="line">    ClientRecord clntRec = (ClientRecord) key.attachment();</span><br><span class="line">    clntRec.buffer.clear();    <span class="comment">// Prepare buffer for receiving</span></span><br><span class="line">    clntRec.clientAddress = channel.receive(clntRec.buffer);</span><br><span class="line">    <span class="keyword">if</span> (clntRec.clientAddress != <span class="keyword">null</span>) &#123;  <span class="comment">// Did we receive something?</span></span><br><span class="line">      <span class="comment">// Register write with the selector</span></span><br><span class="line">      key.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramChannel channel = (DatagramChannel) key.channel();</span><br><span class="line">    ClientRecord clntRec = (ClientRecord) key.attachment();</span><br><span class="line">    clntRec.buffer.flip(); <span class="comment">// Prepare buffer for sending</span></span><br><span class="line">    <span class="keyword">int</span> bytesSent = channel.send(clntRec.buffer, clntRec.clientAddress);</span><br><span class="line">    <span class="keyword">if</span> (bytesSent != <span class="number">0</span>) &#123; <span class="comment">// Buffer completely written?</span></span><br><span class="line">      <span class="comment">// No longer interested in writes</span></span><br><span class="line">      key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> SocketAddress clientAddress;</span><br><span class="line">    <span class="keyword">public</span> ByteBuffer buffer = ByteBuffer.allocate(ECHOMAX);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/04/07/Java-%E5%9F%BA%E7%A1%80-7-3/">https://pingxin0521.gitee.io/2019/04/07/Java-%E5%9F%BA%E7%A1%80-7-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/04/07/Java-%E5%9F%BA%E7%A1%80-7-4/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java 网络编程（四）</div></div></a></div><div class="next-post pull-right"><a href="/2019/04/07/Java-%E5%9F%BA%E7%A1%80-7-2/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java 网络编程（二）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/06/05/Java-基础-10-2/" title="Java 补充知识"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-10-24</div><div class="title">Java 补充知识</div></div></a></div><div><a href="/2020/06/07/Java-基础-11-0/" title="使用IDE开发工具远程调试Java代码"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-07-05</div><div class="title">使用IDE开发工具远程调试Java代码</div></div></a></div><div><a href="/2020/07/05/Java-基础-11-2/" title="Java 常见异常和处理方法（二）"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-07-05</div><div class="title">Java 常见异常和处理方法（二）</div></div></a></div><div><a href="/2019/04/20/Java-基础-1-13/" title="Java8新的日期API LocalDate, LocalTime"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-04-04</div><div class="title">Java8新的日期API LocalDate, LocalTime</div></div></a></div><div><a href="/2019/08/07/Java-基础-11-1/" title="Java 常见异常和处理方法(一)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-04-01</div><div class="title">Java 常见异常和处理方法(一)</div></div></a></div><div><a href="/2019/04/07/Java-基础-7-4/" title="Java 网络编程（四）"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-07-09</div><div class="title">Java 网络编程（四）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">多任务处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.</span> <span class="toc-text">服务器协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">多线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E8%B6%85%E6%97%B6"><span class="toc-number">2.</span> <span class="toc-text">阻塞和超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%8E%A5%E5%8F%97%E8%80%85"><span class="toc-number">3.</span> <span class="toc-text">多接受者</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO"><span class="toc-number"></span> <span class="toc-text">NIO</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
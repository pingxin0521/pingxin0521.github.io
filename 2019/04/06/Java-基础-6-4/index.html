<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java Thread （二） | 平心de小屋</title><meta name="keywords" content="Java"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="线程组线程组ThreadGroup表示一组线程的集合,一旦一个线程归属到一个线程组之中后，就不能再更换其所在的线程组。那么为什么要使用线程组呢？个人认为有以下的好处：方便统一管理，线程组可以进行复制，快速定位到一个线程，统一进行异常设置等。ThreadGroup它其实并不属于Java并发包中的内容，它是java.lang中的内容。但是掌握对其的于理解，在实际应用中有很大的帮助。">
<meta property="og:type" content="article">
<meta property="og:title" content="java Thread （二）">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/04/06/Java-%E5%9F%BA%E7%A1%80-6-4/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="线程组线程组ThreadGroup表示一组线程的集合,一旦一个线程归属到一个线程组之中后，就不能再更换其所在的线程组。那么为什么要使用线程组呢？个人认为有以下的好处：方便统一管理，线程组可以进行复制，快速定位到一个线程，统一进行异常设置等。ThreadGroup它其实并不属于Java并发包中的内容，它是java.lang中的内容。但是掌握对其的于理解，在实际应用中有很大的帮助。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg">
<meta property="article:published_time" content="2019-04-06T11:38:59.000Z">
<meta property="article:modified_time" content="2019-10-18T07:23:01.000Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/04/06/Java-%E5%9F%BA%E7%A1%80-6-4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java Thread （二）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2019-10-18 15:23:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java Thread （二）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-04-06T11:38:59.000Z" title="发表于 2019-04-06 19:38:59">2019-04-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-10-18T07:23:01.000Z" title="更新于 2019-10-18 15:23:01">2019-10-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E5%9F%BA%E7%A1%80/">基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java Thread （二）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>线程组ThreadGroup表示一组线程的集合,一旦一个线程归属到一个线程组之中后，就不能再更换其所在的线程组。那么为什么要使用线程组呢？个人认为有以下的好处：方便统一管理，线程组可以进行复制，快速定位到一个线程，统一进行异常设置等。ThreadGroup它其实并不属于Java并发包中的内容，它是java.lang中的内容。但是掌握对其的于理解，在实际应用中有很大的帮助。</p>
<span id="more"></span>

<p>在java中为了方便线程管理出现了线程组ThreadGroup的概念，每个ThreadGroup可以同时包含多个子线程和多个子线程组，在一个进程中线程组是以树形的方式存在，通常情况下根线程组是system。system线程组下是main线程组，默认情况下第一级应用自己的线程组是通过main线程组创建出来的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadGroupTest &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //主线程对应的线程组</span><br><span class="line">        printGroupInfo(Thread.currentThread());//线程组为main父线程组为system</span><br><span class="line"></span><br><span class="line">        //新建线程，系统默认的线程组</span><br><span class="line">        Thread appThread = new Thread(()-&gt;&#123;&#125;,&quot;appThread&quot;);</span><br><span class="line">        printGroupInfo(appThread);//线程组为main父线程组为system</span><br><span class="line"></span><br><span class="line">        //自定义线程组</span><br><span class="line">        ThreadGroup factoryGroup=new ThreadGroup(&quot;factory&quot;);</span><br><span class="line">        Thread workerThread=new Thread(factoryGroup,()-&gt;&#123;&#125;,&quot;worker&quot;);</span><br><span class="line">        printGroupInfo(workerThread);//线程组为factory，父线程组为main</span><br><span class="line"></span><br><span class="line">        //设置父线程组</span><br><span class="line">        ThreadGroup deviceGroup=new ThreadGroup(factoryGroup,&quot;device&quot;);</span><br><span class="line">        Thread pcThread=new Thread(deviceGroup,()-&gt;&#123;&#125;,&quot;pc&quot;);</span><br><span class="line">        printGroupInfo(pcThread);//线程组为device，父线程组为factory</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void printGroupInfo(Thread t) &#123;</span><br><span class="line">        ThreadGroup group = t.getThreadGroup();</span><br><span class="line">        System.out.println(&quot;thread &quot; + t.getName()</span><br><span class="line">                + &quot; group name is &quot;+ group.getName()</span><br><span class="line">                + &quot; max priority is &quot; + group.getMaxPriority()</span><br><span class="line">                + &quot; thread count is &quot; + group.activeCount()</span><br><span class="line">                + &quot; parent group is &quot;+ (group.getParent()==null?null:group.getParent().getName()));</span><br><span class="line"></span><br><span class="line">        ThreadGroup parent=group;</span><br><span class="line">        do &#123;</span><br><span class="line">            ThreadGroup current = parent;</span><br><span class="line">            parent = parent.getParent();</span><br><span class="line">            if (parent == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(current.getName() +&quot; Group&#x27;s  parent group name is &quot;+parent.getName());</span><br><span class="line"></span><br><span class="line">        &#125; while (true);</span><br><span class="line">        System.out.println(&quot;--------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadGroup线程组的操作"><a href="#ThreadGroup线程组的操作" class="headerlink" title="ThreadGroup线程组的操作"></a>ThreadGroup线程组的操作</h4><ol>
<li><p>线程组信息的获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int activeCount(); // 获得当前线程组中线程数目， 包括可运行和不可运行的</span><br><span class="line">public int activeGroupCount()； //获得当前线程组中活动的子线程组的数目</span><br><span class="line">public int enumerate（Thread list[]）; //列举当前线程组中的线程</span><br><span class="line">public int enumerate（ThreadGroup list[]）； //列举当前线程组中的子线程组</span><br><span class="line">public final int getMaxPriority（）; //获得当前线程组中最大优先级</span><br><span class="line">public final String getName（）； //获得当前线程组的名字</span><br><span class="line">public final ThreadGroup getParent（）; //获得当前线程组的父线程组</span><br><span class="line">public boolean parentOf（ThreadGroup g）； //判断当前线程组是否为指定线程的父线程</span><br><span class="line">public boolean isDaemon（）; //判断当前线程组中是否有监护线程</span><br><span class="line">public void list（）; //列出当前线程组中所有线程和子线程名</span><br></pre></td></tr></table></figure></li>
<li><p>线程组的操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void resume（）； //使被挂起的当前组内的线程恢复到可运行状态</span><br><span class="line">public final void setDaemon (boolean daemon); //指定一个线程为当前线程组的监护线程</span><br><span class="line">public final void setMaxPriority（int pri）； //设置当前线程组允许的最大优先级</span><br><span class="line">public final void stop（）；//终止当前线程组中所有线程</span><br><span class="line">public final void suspend（）; //挂起当前线程组中所有线程</span><br><span class="line">public String toStrinng（）; //将当前线程组转换为String类的对象</span><br></pre></td></tr></table></figure></li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class ThreadGroupDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        // 创建5个线程，并入group里面进行管理</span><br><span class="line">        ThreadGroup threadGroup = new ThreadGroup(&quot;threadGroupTest1&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            Thread thread = new Thread(threadGroup,()-&gt;&#123;</span><br><span class="line">                System.out.println(&quot;Thread Start &quot; + Thread.currentThread().getName());</span><br><span class="line">                try &#123;</span><br><span class="line">                    int value = (int)new Random((new Date()).getTime()).nextDouble()*100;</span><br><span class="line">                    System.out.printf(&quot;Thread %s doTask: %d\n&quot;, Thread.currentThread().getName(),value);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(value);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    System.out.printf(&quot;Thread %s: Interrupted\n&quot;, Thread.currentThread().getName());</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;Thread end &quot; + Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">        //group信息</span><br><span class="line">        System.out.printf(&quot;Number of Threads: %d\n&quot;, threadGroup.activeCount());</span><br><span class="line">        System.out.printf(&quot;Information about the Thread Group\n&quot;);</span><br><span class="line">        threadGroup.list();</span><br><span class="line"></span><br><span class="line">        //复制group的thread信息</span><br><span class="line">        Thread[] threads = new Thread[threadGroup.activeCount()];</span><br><span class="line">        threadGroup.enumerate(threads);</span><br><span class="line">        for (int i = 0; i &lt; threadGroup.activeCount(); i++) &#123;</span><br><span class="line">            System.out.printf(&quot;Thread %s: %s\n&quot;, threads[i].getName(),threads[i].getState());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //等待结束</span><br><span class="line">        while (threadGroup.activeCount() &gt; 9) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //中断group中的线程</span><br><span class="line">        threadGroup.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程组和线程池的区别</strong></p>
<p>线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal一般称为线程本地变量，它是一种特殊的线程绑定机制，将变量与线程绑定在一起，为每一个线程维护一个独立的变量副本。通过ThreadLocal可以将对象的可见范围限制在同一个线程内。</p>
<h4 id="跳出误区"><a href="#跳出误区" class="headerlink" title="跳出误区"></a>跳出误区</h4><p>需要重点强调的的是，不要拿ThreadLocal和synchronized做类比，因为这种比较压根就是无意义的！sysnchronized是一种互斥同步机制，是为了保证在多线程环境下对于共享资源的正确访问。而ThreadLocal从本质上讲，无非是提供了一个“线程级”的变量作用域，它是一种线程封闭（每个线程独享变量）技术，更直白点讲，ThreadLocal可以理解为将对象的作用范围限制在一个线程上下文中，使得变量的作用域为“线程级”。</p>
<p>没有ThreadLocal的时候，一个线程在其声明周期内，可能穿过多个层级，多个方法，如果有个对象需要在此线程周期内多次调用，且是跨层级的（线程内共享），通常的做法是通过参数进行传递；而ThreadLocal将变量绑定在线程上，在一个线程周期内，无论“你身处何地”，只需通过其提供的get方法就可轻松获取到对象。极大地提高了对于“线程级变量”的访问便利性。</p>
<p>假设我们要为每个线程关联一个唯一的序号，在每个线程周期内，我们需要多次访问这个序号，这时我们就可以使用ThreadLocal了.（当然下面这个例子没有完全体现出跨层级跨方法的调用，理解就可以了）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMain</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.通过匿名内部类覆盖ThreadLocal的initialValue()方法，指定初始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; seqNum = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 2.获取下一个序列值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        seqNum.set(seqNum.get() + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> seqNum.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadMain sn = <span class="keyword">new</span> ThreadMain();</span><br><span class="line">        <span class="comment">// 3. 3个线程共享sn，各自产生序列号</span></span><br><span class="line">        TestClient t1 = <span class="keyword">new</span> TestClient(sn);</span><br><span class="line">        TestClient t2 = <span class="keyword">new</span> TestClient(sn);</span><br><span class="line">        TestClient t3 = <span class="keyword">new</span> TestClient(sn);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ThreadMain sn;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestClient</span><span class="params">(ThreadMain sn)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sn = sn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 4. 每个线程打出3个序列值</span></span><br><span class="line">                System.out.println(<span class="string">&quot;thread[&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] --&gt; sn[&quot;</span></span><br><span class="line">                        + sn.getNextNum() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="看看源码"><a href="#看看源码" class="headerlink" title="看看源码"></a>看看源码</h4><p>set操作，为线程绑定变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();//1.首先获取当前线程对象</span><br><span class="line">        ThreadLocalMap map = getMap(t);//2.获取该线程对象的ThreadLocalMap</span><br><span class="line">        if (map != null)</span><br><span class="line">            map.set(this, value);//如果map不为空，执行set操作，以当前threadLocal对象为key，实际存储对象为value进行set操作</span><br><span class="line">        else</span><br><span class="line">            createMap(t, value);//如果map为空，则为该线程创建ThreadLocalMap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，ThreadLocal不过是个入口，真正的变量是绑定在线程上的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;//线程对象持有ThreadLocalMap的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面给是Thread类中的定义，每个线程对象都拥有一个ThreadLocalMap对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure>

<p>现在，我们能看出ThreadLocal的设计思想了：</p>
<ol>
<li><p>ThreadLocal仅仅是个变量访问的入口；</p>
</li>
<li><p>每一个Thread对象都有一个ThreadLocalMap对象，这个ThreadLocalMap持有对象的引用；</p>
</li>
<li><p>ThreadLocalMap以当前的threadlocal对象为key，以真正的存储对象为value。get时通过threadlocal实例就可以找到绑定在当前线程上的对象。</p>
</li>
</ol>
<p>乍看上去，这种设计确实有些绕。我们完全可以在设计成Map&lt;Thread,T&gt;这种形式，一个线程对应一个存储对象。ThreadLocal这样设计的目的主要有两个：</p>
<p>一是可以保证当前线程结束时相关对象能尽快被回收；二是ThreadLocalMap中的元素会大大减少，我们都知道map过大更容易造成哈希冲突而导致性能变差。</p>
<p>我们再来看看get方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">     Thread t = Thread.currentThread();//1.首先获取当前线程</span><br><span class="line">         ThreadLocalMap map = getMap(t);//2.获取线程的map对象</span><br><span class="line">         if (map != null) &#123;//3.如果map不为空，以threadlocal实例为key获取到对应Entry，然后从Entry中取出对象即可。</span><br><span class="line">             ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">             if (e != null)</span><br><span class="line">                 return (T)e.value;</span><br><span class="line">         &#125;</span><br><span class="line">         return setInitialValue();//如果map为空，也就是第一次没有调用set直接get（或者调用过set，又调用了remove）时，为其设定初始值</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>setInitialValue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private T setInitialValue() &#123;</span><br><span class="line">        T value = initialValue();//获取初始值</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">            createMap(t, value);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>initialValue方法，默认是null，访问权限是protected，即允许重写。谈到这儿，我们应该已经对ThreadLocal的设计目的及设计思想有一定的了解了。</p>
<p>使用ThreadLocal一般都是声明在静态变量，如果ThreadLocal而且没有调用其remove方法，会导致内存泄露。</p>
<h4 id="线程独享变量"><a href="#线程独享变量" class="headerlink" title="线程独享变量?"></a>线程独享变量?</h4><p>还有一个会引起疑惑的问题，我们说ThreadLocal为每一个线程维护一个独立的变量副本，那么是不是说各个线程之间真正的做到对于对象的“完全自治”而不对其他线程的对象产生影响呢？其实这已经不属于对于ThreadLocal的讨论，而是你出于何种目的去使用ThreadLocal。如果我们为一个线程关联的对象是“完全独享”的，也就是每个线程拥有一整套的新的 栈中的对象引用+堆中的对象，那么这种情况下是真正的彻底的“线程独享变量”，相当于一种深度拷贝，每个线程自己玩自己的，对该对象做任何的操作也不会对别的线程有任何影响。</p>
<p>另一种更普遍的情况，所谓的独享变量副本，其实也就是每个线程都拥有一个独立的对象引用，而堆中的对象还是线程间共享的，这种情况下，自然还是会涉及到对共享资源的访问操作，依然会有线程不安全的风险。所以说，ThreadLocal无法解决线程安全问题。</p>
<p>所以，需不需要完全独享变量，进行完全隔离，就取决于你的应用场景了。可以想象，对象过大的时候，如果每个线程都有这么一份“深拷贝”，并发又比较大，对于服务器的压力自然是很大的。像web开发中的servlet，servlet是线程不安全的，一请求一线程，多个线程共享一个servlet对象；而早期的CGI设计中，N个请求就对应N个对象，并发量大了之后性能自然就很差。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/05/05/5ccea0fc640bb.png" alt="1.png"></p>
<p>ThreadLocal在spring的事务管理，包括Hibernate的session管理等都有出现，在web开发中，有时会用来管理用户会话 HttpSession，web交互中这种典型的一请求一线程的场景似乎比较适合使用ThreadLocal，但是需要特别注意的是，由于此时session与线程关联，而tomcat这些web服务器多会采用线程池机制，也就是说线程是可复用的，所以在每一次进入的时候都需要重新进行set，或者在结束时及时remove。</p>
<h3 id="异常的处理策略"><a href="#异常的处理策略" class="headerlink" title="异常的处理策略"></a>异常的处理策略</h3><p>由于java thread本身牵涉到并发、锁等相关的问题已经够复杂了。再加上异常处理这些东西，使得它更加特殊。 概括起来，不外乎是三个主要的问题。</p>
<ol>
<li><p>在java启动的线程里可以抛出异常吗？</p>
</li>
<li><p>在启动的线程里可以捕捉异常吗？</p>
</li>
<li><p>如果可以捕捉异常，对于checked exception和unchecked exception，他们分别有什么的处理方式呢？</p>
</li>
</ol>
<h4 id="线程里抛出异常"><a href="#线程里抛出异常" class="headerlink" title="线程里抛出异常"></a>线程里抛出异常</h4><p>我们可以尝试一下在线程里抛异常。按照我们的理解，假定我们要在某个方法里抛异常，需要在该定义的方法头也加上声明。那么一个最简单的方式可能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Task implements Runnable &#123;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public void run() throws Exception &#123;  </span><br><span class="line">        int number0 = Integer.parseInt(&quot;1&quot;);  </span><br><span class="line">        throw new Exception(&quot;Just for test&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>发现这种方式行不通。也就是说，在线程里直接抛异常是不行的。可是，这又会引出一个问题，如果我们在线程代码里头确实是产生了异常，那该怎么办呢？比如说，我们通过一个线程访问一些文件或者对网络进行IO操作，结果产生了异常。或者说访问某些资源的时候系统崩溃了。这样的场景是确实可能会发生的，我们就需要针对这些情况进行进一步的讨论。</p>
<h4 id="异常处理的几种方式"><a href="#异常处理的几种方式" class="headerlink" title="异常处理的几种方式"></a>异常处理的几种方式</h4><p>在前面提到的几种在线程访问资源产生了异常的情况。我们可以看，比如说我们访问文件系统的时候，会抛出IOException, FileNotFoundException等异常。我们在访问的代码里实际上是需要采用两种方式来处理的。一种是在使用改资源的方法头增加throws IOException, FileNotFoundException等异常的修饰。还有一种是直接在这部分的代码块增加try/catch部分。由前面我们的讨论已经发现，在方法声明加throws Exception的方式是行不通的。那么就只有使用try/catch这么一种方式了。</p>
<p>另外，我们也知道，在异常的处理上，一般异常可以分为checked exception和unchecked exception。作为unchecked exception，他们通常是指一些比较严重的系统错误或者系统设计错误，比如Error, OutOfMemoryError或者系统直接就崩溃了。对于这种异常发生的时候，我们一般是无能为力也没法恢复的。那么这种情况的发生，我们会怎么来处理呢？</p>
<p><strong>checked exception</strong></p>
<p>在线程里面处理checked exception，按照我们以前的理解，我们是可以直接捕捉它来处理的。在一些thread的示例里我们也见过。比如说下面的一部分代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;  </span><br><span class="line">import java.util.concurrent.TimeUnit;  </span><br><span class="line"></span><br><span class="line">public class FileLock implements Runnable &#123;  </span><br><span class="line">  @Override  </span><br><span class="line">  public void run() &#123;  </span><br><span class="line">      for(int i = 0; i &lt; 10; i++) &#123;  </span><br><span class="line">          System.out.printf(&quot;%s\n&quot;, new Date());  </span><br><span class="line">          try &#123;  </span><br><span class="line">              TimeUnit.SECONDS.sleep(1);  </span><br><span class="line">          &#125; catch(InterruptedException e) &#123;  </span><br><span class="line">              System.out.printf(&quot;The FileClock has been interrupted&quot;);  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个线程执行代码，并且在这里因为调用TimeUnit.SECONDS.sleep()方法而需要捕捉异常。因为这个方法本身就会抛出InterruptedException，我们必须要用try/catch块来处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;  </span><br><span class="line"></span><br><span class="line">public class Main &#123;  </span><br><span class="line">  public static void main(String[] args) &#123;  </span><br><span class="line">      // Creates a FileClock runnable object and a Thread  </span><br><span class="line">      // to run it  </span><br><span class="line">      FileClock clock=new FileClock();  </span><br><span class="line">      Thread thread=new Thread(clock);  </span><br><span class="line"></span><br><span class="line">      // Starts the Thread  </span><br><span class="line">      thread.start();  </span><br><span class="line">      try &#123;  </span><br><span class="line">          // Waits five seconds  </span><br><span class="line">          TimeUnit.SECONDS.sleep(5);  </span><br><span class="line">      &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">          e.printStackTrace();  </span><br><span class="line">      &#125;;  </span><br><span class="line">      // Interrupts the Thread  </span><br><span class="line">      thread.interrupt();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这部分的代码是启动FileLock线程并尝试去中断它。我们可以发现在运行的时候FileLock里面执行的代码能够正常的处理异常。</p>
<p>因此，在thread里面，如果要处理checked exception，简单的一个try/catch块就可以了。</p>
<p><strong>unchecked exception</strong></p>
<p>对于这种unchecked exception，相对来说就会不一样一点。实际上，在Thread的定义里有一个实例方法：setUncaughtExceptionHandler(UncaughtExceptionHandler). 这个方法可以用来处理一些unchecked exception。那么，这种情况的场景是如何的呢？</p>
<p>setUncaughtExceptionHandler()方法相当于一个事件注册的入口。在jdk里面，该方法的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh) &#123;  </span><br><span class="line">    checkAccess();  </span><br><span class="line">    uncaughtExceptionHandler = eh;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而UncaughtExceptionHandler则是一个接口，它的声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UncaughtExceptionHandler &#123;  </span><br><span class="line">  void uncaughtException(Thread t, Throwable e);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>在异常发生的时候，我们传入的UncaughtExceptionHandler参数的uncaughtException方法会被调用。综合前面的讨论，我们这边要实现handle unchecked exception的方法的具体步骤可以总结如下：</p>
<ol>
<li><p>定义一个类实现UncaughtExceptionHandler接口。在实现的方法里包含对异常处理的逻辑和步骤。</p>
</li>
<li><p>定义线程执行结构和逻辑。这一步和普通线程定义一样。</p>
</li>
<li><p>在创建和执行改子线程的方法里在thread.start()语句前增加一个thread.setUncaughtExceptionHandler语句来实现处理逻辑的注册。</p>
</li>
</ol>
<p>下面，我们就按照这里定义的步骤来实现一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadExce &#123;</span><br><span class="line">  class ExceptionHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line">      public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">          System.out.printf(&quot;An exception has been captured\n&quot;);</span><br><span class="line">          System.out.printf(&quot;Thread: %s\n&quot;, t.getId());</span><br><span class="line">          System.out.printf(&quot;Exception: %s: %s\n&quot;,</span><br><span class="line">                  e.getClass().getName(), e.getMessage());</span><br><span class="line">          System.out.printf(&quot;Stack Trace: \n&quot;);</span><br><span class="line">          e.printStackTrace(System.out);</span><br><span class="line">          System.out.printf(&quot;Thread status: %s\n&quot;, t.getState());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Task implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          int number0 = Integer.parseInt(&quot;TTT&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      ThreadExce exce=new ThreadExce();</span><br><span class="line">      Task task = exce.new Task();</span><br><span class="line">      Thread thread = new Thread(task);</span><br><span class="line">      thread.setUncaughtExceptionHandler(exce.new ExceptionHandler());</span><br><span class="line">      thread.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们去执行整个程序，会发现有如下的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">An exception has been captured</span><br><span class="line">Thread: 12</span><br><span class="line">Exception: java.lang.NumberFormatException: For input string: &quot;TTT&quot;</span><br><span class="line">Stack Trace:</span><br><span class="line">java.lang.NumberFormatException: For input string: &quot;TTT&quot;</span><br><span class="line">	at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)</span><br><span class="line">	at java.base/java.lang.Integer.parseInt(Integer.java:652)</span><br><span class="line">	at java.base/java.lang.Integer.parseInt(Integer.java:770)</span><br><span class="line">	at com.hyp.learn.thread.ThreadExce$Task.run(ThreadExce.java:26)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:834)</span><br><span class="line">Thread status: RUNNABLE</span><br></pre></td></tr></table></figure>
<p>这部分的输出正好就是我们前面实现UncaughtExceptionHandler接口的定义。</p>
<p>因此，对于unchecked exception，我们也可以采用类似事件注册的机制做一定程度的处理。</p>
<p>Java thread里面关于异常的部分比较奇特。你不能直接在一个线程里去抛出异常。一般在线程里碰到checked exception，推荐的做法是采用try/catch块来处理。而对于unchecked exception，比较合理的方式是注册一个实现UncaughtExceptionHandler接口的对象实例来处理。这些细节的东西如果没有碰到过确实很难回答。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/cqqcqqok/blog/1941629">Java中的ThreadGroup线程组</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/chengxiao/p/6152824.html">谈谈Java中的ThreadLocal</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/googlemeoften/p/5769216.html">Java thread中对异常的处理策略</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/04/06/Java-%E5%9F%BA%E7%A1%80-6-4/">https://pingxin0521.gitee.io/2019/04/06/Java-%E5%9F%BA%E7%A1%80-6-4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/04/06/Java-%E5%9F%BA%E7%A1%80-10-1/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java JDK各版本新特性</div></div></a></div><div class="next-post pull-right"><a href="/2019/04/06/Java-%E5%9F%BA%E7%A1%80-6-1/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java Thread （一）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/07/12/Java-SpringBoot-1-4-2/" title="Spring boot 数据访问 MongoDB"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-01-25</div><div class="title">Spring boot 数据访问 MongoDB</div></div></a></div><div><a href="/2019/12/10/Java-SpringBoot-1-6-1/" title="Spring boot 消息队列(使用RabbitMQ)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-02-09</div><div class="title">Spring boot 消息队列(使用RabbitMQ)</div></div></a></div><div><a href="/2019/05/30/Java-SpringCloud-0-0/" title="Spring Cloud 入门 (一)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">Spring Cloud 入门 (一)</div></div></a></div><div><a href="/2019/11/01/Java-SpringCloud-3-0/" title="Spring Cloud 组件之Hystrix (五)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">Spring Cloud 组件之Hystrix (五)</div></div></a></div><div><a href="/2019/10/27/Java-SpringCloud-6-0/" title="微服务组件--分布式追踪系统"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">微服务组件--分布式追踪系统</div></div></a></div><div><a href="/2019/11/03/Java-SpringCloud-6-2/" title="SpringCloud组件之Spring Cloud Sleuth (八)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">SpringCloud组件之Spring Cloud Sleuth (八)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">线程组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadGroup%E7%BA%BF%E7%A8%8B%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.</span> <span class="toc-text">ThreadGroup线程组的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">2.</span> <span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E5%87%BA%E8%AF%AF%E5%8C%BA"><span class="toc-number">2.1.</span> <span class="toc-text">跳出误区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%8B%E7%9C%8B%E6%BA%90%E7%A0%81"><span class="toc-number">2.2.</span> <span class="toc-text">看看源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8B%AC%E4%BA%AB%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.</span> <span class="toc-text">线程独享变量?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">3.</span> <span class="toc-text">异常的处理策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%87%8C%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">3.1.</span> <span class="toc-text">线程里抛出异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">异常处理的几种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
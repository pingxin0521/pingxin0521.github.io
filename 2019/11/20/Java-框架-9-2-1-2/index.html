<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Shiro 学习（三） | 平心de小屋</title><meta name="keywords" content="Java,框架"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Web 集成Shiro 提供了与 Web 集成的支持，其通过一个 ShiroFilter 入口来拦截需要安全控制的 URL，然后进行相应的控制，ShiroFilter 类似于如 Strut2&#x2F;SpringMVC 这种 web 框架的前端控制器，其是安全控制的入口点，其负责读取配置（如 ini 配置文件），然后判断 URL 是否需要登录 &#x2F; 权限等工作。  创建 webapp 应用 此处我们使用了">
<meta property="og:type" content="article">
<meta property="og:title" content="Shiro 学习（三）">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/11/20/Java-%E6%A1%86%E6%9E%B6-9-2-1-2/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="Web 集成Shiro 提供了与 Web 集成的支持，其通过一个 ShiroFilter 入口来拦截需要安全控制的 URL，然后进行相应的控制，ShiroFilter 类似于如 Strut2&#x2F;SpringMVC 这种 web 框架的前端控制器，其是安全控制的入口点，其负责读取配置（如 ini 配置文件），然后判断 URL 是否需要登录 &#x2F; 权限等工作。  创建 webapp 应用 此处我们使用了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg">
<meta property="article:published_time" content="2019-11-20T09:18:59.000Z">
<meta property="article:modified_time" content="2020-03-27T13:27:33.827Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="框架">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/11/20/Java-%E6%A1%86%E6%9E%B6-9-2-1-2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Shiro 学习（三）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-03-27 21:27:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Shiro 学习（三）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-11-20T09:18:59.000Z" title="发表于 2019-11-20 17:18:59">2019-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-03-27T13:27:33.827Z" title="更新于 2020-03-27 21:27:33">2020-03-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E6%A1%86%E6%9E%B6/">框架</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Shiro 学习（三）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="Web-集成"><a href="#Web-集成" class="headerlink" title="Web 集成"></a>Web 集成</h3><p>Shiro 提供了与 Web 集成的支持，其通过一个 ShiroFilter 入口来拦截需要安全控制的 URL，然后进行相应的控制，ShiroFilter 类似于如 Strut2/SpringMVC 这种 web 框架的前端控制器，其是安全控制的入口点，其负责读取配置（如 ini 配置文件），然后判断 URL 是否需要登录 / 权限等工作。</p>
<ol>
<li><p>创建 webapp 应用</p>
<p>此处我们使用了 jetty-maven-plugin 插件；这样可以直接使用 “mvn jetty:run”直接运行 webapp 了</p>
</li>
<li><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="ShiroFilter-入口"><a href="#ShiroFilter-入口" class="headerlink" title="ShiroFilter 入口"></a>ShiroFilter 入口</h4><ol>
<li><p>Shiro 1.1 及以前版本配置方式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>iniShiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.shiro.web.servlet.IniShiroFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>configPath<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:shiro.ini<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>iniShiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>使用 IniShiroFilter 作为 Shiro 安全控制的入口点，通过 url-pattern 指定需要安全的 URL；</li>
<li>通过 configPath 指定 ini 配置文件位置，默认是先从 /WEB-INF/shiro.ini 加载，如果没有就默认加载 classpath:shiro.ini，即默认相对于 web 应用上下文根路径；</li>
<li>也可以通过如下方式直接内嵌 ini 配置文件内容到 web.xml。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>config<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">        ini配置文件贴在这</span><br><span class="line">    <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Shiro 1.2 及以后版本的配置方式</p>
<p>从 Shiro 1.2 开始引入了 Environment/WebEnvironment 的概念，即由它们的实现提供相应的 SecurityManager 及其相应的依赖。ShiroFilter 会自动找到 Environment 然后获取相应的依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">   &lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure>

<p>通过 EnvironmentLoaderListener 来创建相应的 WebEnvironment，并自动绑定到 ServletContext，默认使用 IniWebEnvironment 实现。</p>
<p>可以通过如下配置修改默认实现及其加载的配置文件位置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>shiroEnvironmentClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.apache.shiro.web.env.IniWebEnvironment<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>shiroConfigLocations<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:shiro.ini<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>shiroConfigLocations 默认是 “/WEB-INF/shiro.ini”，IniWebEnvironment 默认是先从 / WEB-INF/shiro.ini 加载，如果没有就默认加载 classpath:shiro.ini。</p>
</li>
</ol>
<p>代码：<a target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521/java-framework/tree/master/learn-shiro/cha06">https://github.com/hanyunpeng0521/java-framework/tree/master/learn-shiro/cha06</a></p>
<h3 id="拦截器机制"><a href="#拦截器机制" class="headerlink" title="拦截器机制"></a>拦截器机制</h3><p>Shiro 使用了与 Servlet 一样的 Filter 接口进行扩展</p>
<p>下图是 Shiro 拦截器的基础类图：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2020/03/26/G9UBDI.png" alt="G9UBDI.png"></p>
<ol>
<li><p>NameableFilter<br>NameableFilter 给 Filter 起个名字，如果没有设置默认就是 FilterName；还记得之前的如 authc 吗？当我们组装拦截器链时会根据这个名字找到相应的拦截器实例；</p>
</li>
<li><p>OncePerRequestFilter<br>OncePerRequestFilter 用于防止多次执行 Filter 的；也就是说一次请求只会走一次拦截器链；另外提供 enabled 属性，表示是否开启该拦截器实例，默认 enabled=true 表示开启，如果不想让某个拦截器工作，可以设置为 false 即可。</p>
</li>
<li><p>ShiroFilter<br>ShiroFilter 是整个 Shiro 的入口点，用于拦截需要安全控制的请求进行处理，这个之前已经用过了。</p>
</li>
<li><p>AdviceFilter<br>AdviceFilter 提供了 AOP 风格的支持，类似于 SpringMVC 中的 Interceptor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(ServletRequest request, ServletResponse response, Exception exception)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>preHandler：类似于 AOP 中的前置增强；在拦截器链执行之前执行；如果返回 true 则继续拦截器链；否则中断后续的拦截器链的执行直接返回；进行预处理（如基于表单的身份验证、授权）</li>
<li>postHandle：类似于 AOP 中的后置返回增强；在拦截器链执行完成后执行；进行后处理（如记录执行时间之类的）；</li>
<li>afterCompletion：类似于 AOP 中的后置最终增强；即不管有没有异常都会执行；可以进行清理资源（如接触 Subject 与线程的绑定之类的）；</li>
</ul>
</li>
<li><p>PathMatchingFilter</p>
<p>PathMatchingFilter 提供了基于 Ant 风格的请求路径匹配功能及拦截器参数解析的功能，如“roles[admin,user]”自动根据“，”分割解析到一个路径参数配置并绑定到相应的路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pathsMatch</span><span class="params">(String path, ServletRequest request)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception</span></span><br></pre></td></tr></table></figure>

<p>pathsMatch：该方法用于 path 与请求路径进行匹配的方法；如果匹配返回 true；<br>onPreHandle：在 preHandle 中，当 pathsMatch 匹配一个路径后，会调用 opPreHandler 方法并将路径绑定参数配置传给 mappedValue；然后可以在这个方法中进行一些验证（如角色授权），如果验证失败可以返回 false 中断流程；默认返回 true；也就是说子类可以只实现 onPreHandle 即可，无须实现 preHandle。如果没有 path 与请求路径匹配，默认是通过的（即 preHandle 返回 true）。</p>
</li>
<li><p>AccessControlFilterAccessControlFilter 提供了访问控制的基础功能；比如是否允许访问/当访问拒绝时如何处理等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception</span>; </span><br></pre></td></tr></table></figure>

<p>isAccessAllowed：表示是否允许访问；mappedValue 就是[urls]配置中拦截器参数部分，如果允许访问返回 true，否则 false；</p>
<p>onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回 true 表示需要继续处理；如果返回 false 表示该拦截器实例已经处理了，将直接返回即可。</p>
<p>onPreHandle 会自动调用这两个方法决定是否继续处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>另外 AccessControlFilter 还提供了如下方法用于处理如登录成功后/重定向到上一个请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLoginUrl</span><span class="params">(String loginUrl)</span> <span class="comment">//身份验证时使用，默认/login.jsp</span></span></span><br><span class="line"><span class="function">String <span class="title">getLoginUrl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Subject <span class="title">getSubject</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="comment">//获取Subject 实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLoginRequest</span><span class="params">(ServletRequest request, ServletResponse response)</span><span class="comment">//当前请求是否是登录请求</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveRequestAndRedirectToLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> IOException <span class="comment">//将当前请求保存起来并重定向到登录页面</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveRequest</span><span class="params">(ServletRequest request)</span> <span class="comment">//将请求保存起来，如登录成功后再重定向回该请求</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redirectToLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="comment">//重定向到登录页面 </span></span></span><br></pre></td></tr></table></figure>

<p>比如基于表单的身份验证就需要使用这些功能。</p>
</li>
</ol>
<p>到此基本的拦截器就完事了，如果我们想进行访问访问的控制就可以继承 AccessControlFilter；如果我们要添加一些通用数据我们可以直接继承 PathMatchingFilter。</p>
<h4 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h4><p>Shiro 对 Servlet 容器的 FilterChain 进行了代理，即 ShiroFilter 在继续 Servlet 容器的 Filter 链的执行之前，通过 ProxiedFilterChain 对 Servlet 容器的 FilterChain 进行了代理；即先走 Shiro 自己的 Filter 体系，然后才会委托给 Servlet 容器的 FilterChain 进行 Servlet 容器级别的 Filter 链执行；Shiro 的 ProxiedFilterChain 执行流程：</p>
<ol>
<li>先执行 Shiro 自己的 Filter 链；</li>
<li>再执行 Servlet 容器的 Filter 链（即原始的 Filter）。</li>
</ol>
<p>而 ProxiedFilterChain 是通过 FilterChainResolver 根据配置文件中[urls]部分是否与请求的 URL 是否匹配解析得到的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain);</span><br></pre></td></tr></table></figure>

<p>即传入原始的 chain 得到一个代理的 chain。</p>
<p>Shiro 内部提供了一个路径匹配的 FilterChainResolver 实现：PathMatchingFilterChainResolver，其根据[urls]中配置的 url 模式（默认 Ant 风格）=拦截器链和请求的 url 是否匹配来解析得到配置的拦截器链的；而 PathMatchingFilterChainResolver 内部通过 FilterChainManager 维护着拦截器链，比如 DefaultFilterChainManager 实现维护着 url 模式与拦截器链的关系。因此我们可以通过 FilterChainManager 进行动态动态增加 url 模式与拦截器链的关系。</p>
<p>DefaultFilterChainManager 会默认添加 org.apache.shiro.web.filter.mgt.DefaultFilter 中声明的拦截器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">DefaultFilter</span> </span>&#123;</span><br><span class="line">    anon(AnonymousFilter.class),</span><br><span class="line">    authc(FormAuthenticationFilter.class),</span><br><span class="line">    authcBasic(BasicHttpAuthenticationFilter.class),</span><br><span class="line">    logout(LogoutFilter.class),</span><br><span class="line">    noSessionCreation(NoSessionCreationFilter.class),</span><br><span class="line">    perms(PermissionsAuthorizationFilter.class),</span><br><span class="line">    port(PortFilter.class),</span><br><span class="line">    rest(HttpMethodPermissionFilter.class),</span><br><span class="line">    roles(RolesAuthorizationFilter.class),</span><br><span class="line">    ssl(SslFilter.class),</span><br><span class="line">    user(UserFilter.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要注册自定义拦截器，IniSecurityManagerFactory/WebIniSecurityManagerFactory 在启动时会自动扫描 ini 配置文件中的 [filters]/[main] 部分并注册这些拦截器到 DefaultFilterChainManager；且创建相应的 url 模式与其拦截器关系链。如果使用 Spring 后续章节会介绍如果注册自定义拦截器。</p>
<p>如果想自定义 FilterChainResolver，可以通过实现 WebEnvironment 接口完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIniWebEnvironment</span> <span class="keyword">extends</span> <span class="title">IniWebEnvironment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> FilterChainResolver <span class="title">createFilterChainResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在此处扩展自己的FilterChainResolver</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.createFilterChainResolver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FilterChain 之间的关系。如果想动态实现 url -拦截器的注册，就可以通过实现此处的 FilterChainResolver 来完成，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、创建 FilterChainResolver</span></span><br><span class="line">PathMatchingFilterChainResolver filterChainResolver =</span><br><span class="line">        <span class="keyword">new</span> PathMatchingFilterChainResolver();</span><br><span class="line"><span class="comment">//2、创建 FilterChainManager</span></span><br><span class="line">DefaultFilterChainManager filterChainManager = <span class="keyword">new</span> DefaultFilterChainManager();</span><br><span class="line"><span class="comment">//3、注册 Filter</span></span><br><span class="line"><span class="keyword">for</span>(DefaultFilter filter : DefaultFilter.values()) &#123;</span><br><span class="line">    filterChainManager.addFilter(</span><br><span class="line">        filter.name(), (Filter) ClassUtils.newInstance(filter.getFilterClass()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4、注册 URL-Filter 的映射关系</span></span><br><span class="line">filterChainManager.addToChain(<span class="string">&quot;/login.jsp&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line">filterChainManager.addToChain(<span class="string">&quot;/unauthorized.jsp&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">filterChainManager.addToChain(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line">filterChainManager.addToChain(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;roles&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"><span class="comment">//5、设置 Filter 的属性</span></span><br><span class="line">FormAuthenticationFilter authcFilter =</span><br><span class="line">         (FormAuthenticationFilter)filterChainManager.getFilter(<span class="string">&quot;authc&quot;</span>);</span><br><span class="line">authcFilter.setLoginUrl(<span class="string">&quot;/login.jsp&quot;</span>);</span><br><span class="line">RolesAuthorizationFilter rolesFilter =</span><br><span class="line">          (RolesAuthorizationFilter)filterChainManager.getFilter(<span class="string">&quot;roles&quot;</span>);</span><br><span class="line">rolesFilter.setUnauthorizedUrl(<span class="string">&quot;/unauthorized.jsp&quot;</span>);</span><br><span class="line">filterChainResolver.setFilterChainManager(filterChainManager);</span><br><span class="line"><span class="keyword">return</span> filterChainResolver;</span><br></pre></td></tr></table></figure>

<p>此处自己去实现注册 filter，及url 模式与 filter 之间的映射关系。可以通过定制 FilterChainResolver 或 FilterChainManager 来完成诸如动态 URL 匹配的实现。</p>
<p>然后再 web.xml 中进行如下配置 Environment：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>shiroEnvironmentClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.hyp.learn.shiro.cha06.web.env.MyIniWebEnvironment<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h4><p>通过自定义自己的拦截器可以扩展一些功能，诸如动态 url -角色/权限访问控制的实现、根据 Subject 身份信息获取用户信息绑定到 Request（即设置通用数据）、验证码验证、在线用户信息的保存等等，因为其本质就是一个 Filter；所以 Filter 能做的它就能做。</p>
<ol>
<li><p>扩展 OncePerRequestFilter</p>
<p>OncePerRequestFilter 保证一次请求只调用一次 doFilterInternal，即如内部的 forward 不会再多执行一次 doFilterInternal：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOncePerRequestFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========once per request filter&quot;</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再 shiro.ini 配置文件中：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[main]</span></span><br><span class="line"><span class="comment">#myFilter1=com.hyp.learn.shiro.cha06.web.filter.MyOncePerRequestFilter</span></span><br><span class="line"><span class="attr">[filters]</span></span><br><span class="line"><span class="attr">myFilter1</span>=<span class="string">com.hyp.learn.shiro.cha06.web.filter.MyOncePerRequestFilter</span></span><br><span class="line"><span class="attr">[urls]</span></span><br><span class="line"><span class="meta">/**</span>=<span class="string">myFilter1</span></span><br></pre></td></tr></table></figure>

<p>Filter 可以在 [main] 或 [filters] 部分注册，然后在 [urls] 部分配置 url 与 filter 的映射关系即可。</p>
</li>
<li><p>扩展 AdviceFilter</p>
<p>AdviceFilter 提供了 AOP 的功能，其实现和 SpringMVC 中的 Interceptor 思想一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdviceFilter</span> <span class="keyword">extends</span> <span class="title">AdviceFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====预处理/前置处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//返回 false 将中断后续拦截器链的执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====后处理/后置返回处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(ServletRequest request, ServletResponse response, Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====完成处理/后置最终处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>preHandle：进行请求的预处理，然后根据返回值决定是否继续处理（true：继续过滤器链）；可以通过它实现权限控制；</li>
<li>postHandle：执行完拦截器链之后正常返回后执行；</li>
<li>afterCompletion：不管最后有没有异常，afterCompletion 都会执行，完成如清理资源功能。</li>
</ul>
<p>然后在 shiro.ini 中进行如下配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[filters]</span></span><br><span class="line"><span class="attr">myFilter1</span>=<span class="string">com.hyp.learn.shiro.cha06.web.filter.MyOncePerRequestFilter</span></span><br><span class="line"><span class="attr">myFilter2</span>=<span class="string">com.hyp.learn.shiro.cha06.web.filter.MyAdviceFilter</span></span><br><span class="line"><span class="attr">[urls]</span></span><br><span class="line"><span class="meta">/**</span>=<span class="string">myFilter1,myFilter2</span></span><br></pre></td></tr></table></figure></li>
<li><p>PathMatchingFilter</p>
<p>PathMatchingFilter 继承了 AdviceFilter，提供了 url 模式过滤的功能，如果需要对指定的请求进行处理，可以扩展 PathMatchingFilter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPathMatchingFilter</span> <span class="keyword">extends</span> <span class="title">PathMatchingFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;url matches,config is &quot;</span> + Arrays.toString((String[])mappedValue));</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>preHandle：会进行 url 模式与请求 url 进行匹配，如果匹配会调用 onPreHandle；如果没有配置 url 模式 / 没有 url 模式匹配，默认直接返回 true；</li>
<li>onPreHandle：如果 url 模式与请求 url 匹配，那么会执行 onPreHandle，并把该拦截器配置的参数传入。默认什么不处理直接返回 true。</li>
</ul>
<p>然后在 shiro.ini 中进行如下配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[filters]</span></span><br><span class="line"><span class="attr">myFilter1</span>=<span class="string">com.hyp.learn.shiro.cha06.web.filter.MyOncePerRequestFilter</span></span><br><span class="line"><span class="attr">myFilter2</span>=<span class="string">com.hyp.learn.shiro.cha06.web.filter.MyAdviceFilter</span></span><br><span class="line"><span class="attr">myFilter3</span>=<span class="string">com.hyp.learn.shiro.cha06.web.filter.MyPathMatchingFilter</span></span><br><span class="line"><span class="attr">[urls]</span></span><br><span class="line"><span class="meta">/**</span>=<span class="string">myFilter1,myFilter2,myFilter3[config]</span></span><br></pre></td></tr></table></figure></li>
<li><p>扩展 AccessControlFilterAccessControlFilter 继承了 PathMatchingFilter，并扩展了了两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isAccessAllowed(request, response, mappedValue)</span><br><span class="line">     || onAccessDenied(request, response, mappedValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isAccessAllowed：即是否允许访问，返回 true 表示允许；<br>onAccessDenied：表示访问拒绝时是否自己处理，如果返回 true 表示自己不处理且继续拦截器链执行，返回 false 表示自己已经处理了（比如重定向到另一个页面）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccessControlFilter</span> <span class="keyword">extends</span> <span class="title">AccessControlFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;access allowed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问拒绝也不自己处理，继续拦截器链的执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 shiro.ini 中进行如下配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[filters]</span></span><br><span class="line"><span class="attr">myFilter1</span>=<span class="string">com.hyp.learn.shiro.cha06.web.filter.MyOncePerRequestFilter</span></span><br><span class="line"><span class="attr">myFilter2</span>=<span class="string">com.hyp.learn.shiro.cha06.web.filter.MyAdviceFilter</span></span><br><span class="line"><span class="attr">myFilter3</span>=<span class="string">com.hyp.learn.shiro.cha06.web.filter.MyPathMatchingFilter</span></span><br><span class="line"><span class="attr">myFilter4</span>=<span class="string">com.hyp.learn.shiro.cha06.web.filter.MyAccessControlFilter</span></span><br><span class="line"><span class="attr">[urls]</span></span><br><span class="line"><span class="meta">/**</span>=<span class="string">myFilter1,myFilter2,myFilter3[config],myFilter4</span></span><br></pre></td></tr></table></figure></li>
<li><p>基于表单登录拦截器</p>
<p>之前我们已经使用过 Shiro 内置的基于表单登录的拦截器了，此处自己做一个类似的基于表单登录的拦截器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormLoginFilter</span> <span class="keyword">extends</span> <span class="title">PathMatchingFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String loginUrl = <span class="string">&quot;/login.jsp&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String successUrl = <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(SecurityUtils.getSubject().isAuthenticated()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//已经登录过</span></span><br><span class="line">        &#125;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        HttpServletResponse resp = (HttpServletResponse) response;</span><br><span class="line">        <span class="keyword">if</span>(isLoginRequest(req)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;post&quot;</span>.equalsIgnoreCase(req.getMethod())) &#123;<span class="comment">//form表单提交</span></span><br><span class="line">                <span class="keyword">boolean</span> loginSuccess = login(req); <span class="comment">//登录</span></span><br><span class="line">                <span class="keyword">if</span>(loginSuccess) &#123;</span><br><span class="line">                    <span class="keyword">return</span> redirectToSuccessUrl(req, resp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//继续过滤器链</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//保存当前地址并重定向到登录界面</span></span><br><span class="line">            saveRequestAndRedirectToLogin(req, resp);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">redirectToSuccessUrl</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        WebUtils.redirectToSavedRequest(req, resp, successUrl);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveRequestAndRedirectToLogin</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        WebUtils.saveRequest(req);</span><br><span class="line">        WebUtils.issueRedirect(req, resp, loginUrl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        String username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password = req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SecurityUtils.getSubject().login(<span class="keyword">new</span> UsernamePasswordToken(username, password));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            req.setAttribute(<span class="string">&quot;shiroLoginFailure&quot;</span>, e.getClass());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLoginRequest</span><span class="params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pathsMatch(loginUrl, WebUtils.getPathWithinApplication(req));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onPreHandle 主要流程：</p>
<ol>
<li>首先判断是否已经登录过了，如果已经登录过了继续拦截器链即可；</li>
<li>如果没有登录，看看是否是登录请求，如果是 get 方法的登录页面请求，则继续拦截器链（到请求页面），否则如果是 get 方法的其他页面请求则保存当前请求并重定向到登录页面；</li>
<li>如果是 post 方法的登录页面表单提交请求，则收集用户名 / 密码登录即可，如果失败了保存错误消息到 “shiroLoginFailure” 并返回到登录页面；</li>
<li>如果登录成功了，且之前有保存的请求，则重定向到之前的这个请求，否则到默认的成功页面。</li>
</ol>
<p>shiro.ini 配置</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[users]</span></span><br><span class="line"><span class="attr">zhang</span>=<span class="string">123,admin</span></span><br><span class="line"><span class="attr">wang</span>=<span class="string">123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[roles]</span></span><br><span class="line"><span class="attr">admin</span>=<span class="string">user:*,menu:*</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[filters]</span></span><br><span class="line"><span class="attr">formLogin</span>=<span class="string">com.hyp.learn.shiro.cha06.web.filter.FormLoginFilter</span></span><br><span class="line"><span class="attr">[urls]</span></span><br><span class="line"><span class="meta">/test.jsp</span>=<span class="string">formLogin</span></span><br><span class="line"><span class="meta">/login.jsp</span>=<span class="string">formLogin</span></span><br></pre></td></tr></table></figure></li>
<li><p>任意角色授权拦截器</p>
<p>Shiro 提供 roles 拦截器，其验证用户拥有所有角色，没有提供验证用户拥有任意角色的拦截器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnyRolesFilter</span> <span class="keyword">extends</span> <span class="title">AccessControlFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String unauthorizedUrl = <span class="string">&quot;/unauthorized.jsp&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String loginUrl = <span class="string">&quot;/login.jsp&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String[] roles = (String[])mappedValue;</span><br><span class="line">        <span class="keyword">if</span>(roles == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//如果没有设置角色参数，默认成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String role : roles) &#123;</span><br><span class="line">            <span class="keyword">if</span>(getSubject(request, response).hasRole(role)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//跳到onAccessDenied处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Subject subject = getSubject(request, response);</span><br><span class="line">        <span class="keyword">if</span> (subject.getPrincipal() == <span class="keyword">null</span>) &#123;<span class="comment">//表示没有登录，重定向到登录页面</span></span><br><span class="line">            saveRequest(request);</span><br><span class="line">            WebUtils.issueRedirect(request, response, loginUrl);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(unauthorizedUrl)) &#123;<span class="comment">//如果有未授权页面跳转过去</span></span><br><span class="line">                WebUtils.issueRedirect(request, response, unauthorizedUrl);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则返回401未授权状态码</span></span><br><span class="line">                WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>流程：</p>
<ol>
<li>首先判断用户有没有任意角色，如果没有返回 false，将到 onAccessDenied 进行处理；</li>
<li>如果用户没有角色，接着判断用户有没有登录，如果没有登录先重定向到登录；</li>
<li>如果用户没有角色且设置了未授权页面（unauthorizedUrl），那么重定向到未授权页面；否则直接返回 401 未授权错误码。</li>
</ol>
<p>shiro.ini 配置</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[users]</span></span><br><span class="line"><span class="attr">zhang</span>=<span class="string">123,admin</span></span><br><span class="line"><span class="attr">wang</span>=<span class="string">123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[roles]</span></span><br><span class="line"><span class="attr">admin</span>=<span class="string">user:*,menu:*</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[filters]</span></span><br><span class="line"><span class="attr">formLogin</span>=<span class="string">com.hyp.learn.shiro.cha06.web.filter.FormLoginFilter</span></span><br><span class="line"><span class="attr">anyRoles</span>=<span class="string">com.hyp.learn.shiro.cha06.web.filter.AnyRolesFilter</span></span><br><span class="line"><span class="attr">[urls]</span></span><br><span class="line"><span class="meta">/test.jsp</span>=<span class="string">formLogin,anyRoles[admin,user]</span></span><br><span class="line"><span class="meta">/login.jsp</span>=<span class="string">formLogin</span></span><br></pre></td></tr></table></figure>

<p>此处可以继承 AuthorizationFilter 实现，其提供了授权相关的基础代码。另外可以参考 Shiro 内嵌的 RolesAuthorizationFilter 的源码，只是实现 hasAllRoles 逻辑。</p>
</li>
</ol>
<h5 id="默认拦截器"><a href="#默认拦截器" class="headerlink" title="默认拦截器"></a>默认拦截器</h5><p>Shiro 内置了很多默认的拦截器，比如身份验证、授权等相关的。默认拦截器可以参考 org.apache.shiro.web.filter.mgt.DefaultFilter 中的枚举拦截器：</p>
<table>
<thead>
<tr>
<th>默认拦截器名</th>
<th>拦截器类</th>
<th>说明（括号里的表示默认值）</th>
</tr>
</thead>
<tbody><tr>
<td>身份验证相关的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>authc</td>
<td>org.apache.shiro.web.filter.authc.FormAuthenticationFilter</td>
<td>基于表单的拦截器；如 “<code>/**=authc</code>”，如果没有登录会跳到相应的登录页面登录；主要属性：usernameParam：表单提交的用户名参数名（ username）；  passwordParam：表单提交的密码参数名（password）； rememberMeParam：表单提交的密码参数名（rememberMe）； loginUrl：登录页面地址（/login.jsp）；successUrl：登录成功后的默认重定向地址； failureKeyAttribute：登录失败后错误信息存储 key（shiroLoginFailure）；</td>
</tr>
<tr>
<td>authcBasic</td>
<td>org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</td>
<td>Basic HTTP 身份验证拦截器，主要属性： applicationName：弹出登录框显示的信息（application）；</td>
</tr>
<tr>
<td>logout</td>
<td>org.apache.shiro.web.filter.authc.LogoutFilter</td>
<td>退出拦截器，主要属性：redirectUrl：退出成功后重定向的地址（/）; 示例 “/logout=logout”</td>
</tr>
<tr>
<td>user</td>
<td>org.apache.shiro.web.filter.authc.UserFilter</td>
<td>用户拦截器，用户已经身份验证 / 记住我登录的都可；示例 “/**=user”</td>
</tr>
<tr>
<td>anon</td>
<td>org.apache.shiro.web.filter.authc.AnonymousFilter</td>
<td>匿名拦截器，即不需要登录即可访问；一般用于静态资源过滤；示例 “/static/**=anon”</td>
</tr>
<tr>
<td><strong>授权相关的</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>roles</td>
<td>org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</td>
<td>角色授权拦截器，验证用户是否拥有所有角色；主要属性： loginUrl：登录页面地址（/login.jsp）；unauthorizedUrl：未授权后重定向的地址；示例 “/admin/**=roles[admin]”</td>
</tr>
<tr>
<td>perms</td>
<td>org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</td>
<td>权限授权拦截器，验证用户是否拥有所有权限；属性和 roles 一样；示例 “/user/**=perms[“user:create”]”</td>
</tr>
<tr>
<td>port</td>
<td>org.apache.shiro.web.filter.authz.PortFilter</td>
<td>端口拦截器，主要属性：port（80）：可以通过的端口；示例 “/test= port[80]”，如果用户访问该页面是非 80，将自动将请求端口改为 80 并重定向到该 80 端口，其他路径 / 参数等都一样</td>
</tr>
<tr>
<td>rest</td>
<td>org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</td>
<td>rest 风格拦截器，自动根据请求方法构建权限字符串（GET=read, POST=create,PUT=update,DELETE=delete,HEAD=read,TRACE=read,OPTIONS=read, MKCOL=create）构建权限字符串；示例 “/users=rest[user]”，会自动拼出“user:read,user:create,user:update,user:delete” 权限字符串进行权限匹配（所有都得匹配，isPermittedAll）；</td>
</tr>
<tr>
<td>ssl</td>
<td>org.apache.shiro.web.filter.authz.SslFilter</td>
<td>SSL 拦截器，只有请求协议是 https 才能通过；否则自动跳转会 https 端口（443）；其他和 port 拦截器一样；</td>
</tr>
<tr>
<td><strong>其他</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>noSessionCreation</td>
<td>org.apache.shiro.web.filter.session.NoSessionCreationFilter</td>
<td>不创建会话拦截器，调用 subject.getSession(false) 不会有什么问题，但是如果 subject.getSession(true) 将抛出 DisabledSessionException 异常；</td>
</tr>
</tbody></table>
<p>另外还提供了一个 org.apache.shiro.web.filter.authz.HostFilter，即主机拦截器，比如其提供了属性：authorizedIps：已授权的 ip 地址，deniedIps：表示拒绝的 ip 地址；不过目前还没有完全实现，不可用。</p>
<p>这些默认的拦截器会自动注册，可以直接在 ini 配置文件中通过 “拦截器名. 属性” 设置其属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perms.unauthorizedUrl=/unauthorized</span><br></pre></td></tr></table></figure>

<p>另外如果某个拦截器不想使用了可以直接通过如下配置直接禁用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perms.enabled=false</span><br></pre></td></tr></table></figure>

<h3 id="JSP-标签"><a href="#JSP-标签" class="headerlink" title="JSP 标签"></a>JSP 标签</h3><blockquote>
<p>了解即可</p>
</blockquote>
<p>Shiro 提供了 JSTL 标签用于在 JSP/GSP 页面进行权限控制，如根据登录用户显示相应的页面按钮。</p>
<h4 id="导入标签库"><a href="#导入标签库" class="headerlink" title="导入标签库"></a>导入标签库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;</span><br></pre></td></tr></table></figure>

<p>标签库定义在 shiro-web.jar 包下的 META-INF/shiro.tld 中定义。</p>
<p>guest 标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:guest&gt;</span><br><span class="line">欢迎游客访问，&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/login.jsp&quot;&gt;登录&lt;/a&gt;</span><br><span class="line">&lt;/shiro:guest&gt; </span><br></pre></td></tr></table></figure>

<p>用户没有身份验证时显示相应信息，即游客访问信息。</p>
<p><strong>user 标签</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:guest&gt;</span><br><span class="line">欢迎游客访问，&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/login.jsp&quot;&gt;登录&lt;/a&gt;</span><br><span class="line">&lt;/shiro:guest&gt; </span><br></pre></td></tr></table></figure>

<p>用户已经身份验证 / 记住我登录后显示相应的信息。</p>
<p><strong>authenticated 标签</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:authenticated&gt;</span><br><span class="line">    用户[&lt;shiro:principal/&gt;]已身份验证通过</span><br><span class="line">&lt;/shiro:authenticated&gt; </span><br></pre></td></tr></table></figure>

<p>用户已经身份验证通过，即 Subject.login 登录成功，不是记住我登录的。</p>
<p><strong>notAuthenticated 标签</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:notAuthenticated&gt;</span><br><span class="line">    未身份验证（包括记住我）</span><br><span class="line">&lt;/shiro:notAuthenticated&gt; </span><br></pre></td></tr></table></figure>

<p>用户已经身份验证通过，即没有调用 Subject.login 进行登录，包括记住我自动登录的也属于未进行身份验证。</p>
<p><strong>principal 标签</strong></p>
<p><code>&lt;shiro: principal/&gt;</code></p>
<p>显示用户身份信息，默认调用 Subject.getPrincipal() 获取，即 Primary Principal。</p>
<p><code>&lt;shiro:principal type=&quot;java.lang.String&quot;/&gt;</code></p>
<p>相当于 Subject.getPrincipals().oneByType(String.class)。</p>
<p><code>&lt;shiro:principal type=&quot;java.lang.String&quot;/&gt;</code></p>
<p>相当于 Subject.getPrincipals().oneByType(String.class)。</p>
<p><code>&lt;shiro:principal property=&quot;username&quot;/&gt;</code></p>
<p>相当于 ((User)Subject.getPrincipals()).getUsername()。</p>
<p><strong>hasRole 标签</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasRole name=&quot;admin&quot;&gt;</span><br><span class="line">    用户[&lt;shiro:principal/&gt;]拥有角色admin&lt;br/&gt;</span><br><span class="line">&lt;/shiro:hasRole&gt; </span><br></pre></td></tr></table></figure>

<p>如果当前 Subject 有角色将显示 body 体内容。</p>
<p><strong>hasAnyRoles 标签</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasAnyRoles name=&quot;admin,user&quot;&gt;</span><br><span class="line">    用户[&lt;shiro:principal/&gt;]拥有角色admin或user&lt;br/&gt;</span><br><span class="line">&lt;/shiro:hasAnyRoles&gt; </span><br></pre></td></tr></table></figure>

<p>如果当前 Subject 有任意一个角色（或的关系）将显示 body 体内容。</p>
<p><strong>lacksRole 标签</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:lacksRole name=&quot;abc&quot;&gt;</span><br><span class="line">    用户[&lt;shiro:principal/&gt;]没有角色abc&lt;br/&gt;</span><br><span class="line">&lt;/shiro:lacksRole&gt; </span><br></pre></td></tr></table></figure>

<p>如果当前 Subject 没有角色将显示 body 体内容。</p>
<p><strong>hasPermission 标签</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasPermission name=&quot;user:create&quot;&gt;</span><br><span class="line">    用户[&lt;shiro:principal/&gt;]拥有权限user:create&lt;br/&gt;</span><br><span class="line">&lt;/shiro:hasPermission&gt; </span><br></pre></td></tr></table></figure>

<p>如果当前 Subject 有权限将显示 body 体内容。</p>
<p><strong>lacksPermission 标签</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:lacksPermission name=&quot;org:create&quot;&gt;</span><br><span class="line">    用户[&lt;shiro:principal/&gt;]没有权限org:create&lt;br/&gt;</span><br><span class="line">&lt;/shiro:lacksPermission&gt; </span><br></pre></td></tr></table></figure>

<p>如果当前 Subject 没有权限将显示 body 体内容。</p>
<p>另外又提供了几个权限控制相关的标签：</p>
<p><strong>导入自定义标签库</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@taglib prefix=&quot;zhang&quot; tagdir=&quot;/WEB-INF/tags&quot; %&gt;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;zhang:hasAllRoles name=&quot;admin,user&quot;&gt;</span><br><span class="line">    用户[&lt;shiro:principal/&gt;]拥有角色admin和user&lt;br/&gt;</span><br><span class="line">&lt;/zhang:hasAllRoles&gt;</span><br><span class="line">&lt;zhang:hasAllPermissions name=&quot;user:create,user:update&quot;&gt;</span><br><span class="line">    用户[&lt;shiro:principal/&gt;]拥有权限user:create和user:update&lt;br/&gt;</span><br><span class="line">&lt;/zhang:hasAllPermissions&gt;</span><br><span class="line">&lt;zhang:hasAnyPermissions name=&quot;user:create,abc:update&quot;&gt;</span><br><span class="line">    用户[&lt;shiro:principal/&gt;]拥有权限user:create或abc:update&lt;br/&gt;</span><br><span class="line">&lt;/zhang:hasAnyPermissions&gt; </span><br></pre></td></tr></table></figure>

<p>hasAllRoles 表示拥有所有相关的角色；hasAllPermissions 表示拥有所有相关的权限；hasAnyPermissions 表示拥有任意一个相关的权限。</p>
<h4 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h4><p>Shiro 提供了完整的企业级会话管理功能，不依赖于底层容器（如 web 容器 tomcat），不管 JavaSE 还是 JavaEE 环境都可以使用，提供了会话管理、会话事件监听、会话存储 / 持久化、容器无关的集群、失效 / 过期支持、对 Web 的透明支持、SSO 单点登录的支持等特性。即直接使用 Shiro 的会话管理可以直接替换如 Web 容器的会话管理。</p>
<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>所谓会话，即用户访问应用时保持的连接关系，在多次交互中应用能够识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后，网站可以记住用户，且在退出之前都可以识别当前用户是谁。</p>
<p>Shiro 的会话支持不仅可以在普通的 JavaSE 应用中使用，也可以在 JavaEE 应用中使用，如 web 应用。且使用方式是一致的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">login(&quot;classpath:shiro.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);</span><br><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line">Session session = subject.getSession(); </span><br></pre></td></tr></table></figure>

<p>登录成功后使用 Subject.getSession() 即可获取会话；其等价于 Subject.getSession(true)，即如果当前没有创建 Session 对象会创建一个；另外 Subject.getSession(false)，如果当前没有创建 Session 则返回 null（不过默认情况下如果启用会话存储功能的话在创建 Subject 时会主动创建一个 Session）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.getId();</span><br></pre></td></tr></table></figure>

<p>获取当前会话的唯一标识。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.getHost();</span><br></pre></td></tr></table></figure>

<p>获取当前 Subject 的主机地址，该地址是通过 HostAuthenticationToken.getHost() 提供的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session.getTimeout();</span><br><span class="line">session.setTimeout(毫秒); </span><br></pre></td></tr></table></figure>

<p>获取 / 设置当前 Session 的过期时间；如果不设置默认是会话管理器的全局过期时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session.getStartTimestamp();</span><br><span class="line">session.getLastAccessTime();</span><br></pre></td></tr></table></figure>

<p>获取会话的启动时间及最后访问时间；如果是 JavaSE 应用需要自己定期调用 session.touch() 去更新最后访问时间；如果是 Web 应用，每次进入 ShiroFilter 都会自动调用 session.touch() 来更新最后访问时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session.touch();</span><br><span class="line">session.stop(); </span><br></pre></td></tr></table></figure>

<p>更新会话最后访问时间及销毁会话；当 Subject.logout() 时会自动调用 stop 方法来销毁会话。如果在 web 中，调用 javax.servlet.http.HttpSession. invalidate() 也会自动调用 Shiro Session.stop 方法进行销毁 Shiro 的会话。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session.setAttribute(&quot;key&quot;, &quot;123&quot;);</span><br><span class="line">Assert.assertEquals(&quot;123&quot;, session.getAttribute(&quot;key&quot;));</span><br><span class="line">session.removeAttribute(&quot;key&quot;);</span><br></pre></td></tr></table></figure>

<p>设置 / 获取 / 删除会话属性；在整个会话范围内都可以对这些属性进行操作。</p>
<p>Shiro 提供的会话可以用于 JavaSE/JavaEE 环境，不依赖于任何底层容器，可以独立使用，是完整的会话模块。</p>
<h4 id="会话管理器"><a href="#会话管理器" class="headerlink" title="会话管理器"></a>会话管理器</h4><p>会话管理器管理着应用中所有 Subject 的会话的创建、维护、删除、失效、验证等工作。是 Shiro 的核心组件，顶层组件 SecurityManager 直接继承了 SessionManager，且提供了SessionsSecurityManager 实现直接把会话管理委托给相应的 SessionManager，DefaultSecurityManager 及 DefaultWebSecurityManager 默认 SecurityManager 都继承了 SessionsSecurityManager。</p>
<p>SecurityManager 提供了如下接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Session start(SessionContext context); //启动会话</span><br><span class="line">Session getSession(SessionKey key) throws SessionException; //根据会话Key获取会话 </span><br></pre></td></tr></table></figure>

<p>另外用于 Web 环境的 WebSessionManager 又提供了如下接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean isServletContainerSessions();// 是否使用 Servlet 容器的会话</span><br></pre></td></tr></table></figure>

<p>Shiro 还提供了 ValidatingSessionManager 用于验资并过期会话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void validateSessions();// 验证所有会话是否过期</span><br></pre></td></tr></table></figure>

<p>Shiro 提供了三个默认实现：</p>
<ol>
<li><strong>DefaultSessionManager</strong>：DefaultSecurityManager 使用的默认实现，用于 JavaSE 环境；</li>
<li><strong>ServletContainerSessionManager</strong>：DefaultWebSecurityManager 使用的默认实现，用于 Web 环境，其直接使用 Servlet 容器的会话；</li>
<li><strong>DefaultWebSessionManager</strong>：用于 Web 环境的实现，可以替代 ServletContainerSessionManager，自己维护着会话，直接废弃了 Servlet 容器的会话管理。</li>
</ol>
<p>替换 SecurityManager 默认的 SessionManager 可以在 ini 中配置（shiro.ini）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[main]</span><br><span class="line">sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager</span><br><span class="line">securityManager.sessionManager=$sessionManager</span><br></pre></td></tr></table></figure>

<p>Web 环境下的 ini 配置 (shiro-web.ini)：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[main]</span></span><br><span class="line"><span class="attr">sessionManager</span>=<span class="string">org.apache.shiro.web.session.mgt.ServletContainerSessionManager</span></span><br><span class="line"><span class="meta">securityManager.sessionManager</span>=<span class="string">$sessionManager</span></span><br></pre></td></tr></table></figure>

<p>另外可以设置会话的全局过期时间（毫秒为单位），默认 30 分钟：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionManager. globalSessionTimeout=1800000</span><br></pre></td></tr></table></figure>

<p>默认情况下 globalSessionTimeout 将应用给所有 Session。可以单独设置每个 Session 的 timeout 属性来为每个 Session 设置其超时时间。</p>
<p>另外如果使用 ServletContainerSessionManager 进行会话管理，Session 的超时依赖于底层 Servlet 容器的超时时间，可以在 web.xml 中配置其会话的超时时间（分钟为单位）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;session-config&gt;</span><br><span class="line">  &lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure>

<p>在 Servlet 容器中，默认使用 JSESSIONID Cookie 维护会话，且会话默认是跟容器绑定的；在某些情况下可能需要使用自己的会话机制，此时我们可以使用 DefaultWebSessionManager 来维护会话：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sessionIdCookie</span>=<span class="string">org.apache.shiro.web.servlet.SimpleCookie</span></span><br><span class="line"><span class="attr">sessionManager</span>=<span class="string">org.apache.shiro.web.session.mgt.DefaultWebSessionManager</span></span><br><span class="line"><span class="meta">sessionIdCookie.name</span>=<span class="string">sid</span></span><br><span class="line"><span class="meta">\#sessionIdCookie.domain</span>=<span class="string">sishuok.com</span></span><br><span class="line"><span class="meta">\#sessionIdCookie.path</span>=<span class="string"></span></span><br><span class="line"><span class="meta">sessionIdCookie.maxAge</span>=<span class="string">1800</span></span><br><span class="line"><span class="meta">sessionIdCookie.httpOnly</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">sessionManager.sessionIdCookie</span>=<span class="string">$sessionIdCookie</span></span><br><span class="line"><span class="meta">sessionManager.sessionIdCookieEnabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">securityManager.sessionManager</span>=<span class="string">$sessionManager</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sessionIdCookie 是 sessionManager 创建会话 Cookie 的模板：</li>
<li>sessionIdCookie.name：设置 Cookie 名字，默认为 JSESSIONID；</li>
<li>sessionIdCookie.domain：设置 Cookie 的域名，默认空，即当前访问的域名；</li>
<li>sessionIdCookie.path：设置 Cookie 的路径，默认空，即存储在域名根下；</li>
<li>sessionIdCookie.maxAge：设置 Cookie 的过期时间，秒为单位，默认 - 1 表示关闭浏览器时过期 Cookie；</li>
<li>sessionIdCookie.httpOnly：如果设置为 true，则客户端不会暴露给客户端脚本代码，使用 HttpOnly cookie 有助于减少某些类型的跨站点脚本攻击；此特性需要实现了 Servlet 2.5 MR6 及以上版本的规范的 Servlet 容器支持；</li>
<li>sessionManager.sessionIdCookieEnabled：是否启用 / 禁用 Session Id Cookie，默认是启用的；如果禁用后将不会设置 Session Id Cookie，即默认使用了 Servlet 容器的 JSESSIONID，且通过 URL 重写（URL 中的 “;JSESSIONID=id” 部分）保存 Session Id。</li>
</ul>
<p>另外我们可以如 “sessionManager. sessionIdCookie.name=sid” 这种方式操作 Cookie 模板。</p>
<h4 id="会话监听器"><a href="#会话监听器" class="headerlink" title="会话监听器"></a>会话监听器</h4><p>会话监听器用于监听会话创建、过期及停止事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySessionListener1</span> <span class="keyword">implements</span> <span class="title">SessionListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Session session)</span> </span>&#123;<span class="comment">//会话创建时触发</span></span><br><span class="line">        System.out.println(<span class="string">&quot;会话创建：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExpiration</span><span class="params">(Session session)</span> </span>&#123;<span class="comment">//会话过期时触发</span></span><br><span class="line">        System.out.println(<span class="string">&quot;会话过期：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">(Session session)</span> </span>&#123;<span class="comment">//退出/会话过期时触发</span></span><br><span class="line">        System.out.println(<span class="string">&quot;会话停止：&quot;</span> + session.getId());</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只想监听某一个事件，可以继承 SessionListenerAdapter 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySessionListener2</span> <span class="keyword">extends</span> <span class="title">SessionListenerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;会话创建：&quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 shiro-web.ini 配置文件中可以进行如下配置设置会话监听器：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sessionListener1</span>=<span class="string">com.github.zhangkaitao.shiro.chapter10.web.listener.MySessionListener1</span></span><br><span class="line"><span class="attr">sessionListener2</span>=<span class="string">com.github.zhangkaitao.shiro.chapter10.web.listener.MySessionListener2</span></span><br><span class="line"><span class="meta">sessionManager.sessionListeners</span>=<span class="string">$sessionListener1,$sessionListener2</span></span><br></pre></td></tr></table></figure>

<h4 id="会话存储-持久化"><a href="#会话存储-持久化" class="headerlink" title="会话存储 / 持久化"></a>会话存储 / 持久化</h4><p>Shiro 提供 SessionDAO 用于会话的 CRUD，即 DAO（Data Access Object）模式实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//如DefaultSessionManager在创建完session后会调用该方法；如保存到关系数据库/文件系统/NoSQL数据库；即可以实现会话的持久化；返回会话ID；主要此处返回的ID.equals(session.getId())；</span><br><span class="line">Serializable create(Session session);</span><br><span class="line">//根据会话ID获取会话</span><br><span class="line">Session readSession(Serializable sessionId) throws UnknownSessionException;</span><br><span class="line">//更新会话；如更新会话最后访问时间/停止会话/设置超时时间/设置移除属性等会调用</span><br><span class="line">void update(Session session) throws UnknownSessionException;</span><br><span class="line">//删除会话；当会话过期/会话停止（如用户退出时）会调用</span><br><span class="line">void delete(Session session);</span><br><span class="line">//获取当前所有活跃用户，如果用户量多此方法影响性能</span><br><span class="line">Collection&lt;Session&gt; getActiveSessions(); </span><br></pre></td></tr></table></figure>

<p>Shiro 内嵌了如下 SessionDAO 实现：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2020/03/27/GPyqzt.png" alt="GPyqzt.png"></p>
<p>AbstractSessionDAO 提供了 SessionDAO 的基础实现，如生成会话 ID 等；CachingSessionDAO 提供了对开发者透明的会话缓存的功能，只需要设置相应的 CacheManager 即可；MemorySessionDAO 直接在内存中进行会话维护；而 EnterpriseCacheSessionDAO 提供了缓存功能的会话维护，默认情况下使用 MapCache 实现，内部使用 ConcurrentHashMap 保存缓存的会话。</p>
<p>可以通过如下配置设置 SessionDAO：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sessionDAO</span>=<span class="string">org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO</span></span><br><span class="line"><span class="meta">sessionManager.sessionDAO</span>=<span class="string">$sessionDAO</span></span><br></pre></td></tr></table></figure>

<p>Shiro 提供了使用 Ehcache 进行会话存储，Ehcache 可以配合 TerraCotta 实现容器无关的分布式集群。</p>
<p>首先在 pom.xml 里添加如下依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>接着配置 shiro-web.ini 文件：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sessionDAO</span>=<span class="string">org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO</span></span><br><span class="line"><span class="meta">sessionDAO.</span> <span class="string">activeSessionsCacheName=shiro-activeSessionCache</span></span><br><span class="line"><span class="meta">sessionManager.sessionDAO</span>=<span class="string">$sessionDAO</span></span><br><span class="line"><span class="attr">cacheManager</span> = <span class="string">org.apache.shiro.cache.ehcache.EhCacheManager</span></span><br><span class="line"><span class="meta">cacheManager.cacheManagerConfigFile</span>=<span class="string">classpath:ehcache.xml</span></span><br><span class="line"><span class="meta">securityManager.cacheManager</span> = <span class="string">$cacheManager</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sessionDAO. activeSessionsCacheName：设置 Session 缓存名字，默认就是 shiro-activeSessionCache；</li>
<li>cacheManager：缓存管理器，用于管理缓存的，此处使用 Ehcache 实现；</li>
<li>cacheManager.cacheManagerConfigFile：设置 ehcache 缓存的配置文件；</li>
<li>securityManager.cacheManager：设置 SecurityManager 的 cacheManager，会自动设置实现了 CacheManagerAware 接口的相应对象，如 SessionDAO 的 cacheManager；</li>
</ul>
<p>然后配置 ehcache.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;shiro-activeSessionCache&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">maxEntriesLocalHeap</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">statistics</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>Cache 的名字为 shiro-activeSessionCache，即设置的 sessionDAO 的 activeSessionsCacheName 属性值。</p>
<p>另外可以通过如下 ini 配置设置会话 ID 生成器：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sessionIdGenerator</span>=<span class="string">org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator</span></span><br><span class="line"><span class="meta">sessionDAO.sessionIdGenerator</span>=<span class="string">$sessionIdGenerator</span></span><br></pre></td></tr></table></figure>

<p>用于生成会话 ID，默认就是 JavaUuidSessionIdGenerator，使用 java.util.UUID 生成。</p>
<p>如果自定义实现 SessionDAO，继承 CachingSessionDAO 即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySessionDAO</span> <span class="keyword">extends</span> <span class="title">CachingSessionDAO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate = JdbcTemplateUtils.jdbcTemplate();</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> Serializable <span class="title">doCreate</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        Serializable sessionId = generateSessionId(session);</span><br><span class="line">        assignSessionId(session, sessionId);</span><br><span class="line">        String sql = <span class="string">&quot;insert into sessions(id, session) values(?,?)&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, sessionId, SerializableUtils.serialize(session));</span><br><span class="line">        <span class="keyword">return</span> session.getId();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(session <span class="keyword">instanceof</span> ValidatingSession &amp;&amp; !((ValidatingSession)session).isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//如果会话过期/停止 没必要再更新了</span></span><br><span class="line">    &#125;</span><br><span class="line">        String sql = <span class="string">&quot;update sessions set session=? where id=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, SerializableUtils.serialize(session), session.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;delete from sessions where id=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, session.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Session <span class="title">doReadSession</span><span class="params">(Serializable sessionId)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select session from sessions where id=?&quot;</span>;</span><br><span class="line">        List&lt;String&gt; sessionStrList = jdbcTemplate.queryForList(sql, String.class, sessionId);</span><br><span class="line">        <span class="keyword">if</span>(sessionStrList.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> SerializableUtils.deserialize(sessionStrList.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doCreate/doUpdate/doDelete/doReadSession 分别代表创建 / 修改 / 删除 / 读取会话；此处通过把会话序列化后存储到数据库实现；接着在 shiro-web.ini 中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionDAO=com.github.zhangkaitao.shiro.chapter10.session.dao.MySessionDAO</span><br></pre></td></tr></table></figure>

<p>其他设置和之前一样，因为继承了 CachingSessionDAO；所有在读取时会先查缓存中是否存在，如果找不到才到数据库中查找。</p>
<h4 id="会话验证"><a href="#会话验证" class="headerlink" title="会话验证"></a>会话验证</h4><p>Shiro 提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话；出于性能考虑，一般情况下都是获取会话时来验证会话是否过期并停止会话的；但是如在 web 环境中，如果用户不主动退出是不知道会话是否过期的，因此需要定期的检测会话是否过期，Shiro 提供了会话验证调度器 SessionValidationScheduler 来做这件事情。</p>
<p>可以通过如下 ini 配置开启会话验证：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sessionValidationScheduler=org.apache.shiro.session.mgt.ExecutorServiceSessionValidationScheduler</span><br><span class="line">sessionValidationScheduler.interval = 3600000</span><br><span class="line">sessionValidationScheduler.sessionManager=$sessionManager</span><br><span class="line">sessionManager.globalSessionTimeout=1800000</span><br><span class="line">sessionManager.sessionValidationSchedulerEnabled=true</span><br><span class="line">sessionManager.sessionValidationScheduler=$sessionValidationScheduler </span><br></pre></td></tr></table></figure>

<ul>
<li>sessionValidationScheduler：会话验证调度器，sessionManager 默认就是使用 ExecutorServiceSessionValidationScheduler，其使用 JDK 的 ScheduledExecutorService 进行定期调度并验证会话是否过期；</li>
<li>sessionValidationScheduler.interval：设置调度时间间隔，单位毫秒，默认就是 1 小时；</li>
<li>sessionValidationScheduler.sessionManager：设置会话验证调度器进行会话验证时的会话管理器；</li>
<li>sessionManager.globalSessionTimeout：设置全局会话超时时间，默认 30 分钟，即如果 30 分钟内没有访问会话将过期；</li>
<li>sessionManager.sessionValidationSchedulerEnabled：是否开启会话验证器，默认是开启的；</li>
<li>sessionManager.sessionValidationScheduler：设置会话验证调度器，默认就是使用 ExecutorServiceSessionValidationScheduler。</li>
</ul>
<p>Shiro 也提供了使用 Quartz 会话验证调度器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sessionValidationScheduler=org.apache.shiro.session.mgt.quartz.QuartzSessionValidationScheduler</span><br><span class="line">sessionValidationScheduler.sessionValidationInterval = 3600000</span><br><span class="line">sessionValidationScheduler.sessionManager=$sessionManager </span><br></pre></td></tr></table></figure>

<p>使用时需要导入 shiro-quartz 依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;shiro-quartz&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>如上会话验证调度器实现都是直接调用 AbstractValidatingSessionManager 的 validateSessions 方法进行验证，其直接调用 SessionDAO 的 getActiveSessions 方法获取所有会话进行验证，如果会话比较多，会影响性能；可以考虑如分页获取会话并进行验证，如 com.github.zhangkaitao.shiro.chapter10.session.scheduler.MySessionValidationScheduler：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//分页获取会话并验证</span><br><span class="line">String sql = &quot;select session from sessions limit ?,?&quot;;</span><br><span class="line">int start = 0; //起始记录</span><br><span class="line">int size = 20; //每页大小</span><br><span class="line">List&lt;String&gt; sessionList = jdbcTemplate.queryForList(sql, String.class, start, size);</span><br><span class="line">while(sessionList.size() &gt; 0) &#123;</span><br><span class="line">  for(String sessionStr : sessionList) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      Session session = SerializableUtils.deserialize(sessionStr);</span><br><span class="line">      Method validateMethod = </span><br><span class="line">        ReflectionUtils.findMethod(AbstractValidatingSessionManager.class, </span><br><span class="line">            &quot;validate&quot;, Session.class, SessionKey.class);</span><br><span class="line">      validateMethod.setAccessible(true);</span><br><span class="line">      ReflectionUtils.invokeMethod(validateMethod, </span><br><span class="line">        sessionManager, session, new DefaultSessionKey(session.getId()));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        //ignore</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> start = start + size;</span><br><span class="line">  sessionList = jdbcTemplate.queryForList(sql, String.class, start, size);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>其直接改造自 ExecutorServiceSessionValidationScheduler，如上代码是验证的核心代码，可以根据自己的需求改造此验证调度器器；ini 的配置和之前的类似。</p>
<p>如果在会话过期时不想删除过期的会话，可以通过如下 ini 配置进行设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionManager.deleteInvalidSessions=false</span><br></pre></td></tr></table></figure>

<p>默认是开启的，在会话过期后会调用 SessionDAO 的 delete 方法删除会话：如会话时持久化存储的，可以调用此方法进行删除。</p>
<p>如果是在获取会话时验证了会话已过期，将抛出 InvalidSessionException；因此需要捕获这个异常并跳转到相应的页面告诉用户会话已过期，让其重新登录，如可以在 web.xml 配置相应的错误页面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;exception-type&gt;org.apache.shiro.session.InvalidSessionException&lt;/exception-type&gt;</span><br><span class="line">    &lt;location&gt;/invalidSession.jsp&lt;/location&gt;</span><br><span class="line">&lt;/error-page&gt;</span><br></pre></td></tr></table></figure>

<h4 id="sessionFactory"><a href="#sessionFactory" class="headerlink" title="sessionFactory"></a>sessionFactory</h4><p>sessionFactory 是创建会话的工厂，根据相应的 Subject 上下文信息来创建会话；默认提供了 SimpleSessionFactory 用来创建 SimpleSession 会话。</p>
<p>首先自定义一个 Session：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class OnlineSession extends SimpleSession &#123;</span><br><span class="line">    public static enum OnlineStatus &#123;</span><br><span class="line">        on_line(&quot;在线&quot;), hidden(&quot;隐身&quot;), force_logout(&quot;强制退出&quot;);</span><br><span class="line">        private final String info;</span><br><span class="line">        private OnlineStatus(String info) &#123;</span><br><span class="line">            this.info = info;</span><br><span class="line">        &#125;</span><br><span class="line">        public String getInfo() &#123;</span><br><span class="line">            return info;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private String userAgent; //用户浏览器类型</span><br><span class="line">    private OnlineStatus status = OnlineStatus.on_line; //在线状态</span><br><span class="line">    private String systemHost; //用户登录时系统IP</span><br><span class="line">    //省略其他</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>OnlineSession 用于保存当前登录用户的在线状态，支持如离线等状态的控制。</p>
<p>接着自定义 SessionFactory：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class OnlineSessionFactory implements SessionFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Session createSession(SessionContext initData) &#123;</span><br><span class="line">        OnlineSession session = new OnlineSession();</span><br><span class="line">        if (initData != null &amp;&amp; initData instanceof WebSessionContext) &#123;</span><br><span class="line">            WebSessionContext sessionContext = (WebSessionContext) initData;</span><br><span class="line">            HttpServletRequest request = (HttpServletRequest) sessionContext.getServletRequest();</span><br><span class="line">            if (request != null) &#123;</span><br><span class="line">                session.setHost(IpUtils.getIpAddr(request));</span><br><span class="line">                session.setUserAgent(request.getHeader(&quot;User-Agent&quot;));</span><br><span class="line">                session.setSystemHost(request.getLocalAddr() + &quot;:&quot; + request.getLocalPort());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return session;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>根据会话上下文创建相应的 OnlineSession。</p>
<p>最后在 shiro-web.ini 配置文件中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionFactory=org.apache.shiro.session.mgt.OnlineSessionFactory</span><br><span class="line">sessionManager.sessionFactory=$sessionFactory</span><br></pre></td></tr></table></figure>

<h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>Shiro 提供了类似于 Spring 的 Cache 抽象，即 Shiro 本身不实现 Cache，但是对 Cache 进行了又抽象，方便更换不同的底层 Cache 实现。</p>
<p><strong>Shiro 提供的 Cache 接口</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//根据Key获取缓存中的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> <span class="keyword">throws</span> CacheException</span>;</span><br><span class="line">    <span class="comment">//往缓存中放入key-value，返回缓存中之前的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> <span class="keyword">throws</span> CacheException</span>; </span><br><span class="line">    <span class="comment">//移除缓存中key对应的值，返回该值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> <span class="keyword">throws</span> CacheException</span>;</span><br><span class="line">    <span class="comment">//清空整个缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">throws</span> CacheException</span>;</span><br><span class="line">    <span class="comment">//返回缓存大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取缓存中所有的key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keys</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取缓存中所有的value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Shiro 提供的 CacheManager 接口</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据缓存名字获取一个Cache</span></span><br><span class="line">    <span class="keyword">public</span> &lt;K, V&gt; <span class="function">Cache&lt;K, V&gt; <span class="title">getCache</span><span class="params">(String name)</span> <span class="keyword">throws</span> CacheException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Shiro 还提供了 CacheManagerAware 用于注入 CacheManager</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheManagerAware</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入CacheManager</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCacheManager</span><span class="params">(CacheManager cacheManager)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Shiro 内部相应的组件（DefaultSecurityManager）会自动检测相应的对象（如 Realm）是否实现了 CacheManagerAware 并自动注入相应的 CacheManager。</p>
<h4 id="Realm-缓存"><a href="#Realm-缓存" class="headerlink" title="Realm 缓存"></a>Realm 缓存</h4><p>Shiro 提供了 CachingRealm，其实现了 CacheManagerAware 接口，提供了缓存的一些基础实现；另外 AuthenticatingRealm 及 AuthorizingRealm 分别提供了对 AuthenticationInfo 和 AuthorizationInfo 信息的缓存。</p>
<p><strong>ini 配置</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userRealm</span>=<span class="string">com.github.zhangkaitao.shiro.chapter11.realm.UserRealm</span></span><br><span class="line"><span class="meta">userRealm.credentialsMatcher</span>=<span class="string">$credentialsMatcher</span></span><br><span class="line"><span class="meta">userRealm.cachingEnabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">userRealm.authenticationCachingEnabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">userRealm.authenticationCacheName</span>=<span class="string">authenticationCache</span></span><br><span class="line"><span class="meta">userRealm.authorizationCachingEnabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">userRealm.authorizationCacheName</span>=<span class="string">authorizationCache</span></span><br><span class="line"><span class="meta">securityManager.realms</span>=<span class="string">$userRealm</span></span><br><span class="line"><span class="attr">cacheManager</span>=<span class="string">org.apache.shiro.cache.ehcache.EhCacheManager</span></span><br><span class="line"><span class="meta">cacheManager.cacheManagerConfigFile</span>=<span class="string">classpath:shiro-ehcache.xml</span></span><br><span class="line"><span class="meta">securityManager.cacheManager</span>=<span class="string">$cacheManager</span></span><br></pre></td></tr></table></figure>

<ul>
<li>userRealm.cachingEnabled：启用缓存，默认 false；</li>
<li>userRealm.authenticationCachingEnabled：启用身份验证缓存，即缓存 AuthenticationInfo 信息，默认 false；</li>
<li>userRealm.authenticationCacheName：缓存 AuthenticationInfo 信息的缓存名称；</li>
<li>userRealm. authorizationCachingEnabled：启用授权缓存，即缓存 AuthorizationInfo 信息，默认 false；</li>
<li>userRealm. authorizationCacheName：缓存 AuthorizationInfo 信息的缓存名称；</li>
<li>cacheManager：缓存管理器，此处使用 EhCacheManager，即 Ehcache 实现，需要导入相应的 Ehcache 依赖，请参考 pom.xml；</li>
</ul>
<p>因为测试用例的关系，需要将 Ehcache 的 CacheManager 改为使用 VM 单例模式： this.manager = new net.sf.ehcache.CacheManager(getCacheManagerConfigFileInputStream())； 改为 this.manager = net.sf.ehcache.CacheManager.create(getCacheManagerConfigFileInputStream())；</p>
<p><strong>测试用例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClearCachedAuthenticationInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    login(u1.getUsername(), password);</span><br><span class="line">    userService.changePassword(u1.getId(), password + <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    RealmSecurityManager securityManager =</span><br><span class="line">     (RealmSecurityManager) SecurityUtils.getSecurityManager();</span><br><span class="line">    UserRealm userRealm = (UserRealm) securityManager.getRealms().iterator().next();   userRealm.clearCachedAuthenticationInfo(subject().getPrincipals());</span><br><span class="line">    login(u1.getUsername(), password + <span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先登录成功（此时会缓存相应的 AuthenticationInfo），然后修改密码；此时密码就变了；接着需要调用 Realm 的 clearCachedAuthenticationInfo 方法清空之前缓存的 AuthenticationInfo；否则下次登录时还会获取到修改密码之前的那个 AuthenticationInfo；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClearCachedAuthorizationInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    login(u1.getUsername(), password);</span><br><span class="line">    subject().checkRole(r1.getRole());</span><br><span class="line">    userService.correlationRoles(u1.getId(), r2.getId());</span><br><span class="line">    RealmSecurityManager securityManager =</span><br><span class="line">      (RealmSecurityManager) SecurityUtils.getSecurityManager();</span><br><span class="line">    UserRealm userRealm = (UserRealm)securityManager.getRealms().iterator().next();   userRealm.clearCachedAuthorizationInfo(subject().getPrincipals());</span><br><span class="line">    subject().checkRole(r2.getRole());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和之前的用例差不多；此处调用 Realm 的 clearCachedAuthorizationInfo 清空之前缓存的 AuthorizationInfo；</p>
<p>另外还有 clearCache，其同时调用 clearCachedAuthenticationInfo 和 clearCachedAuthorizationInfo，清空 AuthenticationInfo 和 AuthorizationInfo。</p>
<p>UserRealm 还提供了 clearAllCachedAuthorizationInfo、clearAllCachedAuthenticationInfo、clearAllCache，用于清空整个缓存。</p>
<p>在某些清空下这种方式可能不是最好的选择，可以考虑直接废弃 Shiro 的缓存，然后自己通过如 AOP 机制实现自己的缓存；</p>
<p>另外如果和 Spring 集成时可以考虑直接使用 Spring 的 Cache 抽象，可以考虑使用 SpringCacheManagerWrapper，其对 Spring Cache 进行了包装，转换为 Shiro 的 CacheManager 实现</p>
<h4 id="Session-缓存"><a href="#Session-缓存" class="headerlink" title="Session 缓存"></a>Session 缓存</h4><p>当我们设置了 SecurityManager 的 CacheManager 时，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">securityManager.cacheManager=$cacheManager</span><br></pre></td></tr></table></figure>

<p>当我们设置 SessionManager 时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager</span><br><span class="line">securityManager.sessionManager=$sessionManager</span><br></pre></td></tr></table></figure>

<p>如 securityManager 实现了 SessionsSecurityManager，其会自动判断 SessionManager 是否实现了 CacheManagerAware 接口，如果实现了会把 CacheManager 设置给它。然后 sessionManager 会判断相应的 sessionDAO（如继承自 CachingSessionDAO）是否实现了 CacheManagerAware，如果实现了会把 CacheManager 设置给它；如第九章的 MySessionDAO 就是带缓存的 SessionDAO；其会先查缓存，如果找不到才查数据库。</p>
<p>对于 CachingSessionDAO，可以通过如下配置设置缓存的名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionDAO=com.github.zhangkaitao.shiro.chapter11.session.dao.MySessionDAO</span><br><span class="line">sessionDAO.activeSessionsCacheName=shiro-activeSessionCache</span><br></pre></td></tr></table></figure>

<p>activeSessionsCacheName 默认就是 shiro-activeSessionCache。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/11/20/Java-%E6%A1%86%E6%9E%B6-9-2-1-2/">https://pingxin0521.gitee.io/2019/11/20/Java-%E6%A1%86%E6%9E%B6-9-2-1-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/11/20/Java-%E6%A1%86%E6%9E%B6-7-2-2-2/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mybatis 动态SQL、批量操作</div></div></a></div><div class="next-post pull-right"><a href="/2019/11/19/Java-%E6%A1%86%E6%9E%B6-7-2-2-1/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MyBatis 的关联映射</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/07/12/Java-SpringBoot-1-4-2/" title="Spring boot 数据访问 MongoDB"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-01-25</div><div class="title">Spring boot 数据访问 MongoDB</div></div></a></div><div><a href="/2019/12/10/Java-SpringBoot-1-6-1/" title="Spring boot 消息队列(使用RabbitMQ)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-02-09</div><div class="title">Spring boot 消息队列(使用RabbitMQ)</div></div></a></div><div><a href="/2019/05/30/Java-SpringCloud-0-0/" title="Spring Cloud 入门 (一)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">Spring Cloud 入门 (一)</div></div></a></div><div><a href="/2019/11/01/Java-SpringCloud-3-0/" title="Spring Cloud 组件之Hystrix (五)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">Spring Cloud 组件之Hystrix (五)</div></div></a></div><div><a href="/2019/10/27/Java-SpringCloud-6-0/" title="微服务组件--分布式追踪系统"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">微服务组件--分布式追踪系统</div></div></a></div><div><a href="/2019/11/03/Java-SpringCloud-6-2/" title="SpringCloud组件之Spring Cloud Sleuth (八)"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-12-27</div><div class="title">SpringCloud组件之Spring Cloud Sleuth (八)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-%E9%9B%86%E6%88%90"><span class="toc-number">1.</span> <span class="toc-text">Web 集成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ShiroFilter-%E5%85%A5%E5%8F%A3"><span class="toc-number">1.1.</span> <span class="toc-text">ShiroFilter 入口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">拦截器机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE"><span class="toc-number">2.1.</span> <span class="toc-text">拦截器链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">自定义拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">默认拦截器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSP-%E6%A0%87%E7%AD%BE"><span class="toc-number">3.</span> <span class="toc-text">JSP 标签</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E6%A0%87%E7%AD%BE%E5%BA%93"><span class="toc-number">3.1.</span> <span class="toc-text">导入标签库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">会话管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D"><span class="toc-number">3.3.</span> <span class="toc-text">会话</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">会话管理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">3.5.</span> <span class="toc-text">会话监听器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E5%AD%98%E5%82%A8-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.6.</span> <span class="toc-text">会话存储 &#x2F; 持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E9%AA%8C%E8%AF%81"><span class="toc-number">3.7.</span> <span class="toc-text">会话验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sessionFactory"><span class="toc-number">3.8.</span> <span class="toc-text">sessionFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">3.9.</span> <span class="toc-text">缓存机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Realm-%E7%BC%93%E5%AD%98"><span class="toc-number">3.10.</span> <span class="toc-text">Realm 缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-%E7%BC%93%E5%AD%98"><span class="toc-number">3.11.</span> <span class="toc-text">Session 缓存</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>nginx 正向代理、反向代理、负载均衡和web缓存 | 平心de小屋</title><meta name="keywords" content="服务器,Nginx"><meta name="author" content="平心"><meta name="copyright" content="平心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="nginx代理nginx的正向代理，只能代理http、tcp等，不能代理https请求。有很多人不是很理解具体什么是nginx的正向代理、什么是反向代理。下面结合自己的使用做的一个简介： 1）正向代理：    所谓正向代理就是内网服务器主动要去请求外网的地址或服务，所进行的一种行为。内网服务—访问—&gt;外网 2）反向代理：   所谓反向代理就是外网要访问内网服务而进行的一种行为。 外网—-请求">
<meta property="og:type" content="article">
<meta property="og:title" content="nginx 正向代理、反向代理、负载均衡和web缓存">
<meta property="og:url" content="https://pingxin0521.gitee.io/2019/08/22/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx-2-2/index.html">
<meta property="og:site_name" content="平心de小屋">
<meta property="og:description" content="nginx代理nginx的正向代理，只能代理http、tcp等，不能代理https请求。有很多人不是很理解具体什么是nginx的正向代理、什么是反向代理。下面结合自己的使用做的一个简介： 1）正向代理：    所谓正向代理就是内网服务器主动要去请求外网的地址或服务，所进行的一种行为。内网服务—访问—&gt;外网 2）反向代理：   所谓反向代理就是外网要访问内网服务而进行的一种行为。 外网—-请求">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg">
<meta property="article:published_time" content="2019-08-22T03:18:59.000Z">
<meta property="article:modified_time" content="2019-12-26T14:17:57.066Z">
<meta property="article:author" content="平心">
<meta property="article:tag" content="服务器">
<meta property="article:tag" content="Nginx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg"><link rel="shortcut icon" href="https://s2.ax1x.com/2020/02/11/1ovFOA.png"><link rel="canonical" href="https://pingxin0521.gitee.io/2019/08/22/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx-2-2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'nginx 正向代理、反向代理、负载均衡和web缓存',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2019-12-26 22:17:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">平心de小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">nginx 正向代理、反向代理、负载均衡和web缓存</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-08-22T03:18:59.000Z" title="发表于 2019-08-22 11:18:59">2019-08-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-12-26T14:17:57.066Z" title="更新于 2019-12-26 22:17:57">2019-12-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/">Nginx</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="nginx 正向代理、反向代理、负载均衡和web缓存"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="nginx代理"><a href="#nginx代理" class="headerlink" title="nginx代理"></a>nginx代理</h3><p>nginx的正向代理，只能代理http、tcp等，不能代理https请求。有很多人不是很理解具体什么是nginx的正向代理、什么是反向代理。下面结合自己的使用做的一个简介：</p>
<p>1）正向代理：</p>
<p>   所谓正向代理就是内网服务器主动要去请求外网的地址或服务，所进行的一种行为。内网服务—访问—&gt;外网</p>
<p>2）反向代理：</p>
<p>  所谓反向代理就是外网要访问内网服务而进行的一种行为。 外网—-请求—&gt;内网服务</p>
<span id="more"></span>

<h4 id="正向代理和反向代理的区别"><a href="#正向代理和反向代理的区别" class="headerlink" title="正向代理和反向代理的区别"></a>正向代理和反向代理的区别</h4><p>正向代理和反向代理的区别我在知乎上找到两张图可以帮助我们很好的理解：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/10/15/DK75VNZB6E1Rywv.png" alt="image.png"></p>
<p><strong>正向代理:客户端 &lt;一&gt; 代理 一&gt;服务端</strong></p>
<p>正向代理简单地打个租房的比方:</p>
<p>A(客户端)想租C(服务端)的房子,但是A(客户端)并不认识C(服务端)租不到。<br>B(代理)认识C(服务端)能租这个房子所以你找了B(代理)帮忙租到了这个房子。</p>
<p>这个过程中C(服务端)不认识A(客户端)只认识B(代理)<br>C(服务端)并不知道A(客户端)租了房子，只知道房子租给了B(代理)。</p>
<p><strong>反向代理:客户端 一&gt;代理 &lt;一&gt; 服务端</strong></p>
<p>反向代理也用一个租房的例子:</p>
<p>A(客户端)想租一个房子,B(代理)就把这个房子租给了他。<br>这时候实际上C(服务端)才是房东。<br>B(代理)是中介把这个房子租给了A(客户端)。</p>
<p>这个过程中A(客户端)并不知道这个房子到底谁才是房东<br>他都有可能认为这个房子就是B(代理)的</p>
<p>由上的例子和图我们可以知道正向代理和反向代理的区别在于代理的对象不一样,正向代理的代理对象是客户端,反向代理的代理对象是服务端。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/10/15/O59W7Vz1CySKgiM.png" alt="image.png"></p>
<ul>
<li>正向代理: 对于客户端,我的请求到达Nginx,Nginx把我的请求分配到外部服务器,隐藏了服务端的身份</li>
<li>反向代理: 服务端向外部客户端提供服务,但是任务是由Nginx下发的,不知道客户端是谁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line"> proxy_pass http://localhost:8000;       # 设定请求跳转后的地址,可以使用 hostname 或 IP:Port 形式</span><br><span class="line"> proxy_set_header X-Real-IP $remote_addr;# 后端请求携带原始请求的真实 IP 地址</span><br></pre></td></tr></table></figure>

<p>proxy_pass:设置被代理服务器的地址和被映射的URI,地址可以使用主机名或IP加端口号的形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /html/ &#123;</span><br><span class="line">1. proxy_pass http://proxy.com;</span><br><span class="line">2. proxy_pass http://proxy.com/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设访问的url是 <code>http://domain.com/html/test.js</code></p>
<p>对于1来说 proxy.com 后面没有”/“,表示”/html/“ 请求(包括自己)后续的路径及其参数等关键字都由<code>http://a.com/</code>来处理,代理后变成了<code>http://proxy.com/html/test.js</code></p>
<p>对 2来所 proxy.com 后面有”/“,表示”/html/“ 请求后续的路径及其参数等关键字都由 <code>http://a.com/</code>来处理,代理后变成了<code>http://proxy.com/test.js</code></p>
<p><strong>一个请求的生命周期</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8000;</span><br><span class="line">    location / &#123;</span><br><span class="line">    proxy_pass http://192.168.31.129:8001;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个server服务监听<code>0.0.0.0:8000</code>端口监听表示本机素有ip的8000端口,如果有客户端请求到我们本机的8000端口,则开始匹配, <code>/</code>表示匹配所有的路径,对8000端口无条件转发到<code>http://192.168.31.129:8001;</code> ps:我们的服务器需要绑定<code>http://192.168.31.129:8001;</code></p>
<h4 id="两种代理配置方式"><a href="#两种代理配置方式" class="headerlink" title="两种代理配置方式"></a>两种代理配置方式</h4><ol>
<li><p>正向代理：</p>
<p>nginx同样可以实现代理上网的功能，在conf.d文件夹中新建文件proxy.conf(文件名随意)，内容如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">access_log</span> /var/log/nginx/access.log;</span><br><span class="line">    <span class="comment">#8090这个端口，就是用来正向代理的。客户端发送到这个端口的请求，都会被代理出去。</span></span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8090</span>;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="comment">#resolver 定义域名解析。本实验好像没有用到这个配置。改成一个不存在的ip都不影响。</span></span><br><span class="line">                <span class="attribute">resolver</span> <span class="number">8.8.8.8</span>;</span><br><span class="line">                <span class="attribute">proxy_pass</span> $scheme://$http_host$request_uri;</span><br><span class="line">                <span class="attribute">proxy_buffers</span>   <span class="number">256</span> <span class="number">4k</span>;</span><br><span class="line">                <span class="attribute">proxy_max_temp_file_size</span> <span class="number">0k</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nginx实现代理上网，有三个关键点必须注意，其余的配置跟普通的nginx一样</p>
<ol>
<li><p>增加dns解析resolver</p>
</li>
<li><p>增加无server_name名的server</p>
</li>
<li><p>proxy_pass指令</p>
</li>
</ol>
<p>client端：</p>
<p>一次代理，直接在shell执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># export http_proxy=http://192.168.1.9:8090</span><br></pre></td></tr></table></figure>

<p>永久使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vim .bashrc</span><br><span class="line">export http_proxy=http://192.168.1.9:8090</span><br><span class="line"># source .bashrc</span><br></pre></td></tr></table></figure>

<p>注：取消代理<code>unset http_proxy</code></p>
</li>
<li><p>反向代理</p>
<p>nginx反向代理的指令不需要新增额外的模块，默认自带proxy_pass指令，只需要修改配置文件就可以实现反向代理。</p>
<p>配置前的准备工作，后端跑apache服务的ip和端口，也就是说可以通过<a href="http://ip:port能访问到你的网站。">http://ip:port能访问到你的网站。</a></p>
<p>然后就可以新建一个proxy.conf,加入如下内容，记得修改ip和域名为你的ip和域名。</p>
<p>在配置文件夹下的<code>conf.d</code>文件夹下创建<code>proxy.conf</code></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Basic reverse proxy server ##</span></span><br><span class="line"><span class="comment">## tomcat and httpd</span></span><br><span class="line"><span class="attribute">upstream</span> ippools  &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.17.0.4:8080</span>; <span class="comment">#Apache</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.17.0.5:8080</span>; <span class="comment">#Apache</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line">	<span class="attribute">root</span>   html;</span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">    <span class="comment">## send request back to apache ##</span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>  $scheme://ippools;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#Proxy Settings</span></span><br><span class="line">        <span class="attribute">proxy_redirect</span>     <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   Host             $host;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   X-Real-IP        $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">        <span class="attribute">proxy_next_upstream</span> <span class="literal">error</span> timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">        <span class="attribute">proxy_max_temp_file_size</span> <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">proxy_connect_timeout</span>      <span class="number">90</span>;</span><br><span class="line">        <span class="attribute">proxy_send_timeout</span>         <span class="number">90</span>;</span><br><span class="line">        <span class="attribute">proxy_read_timeout</span>         <span class="number">90</span>;</span><br><span class="line">        <span class="comment">#该指令开启从后端被代理服务器的响应内容缓冲.</span></span><br><span class="line">        <span class="attribute">proxy_buffering</span> <span class="literal">on</span>；</span><br><span class="line">        <span class="comment">#该指令设置缓冲区大小,从被代理的后端服务器取得的响应内容,会先读取放置到这里</span></span><br><span class="line">        <span class="comment">#小的响应header通常位于这部分响应内容里边.</span></span><br><span class="line">        <span class="comment">#默认来说,该缓冲区大小等于指令proxy_buffers所设置的;但是,你可以把它设置得更小.</span></span><br><span class="line">        proxy_buffer_size          <span class="number">4k</span>;</span><br><span class="line">        <span class="comment">#该指令设置缓冲区的大小和数量,从被代理的后端服务器取得的响应内容,会放置到这里. 默认情况下,一个缓冲区的大小等于页面大小,可能是4K也可能是8K,这取决于平台</span></span><br><span class="line">        <span class="attribute">proxy_buffers</span>              <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line">     <span class="attribute">proxy_busy_buffers_size</span>    <span class="number">64k</span>;</span><br><span class="line">        <span class="attribute">proxy_temp_file_write_size</span> <span class="number">64k</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>代理服务器站在客户端那边就是正向代理，代理服务器站在原始服务器那边就是反向代理,Nginx通过<code>proxy_pass</code>可以设置代理服务。</p>
<h4 id="Nginx代理服务的配置说明"><a href="#Nginx代理服务的配置说明" class="headerlink" title="Nginx代理服务的配置说明"></a>Nginx代理服务的配置说明</h4><p>当代理遇到状态码为404时，我们把404页面导向百度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_page 404 https://www.baidu.com; #错误页</span><br></pre></td></tr></table></figure>

<p>如果我们想让他起作用，我们必须配合着下面的配置一起使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_intercept_errors on;    #如果被代理服务器返回的状态码为400或者大于400，设置的error_page配置起作用。默认为off。</span><br></pre></td></tr></table></figure>

<p>如果我们的代理只允许接受get，post请求方法的一种</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_method get;    #支持客户端的请求方法。post/get；</span><br></pre></td></tr></table></figure>

<p>设置支持的http协议版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_http_version 1.0 ; #Nginx服务器提供代理服务的http协议版本1.0，1.1，默认设置为1.0版本</span><br></pre></td></tr></table></figure>

<p>如果你的nginx服务器给2台web服务器做代理，负载均衡算法采用轮询，那么当你的一台机器web程序iis关闭，也就是说web不能访问，那么nginx服务器分发请求还是会给这台不能访问的web服务器，如果这里的响应连接时间过长，就会导致客户端的页面一直在等待响应，对用户来说体验就打打折扣，这里我们怎么避免这样的情况发生呢。这里我配张图来说明下问题。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/10/15/KVrFoa7TJ982zB1.png" alt="image.png"></p>
<p>如果负载均衡中其中web2发生这样的情况，nginx首先会去web1请求，但是nginx在配置不当的情况下会继续分发请求道web2，然后等待web2响应，直到我们的响应时间超时，才会把请求重新分发给web1，这里的响应时间如果过长，用户等待的时间就会越长。</p>
<p>下面的配置是解决方案之一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_connect_timeout 1;   #nginx服务器与被代理的服务器建立连接的超时时间，默认60秒</span><br><span class="line">proxy_read_timeout 1; #nginx服务器想被代理服务器组发出read请求后，等待响应的超时间，默认为60秒。</span><br><span class="line">proxy_send_timeout 1; #nginx服务器想被代理服务器组发出write请求后，等待响应的超时间，默认为60秒。</span><br><span class="line">proxy_ignore_client_abort on;  #客户端断网时，nginx服务器是否终端对被代理服务器的请求。默认为off。</span><br></pre></td></tr></table></figure>

<p>如果使用upstream指令配置啦一组服务器作为被代理服务器，服务器中的访问算法遵循配置的负载均衡规则，同时可以使用该指令配置在发生哪些异常情况时，将请求顺次交由下一组服务器处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_next_upstream timeout;  #反向代理upstream中设置的服务器组，出现故障时，被代理服务器返回的状态值。</span><br><span class="line">error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off</span><br></pre></td></tr></table></figure>

<ul>
<li>error：建立连接或向被代理的服务器发送请求或读取响应信息时服务器发生错误。</li>
<li>timeout：建立连接，想被代理服务器发送请求或读取响应信息时服务器发生超时。</li>
<li>invalid_header:被代理服务器返回的响应头异常。</li>
<li>off:无法将请求分发给被代理的服务器。</li>
<li>http_400，….:被代理服务器返回的状态码为400，500，502，等。</li>
</ul>
<p>如果你想通过http获取客户的真是ip而不是获取代理服务器的ip地址，那么要做如下的设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header Host $host; #只要用户在浏览器中访问的域名绑定了 VIP VIP 下面有RS；则就用$host ；host是访问URL中的域名和端口  www.taobao.com:80</span><br><span class="line"></span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;  #把源IP 【$remote_addr,建立HTTP连接header里面的信息】赋值给X-Real-IP;这样在代码中 $X-Real-IP来获取 源IP</span><br><span class="line"></span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;#在nginx 作为代理服务器时，设置的IP列表，会把经过的机器ip，代理机器ip都记录下来，用 【，】隔开；代码中用 echo $x-forwarded-for |awk -F, &#x27;&#123;print $1&#125;&#x27; 来作为源IP</span><br></pre></td></tr></table></figure>

<p><strong>HTTP 请求头中的 X-Forwarded-For</strong></p>
<p>通过名字就知道，X-Forwarded-For 是一个 HTTP 扩展头部。HTTP/1.1（RFC 2616）协议并没有对它的定义，它最开始是由 Squid 这个缓存代理软件引入，用来表示 HTTP 请求端真实 IP。如今它已经成为事实上的标准，被各大 HTTP 代理、负载均衡等转发服务广泛使用，并被写入 <a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc7239">RFC 7239</a>（Forwarded HTTP Extension）标准之中。</p>
<p>X-Forwarded-For 请求头格式非常简单，就这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: client, proxy1, proxy2</span><br></pre></td></tr></table></figure>

<p>可以看到，XFF 的内容由「英文逗号 + 空格」隔开的多个部分组成，最开始的是离服务端最远的设备 IP，然后是每一级代理设备的 IP。</p>
<p>如果一个 HTTP 请求到达服务器之前，经过了三个代理 Proxy1、Proxy2、Proxy3，IP 分别为 IP1、IP2、IP3，用户真实 IP 为 IP0，那么按照 XFF 标准，服务端最终会收到以下信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: IP0, IP1, IP2</span><br></pre></td></tr></table></figure>

<p>Proxy3 直连服务器，它会给 XFF 追加 IP2，表示它是在帮 Proxy2 转发请求。列表中并没有 IP3，IP3 可以在服务端通过 Remote Address 字段获得。我们知道 HTTP 连接基于 TCP 连接，HTTP 协议中没有 IP 的概念，Remote Address 来自 TCP 连接，表示与服务端建立 TCP 连接的设备 IP，在这个例子里就是 IP3。</p>
<p>Remote Address 无法伪造，因为建立 TCP 连接需要三次握手，如果伪造了源 IP，无法建立 TCP 连接，更不会有后面的 HTTP 请求。不同语言获取 Remote Address 的方式不一样，例如 php 是 <code>$_SERVER[&quot;REMOTE_ADDR&quot;]</code>，Node.js 是 <code>req.connection.remoteAddress</code>，但原理都一样。</p>
<ol>
<li>直接对外提供服务的 Web 应用，在进行与安全有关的操作时，只能通过 Remote Address 获取 IP，不能相信任何请求头；</li>
<li>使用 Nginx 等 Web Server 进行反向代理的 Web 应用，在配置正确的前提下，要用 <code>X-Forwarded-For</code> 最后一节 或 <code>X-Real-IP</code> 来获取 IP（因为 Remote Address 得到的是 Nginx 所在服务器的内网 IP）；同时还应该禁止 Web 应用直接对外提供服务；</li>
<li>在与安全无关的场景，例如通过 IP 显示所在地天气，可以从 <code>X-Forwarded-For</code> 靠前的位置获取 IP，但是需要校验 IP 格式合法性；</li>
</ol>
<p>PS：网上有些文章建议这样配置 Nginx，其实并不合理：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Forwarded-For $remote_addr;</span><br></pre></td></tr></table></figure>

<p>这样配置之后，安全性确实提高了，但是也导致请求到达 Nginx 之前的所有代理信息都被抹掉，无法为真正使用代理的用户提供更好的服务。还是应该弄明白这中间的原理，具体场景具体分析。</p>
<p><strong>关于代理配置的配置文件部分示例</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">include</span>       mime.types;   <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">   <span class="attribute">default_type</span>  application/octet-stream; <span class="comment">#默认文件类型，默认为text/plain</span></span><br><span class="line">   <span class="comment">#access_log off; #取消服务日志    </span></span><br><span class="line">   <span class="attribute">log_format</span> myFormat <span class="string">&#x27; $remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#x27;</span>; <span class="comment">#自定义格式</span></span><br><span class="line">   <span class="attribute">access_log</span> log/access.log myFormat;  <span class="comment">#combined为日志格式的默认值</span></span><br><span class="line">   <span class="attribute">sendfile</span> <span class="literal">on</span>;   <span class="comment">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span></span><br><span class="line">   <span class="attribute">sendfile_max_chunk</span> <span class="number">100k</span>;  <span class="comment">#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span></span><br><span class="line">   <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;  <span class="comment">#连接超时时间，默认为75s，可以在http，server，location块。</span></span><br><span class="line">   <span class="attribute">proxy_connect_timeout</span> <span class="number">1</span>;   <span class="comment">#nginx服务器与被代理的服务器建立连接的超时时间，默认60秒</span></span><br><span class="line">   <span class="attribute">proxy_read_timeout</span> <span class="number">1</span>; <span class="comment">#nginx服务器想被代理服务器组发出read请求后，等待响应的超时间，默认为60秒。</span></span><br><span class="line">   <span class="attribute">proxy_send_timeout</span> <span class="number">1</span>; <span class="comment">#nginx服务器想被代理服务器组发出write请求后，等待响应的超时间，默认为60秒。</span></span><br><span class="line">   <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">0</span> ; <span class="comment">#Nginx服务器提供代理服务的http协议版本1.0，1.1，默认设置为1.0版本。</span></span><br><span class="line">   <span class="comment">#proxy_method get;    #支持客户端的请求方法。post/get；</span></span><br><span class="line">   <span class="attribute">proxy_ignore_client_abort</span> <span class="literal">on</span>;  <span class="comment">#客户端断网时，nginx服务器是否终端对被代理服务器的请求。默认为off。</span></span><br><span class="line">   <span class="attribute">proxy_ignore_headers</span> <span class="string">&quot;Expires&quot;</span> <span class="string">&quot;Set-Cookie&quot;</span>;  <span class="comment">#Nginx服务器不处理设置的http相应投中的头域，这里空格隔开可以设置多个。</span></span><br><span class="line">   <span class="attribute">proxy_intercept_errors</span> <span class="literal">on</span>;    <span class="comment">#如果被代理服务器返回的状态码为400或者大于400，设置的error_page配置起作用。默认为off。</span></span><br><span class="line">   <span class="attribute">proxy_headers_hash_max_size</span> <span class="number">1024</span>; <span class="comment">#存放http报文头的哈希表容量上限，默认为512个字符。</span></span><br><span class="line">   <span class="attribute">proxy_headers_hash_bucket_size</span> <span class="number">128</span>; <span class="comment">#nginx服务器申请存放http报文头的哈希表容量大小。默认为64个字符。</span></span><br><span class="line">   <span class="attribute">proxy_next_upstream</span> timeout;  <span class="comment">#反向代理upstream中设置的服务器组，出现故障时，被代理服务器返回的状态值。error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off</span></span><br><span class="line">   <span class="comment">#proxy_ssl_session_reuse on; 默认为on，如果我们在错误日志中发现“SSL3_GET_FINSHED:digest check failed”的情况时，可以将该指令设置为off。</span></span><br></pre></td></tr></table></figure>

<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>Nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不到的没有他做不到的啦，你可以参照所有的负载均衡算法，给他一一找出来做下实现。</p>
<h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><ol>
<li><p>源地址哈希法：根据获取客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</p>
</li>
<li><p>轮询法：将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</p>
</li>
<li><p>随机法：通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。</p>
</li>
<li><p>加权轮询法：不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p>
</li>
<li><p>加权随机法：与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p>
</li>
<li><p>最小连接数法：由于后端服务器的配置不尽相同，对于请求的处理有快有慢，最小连接数法根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</p>
</li>
</ol>
<p>上3个图，理解这三种负载均衡算法的实现</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/10/15/Z42exq5GAQFTYBl.png" alt="image.png"></p>
<p>Ip hash算法，对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。 </p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/10/15/spbCTzYkwDNqGhu.png" alt="image.png"></p>
<p><strong>示例</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//test-yii2.<span class="attribute">conf</span></span><br><span class="line">upstream guwenjie_http &#123;</span><br><span class="line">        <span class="attribute">server</span> **.***.***.***:<span class="number">9503</span> weight=<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">server</span> **.***.***.***:<span class="number">8811</span> weight=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span></span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="comment">#listen [::]:80 default_server ipv6only=on;</span></span><br><span class="line">        <span class="attribute">server_name</span> test1.freephp.top;</span><br><span class="line">        <span class="attribute">index</span>  index.php index.html   index.htm ;</span><br><span class="line">        <span class="attribute">root</span>   /home/wwwroot/workspace/public/static;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page   404   /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Deny access to PHP files in specific directory</span></span><br><span class="line">        <span class="comment">#location ~ /(wp-content|uploads|wp-includes|images)/.*\.php$ &#123; deny all; &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">include</span> enable-php.conf;</span><br><span class="line">		</span><br><span class="line">		<span class="attribute">location</span> / &#123;</span><br><span class="line">             <span class="attribute">if</span> (!-e $request_filename)&#123;</span><br><span class="line">                <span class="comment">#proxy_pass http://127.0.0.1:8855;</span></span><br><span class="line">                <span class="attribute">proxy_pass</span> http://guwenjie_http;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="attribute">location</span> /nginx_status</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attribute">stub_status</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">access_log</span>   <span class="literal">off</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attribute">expires</span>      <span class="number">30d</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*\.(js|css)?$</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attribute">expires</span>      <span class="number">12h</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ /.well-known</span> &#123;</span><br><span class="line">            <span class="attribute">allow</span> all;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ /\.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attribute">deny</span> all;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>我们使用 nginx 中的 upstream模块 来实现nginx将跨越单机的限制，完成网络数据的接收、处理和转发。我们主要使用提到的转发功能进行调度分发。</p>
<p>我定义的 upstream 模块名称是 guwenjie_http （最好定义一个有意义的，这个就很不好 _），我配置了两个IP端口，到时候nginx分发的视乎就往这两个服务器上分发。</p>
<p>先来对 upstream 进行一个说明吧</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//举例，以下IP，端口无效</span><br><span class="line"> <span class="attribute">upstream</span> test&#123; </span><br><span class="line">      <span class="attribute">server</span> <span class="number">11.22.333.11:6666</span> weight=<span class="number">1</span>; </span><br><span class="line">      <span class="attribute">server</span> <span class="number">11.22.333.22:8888</span> down; </span><br><span class="line">      <span class="attribute">server</span> <span class="number">11.22.333.33:8888</span> backup;</span><br><span class="line">      <span class="attribute">server</span> <span class="number">11.22.333.44:5555</span> weight=<span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line">//<span class="attribute">down</span> 表示单前的server临时不參与负载.</span><br><span class="line">//weight 默觉得<span class="number">1</span>.weight越大，负载的权重就越大</span><br><span class="line">//backup： 其他全部的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻</span><br></pre></td></tr></table></figure>

<p>后面的 weight=1，weight=2 是表示权重的意思，数字越大，权重越高，在该例中 8811 这个端口权重就是 8855 的两倍，比如三次请求，大概就是两次分发给 8811 一次分发给 8855 ，其实这个是不需要写的，upstream 模块默认就是轮询法，每个ip分发一次，设置权重（加权轮询法）的意义上面已经解释过了。</p>
<p>1、热备：如果你有2台服务器，当一台服务器发生事故时，才启用第二台服务器给提供服务。服务器处理请求的顺序：AAAAAA突然A挂啦，BBBBBBBBBBBBBB…..</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream mysvr &#123; </span><br><span class="line">      server 127.0.0.1:7878; </span><br><span class="line">      server 192.168.10.121:3333 backup;  #热备     </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2、轮询：nginx默认就是轮询其权重都默认为1，服务器处理请求的顺序：ABABABABAB….</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream mysvr &#123; </span><br><span class="line">      server 127.0.0.1:7878;</span><br><span class="line">      server 192.168.10.121:3333;       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>3、加权轮询：跟据配置的权重的大小而分发给不同服务器不同数量的请求。如果不设置，则默认为1。下面服务器的请求顺序为：ABBABBABBABBABB….</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream mysvr &#123; </span><br><span class="line">     server 127.0.0.1:7878 weight=1;</span><br><span class="line">     server 192.168.10.121:3333 weight=2;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>4、ip_hash:nginx会让相同的客户端ip请求相同的服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream mysvr &#123; </span><br><span class="line">      server 127.0.0.1:7878; </span><br><span class="line">      server 192.168.10.121:3333;</span><br><span class="line">      ip_hash;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>5、fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。与weight分配策略类似。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    server server1;</span><br><span class="line">    server server2;</span><br><span class="line">    fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、url_hash（第三方）按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    server squid1:3128;</span><br><span class="line">    server squid2:3128;</span><br><span class="line">    hash $request_uri;</span><br><span class="line">    hash_method crc32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、如果你对上面4种均衡算法不是很理解，那么麻烦您去看下我上一篇配的图片，可能会更加容易理解点。</p>
<p>到这里你是不是感觉nginx的负载均衡配置特别简单与强大，那么还没完，咱们继续哈，这里扯下蛋。</p>
<p>关于nginx负载均衡配置的几个状态参数讲解。</p>
<ul>
<li>down，表示当前的server暂时不参与负载均衡。</li>
<li>backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。</li>
<li>weight 默认为1.weight越大，负载的权重就越大。</li>
<li>max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。</li>
<li>fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream mysvr &#123; </span><br><span class="line">     server 127.0.0.1:7878 weight=2 max_fails=2 fail_timeout=2;</span><br><span class="line">     server 192.168.10.121:3333 weight=1 max_fails=2 fail_timeout=1;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>到这里应该可以说nginx的内置负载均衡算法已经没有货啦。如果你像跟多更深入的了解nginx的负载均衡算法，nginx官方提供一些插件大家可以了解下。</p>
<p>配置实例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">4</span>;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="comment"># 最大并发数</span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line">http&#123;</span><br><span class="line">    <span class="comment"># 待选服务器列表</span></span><br><span class="line">    <span class="attribute">upstream</span> myproject&#123;</span><br><span class="line">        <span class="comment"># ip_hash指令，将同一用户引入同一服务器。</span></span><br><span class="line">        ip_hash;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">125.219.42.4</span> fail_timeout=<span class="number">60s</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">172.31.2.183</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    server&#123;</span><br><span class="line">                <span class="comment"># 监听端口</span></span><br><span class="line">                <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">                <span class="comment"># 根目录下</span></span><br><span class="line">                <span class="attribute">location</span> / &#123;</span><br><span class="line">                    <span class="comment"># 选择哪个服务器列表</span></span><br><span class="line">                    <span class="attribute">proxy_pass</span> http://myproject;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="负载均衡的session共享"><a href="#负载均衡的session共享" class="headerlink" title="负载均衡的session共享"></a>负载均衡的session共享</h4><p>如果网站是存放在一台机器上，是不存在session共享这个问题的，因为所有的会话数据都在这一台机器上。但是，现在的网站大部分都是需要做负载均衡的，即需要把用户的请求分发到不同机器，当然这时会话ID在客户端是不存在问题的，但是服务端会出现取不到session数据的情况。如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/10/15/HACtzigNW9X36GM.png" alt="image.png"></p>
<p>在该架构中，采用Nginx做负载均衡，两个Tomcat做后端服务器，假设当客户端第一次请求时，Nginx将其分发到了Tomcat1，这时候Tomcat1会产生sessionID返回给客户端，并同时保存在自己的内存中；当客户端第二次请求时，Nginx将其分发到了Tomcat2，这时便无法取到session。从而就会重新生成session，返回给客户端，并保存在自己的内存中。两台Tomcat中保存的同一个用户的session不同，这便是session的一致性问题。</p>
<p><strong>解决的方案</strong></p>
<ol>
<li><p>不使用session，使用cookie</p>
<p>session是存放在服务器端的，cookie是存放在客户端的，我们可以把用户访问页面产生的session放到cookie里面，就是以cookie为中转站。你访问web服务器A，产生了session然后把它放到cookie里面，当你的请求被分配到B服务器时，服务器B先判断服务器有没有这个session，如果没有，再去看看客户端的cookie里面有没有这个session，如果也没有，说明session真的不存，如果cookie里面有，就把cookie里面的sessoin同步到服务器B，这样就可以实现session的同步了。</p>
<p>说明：这种方法实现起来简单，方便，也不会加大数据库的负担，但是如果客户端把cookie禁掉了的话，那么session就无从同步了，这样会给网站带来损失；cookie的安全性不高，虽然它已经加了密，但是还是可以伪造的，所以这种方式也是不推荐的。</p>
</li>
<li><p> session存在数据库mysql</p>
</li>
</ol>
<p>   session保存在数据库中，是把session表和其他的数据表存放在一起，那么当用户只要登录后随便操作了些什么就要去数据库验证一下session的状态，这样无疑加重了mysql数据库的压力；如果数据库也做了集群的话，那么也就是说每个数据库集群的节点都得保存这个session表，而且要保证每个集群的节点中数据库的session表的数据保持一致，实时同步</p>
<p>   说明：session保持在数据库，加重了数据库的IO，增大数据库的压力和负担，从而影响数据库的读写性能，而且mysql集群的话也不利于session的实时同步</p>
<ol start="3">
<li><p>session存在缓存memcache或者redis中</p>
<p>memcache可以做分布式，php配置文件中设置存储方式为memcache，这样php自己会建立一个session集群，将session数据存储在memcache中。</p>
<p>说明：这种方式来同步session，不会加大数据库的负担，而且安全性比用cookie保存session大大的提高，把session放到内存里面，比从文件中读取要快很多。但是memcache把内存分成很多种规格的存储块，有块就有大小，这种方式也就决定了，memcache不能完全利用内存，会产生内存碎片，如果存储块不足，还会产生内存溢出。</p>
</li>
<li><p>ip_hash技术，nginx中可以配置，当某个ip下的客户端请求指定（固定，因为根据IP地址计算出一个hash值，根据hash值来判断分配给那台服务器，从而每次该ip请求都分配到指定的服务器）的服务器，这样就可以保证有状态请求的状态的完整性，不至于出现状态丢失的情况，一下是nginx的配置，可以参考一下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> nginx.example.com  </span><br><span class="line">    &#123;   </span><br><span class="line">             <span class="attribute">server</span> <span class="number">192.168.1.2:80</span>;   </span><br><span class="line">             <span class="attribute">server</span> <span class="number">192.168.1.3:80</span>;  </span><br><span class="line">             ip_hash;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="section">server</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">             <span class="attribute">listen</span> <span class="number">80</span>;  </span><br><span class="line">             <span class="attribute">location</span> /  </span><br><span class="line">             &#123;  </span><br><span class="line">                     <span class="attribute">proxy_pass</span>  </span><br><span class="line">                    http://nginx.example.com;  </span><br><span class="line">             &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注意：ip_hash这个方案确实可以保证带有状态的请求的完整性，但是它有一个很大的缺陷，那就是ip_hash方案必须保证Nginx是最前端的服务器（接受真实的ip），如果nginx不是最前端的服务器，还存在中间件（中间服务器什么的），那么nginx获取的ip地址就不是真实的ip地址，那么这个ip_hash就没有任何意义</p>
</li>
<li><p>还有其他的一些方法，本人暂时还不太清楚，有待继续的学习（url_hash不知道可以不可以？是否添加一台共享数据的服务器，把状态等一些公共的数据都保持到这台服务器上，从而集群的所有服务器都从共享服务器上边获取状态进行验证？？待求证）</p>
</li>
</ol>
<p>为了解决这个问题，首当其冲，我会想到，将Tomcat1中的session复制到Tomcat2中即可，当然是可以的，但是不方便，因为这里只有两台服务器，而当后台服务器增多时，会很麻烦。从而，便有了如下的解决方法：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2019/10/15/mU1kfblEJQzxZ9I.png" alt="image.png"></p>
<p>即，将session分离出来，每个服务器都是从该session服务器（集群）中获取。这样以来，新增加的服务器也只需从session集群中获取。</p>
<p>（session集群可以通过memcached或redis来实现）</p>
<h5 id="使用nginx和tomcat配置负载均衡和session共享"><a href="#使用nginx和tomcat配置负载均衡和session共享" class="headerlink" title="使用nginx和tomcat配置负载均衡和session共享"></a>使用nginx和tomcat配置负载均衡和session共享</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012383839/article/details/79801105">https://blog.csdn.net/u012383839/article/details/79801105</a></p>
<h3 id="Nginx动静分离"><a href="#Nginx动静分离" class="headerlink" title="Nginx动静分离"></a>Nginx动静分离</h3><p>必须依赖服务器生存的我们称为动。不需要依赖容器的比如css/js或者图片等，这类就叫静</p>
<p><strong>静态资源的类型</strong> </p>
<p>在Nginx的conf目录下，有一个mime.types文件</p>
<p>输入命令 ：<code>cat ../conf/mime.types</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">types &#123;</span><br><span class="line">text/html html htm shtml;</span><br><span class="line">text/css css;</span><br><span class="line">text/xml xml;</span><br><span class="line">image/gif gif;</span><br><span class="line">image/jpeg jpeg jpg;</span><br><span class="line">application/javascript js;</span><br><span class="line">application/atom+xml atom;</span><br><span class="line">application/rss+xml rss;</span><br><span class="line">text/mathml mml;</span><br><span class="line">text/plain txt;</span><br><span class="line">text/vnd.sun.j2me.app-descriptor jad;</span><br><span class="line">text/vnd.wap.wml wml;</span><br><span class="line">text/x-component htc;</span><br><span class="line">image/png png;</span><br><span class="line">image/svg+xml svg svgz;</span><br><span class="line">image/tiff tif tiff;</span><br><span class="line">image/vnd.wap.wbmp wbmp;</span><br><span class="line">image/webp webp;</span><br><span class="line">image/x-icon ico;</span><br><span class="line">image/x-jng jng;</span><br><span class="line">image/x-ms-bmp bmp;</span><br><span class="line">application/font-woff woff;</span><br><span class="line">application/java-archive jar war ear;</span><br><span class="line">application/json json;</span><br><span class="line">application/mac-binhex40 hqx;</span><br><span class="line">application/msword doc;</span><br><span class="line">application/pdf pdf;</span><br><span class="line">application/postscript ps eps ai;</span><br><span class="line">application/rtf rtf;</span><br><span class="line">application/vnd.apple.mpegurl m3u8;</span><br><span class="line">application/vnd.google-earth.kml+xml kml;</span><br><span class="line">application/vnd.google-earth.kmz kmz;</span><br><span class="line">application/vnd.ms-excel xls;</span><br><span class="line">application/vnd.ms-fontobject eot;</span><br><span class="line">application/vnd.ms-powerpoint ppt;</span><br><span class="line">application/vnd.oasis.opendocument.graphics odg;</span><br><span class="line">application/vnd.oasis.opendocument.presentation odp;</span><br><span class="line">application/vnd.oasis.opendocument.spreadsheet ods;</span><br><span class="line">application/vnd.oasis.opendocument.text odt;</span><br><span class="line">application/vnd.openxmlformats-officedocument.presentationml.presentation</span><br><span class="line">pptx;</span><br><span class="line">application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</span><br><span class="line">xlsx;</span><br><span class="line">application/vnd.openxmlformats-officedocument.wordprocessingml.document</span><br><span class="line">docx;</span><br><span class="line">application/vnd.wap.wmlc wmlc;</span><br><span class="line">application/x-7z-compressed 7z;</span><br><span class="line">application/x-cocoa cco;</span><br><span class="line">application/x-java-archive-diff jardiff;</span><br><span class="line">application/x-java-jnlp-file jnlp;</span><br><span class="line">application/x-makeself run;</span><br><span class="line">application/x-perl pl pm;</span><br><span class="line">application/x-pilot prc pdb;</span><br><span class="line">application/x-rar-compressed rar;</span><br><span class="line">application/x-redhat-package-manager rpm;</span><br><span class="line">application/x-sea sea;</span><br><span class="line">application/x-shockwave-flash swf;</span><br><span class="line">application/x-stuffit sit;</span><br><span class="line">application/x-tcl tcl tk;</span><br><span class="line">application/x-x509-ca-cert der pem crt;</span><br><span class="line">application/x-xpinstall xpi;</span><br><span class="line">application/xhtml+xml xhtml;</span><br><span class="line">application/xspf+xml xspf;</span><br><span class="line">application/zip zip;</span><br><span class="line">application/octet-stream bin exe dll;</span><br><span class="line">application/octet-stream deb;</span><br><span class="line">application/octet-stream dmg;</span><br><span class="line">application/octet-stream iso img;</span><br><span class="line">application/octet-stream msi msp msm;</span><br><span class="line">audio/midi mid midi kar;</span><br><span class="line">audio/mpeg mp3;</span><br><span class="line">audio/ogg ogg;</span><br><span class="line">audio/x-m4a m4a;</span><br><span class="line">audio/x-realaudio ra;</span><br><span class="line">video/3gpp 3gpp 3gp;</span><br><span class="line">video/mp2t ts;</span><br><span class="line">video/mp4 mp4;</span><br><span class="line">video/mpeg mpeg mpg;</span><br><span class="line">video/quicktime mov;</span><br><span class="line">video/webm webm;</span><br><span class="line">video/x-flv flv;</span><br><span class="line">video/x-m4v m4v;</span><br><span class="line">video/x-mng mng;</span><br><span class="line">video/x-ms-asf asx asf;</span><br><span class="line">video/x-ms-wmv wmv;</span><br><span class="line">video/x-msvideo avi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户访问一个网站，然后从服务器端获取相应的资源通过浏览器进行解析渲染最后展示给用户，而服务端可以返回</p>
<p>各种类型的内容，比如xml、jpg、png、gif、flflash、MP4、html、css等等，那么浏览器就是根据mime-type来决定用什么形式来展示的</p>
<p>服务器返回的资源给到浏览器时，会把媒体类型告知浏览器，这个告知的标识就是Content-Type，比如Content-Type:text/html。 </p>
<p><strong>演示代码</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(js|css|png|svg|ico|jpg)$</span> &#123;</span><br><span class="line">    <span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> <span class="number">192.168.20.130</span> www.gupaoedu.com;</span><br><span class="line">    <span class="attribute">if</span> ($invalid_referer) &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">root</span> static-resource;</span><br><span class="line">    <span class="attribute">expires</span> <span class="number">1d</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p><strong>动静分离的好处</strong></p>
<ul>
<li><p>第一个，Nginx本身就是一个高性能的静态web服务器；</p>
</li>
<li><p>第二个，其实静态文件有一个特点就是基本上变化不大，所以动静分离以后我们可以对静态文件进行缓存、或者压缩提高网站性能 </p>
</li>
</ul>
<h3 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h3><p>当一个客户端请求web服务器, 请求的内容可以从以下几个地方获取：服务器、浏览器缓存中或缓存服务器中。这取决于服务器端输出的页面信息</p>
<p>浏览器缓存将文件保存在客户端，好的缓存策略可以减少对网络带宽的占用，可以提高访问速度，提高用户的体验，还可以减轻服务器的负担nginx缓存配置 </p>
<p>Nginx的Web缓存服务主要由proxy_cache相关指令集和fastcgi_cache相关指令集构成，前者用于反向代理时，对后端内容源服务器进行缓存，后者主要用于对FastCGI的动态程序进行缓存。两者的功能基本上一样。</p>
<p>最新的Nginx版本，proxy_cache和fastcgi_cache已经比较完善，加上第三方的ngx_cache_purge模块（用于清除指定URL的缓存），已经可以完全取代Squid。</p>
<p><strong>proxy_cache相关指令集</strong></p>
<ol>
<li><p>proxy_cache指令 语法: <code>proxy_cache zone_name ;</code><br>该指令用于设置哪个缓存区将被使用,zone_name的值为proxy_cache_path指令创建的缓存区的名称.</p>
</li>
<li><p>proxy_cache_path指令, 语法 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_path path [levels=number]</span><br><span class="line">keys_zone=zone_name:zone_size[inactive=time] [max_size=size];</span><br></pre></td></tr></table></figure>

<p>该指令用于设置缓存文件的存放路径.例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_path /data0/proxy_cache_dir levels=1:2 keys_zone=cache_one:500m</span><br><span class="line">inactive=1d max_size=30g ;</span><br></pre></td></tr></table></figure>

<p>path 存放目录<br>levels 指定该缓存空间有两层hash目录,第一层目录为1个字母,第二层目录为2个字母,保存的文件名会类似/data0/proxy_cache_dir/c/29/XXXXXX ;<br>keys_zone参数用来为这个缓存区起名.<br>500m 指内存缓存空间大小为500MB<br>inactive的1d指如果缓存数据在1天内没有被访问,将被删除<br>max_size的30g是指硬盘缓存空间为30G</p>
</li>
<li><p>proxy_cache_methods 指令 </p>
<p>语法:<code>proxy_cache_methods[GET HEAD POST];</code><br>该指令用于设置缓存哪些HTTP方法,默认缓存HTTP GET/HEAD方法,不缓存HTTP POST 方法</p>
</li>
<li><p>proxy_cache_min_uses指令 </p>
<p>语法:<code>proxy_cache_min_uses the_number</code><br>该指令用于设置缓存的最小使用次数,默认值为1</p>
</li>
<li><p>proxy_cache_valid指令 </p>
<p>语法: <code>proxy_cache_valid reply_code [reply_code...] time ;</code><br>该指令用于对不同返回状态码的URL设置不同的缓存时间.<br>例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_valid 200 302 10m ;</span><br><span class="line">proxy_cache_valid 404 1m ;</span><br></pre></td></tr></table></figure>

<p>设置200,302状态的URL缓存10分钟,404状态的URL缓存1分钟.</p>
</li>
<li><p>proxy_cache_key指令 </p>
<p>语法: <code>proxy_cache_key line ;</code><br>该指令用来设置Web缓存的Key值,Nginx根据Key值md5哈希存储缓存.一般根据$host(域名),$request_uri(请求的路径)等变量组合成proxy_cache_key .</p>
</li>
</ol>
<p><strong>proxy_cache完整示例</strong></p>
<p>Nginx配置文件(nginx.conf)对扩展名为gif,jpg,jpeg,png,bmp,swf,js,css的图片,flash，javascript , css文件开启Web缓存,其他文件不缓存.</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">  <span class="attribute">proxy_temp_path</span> /data0/proxy_temp_path ;</span><br><span class="line">  <span class="comment">#设置Web缓存区名称为cache_one,内存缓存空间大小为500M,自动清除超过1天没有被  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#访问的缓存数据,硬盘缓存空间大小为30G</span></span><br><span class="line">  <span class="attribute">proxy_cache_path</span> /data0/proxy_cache_path levels=<span class="number">1</span>:<span class="number">2</span></span><br><span class="line"></span><br><span class="line">keys_zone=cache_one:<span class="number">200m</span> inactive=<span class="number">1d</span> max_size=<span class="number">30g</span> ;</span><br><span class="line">    </span><br><span class="line">  server&#123;</span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf|js|css)$</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="comment">#使用Web缓存区cache_one</span></span><br><span class="line">     <span class="attribute">proxy_cache</span> cache_one ;</span><br><span class="line">     <span class="comment">#对不同HTTP状态码缓存设置不同的缓存时间</span></span><br><span class="line">     <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">304</span> <span class="number">12h</span> ;</span><br><span class="line">     <span class="attribute">proxy_cache_valid</span> <span class="number">301</span> <span class="number">302</span> <span class="number">1m</span> ;</span><br><span class="line">     <span class="attribute">proxy_cache_valid</span> any <span class="number">1m</span> ;</span><br><span class="line">     <span class="comment">#设置Web缓存的Key值,Nginx根据Key值md5哈希存储缓存,这里根据&quot;域名,URI,</span></span><br><span class="line">     <span class="comment">#参数&quot;组合成Key</span></span><br><span class="line">     <span class="attribute">proxy_cache_key</span> $host$uri$is_args$args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">#用于清除缓存,假设一个URL为http://my.domain.com/test.gif,通过访问</span></span><br><span class="line">   <span class="comment">#http://my.domain.com/purge/test.gif可以清除该URL的缓存</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ /purge(/.*)</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="comment">#设置只允许指定的IP或IP段才可以清除URL缓存</span></span><br><span class="line">     <span class="attribute">allow</span> <span class="number">127.0.0.1</span> ;</span><br><span class="line">     <span class="attribute">allow</span> <span class="number">192.168.0.0</span>/<span class="number">16</span> ;</span><br><span class="line">     <span class="attribute">deny</span> all ;</span><br><span class="line">     <span class="attribute">proxy_cache_purge</span> cache_one $host<span class="variable">$1</span>$is_args$args ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>fastcgi_cache相关指令集</strong></p>
<ol>
<li><p>fastcgi_cache指令<br>语法:<code>fastcgi_cache zone_name;</code><br>该指令用于设置哪个缓存区将被使用,zone_name的值为fastcgi_cache_path指令创建的缓存区名称.</p>
</li>
<li><p>fastcgi_cache_path指令<br>语法:<code>fastcgi_cache_path path [levels=number] keys_zone=zone_name:zone_size [inactive=time] [max_size=size];</code><br>该指令用于设置缓存文件的存放路径,<br>例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_cache_path /data0/fastcgi_cache_dir levels=1:2</span><br><span class="line">keys_zone=cache_one:500m inactive=1d max_size=30g ;</span><br></pre></td></tr></table></figure>

<p>注意这个指令只能在http标签内配置,levels指定该缓存空间有两层hash目录,第一层目录为1个字母,第二层为2个字母,保存的文件名会类似/data0/fastcgi_cache_dir/c/29/XXXX;</p>
<p>keys_zone参数用来为这个缓存区起名,<br>500m指内存缓存空间大小为500MB;<br>inactive的1d指如果缓存数据在1天内没有被访问,将被删除;<br>max_size的30g是指硬盘缓存空间为30GB</p>
</li>
<li><p>fastcgi_cache_methods指令<br>语法:<code>fastcgi_cache_methods [GET HEAD POST] ;</code><br>该指令用于设置缓存哪些HTTP方法,默认缓存HTTP GET/HEAD 方法,不缓存HTTP POST方法</p>
</li>
<li><p>fastcgi_cache_min_uses指令<br>语法:<code>fastcgi_cache_min_uses the_number;</code><br>该指令用于设置缓存的最小使用次数,默认值为1.</p>
</li>
<li><p>fastcgi_cache_valid指令<br><code>fastcgi_cache_valid reply_code [reply_code...] time;</code><br>该指令用于对不同返回状态码的URL设置不同的缓存时间.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_cache_valid 200 302 10m ;</span><br><span class="line">fastcgi_cache_valid 404 1m ;</span><br></pre></td></tr></table></figure>

<p>设置200,302状态的URL缓存10分钟,404状态的URL缓存1分钟.<br>如果不指定状态码,直接指定缓存时间,则只有200,301,302状态的URL缓存5分钟.</p>
</li>
<li><p>fastcgi_cache_key指令<br>语法:<code>fastcgi_cache_key line ;</code><br>该指令用来设置Web缓存的Key值,Nginx根据Key值md5哈希存储缓存.一般根据FastCGI服务器的地址和端口,$request_uri(请求的路径)等变量组合成fastcgi_cache_key。</p>
</li>
</ol>
<p><strong>fastcgi_cache完整示例</strong></p>
<p>Nginx配置文件(nginx.conf)对扩展名为gif,jpg,jpeg,png,bmp,swf,js,css的图片,Flash,JavaScript,CSS文件开启Web缓存,其他文件不缓存.</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line"> <span class="comment">#fastcgi_temp_path和fastcgi_cache_path指定的路径必须在同一分区</span></span><br><span class="line">  <span class="attribute">fastcgi_temp_path</span> /data0/fastcgi_temp_path ;</span><br><span class="line"> <span class="comment">#设置Web缓存区名称为cache_one,内存缓存空间大小为500MB,自动清除超过1天没有被</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#访问的缓存数据,硬盘缓存空间大小为30G</span></span><br><span class="line">  <span class="attribute">fastcgi_cache_path</span> /data0/fastcgi_cache_path levels=<span class="number">1</span>:<span class="number">2</span></span><br><span class="line"></span><br><span class="line">keys_zone=cache_one:<span class="number">200m</span> inactive=<span class="number">1d</span> max_size=<span class="number">30g</span> ;</span><br><span class="line"></span><br><span class="line">  server&#123;</span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ .*\.(php|php5)$</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="comment">#使用Web缓存区cache_one</span></span><br><span class="line">     <span class="attribute">fastcgi_cache</span> cache_one ;</span><br><span class="line">     <span class="comment">#对不同的HTTP状态码缓存设置不同的缓存时间</span></span><br><span class="line">     <span class="attribute">fastcgi_cache_valid</span> <span class="number">200</span> <span class="number">10m</span> ;</span><br><span class="line">     <span class="attribute">fastcgi_cache_valid</span> <span class="number">301</span> <span class="number">302</span> <span class="number">1h</span> ;</span><br><span class="line">     <span class="attribute">fastcgi_cache_valid</span> an <span class="number">1m</span> ;</span><br><span class="line">     <span class="comment">#设置Web缓存的key值,Nginx根据key值md5哈希存储缓存,这里根据&quot;FastCGI服务  </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">#器的IP,端口,请求的URI&quot;组合成Key。</span></span><br><span class="line">     <span class="attribute">fastcgi_cache_key</span> <span class="number">127.0.0.1:9000</span>$requet_uri ;</span><br><span class="line">     <span class="comment">#FastCGI服务器</span></span><br><span class="line">     <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span> ;</span><br><span class="line">     <span class="attribute">fastcgi_index</span> index.php ;</span><br><span class="line">     <span class="attribute">include</span> fcgi.conf ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a target="_blank" rel="noopener" href="https://imququ.com/post/x-forwarded-for-header-in-http.html">HTTP 请求头中的 X-Forwarded-For</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/knowledgesea/p/5199046.html">Nginx代理功能与负载均衡详解</a></li>
<li><a target="_blank" rel="noopener" href="http://www.uml.org.cn/zjjs/201808214.asp">Nginx负载均衡高可用</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012453843/article/details/69668663">nginx和keepalived实现nginx高可用</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zengguowang/p/8261695.html">nginx:负载均衡的session共享</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31246691/article/details/81517186">Nginx的session一致性问题</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">平心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pingxin0521.gitee.io/2019/08/22/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx-2-2/">https://pingxin0521.gitee.io/2019/08/22/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx-2-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pingxin0521.gitee.io" target="_blank">平心de小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a><a class="post-meta__tags" href="/tags/Nginx/">Nginx</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/08/22/Java-%E6%A1%86%E6%9E%B6-1-2/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Apache Commons FileUpload、Apache Tika</div></div></a></div><div class="next-post pull-right"><a href="/2019/08/21/%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx-2-1/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">nginx 热部署、虚拟主机和日志</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/11/16/服务器-Nginx-2-3/" title="nginx 常用屏蔽规则"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/PFDRNxj93taz6pw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">nginx 常用屏蔽规则</div></div></a></div><div><a href="/2019/08/20/服务器-Nginx-1-1/" title="nginx 安装"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-06-02</div><div class="title">nginx 安装</div></div></a></div><div><a href="/2019/08/29/服务器-Nginx-1-4/" title="nginx 常用http模块"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-12-28</div><div class="title">nginx 常用http模块</div></div></a></div><div><a href="/2019/08/20/服务器-Nginx-1-2/" title="nginx 配置详解"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2020-06-10</div><div class="title">nginx 配置详解</div></div></a></div><div><a href="/2019/08/28/服务器-Nginx-1-3/" title="nginx 架构"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2019-12-27</div><div class="title">nginx 架构</div></div></a></div><div><a href="/2019/08/21/服务器-Nginx-2-1/" title="nginx 热部署、虚拟主机和日志"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/7dHvepmfYOLWTrX.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-01-09</div><div class="title">nginx 热部署、虚拟主机和日志</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.ax1x.com/2020/02/11/1ovw6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">平心</div><div class="author-info__description">年轻人的life、learn and think</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">449</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">68</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanyunpeng0521"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanyunpeng0521" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="mailto:m13839441583@163.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">为什么呢？开始提问吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#nginx%E4%BB%A3%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">nginx代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">正向代理和反向代理的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">两种代理配置方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nginx%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E"><span class="toc-number">1.3.</span> <span class="toc-text">Nginx代理服务的配置说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">2.</span> <span class="toc-text">负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">负载均衡算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84session%E5%85%B1%E4%BA%AB"><span class="toc-number">2.2.</span> <span class="toc-text">负载均衡的session共享</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8nginx%E5%92%8Ctomcat%E9%85%8D%E7%BD%AE%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8Csession%E5%85%B1%E4%BA%AB"><span class="toc-number">2.2.1.</span> <span class="toc-text">使用nginx和tomcat配置负载均衡和session共享</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB"><span class="toc-number">3.</span> <span class="toc-text">Nginx动静分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web%E7%BC%93%E5%AD%98"><span class="toc-number">4.</span> <span class="toc-text">web缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.1.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/okfOw28KlZFbE7z.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Egg.js -- 为企业级框架和应用而生"/></a><div class="content"><a class="title" href="/2021/05/15/node-2-4/" title="Egg.js -- 为企业级框架和应用而生">Egg.js -- 为企业级框架和应用而生</a><time datetime="2021-05-15T10:18:59.000Z" title="发表于 2021-05-15 18:18:59">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/HjVAdIuT7bZJypS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Koa -- 基于Node.js平台的下一代Web开发框架"/></a><div class="content"><a class="title" href="/2021/04/30/node-2-3/" title="Koa -- 基于Node.js平台的下一代Web开发框架">Koa -- 基于Node.js平台的下一代Web开发框架</a><time datetime="2021-04-30T10:18:59.000Z" title="发表于 2021-04-30 18:18:59">2021-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.JS web开发前置知识"/></a><div class="content"><a class="title" href="/2021/04/01/node-2-1/" title="Node.JS web开发前置知识">Node.JS web开发前置知识</a><time datetime="2021-04-01T03:18:59.000Z" title="发表于 2021-04-01 11:18:59">2021-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/gGE57HRvpcKPfDY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--谷歌浏览器插件"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-1/" title="第十一周--谷歌浏览器插件">第十一周--谷歌浏览器插件</a><time datetime="2020-12-26T10:18:59.000Z" title="发表于 2020-12-26 18:18:59">2020-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2020/05/08/vCnKyoFJZ1g4XYR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十一周--浏览器技术"/></a><div class="content"><a class="title" href="/2020/12/26/%E5%91%A8%E8%AE%B0-10-0/" title="第十一周--浏览器技术">第十一周--浏览器技术</a><time datetime="2020-12-26T06:18:59.000Z" title="发表于 2020-12-26 14:18:59">2020-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 平心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4lfIXzqxaC1ONs0MJO4oHu07-gzGzoHsz',
      appKey: 'qw99Bw8FD0KVKU9m457CwWsr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
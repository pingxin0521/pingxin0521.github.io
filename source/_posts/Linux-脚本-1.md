---
title: Linux-bash基础（一）
date: 2019-03-25 21:55:22
tags: 
 - Linux
 - 脚本
category: 
 - Linux
 - 脚本
---

### 前言

我们在前面介绍了Bash的特性，里面提到了变量，其实变量是shell脚本的一部分。那么什么才是shell脚本呢？

我们都知道shell是一个命令解释器，它的作用是解释用户输入的命令和程序，命令和程序可以理解成上层的应用程序，我们linux系统中的那些命令其实也都是一个个的小程序，只不过完成的是系统的应用功能。我们在系统的终端中输入一条命令，可以立马看到一条或者几条系统回复我们的信息，其实就是shell在帮我们回复，所以shell可以称之为命令解释器。这种从键盘一输入命令，就可以立马得到相应的回复信息，叫作**交互的方式，**相当于我们在和电脑交流。Shell存在于系统的最外层，所以算作操作系统的外壳，它之外的应用程序就不能算作操作系统了。我们从输入系统的账户密码开始，到登录系统以后的所有操作都是shell在帮我们解释执行的。

如果我们的命令或者应用程序不在命令行直接执行，而是通过一个程序文件来执行时，这个程序就被称之为shell脚本。Shell脚本里面通常内置了多条命令，有的还包含控制语句，比如if和else的条件控制语句，for和select的循环控制语句等。这些内置在一个shell脚本中的命令通常是一次性执行完成，不会不停的返回信息给用户，这种通过文件执行脚本的方式称之为**非交互方式。**Shell脚本类似于windows下的批处理，但是它比批处理要强大一些。

<!--more-->

#### Shell 能做什么？

1. 自动化批量系统初始化程序 （update，软件安装，时区设置，安全策略...）
2. 自动化批量软件部署程序 （LAMP，LNMP，Tomcat，LVS，Nginx）
3. 应用管理程序 (KVM，集群管理扩容，MySQL，DELLR720 批量 RAID）
4. 日志分析处理程序（PV, UV, 200, !200, top 100, grep/awk）
5. 自动化备份恢复程序（MySQL 完全备份/增量 + Crond）
6. 自动化管理程序（批量远程修改密码，软件升级，配置更新）
7. 自动化信息采集及监控程序（收集系统/应用状态信 CPU,Mem,Disk,Net,TCP Status,Apache,MySQL）
8. 配合 Zabbix 信息采集（收集系统/应用状态信息 CPU,Mem,Disk,Net,TCP Status,Apache,MySQL）
9. 自动化扩容（增加云主机——>业务上线）zabbix 监控 CPU 80%+|-50% Python API AWS/EC2（增加/删除云主机） + Shell Script（业务上线）
10. 俄罗斯方块，打印三角形，打印圣诞树，打印五角星，运行小火车，坦克大战，排序算法实现
11. Shell 可以做任何事（一切取决于业务需）

**程序语言执行**：

```
C —— 编译 —— 二进制机器码 （CPU X86 复杂指令集, Power 精简指令集，
APM）
Java —— 编译 —— 字节码（Java 虚拟机 JDK） Tomcat/Hadoop 
shell —— 解释 （/usr/bin/bash）
perl —— 解释 （/usr/bin/perl）
expect —— 解释 （/usr/bin/expect）
Python —— 解释 ( /usr/bin/python)
	—— 编译 —— 字节码（Python 虚拟机）
```

程序是由哪些组程序： 逻辑 + 数据

### Hello World

先给出一个简单的实例：

```bash
#！/bin/bash
str="Hello World"
echo ${str}
```

运行结果是

```shell
[hyp@localhost ~]$ sh hello.sh
Hello World
```

那么这又是怎么回事呢？`echo`是我们之前使用过的命令，而`str`是变量，`#！/bin/bash`声明所使用的解释器，可以在脚本拥有执行权限时，找到对应位置的shell命令，新建一个进程，解释运行该脚本里的命令。`.sh`为脚本的推荐标识后缀。

也就是说，我们在命令行使用的命令，都可以在脚本中使用，而且也可以使用shell规定的流程控制语句，接下来我们慢慢介绍它的语法。

### 运行 Shell 脚本

**1、作为可执行程序**

将上面的代码保存为 test.sh，并 cd 到相应目录：

```
chmod +x ./test.sh  #使脚本具有执行权限
./test.sh  #执行脚本
```

注意，一定要写成 ./test.sh，而不是 **test.sh**，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。

**2、作为解释器参数**

这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：

```
/bin/sh test.sh
/bin/php test.php
```

这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。

### 变量

变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：

```
命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。
中间不能有空格，可以使用下划线（_）。
不能使用标点符号。
不能使用bash里的关键字（可用help命令查看保留关键字）
使用变量时尽量加上大括号
```

普通变量可以被重定义， readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变， unset 命令可以删除变量，unset 命令不能删除只读变量。

运行shell时，会同时存在三种变量：

1) 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。

```
定义变量： 变量名=变量值 变量名必须以字母或下划线开头，区分大小写
引用变量： $变量名 或 ${变量名}
查看变量： echo $变量名 set(所有变量：包括自定义变量和环境变量)
取消变量： unset 变量名作用范围仅在当前 shell 中
```

2) 环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。

```
定义环境变量： 
方法一 export back_dir2=/home/backup 
方法二 export back_dir1 将自定义变量转换成环境变量
引用环境变量： $变量名 或 ${变量名}
查看环境变量： echo $变量名 env 例如 env |grep back_dir2
取消环境变量： unset 变量名
变量作用范围： 在当前 shell 和子 shell 有效
=======================================================
C 语言 局部变量 vs 全局变量
SHELL 自定义变量 vs 环境变量
=======================================================
```

3) shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行

```
位置变量：
$1 $2 $3 $4 $5 $6 $7 $8 $9 ${10}

```

4) 预定义变量

```
$0 脚本名
$* 所有的参数
$@ 所有的参数
$# 参数的个数
$$ 当前进程的 PID
$! 上一个后台进程的 PID
$? 上一个命令的返回值 0 表示
```

使用一个定义过的变量，只要在变量名前面加美元符号即可，如：

```shell
your_name="qinjx"
echo $your_name
echo ${your_name}
```

变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界。

1. 示例 1

   ```shell
   $ vim test.sh
   echo "第 2 个位置参数是$2"
   echo "第 1 个位置参数是$1"
   echo "第 4 个位置参数是$4"
   echo "所有参数是: $*"
   echo "所有参数是: $@"
   echo "参数的个数是: $#"
   echo "当前进程的 PID 是: $$"
   echo '$1='$1
   echo '$2='$2
   echo '$3='$3
   echo '$*='$*
   echo '$@='$@
   echo '$#='$#
   echo '$$='$$
   $ sudo chmod a+x test.sh
   $ ./test.sh 1 2 3 a b c
   第 2 个位置参数是2
   第 1 个位置参数是1
   第 4 个位置参数是a
   所有参数是: 1 2 3 a b c
   所有参数是: 1 2 3 a b c
   参数的个数是: 6
   当前进程的 PID 是: 23806
   $1=1
   $2=2
   $3=3
   $*=1 2 3 a b c
   $@=1 2 3 a b c
   $#=6
   $$=23806
   ```

2. 示例 2

   ```shell
   $ vim ping.sh
   #!/bin/bash
   ping -c1 $1 &>/dev/null  
   if $? then
       echo "$1 is up"
   else
       echo "$1 is down"
   fi
   $ chmod a+x ping.sh
   $ ./ping.sh baidu.com
   ```

3. `$*与$@`的区别

   ```bash
   $ vim test1.sh
   #! /bin/bash
   test() {
           echo "未加引号,二者相同"
           echo $*
           echo $@
           echo "加入引号后对比"
           for N in "$*"
           do
              echo $N
           done
   
           echo "----------"
           for N in "$@"
           do
              echo $N
           done
   }
   test  12 123  3424 546
   $ sudo chmod a+x test1.sh
   $ ./test1.sh 
   未加引号,二者相同
   12 123 3424 546
   12 123 3424 546
   加入引号后对比
   12 123 3424 546
   ----------
   12
   123
   3424
   546
   ```

   可以看到不加引号时,二者都是返回传入的参数,但加了引号后,此时`$*`把参数作为一个字符串整体(单字符串)返回,`$@`把每个参数作为一个字符串返回

#### 字符串

单引号字符串的限制：

- 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；
- 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

双引号的优点：

- 双引号里可以有变量
- 双引号里可以出现转义字符

输出字符串长度

```shell
echo "name length="${#name}
```

提取子字符串

```shell
echo ${name:1:${#name}}
```

查找子字符串

```shell
echo `expr index "${name}" io`
```

反引号``的功能，反引号的功能是将反引号括起来的内容执行，没错，就是执行，这就意味着，反引号括起来的是一条命令，此时是一个命令的运行结果，而结果就是一条命令，并且反引号不能单独使用，要将包含反引号及其括起来的语句赋值给一个变量，否则出错；如果不想将其赋给一个变量，就不要用反引号，直接写反引号中的内容，因为其内容就是一条命令。

**定义或引用变量时注意事:**

```bash
#" " 弱引用
#' ' 强引用
 $ school=1000phone
 $ echo "${school} is good"
1000phone is good
 $ echo '${school} is good'
${school} is good
#` ` 命令替换 等价于 $() 反引号中的 shell 命令会被先执行
 $ touch `date +%F`_file1.txt 
 $ touch $(date +%F)_file2.txt
 $ disk_free3="df -Ph |grep '/$' |awk '{print $4}'" #错误
 $ disk_free4=$(df -Ph |grep '/$' |awk '{print $4}')
 $ disk_free5=`df -Ph |grep '/$' |awk '{print $4}'`
 $ echo $disk_free3 $disk_free4 $disk_free5
 df -Ph |grep '/$' |awk '{print }' 23G 23G
```



#### 注释

```
# 开头的行就是注释
```

多行注释：

```bash
:<<EOF
注释内容...
注释内容...
注释内容...
EOF
```

EOF 也可以使用其他符号

#### 数组

bash支持一维数组（不支持多维数组），并且没有限定数组的大小。

数组元素的下标由0开始。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。

Shell 数组用括号来表示，元素用"空格"符号分割开

```bash
# 数组名=(值1 值2 ... 值n)
a_n[0]="apple"
a_n[1]="banana"
echo ${a_n[0]}
#获取所有数据
echo ${a_n[@]}
#数组长度
echo ${#a_n[@]}
echo ${#a_n[*]}
#第一个数据的长度
echo ${#a_n[0]}
```

**数组定义方法**：

像很多脚本语言一样，shell变量不区分类型，对于普通数组，可申明也可以不申明：

如果习惯使用声明，就使用declare 命令声明，例如：

```
declare -a myarray
```

在 Shell 中，用括号`( )`来表示数组，数组元素之间用空格来分隔。由此，定义数组的一般形式为：

```
array_name=(ele1  ele2  ele3 ... elen)
```

注意，赋值号`=`两边不能有空格，必须紧挨着数组名和数组元素。

下面是一个定义数组的实例：

```
nums=(29 100 13 8 91 44)
```

Shell 是弱类型的，它并不要求所有数组元素的类型必须相同，例如：

```
arr=(20 56 "http://c.biancheng.net/shell/")
```

Shell 数组的长度不是固定的，定义之后还可以增加元素。例如，对于上面的 nums 数组，它的长度是 6，使用下面的代码会在最后增加一个元素，使其长度扩展到 7：

```
nums[6]=88
```

此外，你也无需逐个元素地给数组赋值，下面的代码就是只给特定元素赋值：

```
ages=([3]=24 [5]=19 [10]=12)
```

以上代码就只给第 3、5、10 个元素赋值，所以数组长度是 3。

```bash
#!/bin/bash

nums=(29 100 13 8 91 44)
echo ${nums[@]}  #输出所有数组元素
nums[10]=66  #给第10个元素赋值（此时会增加数组长度）
echo ${nums[*]}  #输出所有数组元素
echo ${nums[4]}  #输出第4个元素
```

**删除数组**

```
删除数组某个元素：unset arr_name[index]
删除整个数组：unset arr_number
```

**数组分片访问**

分片访问形式为：${数组名[@或*]:开始下标:偏移长度}

例如：

```
arr_name=(1 2 3 test go now)
echo ${arr_name[@]:1:2}，将输出2 3
${arr_name[@]:1:2}，这里分片访问从下标1开始，元素个数为2。
```

**有用的数组扩展**

数组支持”+=“赋值运算符，利用这一点可以通过这种方式往一个已知数组中更方便的添加元素，特别是往空数组中填充元素时非常有用

实际应用举例：

为了充分利用多核处理器，对一组文件进行md5散列计算时，将每个文件的md5计算放到后台，

利用空数组把每次调用md5sum命令产生的后台进程ID收集到空数组中，并等待所有后台md5sum进程结束后才退出主进程

下面是gen_checksum.sh脚本的内容：

```
#!/bin/bash
#文件名：gen_checksum.sh
PIDARRAY=()
for file in file{1..10}iso ; do
	md5sum $file & 
	PIDARRAY+=($!)
done
wait ${PIDARRAY[@]}

```

另一种方法扩展数组

利用shell只有一维数组，在赋值时引用多个数组进行合并

例如：

格式：`merge_array=( ${a[@] ${b[@]} ... )`

**模式替换**

格式为：${数组名[@或*]/模式/新值}

　　　　例如：echo ${arr_name[@]/now/past}，将输出1 2 3 test go past

**数组的遍历**

通常我们使用for命令遍历数组，遍历数组时对数组引用通常需要加上双引号，这样才能正确遍历含有空格字符串的元素

无论使用@还是*的格式引用数组，不存在含空格的元素时，加不加引号对数组遍历不会有什么问题，但一旦元素中含有空格，将不能得到预期效果，在实际使用时，元素的值通常时变量替换得到的，这不能保证是否含有空格，因此，为了稳妥起见，建议用引号括住数组变量

#### 参数传递

```
$#	传递到脚本的参数个数
$*	以一个单字符串显示所有向脚本传递的参数。
如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。
$$	脚本运行的当前进程ID号
$!	后台运行的最后一个进程的ID号
$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。
如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。
$-	显示Shell使用的当前选项，与set命令功能相同。
$?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
```

$\* 与 $@ 区别：

相同点：都是引用所有参数。
不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " \* " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）。

#### declare

既然所有变量的默认类型是字符串型，那么只要把变量声明为整数型不就可以参与运算了吗？使用 declare 命令就可以声明变量的类型。

语法：`declare [+/-] [选项] 变量名`

选项：

- -：给变量设定类型属性；
- +：取消变量的类型属性；
- -a：将变量声明为数组型；
- -i：将变量声明为整数型（integer）；
- -r：将变量声明为只读变量。注意，一旦设置为只读变量，既不能修改变量的值，也不能删除变量，甚至不能通过 +r 取消只读属性；
- -x：将变量声明为环境变量；
- -p：显示指定变量的被声明的类型；

#### read

除位置参数变量外，我们也可以使用 read 命令向脚本中传入数据。read 命令接收标准输入（键盘）的输入，或者其他文件描述符的输入。得到输入后，read 命令将数据放入一个标准变量中。

语法：`read [选项] [变量名]`

选项:

- -p "提示信息"：在等待read输入时，输出提示信息；
- -t 秒数：read命令会一直等待用户输入，使用此选项可以指定等待时间；
- -n 字符数：read命令只接收指定的字符数就会执行；
- -s： 隐藏输入的数据，适用于机密信息的输入；

变量名：

- 变量名可以自定义。如果不指定变量名，则会把输入保存到默认变量REPLY中；
- 如果只提供了一个变量名，则将整个输入行赋予该变量；
- 如果提供了一个以上的变量名，则输入行分为若干字，一个接一个地赋予各个变量，而命令行上的最后一个变量取得剩余的所有字；

实例：

```shell
[root@localhost sh]# vi read.sh
#!/bin/bash
read -t 30 -p "Please input your name:" name
#提示"请输入姓名"并等待30秒，把用户的输入保存到变量name中
echo "Name is $name"
#看看变量"$name"中是否保存了你的输入
read -s -t 30 -p "Please enter your age:" age
#提示"请输入年龄"并等待30秒，把用户的输入保存到变量age中
#年龄是隐私，所以我们用"-s"选项隐藏输入
echo -e "\n"
#调整输出格式，如果不输出换行，则一会儿的年龄输出不会换行
echo "Age is $age"
read -n 1 -t 30 -p "Please select your gender[M/F]:" gender
#提示"请选择性别"并等待30秒，把用户的输入保存到变量gender中
#使用"-n 1"选项只接收一个输入字符就会执行(无须按回车键）
echo -e "\n"
echo "Sex is $gender"
```

运行结果：

```shell
[root@localhost sh]# chmod 755 read.sh
赋予执行权限
[root@localhost sh]#./read.sh
#执行脚本
Please input your name: zhang san
#在read的提示界面输入姓名
Name is zhang san
#"$name"变量中保存了我们的输入
Please enter your age:
#因为加入了"-s"选项，所以输入不会显示在命令行上
Age is 18
#"$age"变量中保存了我们的输入
Please select your gender[M/F]: M
#因为加入了"-n 1"选项，所以只能输入一个字符
Sex is M
# "$gender"变量中保存了我们的输入
```

read 命令并不难，却是接收键盘输入的重要方法，要熟练使用。

#### 变量"内容"的删除和替换

```bash
# ==="内容"的删除===
 $ url=www.sina.com.cn
 $ echo ${#url} 获取变量值的长度
15
 $ echo ${url} 标准查看
www.sina.com.cn
 $ echo ${url#*.} 从前往后，最短匹配
sina.com.cn
 $ echo ${url##*.} 从前往后，最长匹配 贪婪匹配
cn
 $ url=www.sina.com.cn
 $ echo ${url}
www.sina.com.cn
 $ echo ${url%.*} 从后往前，最短匹配
www.sina.com
 $ echo ${url%%.*} 从后往前，最长匹配 贪婪匹配
www
 $ url=www.sina.com.cn
 $ echo ${url#a.}
www.sina.com.cn
 $ echo ${url#*sina.}
com.cn
 $ echo $HOSTNAME
tianyun.1000phone.com
 $ echo ${HOSTNAME%%.*}
tianyun
#索引及切片
 $ echo ${url:0:5} 
 $ echo ${url:5:5} 
 $ echo ${url:5} 

#==="内容"的替换===
 $ url=www.sina.com.cn
 $ echo ${url/sina/baidu}
www.baidu.com.cn
 $ url=www.sina.com.cn
 $ echo ${url/n/N}
www.siNa.com.cn
 $ echo ${url//n/N} 贪婪匹配
www.siNa.com.cN

#===变量的替代===
 $ unset var1
 $ 
 $ echo ${var1}
 $ echo ${var1-aaaaa}
aaaaa
 $ var2=111
 $ echo ${var2-bbbbb}
111
 $ 
 $ var3=
 $ echo ${var3-ccccc}

# ${变量名-新的变量值}
#变量没有被赋值：会使用“新的变量值“ 替代
#变量有被赋值（包括空值）： 不会被替代
 $ unset var1
 $ unset var2
 $ unset var3
 $ 
 $ var2=
 $ var3=111
 $ echo ${var1:-aaaa}aaaa
 $ echo ${var2:-aaaa}aaaa
 $ echo ${var3:-aaaa}111

# ${变量名:-新的变量值}
# 变量没有被赋值（包括空值）：都会使用“新的变量值“ 替代
#变量有被赋值： 不会被替
 $ echo ${var3+aaaa}
 $ echo ${var3:+aaaa}
 $ echo ${var3=aaaa}
 $ echo ${var3:=aaa

```

#### printf命令

```
printf  format-string  [arguments...]
```

输出类型：

```
%ns：输出字符串。n 是数字，指代输出几个字符；
%ni：输出整数。n 是数字，指代输出几个数字‘’
%m.nf: 输出浮点数。m 和 n 是数字，指代输出的整数位数和小数位数。如 %8.2f 代表共输出 8 位数，其中 2 位是小数，6 位是整数；
```

#### 转义字符

```
\a	警告字符，通常为ASCII的BEL字符
\b	后退
\c	抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略
\f	换页（formfeed）
\n	换行
\r	回车（Carriage return）
\t	水平制表符
\v	垂直制表符
\\	一个字面上的反斜杠字符
\ddd	表示1到3位数八进制值的字符。仅在格式字符串中有效
\0ddd	表示1到3位的八进制值字符
```

 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试

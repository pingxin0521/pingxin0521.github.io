---
title: JVM内存结构
date: 2019-06-09 19:18:59
tags:
 - Java
categories:
 - Java
 - JVM
---
Java内存模型是每个java程序员必须掌握理解的，这是Java的核心基础，对我们编写代码特别是并发编程时有很大帮助。由于Java程序是交由JVM执行的，所以我们在谈Java内存区域划分的时候事实上是指JVM内存区域划分。

<!--more-->

Java内存模型规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机是一个完整的计算机的一个模型，因此这 个模型自然也包含一个内存模型——又称为Java内存模型。

如果你想设计表现良好的并发程序，理解Java内存模型是非常重要的。Java内存模型规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。

原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中使用。

#### 区分

**JVM内存结构**

在《[Java虚拟机规范（Java SE 8）](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4)》中描述了JVM运行时内存区域结构如下：

![ZCQVJA.png](https://s2.ax1x.com/2019/06/23/ZCQVJA.png)

也就是说, JVM内存结构由Java虚拟机规范定义, 其描述的是Java程序执行过程中, 由JVM管理的不同的数据区域。

**Java内存模型**

**在计算机世界中, 为了保证共享内存的正确性(原子性、可见性、有序性), 内存模型定义了共享内存系统中多线程程序读写操作行为的规范**。通过这些规则来规范对内存的读写操作, 从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、有编译有关。它解决了CPU多级缓存、处理器优化、指令重排等导致的访问问题, 保证了并发场景下的有序性、一致性、原子性。

内存模型解决并发问题主要采用两种方式: **限制处理器优化**和**使用内存屏障**。

我们知道, Java的多线程之间是通过共享内存进行通信的, 而由于采用共享内存进行通信,  在通信过程中会存在一系列如可见性、原子性、顺序性等问题, 而JMM(Java Memory  Model)就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。它只是一个抽象的概念, **是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范**。JMM定义了一些语法集, 这些语法集映射到Java语言中就是volatile、synchronized等关键字。

![ZCQBo4.png](https://s2.ax1x.com/2019/06/23/ZCQBo4.png)

**Java对象模型**

Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。

HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。

如下图所示, 就是一个简单的Java对象的OOP-Klass模型，即Java对象模型。

![ZCQHSI.jpg](https://s2.ax1x.com/2019/06/23/ZCQHSI.jpg)

**小结**

- JVM内存结构, 和Java虚拟机的运行时区域有关。

- Java内存模型, 和Java的并发编程有关。
- Java对象模型, 和Java对象在虚拟机中的表现形式有关。

### JVM内存结构

1. 堆内存: 用于分配所有类实例和数组的内存

2. 非堆内存: 方法区、JVM内部处理或优化、类结构(常量池,字段,方法数据)、方法、构造方法

 **运行时数据区分为几个部分？**

根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。

![ZCKNhn.png](https://s2.ax1x.com/2019/06/23/ZCKNhn.png)

![ZCMFCn.png](https://s2.ax1x.com/2019/06/23/ZCMFCn.png)

#### 方法区

方法区是java虚拟机规范去中定义的一种概念上的区域，具有什么功能，但并没有规定这个区域到底应该位于何处，因此对于实现者来说，如何来实际方法区是有着很大自由度的。

永生代是hotspot中的一个概念，其他jvm实现未必有，例如jrockit就没这东西。java8之前，hotspot使用在内存中划分出一块区域来存储类的元信息、类变量以及内部字符串（interned string）等内容，称之为永生代，把它作为方法区来使用。

[JEP122][2]提议取消永生代，方法区作为概念上的区域仍然存在。原先永生代中类的元信息会被放入本地内存（元数据区，metaspace），将类的静态变量和内部字符串放入到java堆中。

##### 特征

- 同 Java 堆一样，方法区也是全局共享的一块内存区域
- 方法区的作用是存储 Java 类的结构信息，当我们创建对象实例后，**对象的类型信息存储在方法堆之中，实例数据存放在堆中；实例数据指的是在 Java 中创建的各种实例对象以及它们的值，类型信息指的是定义在 Java 代码中的常量、静态变量、以及在类中声明的各种方法、方法字段等等；同事可能包括即时编译器编译后产生的代码数据。**

- JVMS 不要求该区域实现自动的内存管理，但是商用 JVM 一般都已实现该区域的自动内存管理。
- 方法区分配内存可以不连续，可以动态扩展。
- 该区域并非像 JMM 规范描述的那样数据一旦放进去就属于 “永久代”；**在该区域进行内存回收的主要目的是对常量池的回收和对内存数据的卸载；一般来说这个区域的内存回收效率比起 Java 堆要低得多。**
- 当方法区无法满足内存需求时，将抛出 OutOfMemoryError 异常。

##### 运行时常量池

- **运行时常量池是方法区的一部分，**所以也是全局共享的。
- **其作用是存储 Java 类文件常量池中的符号信息。**
- **class 文件中存在常量池(非运行时常量池)，其在编译阶段就已经确定；JVM 规范对 class 文件结构有着严格的规范，必须符合此规范的 class 文件才会被 JVM 认可和装载。**
- **运行时常量池** 中保存着一些 class 文件中描述的符号引用，同时还会将这些符号引用所翻译出来的直接引用存储在 **运行时常量池** 中。
- **运行时常量池相对于 class 常量池一大特征就是其具有动态性，Java  规范并不要求常量只能在运行时才产生，也就是说运行时常量池中的内容并不全部来自 class 常量池，class  常量池并非运行时常量池的唯一数据输入口；在运行时可以通过代码生成常量并将其放入运行时常量池中。**
- 同方法区一样，当运行时常量池无法申请到新的内存时，将抛出 OutOfMemoryError 异常。



**为了清楚方法区那么需要解释两个名词：永久代和元空间**

**PermGen(永久代)**

绝大部分Java程序员应该都见过“java.lang.OutOfMemoryError: PremGen space”异常。这里的“PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是JVM的规范，而后者则是JVM规范的一种实现，并且只有HotSpot才有“PermGen space”，而对于其他类型的虚拟机，如JRockit(Oracle)、J9(IBM)并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。并且JDK 1.8中参数PermSize和MaxPermSize已经失效。

**元空间**

其实，移除永久代的工作从JDK 1.7就开始了。JDK 1.7中，存储在永久代的部分数据就已经转移到Java Heap或者Native Heap。但永久代仍存在于JDK 1.7中，并没有完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了Java heap；类的静态变量(class statics)转移到了Java heap。

JDK1.8对JVM架构的改造将类元数据放到本地内存中，另外，将常量池和静态变量放到Java堆里。HotSpot VM将会为类的元数据明确分配和释放本地内存。在这种架构下，类元信息就突破了原来-XX:MaxPermSize的限制，现在可以使用更多的本地内存。这样就从一定程度上解决了原来在运行时生成大量类造成经常Full GC问题，如运行时使用反射、代理等。所以升级以后Java堆空间可能会增加。

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间的最大区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数指定元空间的大小：

    -XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对改值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
    
    -XX:MaxMetaspaceSize，最大空间，默认是没有限制的。

除了上面的两个指定大小的选项外，还有两个与GC相关的属性：

    -XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集。
    
    -XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集。


所以对于方法区，Java8之后的变化：

- 移除了永久代（PermGen），替换为元空间（Metaspace）；
- 永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；
- 永久代中的 interned Strings 和 class static variables 转移到了 Java heap；
- 永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize）

更多：[JVM学习——元空间（Metaspace）](https://www.jianshu.com/p/a6f19189ec62)

##### 方法区变迁

1. JDK1.2 ~ JDK6

   在 JDK1.2 ~ JDK6 的实现中，HotSpot 使用永久代实现方法区；HotSpot 使用 GC 分代实现方法区带来了很大便利；

2. JDK7

   由于 GC 分代技术的影响，使之许多优秀的内存调试工具无法在 Oracle HotSpot之上运行，必须单独处理；并且 Oracle 同时收购了 BEA 和 Sun 公司，同时拥有 JRockit 和 HotSpot，在将 JRockit 许多优秀特性移植到 HotSpot 时由于 GC 分代技术遇到了种种困难，所以从 JDK7 开始 Oracle HotSpot 开始移除永久代。

   JDK7中符号表被移动到 Native Heap中，字符串常量和类引用被移动到 Java Heap中。

3. JDK8

   在 JDK8 中，永久代已完全被元空间(Meatspace)所取代。

##### 永久代变迁产生的影响

1. 测试代码1

   ```java
   public class Test1 {
       public static void main(String[] args) {
   
   		 String s1 = new StringBuilder("漠").append("然").toString();
   		 System.out.println(s1.intern() == s1);
   
   		 String s2 = new StringBuilder("漠").append("然").toString();
   		 System.out.println(s2.intern() == s2);
   
   	}
   
   }
   ```

   以上代码，在 JDK6 下执行结果为 false、false，在 JDK7 以上执行结果为 true、false。

   **首先明确两点：** 1、在 Java 中直接使用双引号展示的字符串将会在常量池中直接创建。 2、String 的 intern 方法首先将尝试在常量池中查找该对象，如果找到则直接返回该对象在常量池中的地址；找不到则将该对象放入常量池后再返回其地址。**JDK6 常量池在方法区，频繁调用该方法可能造成 OutOfMemoryError。**

   **产生两种结果的原因：**

   在 JDK6 下 s1、s2 指向的是新创建的对象，**该对象将在 Java Heap 中创建，所以 s1、s2 指向的是 Java Heap 中的内存地址；**调用 intern 方法后将尝试在常量池中查找该对象，没找到后将其放入常量池并返回，**所以此时 s1/s2.intern() 指向的是常量池中的地址，JDK6常量池在方法区，与堆隔离，；所以 s1.intern()==s1 返回false。**

2. 测试代码2

   ```java
   public class Test2 {
   	public static void main(String[] args) {
   		/**
   		 * 首先设置 持久代最大和最小内存占用(限定为10M)
   		 * VM args: -XX:PermSize=10M -XX:MaxPremSize=10M
   		 */
   
   		List<String> list  = new ArrayList<String>();
   
   		// 无限循环 使用 list 对其引用保证 不被GC  intern 方法保证其加入到常量池中
   		int i = 0;
   		while (true) {
   		    // 此处永久执行，最多就是将整个 int 范围转化成字符串并放入常量池
   			list.add(String.valueOf(i++).intern());
   		}
   	}
   }
   ```

   以上代码在 JDK6 下会出现 Perm 内存溢出，JDK7 or high 则没问题。

   **原因分析：**

   **JDK6 常量池存在方法区，设置了持久代大小后，不断while循环必将撑满 Perm 导致内存溢出；JDK7  常量池被移动到 Native Heap(Java  Heap)，所以即使设置了持久代大小，也不会对常量池产生影响；不断while循环在当前的代码中，所有int的字符串相加还不至于撑满 Heap  区，所以不会出现异常。**

#### 虚拟机栈（线程栈）与 堆（Heap）

为更好的理解Java线程栈和堆，我们简单的认为Java内存模型把Java虚拟机内部划分为线程栈和堆。这张图演示了Java内存模型的逻辑视图。
![ZCMAg0.png](https://s2.ax1x.com/2019/06/23/ZCMAg0.png)

每一个运行在Java虚拟机里的线程都拥有自己的线程栈。这个线程栈包含了这个线程调用的方法当前执行点相关的信息。一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。

所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。

堆上包含在Java程序中创建的所有对象，无论是哪一个对象创建的。这包括原始类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。

下面这张图演示了调用栈和本地变量存放在线程栈上，对象存放在堆上。

![ZCMEvV.png](https://s2.ax1x.com/2019/06/23/ZCMEvV.png)

一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。

一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。

一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。

一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。

静态成员变量跟随着类定义一起也存放在堆上。

存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。

下图演示了上面提到的点：

![ZCMk3q.png](https://s2.ax1x.com/2019/06/23/ZCMk3q.png)

两个线程拥有一些列的本地变量。其中一个本地变量（Local Variable 2）执行堆上的一个共享对象（Object 3）。这两个线程分别拥有同一个对象的不同引用。这些引用都是本地变量，因此存放在各自线程的线程栈上。这两个不同的引用指向堆上同一个对象。

注意，这个共享对象（Object 3）持有Object2和Object4一个引用作为其成员变量（如图中Object3指向Object2和Object4的箭头）。通过在Object3中这些成员变量引用，这两个线程就可以访问Object2和Object4。

这张图也展示了指向堆上两个不同对象的一个本地变量。在这种情况下，指向两个不同对象的引用不是同一个对象。理论上，两个线程都可以访问Object1和Object5，如果两个线程都拥有两个对象的引用。但是在上图中，每一个线程仅有一个引用指向两个对象其中之一。

#### 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。

此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

#### 本地方法栈

本地方法栈（Native MethodStacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。

与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常

### 参考

1. [JVM内存结构 VS Java内存模型 VS Java对象模型](http://www.hollischuang.com/archives/2509)

2. [再有人问你Java内存模型是什么, 就把这篇文章发给他](http://www.hollischuang.com/archives/2550)
3. [Java 内存之方法区和运行时常量池](https://mritd.me/2016/03/22/Java-%E5%86%85%E5%AD%98%E4%B9%8B%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0/)

4. [深入理解多线程（二）—— Java的对象模型-HollisChuang's Blog](http://www.hollischuang.com/archives/1910)

5. [深入理解多线程（三）—— Java的对象头-HollisChuang's Blog](http://www.hollischuang.com/archives/1953)
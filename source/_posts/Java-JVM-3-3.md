---
title: java对象模型、类加载
date: 2019-06-09 19:18:59
tags:
 - Java
categories:
 - Java
 - JVM
---
Java虚拟机为Java程序提供运行时环境，其中一项重要的任务就是管理类和对象的生命周期。类的生命周期。类的生命周期从类被加载、连接和初始化开始，到类被卸载结束。当类处于生命周期中时，它的二进制数据位于方法区内，在堆区中还会有一个相应的描述这个类的Class对象（**当Java程序使用任何一个类时，系统都会为之创建一个java.lang.Class对象**）。只有当类处于生命周期中时，Java程序才能使用它，比如调用类的静态成员或者创建类的实例。

![KvPNxf.png](https://s2.ax1x.com/2019/11/04/KvPNxf.png)

<!--more-->

当通过java命令运行一个Java程序时，就启动了一个Java虚拟机进程。Java虚拟机进程从启动到终止的过程，称为Java虚拟机的生命周期。在以下情况中，Java虚拟机将结束生命周期。

1. 程序正常执行结束,如main运行return；
2. 程序在执行中因为出现异常或错误而异常终止；
3. 执行了System.exit()或者Runtime.getRuntime().exit()；
4. 由于操作系用出现错误而导致Java虚拟机进程终止；

当Java虚拟机处于生命周期中时，它的总任务就是运行Java程序。Java程序从开始运行带终止的过程称为程序的生命周期，它和Java虚拟机的生命周期的一致的

当Java程序运行结束时，JVM进程结束，在进程在内存中的状态将全部丢失。下面通过一个小例子来说明。

```java
public class A {
    public static int a = 5;
}
public class ATest1 {

    public static void main(String[] args) {
        A.a++;
        System.out.println(A.a);//6
    }

}
public class ATest2 {

    public static void main(String[] args) {
        System.out.println(A.a);//5
    }

}
```

观察输出结果，原因就是ATest1和ATest2是两次运行JVM进程，第一次运行结束后它对A类所做的修改将全部丢失；第二次运行JVM将再次初始化A类。

一些初学者会认为A类中的a是静态成员变量，同一个类中所有实例的静态变量共享同一块内存区，错误的认为第二次运行会输出被第一次改变后的结果。但实际上两次运行Java程序处于两个不同的JVM进程中，故两个JVM之间不会共享数据。

#### Java虚拟机类加载机制

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。

在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的

##### 类加载的过程

类的个生命周期如下图：

![lNcFs0.png](https://s2.ax1x.com/2020/01/03/lNcFs0.png)


为支持运行时绑定，解析过程在某些情况下可在初始化之后再开始，除解析过程外的其他加载过程必须按照如图顺序开始。

##### 加载

1. 通过全限定类名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

##### 验证

验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

1. 文件格式验证：如是否以魔数 0xCAFEBABE 开头、主、次版本号是否在当前虚拟机处理范围之内、常量合理性验证等。
   此阶段保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java类型信息的要求。
2. 元数据验证：是否存在父类，父类的继承链是否正确，抽象类是否实现了其父类或接口之中要求实现的所有方法，字段、方法是否与父类产生矛盾等。
   第二阶段，保证不存在不符合 Java 语言规范的元数据信息。
3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。例如保证跳转指令不会跳转到方法体以外的字节码指令上。
4. 符号引用验证：在解析阶段中发生，保证可以将符号引用转化为直接引用。

可以考虑使用 `-Xverify:none` 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

##### 准备

为**类变量**分配内存并设置类变量初始值，这些变量所使用的内存都将在方法区中进行分配。

##### 解析

虚拟机将常量池内的符号引用替换为直接引用的过程。
解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。

##### 初始化

到初始化阶段，才真正开始执行类中定义的 Java 程序代码，此阶段是执行 `<clinit>()` 方法的过程。

`<clinit>()` 方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有**类变量**的赋值动作和静态代码块中的语句合并产生的。（不包括构造器中的语句。构造器是初始化对象的，类加载完成后，创建对象时候将调用的 `<init>()` 方法来初始化对象）

静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问，如下程序：

```java
public class Test {
    static {
        // 给变量赋值可以正常编译通过
        i = 0;
        // 这句编译器会提示"非法向前引用"
        System.out.println(i);
    }

    static int i = 1;
}
```

`<clinit>()` 不需要显式调用父类（接口除外，接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）的初始化方法 `<clinit>()`，虚拟机会保证在子类的 `<clinit>()` 方法执行之前，父类的 `<clinit>()` 方法已经执行完毕，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。

`<clinit>()` 方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 `<clinit>()` 方法。

虚拟机会保证一个类的 `<clinit>()` 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 `<clinit>()` 方法，其他线程都需要阻塞等待，直到活动线程执行 `<clinit>()` 方法完毕。

##### 类加载的时机

对于初始化阶段，虚拟机规范规定了有且只有 5 种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：

1. 遇到new、getstatic 和 putstatic 或 invokestatic 这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。对应场景是：使用 new 实例化对象、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法。
2. 对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3. 当初始化类的父类还没有进行过初始化，则需要先触发其父类的初始化。（而一个接口在初始化时，并不要求其父接口全部都完成了初始化）
4. 虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），
   虚拟机会先初始化这个主类。

> 1. 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

第5种情况，我暂时看不懂。

以上这 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用，例如：

1. 通过子类引用父类的静态字段，不会导致子类初始化。
2. 通过数组定义来引用类，不会触发此类的初始化。`MyClass[] cs = new MyClass[10];`
3. 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

##### new一个对象过程中发生了什么？

1. **确认类元信息是否存在。**当 JVM 接收到 new 指令时，首先在 metaspace 内检查需要创建的类元信息是否存在。 若不存在，那么在双亲委派模式下，使用当前类加载器以 ClassLoader + 包名＋类名为 Key 进行查找对应的 class 文件。 如果没有找到文件，则抛出 ClassNotFoundException 异常 ， 如果找到，则进行类加载（加载 - 验证 - 准备 - 解析 - 初始化），并生成对应的 Class 类对象。
2. **分配对象内存。** 首先计算对象占用空间大小，如果实例成员变量是引用变量，仅分配引用变量空间即可，即 4 个字节大小，接着在堆中划分—块内存给新对象。 在分配内存空间时，需要进行同步操作，比如采用 CAS (Compare And Swap) 失败重试、 区域加锁等方式保证分配操作的原子性。
3. **设定默认值。** 成员变量值都需要设定为默认值， 即各种不同形式的零值。
4. **设置对象头。**设置新对象的哈希码、 GC 信息、锁信息、对象所属的类元信息等。这个过程的具体设置方式取决于 JVM 实现。
5. **执行 init 方法。** 初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。

#### 类加载

类加载器把class文件中的二进制数据读入到内存中，存放在方法区，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类加载的步骤如下：

1. 加载：查找并加载类的二进制数据（把class文件里面的信息加载到内存里面）

2. 连接：把内存中类的二进制数据合并到虚拟机的运行时环境中

   - 验证：确保被加载的类的正确性。包括：

     ```
     A、类文件的结构检查：检查是否满足Java类文件的固定格式
     B、语义检查：确保类本身符合Java的语法规范
     C、字节码验证：确保字节码流可以被Java虚拟机安全的执行。字节码流是操作码组成的序列。每一个操作码后面都会跟着一个或者多个操作数。字节码检查这个步骤会检查每一个操作码是否合法。
     D、二进制兼容性验证：确保相互引用的类之间是协调一致的。
     ```

   - 准备：为类的静态变量分配内存，并将其初始化为默认值

   - 解析：把类中的符号引用转化为直接引用（比如说方法的符号引用，是有方法名和相关描述符组成，在解析阶段，JVM把符号引用替换成一个指针，这个指针就是直接引用，它指向该类的该方法在方法区中的内存位置）

3. 初始化：为类的静态变量赋予正确的初始值。当静态变量的等号右边的值是一个常量表达式时，不会调用static代码块进行初始化。只有等号右边的值是一个运行时运算出来的值，才会调用static初始化。

##### 双亲委派模型

当一个类加载器收到类加载请求的时候，它首先不会自己去加载这个类的信息，而是把该
请求转发给父类加载器，依次向上。所以所有的类加载请求都会被传递到父类加载器中，只有当父类加载器中无法加载到所需的类，子类加载器才会自己尝试去加载该类。当当前类加载器和所有父类加载器都无法加载该类时，抛出ClassNotFindException异常。

> 提高系统的安全性。用户自定义的类加载器不可能加载应该由父加载器加载的可靠类。（比如用户定义了一个恶意代码，自定义的类加载器首先让系统加载器去加载，系统加载器检查该代码不符合规范，于是就不继续加载了）
>
> 并且在相同的类只会加载一次

定义类加载器：如果某个类加载器能够加载一个类，那么这个类加载器就叫做定义类加载器

初始类加载器：定义类加载器及其所有子加载器都称作初始类加载器。

运行时包：

- 由同一个类加载器加载并且拥有相同包名的类组成运行时包
- 只有属于同一个运行时包的类，才能访问包可见（default）的类和类成员。作用是 **限制用户自定义的类冒充核心类库的类去访问核心类库的包可见成员。**

加载两份相同的class对象的情况：A和B不属于父子类加载器关系，并且各自都加载了同一个类

**特点**

全盘负责：当一个类加载器加载一个类时，该类所依赖的其他类也会被这个类加载器加载到内存中。

缓存机制：所有的Class对象都会被缓存，当程序需要使用某个Class时，类加载器先从缓存中查找，找不到，才从class文件中读取数据，转化成Class对象，存入缓存中。

**类加载器**

![java类加载.png](https://i.loli.net/2019/04/09/5cac620a7be78.png)

两种类型的类加载器：

1. JVM自带的类加载器（3种）

   - 根类加载器（Bootstrap）

     ```
     a、C++编写的，程序员无法在程序中获取该类
     b、负责加载虚拟机的核心库，比如java.lang.Object
     c、没有继承ClassLoader类
     ```

   - 扩展类加载器（Extension）

     ```
     a、Java编写的，从指定目录中加载类库
     b、父加载器是根类加载器
     c、是ClassLoader的子类
     d、如果用户把创建的jar文件放到指定目录中，也会被扩展加载器加载。
     ```

   - 系统加载器（System）或者应用加载器(App)

     ```
     a、Java编写的
     b、父加载器是扩展类加载器
     c、从环境变量或者class.path中加载类
     d、是用户自定义类加载的默认父加载器
     e、是ClassLoader的子类
     ```

2. 用户自定义的类加载器

   - Java.lang.ClassLoader类的子类

   - 用户可以定制类的加载方式

   - 父类加载器是系统加载器

   - 编写步骤：

     ```
     A、继承ClassLoader
     B、重写findClass方法。从特定位置加载class文件，得到字节数组，然后利用defineClass把字节数组转化为Class对象
     ```

   - 为什么要自定义类加载器？

     ```
     A、可以从指定位置加载class文件，比如说从数据库、云端加载class文件
     B、加密：Java代码可以被轻易的反编译，因此，如果需要对代码进行加密，那么加密以后的代码，就不能使用Java自带的ClassLoader来加载这个类了，需要自定义ClassLoader，对这个类进行解密，然后加载。
     ```

 为什么要这么做呢？

 如果没有使用双亲委派模型，由各个类加载器自行加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统将会出现多个不同的Object类， Java类型体系中最基础的行为就无法保证。应用程序也将会变得一片混乱。

**双亲委任模型时如何实现的？**

非常简单：所有的代码都在java.lang.ClassLoader中的loadClass方法之中，代码如下：

![lntqqs.png](https://s2.ax1x.com/2019/12/29/lntqqs.png)

先检查是否已经被加载过，若没有加载则调用父加载器的loadClass方法， 如父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException 异常后，再调用自己的findClass方法进行加载。

**问题：Java程序对类的执行有几种方式：**

1. 主动使用（6种情况）

   JVM必须在每个类“首次 主动使用”的时候，才会初始化这些类。

   - 创建类的实例
   - 读写某个类或者接口的静态变量
   - 调用类的静态方法
   - 同过反射的API（Class.forName()）获取类
   - 初始化一个类的子类
   - JVM启动的时候，被标明启动类的类（包含Main方法的类）

   只有当程序使用的静态变量或者静态方法确实在该类中定义时，该可以认为是对该类或者接口的主动使用。

2. 被动使用：除了主动使用的6种情况，其他情况都是被动使用，都不会导致类的初始化。

3. JVM规范允许类加载器在预料某个类将要被使用的时候，就预先加载它。如果该class文件缺失或者存在错误，则在程序“首次 主动使用”的时候，才报告这个错误。（Linkage Error错误）。如果这个类一直没有被程序“主动使用”，就不会报错。

**类加载机制与接口**

1. 当Java虚拟机初始化一个类时，不会初始化该类实现的接口。
2. 在初始化一个接口时，不会初始化这个接口父接口。
3. 只有当程序首次使用该接口的静态变量时，才导致该接口的初始化。

ClassLoader：调用Classloader的loadClass方法去加载一个类，不是主动使用，因此不会进行类的初始化

**类的卸载**

有JVM自带的三种类加载器（根、扩展、系统）加载的类始终不会卸载。因为JVM始终引用这些类加载器，这些类加载器使用引用他们所加载的类，因此这些Class类对象始终是可到达的。

由用户自定义类加载器加载的类，是可以被卸载的。

##### 如何破坏双亲委任模型？

双亲委任模型不是一个强制性的约束模型，而是一个建议型的类加载器实现方式。在Java的世界中大部分的类加载器都遵循者模型，但也有例外，到目前为止，双亲委派模型有过3次大规模的“被破坏”的情况。
**第一次**：在双亲委派模型出现之前-----即JDK1.2发布之前。
**第二次**：是这个模型自身的缺陷导致的。我们说，双亲委派模型很好的解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API， 但没有绝对，**如果基础类调用会用户的代码**怎么办呢？

这不是没有可能的。一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时就放进去的rt.jar）,但它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI， Service Provider Interface）的代码，但启动类加载器不可能“认识“这些代码啊。因为这些类不在rt.jar中，但是启动类加载器又需要加载。怎么办呢？

为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：**线程上下文类加载器（Thread Context ClassLoader）**。这个类加载器可以通过java.lang.Thread类的setContextClassLoader方法进行设置。如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过多的话，那这个类加载器默认即使应用程序类加载器。

嘿嘿，有了线程上下文加载器，JNDI服务使用这个线程上下文加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。但这无可奈何，Java中所有涉及SPI的加载动作基本胜都采用这种方式。例如JNDI，**JDBC**，JCE，JAXB，JBI等。

**第三次**：为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。

#### 对象的创建

java程序在运行过程中无时无刻都有对象被创建出来，那么创建对象是个怎么样的过程呢？

**判断是否已经执行类加载**

当虚拟机遇到一条new指令时 ，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，那必须先执行相应的类加载过程。（类加载过程参考上面）

**内存分配**

当已经执行过类加载过程后，会为新对象在Java堆中分配一个大小已经确定的内存，具体的内存分配规则有两种：

1. **指针碰撞（Bump the Pointer）**如果Java堆中的内存是绝对规整的，所有用过的内存放一边，空闲的内存放到一边，中间放着指针为分界点，分配内存就是把指针向空闲的一边挪动一段与对象大小相等的距离。
2. **空闲列表 (Free List )**如果Java堆中的内存并不是规整对的，已使用的内存和空间相互交错，虚拟机会将可以用的内存维护到一个列表上，在分配内存时从这个列表中找到一块足够大的空间划给对象。然后更新列表记录。

Java堆中的内存是否是规整的是根据虚拟机所采用的垃圾收集器是否带有压缩整理功能决定的。Serial、ParNew带压缩整理的分配内存用指针碰撞，CMS这种通常用空闲列表方式分配内存

**防止并发**

在虚拟机上创建对象是非常频繁的行为，所以要做到防止并发，有以下两种方式可实现：

1. 堆分配内存空间的动作进行同步处理，实际上JVM采用CAS(Cmpare And Set)配上失败重试的方式保证更新操作的原子性；
2. 把内存分配的动作按照线程划分在不同的空间之中进行，即为每个线程在java堆中预先分配一块小内存，称为本地线程分配缓冲区（Thread Local Allocation Buffer,TLAB）。分配内存时在线程的TLBA上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。JVM是否使用TLAB可以通过-XX:+UseTLAB参数来设定。

**初始化对象内存空间**

内存分配完成后，JVM将分配到的内存空间都初始化为零值（不包括对象头）。

**对象头的设置**

将对象的类、哈希码、对象的GC分代年龄等信息设置到对象头之中。

**执行Java的init方法**

设置完对象头后，从JVM的角度来看一个对象已经完成了，但是从java程序的角度来看还没有创建完成呢。此时就需要执行init方法，调用构造方法等过程，这样一个真正可用的对象才算完全的产生出来。

### 对象的内存布局

创建完对象后，对象对分配给自己的内存是如何布局的呢？下面来介绍一下。

#### Java对象的表示模型

Hotspot主要是用C++写的，所以它定义的Java对象表示模型也是基于C++实现的。

Java对象的表示模型叫做“OOP-Klass”二分模型，包括两部分:

1. OOP，即Ordinary Object Point，普通对象指针。说实话这个名称挺难理解。说白了其实就是表示对象的实例信息
2. Klass，即Java类的C++对等体，用来描述Java类，包含了元数据和方法信息等

一个Java对象就包括两部分，数据和方法，分别对应到OOP和Klass。最简单的理解就是如果让你自己用Java语言来开发一套新的语言，你如何来表示这个新的语言的对象呢。肯定也是类似的思路，一个模块是用Java类来实现表示数据的部分，一个模块是用Java类实现表示方法和元数据的部分。

JVM运行时加载一个Class时，会在JVM内部创建一个instanceKlass对象，表示这个类的运行时元数据。创建一个这个Class的Java对象时，会在JVM内部相应的创建一个instanceOop来表示这个Java对象。熟悉JVM的同学可以明白，instanceKlass对象放在了方法区，instanceOop放在了堆，instanceOop的引用放在了JVM栈。

JVM是基于栈来运行的，当一个线程调用一个对象的方法时，会在它的JVM栈的栈顶创建一个栈帧（Frame）的数据结构，这个数据结构是用来保存方法的局部变量，操作数栈，动态连接和方法返回值的。通过参数传递的值和在方法中new出来的对象的引用都保持在局部变量表里面。

Java的方法调用是值传递，不是引用传递，原因就在这里，传递进来的参数相当于在局部变量表里面拷贝了一份，实际计算时，操作数栈操作的是局部变量变量里面的值，而不是外部的变量
![lJYOVf.png](https://s2.ax1x.com/2020/01/01/lJYOVf.png)



对象在堆内存中的布局可分为三部分：**对象头（Header）**，**实例数据(Instance Data)**，**对齐填充(Padding)**。

**普通对象的结构**如下，按64位机器的长度计算

1. 对象头(_mark)， 8个字节

2. Oop指针，如果是32G内存以下的，默认开启对象指针压缩，4个字节

3. 数据区

4. Padding(内存对齐)，按照8的倍数对齐

如果是数组对象的话，还多了一个部分，就是数组长度。

数组对象结构是：

1. 对象头(_mark)， 8个字节

2. Oop指针，如果是32G内存以下的，默认开启对象指针压缩，4个字节

3. 数组长度，4个字节

4. 数据区

5. Padding(内存对齐)，按照8的倍数对齐

![lJteG4.png](https://s2.ax1x.com/2020/01/01/lJteG4.png)

对象头主要存储对象运行时记录信息，如hashcode, GC分代年龄，锁状态标志，偏向线程ID，偏向时间戳等。对象头的长度和JVM的字长一致，比如32位JVM的对象头是32位，64位JVM的对象头是64位。

这里可以看到，所谓的给一个对象加锁，其实就是设置了对象头某些位。当其他线程看到这个对象的状态是加锁状态后，就等待释放锁。

在方法区的instanceKlass对象相当于Class加载后创建的运行时对象，它包含了运行时常量池，字段，方法等元数据，当调用一个对象的方法时，如上面的图所示，实际定位到了方法区的instanceKlass对象的方法元数据。

下面我们通过一个实例，使用HSDB来看看运行时的instanceKlass和instanceOop到底是什么样的。在方法区

创建一个Person类，有name, age, sex实例属性，有一个sayHi方法

```java
package main;
 
public class Person {
    private String name;
    private int age;
    private boolean sex;
    
    public void sayHi(){
        System.out.println("Say hi from ITer_ZC");
    }
    
    public static void main(String[] args){
        Person p = new Person();
        p.sayHi();
        
        try {
            Thread.sleep(500000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
 
```

HSDB是一款内置与SA的GUI调试工具，集成了各种JVM监控工具，可以用来深入分析JVM内部状态。

启动HSDB:

```java
java -cp ${JAVA_HOME}/lib/sa-jdi.jar sun.jvm.hotspot.HSDB
```

运行Person，使用JPS查看进程ID;使用HSDB attach Person进程;Attach成功后看到21461进程里的各个子进程

在Class Browser里面找到Person对应的instanceKlass的运行时实例,运行地址为0x0000000100060828

在inspector里面查看0x0000000100060828这个对象实例，我们可以看到instanceKlass的字段，方法，运行时常量池，父类，兄弟类等元数据信息

在Object Histogram里面找到main.Person对象;查看main.Person Oop的运行时实例

_mark就是对象头，接着是实例数据信息。HSDB没有显示类对象指针

#### 大小计算

```xml
            <!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core -->
            <dependency>
                <groupId>org.openjdk.jol</groupId>
                <artifactId>jol-core</artifactId>
                <version>0.9</version>
            </dependency>
```

测试类：

```java
public class SizeofWithInstrumetation {
    private static class ObjectA {
        String str;  // 4
        int i1; // 4
        byte b1; // 1
        byte b2; // 1
        int i2;     // 4
        ObjectB obj; //4
        byte b3;  // 1
    }

    private static class ObjectB {

    }

    private static Unsafe unsafe;

    //方法一：我们可以令我们的代码“受信任”。运行程序时，使用bootclasspath选项，指定系统类路径加上你使用的一个Unsafe路径
//    java -Xbootclasspath:/usr/jdk1.7.0/jre/lib/rt.jar:. com.mishadoff.magic.UnsafeClient

    // 方法二
    static {
        try {
            Field field = Unsafe.class.getDeclaredField("theUnsafe");
            field.setAccessible(true);
            unsafe = (Unsafe) field.get(null);
        } catch (Exception e) {
        }
    }


    public static void main(String[] args) {
//        System.out.println(ObjectShallowSize.sizeOf(new ObjectA()));

        Field[] fields =
                ObjectA.class.getDeclaredFields();
        for (Field f : fields) {
            System.out.println(f.getName() + " offset: " + unsafe.objectFieldOffset(f));
        }
    }

}
//str offset: 24
//i1 offset: 12
//b1 offset: 20
//b2 offset: 21
//i2 offset: 16
//obj offset: 28
//b3 offset: 22
//size : 32
```

HotSpot创建的对象的字段会先按照给定顺序排列一下,默认的顺序如下，**从长到短排列，引用排最后**: long/double --> int/float --> short/char --> byte/boolean --> Reference

这个顺序可以使用JVM参数: -XX:FieldsAllocationSylte=0(默认是1)来改变。

可以看到确实是按照从长到短，引用排最后的方式在内存中排列的。按照这种方法我们来重新计算下ObjectA创建的对象的长度:

8(_mark) + 4(oop指针) + 4(i1) + 4(i2) + 1(b1) + 1(b2) + 1(b3) + 1(padding) +  4(str) + 4(obj) = 32

再来测试一下数组对象的长度。有两个类如下:

```java
private static class ObjectC {
    	ObjectD[] array = new ObjectD[2];
    }
    
    private static class ObjectD {
    	int value;
    }
 
```

![lJ0yF0.png](https://s2.ax1x.com/2020/01/01/lJ0yF0.png)

我们可以手工计算一下ObjectC obj = new ObjectC()的大小：

ObjectC的Shallow size = 8(_mark) + 4(oop指针)  + 4(ObjectD[]引用) = 16

new ObjectD[2]数组的长度 =  8(_mark) + 4(oop指针) + 4(数组长度占4个字节) + 4(ObjectD[0]引用) + 4(ObjectD[1]引用) = 24

由于ObjectD[]数组没有指向具体的对象大小，所以我们手工计算的结果是16 + 24 = 40

再给ObjectD[]数组指向具体的ObjectD对象，再测试一下结果：

```java
  private static class ObjectC {
    	ObjectD[] array = new ObjectD[2];
    	
    	public ObjectC(){
    		array[0] = new ObjectD();
    		array[1] = new ObjectD();
    	}
    }
    
    private static class ObjectD {
    	int value;
    }
```

我们可以手工计算一下ObjectC obj = new ObjectC()的大小：
ObjectC的Shallow size = 8(_mark) + 4(oop指针)  + 4(ObjectD[]引用) = 16

new ObjectD[2]数组的长度 =  8(_mark) + 4(oop指针) + 4(数组长度占4个字节) + 4(ObjectD[0]引用) + 4(ObjectD[1]引用) = 24

ObjectD对象长度 = 8(_mark) + 4(oop指针) + 4(value) = 16

所以ObjectC实际占用的空间 = 16 + 24 + 2 * 16 = 72

### 参考

1. [Java虚拟机类加载机制](https://www.cnblogs.com/czwbig/p/11127222.html)
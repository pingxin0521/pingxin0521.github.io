---
title: Spring Security 入门
date: 2019-10-07 16:18:59
tags:
 - Java
 - 框架
categories:
 - Java
 - 框架
---

#### 基本概念

##### 什么是认证

系统为什么要认证?

认证是为了保护系统的隐私数据与资源,用户的身份合法方可访问该系统的资源。

**认证** :用户认证就是判断一个用户的身份是否合法的过程,用户去访问系统资源时系统要求验证用户的身份信息,身份合法方可继续访问,不合法则拒绝访问。常见的用户身份认证方式有:用户名密码登录,二维码登录,手机短信登录,指纹认证等方式。

<!--more-->

##### 什么是会话

用户认证通过后,为了避免用户的每次操作都进行认证可将用户的信息保证在会话中。会话就是系统为了保持当前用户的登录状态所提供的机制,常见的有基于session方式、基于token方式等。

基于session的认证方式如下图:

![QHR14f.png](https://s2.ax1x.com/2019/12/18/QHR14f.png)

它的交互流程是,用户认证成功后,在服务端生成用户相关的数据保存在session(当前会话)中,发给客户端的sesssion_id 存放到 cookie 中,这样用户客户端请求时带上 session_id 就可以验证服务器端是否存在 session 数据,以此完成用户的合法校验,当用户退出系统或session过期销毁时,客户端的session_id也就无效了。

基于token方式如下图:

![QHR0U0.png](https://s2.ax1x.com/2019/12/18/QHR0U0.png)

它的交互流程是,用户认证成功后,服务端生成一个token发给客户端,客户端可以放到 cookie 或 localStorage
等存储中,每次请求时带上 token,服务端收到token通过验证后即可确认用户身份。

**区别**：基于session的认证方式由Servlet规范定制,服务端要存储session信息需要占用内存资源,客户端需要支持cookie;基于token的方式则一般不需要服务端存储token,并且不限制客户端的存储方式。如今移动互联网时代更多类型的客户端需要接入系统,系统多是采用前后端分离的架构进行实现,所以基于token的方式更适合，如JWT认证。

##### 什么是授权

微信登录成功后用户即可使用微信的功能,比如,发红包、发朋友圈、添加好友等,没有绑定银行卡的用户是无法发送红包的,绑定银行卡的用户才可以发红包,发红包功能、发朋友圈功能都是微信的资源即功能资源,用户拥有发红包功能的权限才可以正常使用发送红包功能,拥有发朋友圈功能的权限才可以使用发朋友圈功能,这个根据用户的权限来控制用户使用资源的过程就是授权。

为什么要授权?

认证是为了保证用户身份的合法性,授权则是为了更细粒度的对隐私数据进行划分,授权是在认证通过后发生的,
控制不同的用户能够访问不同的资源。

**授权**: 授权是用户认证通过根据用户的权限来控制用户访问资源的过程,拥有资源的访问权限则正常访问,没有权限则拒绝访问。

##### 授权的数据模型

如何进行授权即如何对用户访问资源进行控制,首先需要学习授权相关的数据模型。

授权可简单理解为Who对What(which)进行How操作,包括如下:

- Who,即主体(Subject),主体一般是指用户,也可以是程序,需要访问系统中的资源。

- What,即资源(Resource),如系统菜单、页面、按钮、代码方法、系统商品信息、系统订单信息等。系统菜单、页面、按钮、代码方法都属于系统功能资源,对于web系统每个功能资源通常对应一个URL;系统商品信息、系统订单信息都属于实体资源(数据资源),实体资源由资源类型和资源实例组成,比如商品信息为资源类型,商品编号 为001的商品为资源实例。 

- How,权限/许可(Permission),规定了用户对资源的操作许可,权限离开资源没有意义,如用户查询权限、用户添加权限、某个代码方法的调用权限、编号为001的用户的修改权限等,通过权限可知用户对哪些资源都有哪些操作许可。

主体、资源、权限关系如下图:

![QHWVI0.png](https://s2.ax1x.com/2019/12/18/QHWVI0.png)

主体、资源、权限相关的数据模型如下:

- 主体(用户id、账号、密码、...)
- 资源(资源id、资源名称、访问地址、...)
- 权限(权限id、权限标识、权限名称、资源id、...)
- 角色(角色id、角色名称、...)

- 角色和权限关系(角色 id、权限id、...)
- 主体(用户)和角色关系(用户id、角色id、...)

主体(用户)、资源、权限关系如下图:

![QHWMM4.png](https://s2.ax1x.com/2019/12/18/QHWMM4.png)

通常企业开发中将资源和权限表合并为一张权限表,如下:

- 资源(资源id、资源名称、访问地址、...)
- 权限(权限id、权限标识、权限名称、资源id、...)

合并为:

- 权限(权限id、权限标识、权限名称、资源名称、资源访问地址、...)

修改后数据模型之间的关系如下图:

![QHWGIx.png](https://s2.ax1x.com/2019/12/18/QHWGIx.png)

##### RBAC

如何实现授权?业界通常基于RBAC实现授权。

**基于角色的访问控制**

RBAC基于角色的访问控制(Role-Based Access Control)是按角色进行授权,比如:主体的角色为总经理可以查询企业运营报表,查询员工工资信息等,访问控制流程如下:

![QHWdQe.png](https://s2.ax1x.com/2019/12/18/QHWdQe.png)

根据上图中的判断逻辑,授权代码可表示如下:

```
if(主体.hasRole("总经理角色id")){
查询工资
}
```

如果上图中查询工资所需要的角色变化为总经理和部门经理,此时就需要修改判断逻辑为“判断用户的角色是否是总经理或部门经理”,修改代码如下:

```
if(主体.hasRole("总经理角色id") ||
主体.hasRole("部门经理角色id")){
查询工资
}
```

根据上边的例子发现,当需要修改角色的权限时就需要修改授权的相关代码,系统可扩展性差。

**基于资源的访问控制**

RBAC基于资源的访问控制(Resource-Based Access Control)是按资源(或权限)进行授权,比如:用户必须具有查询工资权限才可以查询员工工资信息等,访问控制流程如下:

![QHfklD.png](https://s2.ax1x.com/2019/12/18/QHfklD.png)

根据上图中的判断,授权代码可以表示为:

```
if(主体.hasPermission("查询工资权限标识")){
查询工资
}
```

优点:系统设计时定义好查询工资的权限标识,即使查询工资所需要的角色变化为总经理和部门经理也不需要修改
授权代码,系统可扩展性强。

#### 基于Session的认证方式

**认证流程**

基于Session认证方式的流程是,用户认证成功后,在服务端生成用户相关的数据保存在session(当前会话),而发给客户端的 sesssion_id 存放到 cookie 中,这样用客户端请求时带上 session_id 就可以验证服务器端是否存在
session 数据,以此完成用户的合法校验。当用户退出系统或session过期销毁时,客户端的session_id也就无效了。

下图是session认证方式的流程图:

![image-20191218221229380](/home/hyp/.config/Typora/typora-user-images/image-20191218221229380.png)

基于Session的认证机制由Servlet规范定制,Servlet容器已实现,用户通过HttpSession的操作方法即可实现,如下是HttpSession相关的操作API。

![QHf41O.png](https://s2.ax1x.com/2019/12/18/QHf41O.png)

代码参考：<https://github.com/hanyunpeng0521/learn-sercurity/tree/master/security-springmvc>

运行项目：`mvn clean tomcat7:run`

浏览器访问：<http://localhost:8080/security-springmvc>

未登录情况下,/r/r1与/r/r2均提示 “请先登录”。

张三登录情况下,由于张三有p1权限,因此可以访问/r/r1,张三没有p2权限,访问/r/r2时提示 “权限不足 “。

李四登录情况下,由于李四有p2权限,因此可以访问/r/r2,李四没有p1权限,访问/r/r1时提示 “权限不足 “。

测试结果全部符合预期结果。

### Spring Security

一个能够为基于Spring的企业应用系统提供声明式的安全訪问控制解决方式的安全框架（简单说是对访问权限进行控制嘛），应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。

用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。

用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。   

spring security的主要核心功能为 认证和授权，所有的架构也是基于这两个核心功能去实现的。

spring security的项目：<https://github.com/hanyunpeng0521/learn-sercurity/tree/master/security-spring-security>

spring boot+spring security项目：<https://github.com/hanyunpeng0521/learn-sercurity/tree/master/security-spring-boot>

#### 原理

Spring Security所解决的问题就是**安全访问控制**,而安全访问控制功能其实就是对所有进入系统的请求进行拦截,校验每个请求是否能够访问它所期望的资源。根据前边知识的学习,可以通过Filter或AOP等技术来实现,Spring Security对Web资源的保护是靠Filter实现的,所以从这个Filter来入手,逐步深入Spring Security原理。

当初始化Spring Security时,会创建一个名为 **SpringSecurityFilterChain** 的Servlet过滤器,类型为org.springframework.security.web.FilterChainProxy,它实现了javax.servlet.Filter,因此外部的请求会经过此类,下图是Spring Security过虑器链结构图:

![QqFEy8.png](https://s2.ax1x.com/2019/12/19/QqFEy8.png)

FilterChainProxy 是一个代理,真正起作用的是FilterChainProxy中SecurityFilterChain所包含的各个Filter,同时这些Filter作为Bean被Spring管理,它们是Spring Security核心,各有各的职责,但他们并不直接处理用户的认
证,也不直接处理用户的授权,而是把它们交给了认证管理器(AuthenticationManager)和决策管理器(AccessDecisionManager)进行处理,下图是FilterChainProxy相关类的UML图示。

![UTOOLS1576733298633.png](https://i.loli.net/2019/12/19/d6BwiLSQX2WxDOF.png)

spring Security功能的实现主要是由一系列过滤器链相互配合完成。

![UTOOLS1576733329015.png](https://i.loli.net/2019/12/19/YW4H8pihzyQFAEU.png)

下面介绍过滤器链中主要的几个过滤器及其作用:

- SecurityContextPersistenceFilter 这个Filter是整个拦截过程的入口和出口(也就是第一个和最后一个拦截器),会在请求开始时从配置好的 SecurityContextRepository 中获取 SecurityContext,然后把它设置给SecurityContextHolder。在请求完成后将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好的 SecurityContextRepository,同时清除 securityContextHolder 所持有的 SecurityContext;
- UsernamePasswordAuthenticationFilter 用于处理来自表单提交的认证。该表单必须提供对应的用户名和密码,其内部还有登录成功或失败后进行处理的 AuthenticationSuccessHandler 和AuthenticationFailureHandler,这些都可以根据需求做相关改变;
- FilterSecurityInterceptor 是用于保护web资源的,使用AccessDecisionManager对当前用户进行授权访问,前面已经详细介绍过了;
- ExceptionTranslationFilter 能够捕获来自 FilterChain 所有的异常,并进行处理。但是它只会处理两类异常:AuthenticationException 和 AccessDeniedException,其它的异常它会继续抛出。

##### 认证流程

![UTOOLS1576733427247.png](https://i.loli.net/2019/12/19/1tbQRFcLy37elMI.png)

让我们仔细分析认证过程:
1. 用户提交用户名、密码被SecurityFilterChain中的 UsernamePasswordAuthenticationFilter 过滤器获取到,封装为请求Authentication,通常情况下是UsernamePasswordAuthenticationToken这个实现类。

2. 然后过滤器将Authentication提交至认证管理器(AuthenticationManager)进行认证

3. 认证成功后, AuthenticationManager 身份管理器返回一个被填充满了信息的(包括上面提到的权限信息,身份信息,细节信息,但密码通常会被移除) Authentication 实例。

4. SecurityContextHolder 安全上下文容器将第3步填充了信息的 Authentication ,通过`SecurityContextHolder.getContext().setAuthentication(...)`方法,设置到其中。

  可以看出AuthenticationManager接口(认证管理器)是认证相关的核心接口,也是发起认证的出发点,它的实现类为ProviderManager。而Spring Security支持多种认证方式,因此ProviderManager维护着一个`List<AuthenticationProvider>` 列表,存放多种认证方式,最终实际的认证工作是由AuthenticationProvider完成的。

  咱们知道web表单的对应的AuthenticationProvider实现类为DaoAuthenticationProvider,它的内部又维护着一个UserDetailsService负责UserDetails的获取。最终AuthenticationProvider将UserDetails填充至Authentication。

  认证核心组件的大体关系如下:

  ![UTOOLS1576733517982.png](https://i.loli.net/2019/12/19/QwsxdNb62G7ktiu.png)

**AuthenticationProvider**

通过前面的Spring Security认证流程我们得知,认证管理器(AuthenticationManager)委托AuthenticationProvider完成认证工作。

AuthenticationProvider是一个接口,定义如下:

```java
public interface AuthenticationProvider {

	Authentication authenticate(Authentication authentication)
			throws AuthenticationException;

	boolean supports(Class<?> authentication);
}

```

authenticate()方法定义了认证的实现过程,它的参数是一个Authentication,里面包含了登录用户所提交的用
户、密码等。而返回值也是一个Authentication,这个Authentication则是在认证成功后,将用户的权限及其他信息重新组装后生成。

Spring Security中维护着一个 List<AuthenticationProvider\> 列表,存放多种认证方式,不同的认证方式使用不同的AuthenticationProvider。如使用用户名密码登录时,使用AuthenticationProvider1,短信登录时使用
AuthenticationProvider2等等这样的例子很多。

每个AuthenticationProvider需要实现supports()方法来表明自己支持的认证方式,如我们使用表单方式认证,
在提交请求时Spring Security会生成UsernamePasswordAuthenticationToken,它是一个Authentication,里面
封装着用户提交的用户名、密码信息。而对应的,哪个AuthenticationProvider来处理它?

我们在DaoAuthenticationProvider的基类AbstractUserDetailsAuthenticationProvider发现以下代码:

```java
	public boolean supports(Class<?> authentication) {
		return (UsernamePasswordAuthenticationToken.class
				.isAssignableFrom(authentication));
	}

```

也就是说当web表单提交用户名密码时,Spring Security由DaoAuthenticationProvider处理。

最后,我们来看一下 Authentication(认证信息)的结构,它是一个接口,我们之前提到的UsernamePasswordAuthenticationToken就是它的实现之一:

```java
//Authentication是spring security包中的接口,直接继承自Principal类,
//而Principal是位于 java.security包中的。
//它是表示着一个抽象主体身份,任何主体都有一个名称,因此包含一个getName()方法。
public interface Authentication extends Principal, Serializable {
    //权限信息列表,默认是GrantedAuthority接口的一些实现类,通常是代表权限信息的一系列字符串。
	Collection<? extends GrantedAuthority> getAuthorities();
    //凭证信息,用户输入的密码字符串,在认证过后通常会被移除,用于保障安全。
	Object getCredentials();

    //细节信息,web应用中的实现接口通常为 WebAuthenticationDetails,它记录了访问者的ip地址和sessionId的值。
	Object getDetails();

    //身份信息,大部分情况下返回的是UserDetails接口的实现类,UserDetails代表用户的详细信息,那从Authentication中取出来的UserDetails就是当前登录用户信息,它也是框架中的常用接口之一。
	Object getPrincipal();
    
	boolean isAuthenticated();
	void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;
}

```

**UserDetailsService**

现在咱们现在知道DaoAuthenticationProvider处理了web表单的认证逻辑,认证成功后既得到一个Authentication(UsernamePasswordAuthenticationToken实现),里面包含了身份信息(Principal)。这个身份信息就是一个 Object ,大多数情况下它可以被强转为UserDetails对象。

DaoAuthenticationProvider中包含了一个UserDetailsService实例,它负责根据用户名提取用户信息UserDetails(包含密码),而后DaoAuthenticationProvider会去对比UserDetailsService提取的用户密码与用户提交的密码是否匹配作为认证成功的关键依据,因此可以通过将自定义的 UserDetailsService 公开为spring bean来定义自定义身份验证。

```java
public interface UserDetailsService {
	UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
```

很多人把 DaoAuthenticationProvider和UserDetailsService的职责搞混淆,其实UserDetailsService只负责从特定的地方(通常是数据库)加载用户信息,仅此而已。而DaoAuthenticationProvider的职责更大,它完成完整的认证流程,同时会把UserDetails填充至Authentication。

上面一直提到UserDetails是用户信息,咱们看一下它的真面目:

```java
public interface UserDetails extends Serializable {

	Collection<? extends GrantedAuthority> getAuthorities();

	String getPassword();

	String getUsername();

	boolean isAccountNonExpired();

	boolean isAccountNonLocked();

	boolean isCredentialsNonExpired();

	boolean isEnabled();
}
```

它和Authentication接口很类似,比如它们都拥有username,authorities。Authentication的getCredentials()与UserDetails中的getPassword()需要被区分对待,前者是用户提交的密码凭证,后者是用户实际存储的密码,认证其实就是对这两者的比对。Authentication中的getAuthorities()实际是由UserDetails的getAuthorities()传递而形成的。还记得Authentication接口中的getDetails()方法吗?其中的UserDetails用户详细信息便是经过了AuthenticationProvider认证之后被填充的。

通过实现UserDetailsService和UserDetails,我们可以完成对用户信息获取方式以及用户信息字段的扩展。Spring Security提供的InMemoryUserDetailsManager(内存认证),JdbcUserDetailsManager(jdbc认证)就是UserDetailsService的实现类,主要区别无非就是从内存还是从数据库加载用户。

自定义UserDetailsService:

```java

@Service
public class SpringDataUserDetailsService implements UserDetailsService {
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
//登录账号
        System.out.println("username=" + username);
//根据账号去数据库查询...
//这里暂时使用静态数据
        UserDetails userDetails =
                User.withUsername(username).password("123").authorities("p1").build();
        return userDetails;
    }
}

```

屏蔽安全配置类中 UserDetailsService的定义:

```java
//    @Override
//    @Bean
//    public UserDetailsService userDetailsService() {
//        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
//        manager.createUser(User.withUsername("zhangsan").password("123").authorities("p1").build());
//        manager.createUser(User.withUsername("lisi").password("456").authorities("p2").build());
//        return manager;
//    }
```

重启工程,请求认证,SpringDataUserDetailsService的loadUserByUsername方法被调用 ,查询用户信息。

##### PasswordEncoder

DaoAuthenticationProvider认证处理器通过UserDetailsService获取到UserDetails后,它是如何与请求Authentication中的密码做对比呢?

在这里Spring Security为了适应多种多样的加密类型,又做了抽象,DaoAuthenticationProvider通过PasswordEncoder接口的matches方法进行密码的对比,而具体的密码对比细节取决于实现:

```java
public interface PasswordEncoder {

	String encode(CharSequence rawPassword);

	boolean matches(CharSequence rawPassword, String encodedPassword);

	default boolean upgradeEncoding(String encodedPassword) {
		return false;
	}
}
```

而Spring Security提供很多内置的PasswordEncoder,能够开箱即用,使用某种PasswordEncoder只需要进行如下声明即可,如下:

```java
    @Bean
    public PasswordEncoder passwordEncoder() {
        return NoOpPasswordEncoder.getInstance();
    }
```

NoOpPasswordEncoder采用字符串匹配方法,不对密码进行加密比较处理,密码比较流程如下:

1. 用户输入密码(明文 )
2. DaoAuthenticationProvider获取UserDetails(其中存储了用户的正确密码)
3. DaoAuthenticationProvider使用PasswordEncoder对输入的密码和正确的密码进行校验,密码一致则校验通
   过,否则校验失败。

NoOpPasswordEncoder 的校验规则拿 输入的密码和UserDetails中的正确密码进行字符串比较,字符串内容一致则校验通过,否则校验失败。

实际项目中推荐使用BCryptPasswordEncoder, Pbkdf2PasswordEncoder, SCryptPasswordEncoder等,感兴趣的大家可以看看这些PasswordEncoder的具体实现。

**spring security 5**

在最新的 Spring Security 5发布版本中, 出于安全性的考虑调整了PasswordEncoder的实现与使用策略.

1. 以前常用的实现 StandardPasswordEncoder, MessageDigestPasswordEncoder, StandardPasswordEncoder 不再推荐使用, 全加上了@Deprecated ,并有具体的说明，推荐使用BCryptPasswordEncoder, Pbkdf2PasswordEncoder, SCryptPasswordEncoder等

2. 增加 PasswordEncoderFactories 类提供一个静态方法 createDelegatingPasswordEncoder()方法, 使用委托方式创建PasswordEncoder的实现，在此方法的实现中,实际上使用了 BCryptPasswordEncoder 作为默认的实现(我想, 这也是Spring Security团队推荐使用的吧).

   ```java
   //org/springframework/security/crypto/factory/PasswordEncoderFactories.java
   public static PasswordEncoder createDelegatingPasswordEncoder() {
   	String encodingId = "bcrypt";
   	Map<String, PasswordEncoder> encoders = new HashMap<>();
   	encoders.put(encodingId, new BCryptPasswordEncoder());
   	encoders.put("ldap", new org.springframework.security.crypto.password.LdapShaPasswordEncoder());
   	encoders.put("MD4", new org.springframework.security.crypto.password.Md4PasswordEncoder());
   	encoders.put("MD5", new org.springframework.security.crypto.password.MessageDigestPasswordEncoder("MD5"));
   	encoders.put("noop", org.springframework.security.crypto.password.NoOpPasswordEncoder.getInstance());
   	encoders.put("pbkdf2", new Pbkdf2PasswordEncoder());
   	encoders.put("scrypt", new SCryptPasswordEncoder());
   	encoders.put("SHA-1", new org.springframework.security.crypto.password.MessageDigestPasswordEncoder("SHA-1"));
   	encoders.put("SHA-256", new org.springframework.security.crypto.password.MessageDigestPasswordEncoder("SHA-256"));
   	encoders.put("sha256", new org.springframework.security.crypto.password.StandardPasswordEncoder());
   
   	return new DelegatingPasswordEncoder(encodingId, encoders);
   }
   
   ```

3. 关于加密salt(盐值)的变化. 在之前的使用中, 一般在使用时自己指定salt值,一个配置示例如下:

   ![UTOOLS1576737719093.png](https://i.loli.net/2019/12/19/I5qGjog2bSrlfV1.png)

   而在新的使用中, salt的实现 将由各具体实现类去处理(如使用随机生成的值)

BCrypt 密码散列函数的概念介绍可以看一下维基百科或百度百科的内容 （因为只是使用，暂时不需要对算法的了解和实现）

> 维基百科：[BCrypt](https://zh.wikipedia.org/wiki/Bcrypt)

> 百度百科：[BCrypt](https://baike.baidu.com/item/Bcrypt)

加密/解密 与 Hash 这两个概念不能混淆，比如：SHA 系列是 Hash 算法，不是加密算法，加密意味着可以解密，但是 Hash 是不可逆的（无法通过 Hash 值还原得到密码，只能比对 Hash 值看看是否相等）。

目前很大一部分存在安全问题的系统一般仅仅使用密码的 MD5 值进行保存，可以通过 MD5 查询库去匹配对大部分的密码（可以直接从彩虹表里反推出来），而且 MD5 计算 Hash 值碰撞容易构造，安全性大大降低。MD5 加盐在本地计算速度也是很快，也是密码短也是极其容易破解；更好的选择是 SHA-256、BCrypt 等等等

**使用**

使用BCryptPasswordEncoder:

```java
//在安全配置类中定义
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
```

修改SpringDataUserDetailsService

```java
@Service
public class SpringDataUserDetailsService implements UserDetailsService {
    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        System.out.println("username=" + s);
        UserDetails user = User
                .builder()
                .username("zhangsan")
//                .password("123")
                .password("$2a$10$1b5mIkehqv5c4KRrX9bUj.A4Y2hug3IGCnMCL5i4RpQrYV12xNKye")
                .authorities("p1")
                .build();
        return user;
    }
}
```

**解释**

如果是使用 BCryptPasswordEncoder 调用 encode() 方法编码输入密码的话，其实这个编码后的“密码”并不是我们平时输入的真正密码，而是密码加盐后的通过单向 Hash 算法（BCrypt）得到值。

这里面细心的同学可能会发现一些问题：

- 同一个密码计算 Hash 不应该是一样的吗？每次使用 BCryptPasswordEncoder 编码同一个密码都是不一样的？
- BCryptPasswordEncoder 编码同一个密码后结果都不一样，怎么进行匹配？

下面通过源码简单说一下这个匹配的流程：
`matches(CharSequence rawPassword, String encodedPassword)` 方法根据两个参数都可以知道

- 第一个参数是原密码
- 第二个参数就是用 PasswordEncoder 调用 `encode(CharSequence rawPassword)` 编码过后保存在数据库的密码。

```java
//org/springframework/security/crypto/bcrypt/BCryptPasswordEncoder.java
public boolean matches(CharSequence rawPassword, String encodedPassword) {
    if (encodedPassword == null || encodedPassword.length() == 0) {
        logger.warn("Empty encoded password");
        return false;
    }

    if (!BCRYPT_PATTERN.matcher(encodedPassword).matches()) {
        logger.warn("Encoded password does not look like BCrypt");
        return false;
    }

    return BCrypt.checkpw(rawPassword.toString(), encodedPassword);
}
```

上述代码解读：首先判断是否数据库保存的“密码”（后面简称：“密码”）是否为空或者 `null` ，在通过正则表达式匹配“密码”是否符合格式，最后通过 `BCrypt` 的 `checkpw(String plaintext, String hashed)` 方法进行密码匹配

再详细看看 `BCrypt` 的 `checkpw(String plaintext, String hashed)` 方法：

```java
//org/springframework/security/crypto/bcrypt/BCrypt.java
public static boolean checkpw(String plaintext, String hashed) {
	return equalsNoEarlyReturn(hashed, hashpw(plaintext, hashed));
}

```

第二个参数 hashed 表明其实数据库查询出来的“密码”也就是 Hash 值；`equalsNoEarlyReturn(hashed, hashpw(plaintext, hashed))` 代码中通过调用 hashpw 计算输入密码的 Hash 值（参数分别是输入的密码和保存在数据库的“密码”）

再继续看 `hashpw` 里面的部分代码（内容过长，省略部分代码，看看代码中的中文注释）：

```java
//org/springframework/security/crypto/bcrypt/BCrypt.java
public static String hashpw(String password, String salt) throws IllegalArgumentException {
	BCrypt B;
	String real_salt;
	byte passwordb[], saltb[], hashed[];
	char minor = (char) 0;
	int rounds, off = 0;
	StringBuilder rs = new StringBuilder();

	if (salt == null) {
		throw new IllegalArgumentException("salt cannot be null");
	}

	int saltLength = salt.length();

	if (saltLength < 28) {
		throw new IllegalArgumentException("Invalid salt");
	}

	if (salt.charAt(0) != '$' || salt.charAt(1) != '2') {
		throw new IllegalArgumentException("Invalid salt version");
	}
	if (salt.charAt(2) == '$') {
		off = 3;
	}
	else {
		minor = salt.charAt(2);
		if (minor != 'a' || salt.charAt(3) != '$') {
			throw new IllegalArgumentException("Invalid salt revision");
		}
		off = 4;
	}

	if (saltLength - off < 25) {
		throw new IllegalArgumentException("Invalid salt");
	}

	// Extract number of rounds
	if (salt.charAt(off + 2) > '$') {
		throw new IllegalArgumentException("Missing salt rounds");
	}
	rounds = Integer.parseInt(salt.substring(off, off + 2));
	
	// 关键点：上面***一大堆就是校验是否符合相应格式，然后下面这行就是取出密码的盐，real_salt就是 Hash 计算前的密码盐（关于盐的介绍：https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6)）
    
	real_salt = salt.substring(off + 3, off + 25);
	try {
		passwordb = (password + (minor >= 'a' ? "\000" : "")).getBytes("UTF-8");
	}
	catch (UnsupportedEncodingException uee) {
		throw new AssertionError("UTF-8 is not supported");
	}

	saltb = decode_base64(real_salt, BCRYPT_SALT_LEN);

	B = new BCrypt();
	hashed = B.crypt_raw(passwordb, saltb, rounds);

	rs.append("$2");
	if (minor >= 'a') {
		rs.append(minor);
	}
	rs.append("$");
	if (rounds < 10) {
		rs.append("0");
	}
	rs.append(rounds);
	rs.append("$");
	encode_base64(saltb, saltb.length, rs);
	encode_base64(hashed, bf_crypt_ciphertext.length * 4 - 1, rs);
	return rs.toString();
}

```

其实上面代码就是从数据库得到的“密码”（参数： salt ）进行一系列校验（长度校验等）并截取“密码”中相应的密码盐，利用这个密码盐进行同样的一系列计算 Hash 操作和 Base64 编码拼接一些标识符 生成所谓的“密码”，最后 `equalsNoEarlyReturn` 方法对同一个密码盐生成的两个“密码”进行匹配。

上述大致就是密码匹配流程了，对于问题`“ BCryptPasswordEncoder 编码同一个密码后结果都不一样，怎么进行匹配”`的简单解答:

> 因为密码盐是随机生成的，但是可以根据数据库查询出来的“密码”拿到密码盐，同一个密码盐+原密码计算 Hash 结果值是能匹配的。

看看加密的一个过程，

```java
//org/springframework/security/crypto/bcrypt/BCryptPasswordEncoder.java
public String encode(CharSequence rawPassword) {
	String salt;
	if (strength > 0) {
		if (random != null) {
		    // 生成随机密码盐
			salt = BCrypt.gensalt(strength, random);
		}
		else {
		    // 生成随机密码盐
			salt = BCrypt.gensalt(strength);
		}
	}
	else {
	    // 生成随机密码盐
		salt = BCrypt.gensalt();
	}
	return BCrypt.hashpw(rawPassword.toString(), salt);
}

```

encode 方法传入是原密码，其中 `int strength, SecureRandom random` 这两个构造参数是 `BCryptPasswordEncoder(int strength, SecureRandom random)` 构造方法按需传入，如果不指定strength和random，默认执行 `BCrypt.gensalt()` 这行代码生成也相应密码随机盐。

先看看 `gensalt(int log_rounds, SecureRandom random)` 方法的代码（可以看看中文注释）:

```java
//org/springframework/security/crypto/bcrypt/BCrypt.java
public static String gensalt(int log_rounds, SecureRandom random) {
    // 一些检验
	if (log_rounds < MIN_LOG_ROUNDS || log_rounds > MAX_LOG_ROUNDS) {
		throw new IllegalArgumentException("Bad number of rounds");
	}
	StringBuilder rs = new StringBuilder();
	byte rnd[] = new byte[BCRYPT_SALT_LEN];

    // 生成随机字节并将其置于rnd字节数组
	random.nextBytes(rnd);

	rs.append("$2a$");
	if (log_rounds < 10) {
	    // 不够长度补够
		rs.append("0");
	}
	// 拼接字符串得到相应的格式
	rs.append(log_rounds);
	rs.append("$");
	encode_base64(rnd, rnd.length, rs);
	return rs.toString();
}

```

最终上面的 `gensalt` 方法得到一个 随机密码盐+无用字符串（这个字符串可以理解为你输入的密码） 计算 Hash 操作和 Base64 编码拼接一些标识符 生成假“密码”（这个假“密码”为了兼容方便调用 `hashpw` 方法），最后关键点就是调用 `BCrypt.hashpw` 方法取到密码盐生成相应的真实“密码”（这个得到的密码可以用于保存在数据库中了）。

对于问题`“同一个密码计算 Hash 不应该是一样的吗？每次使用 BCryptPasswordEncoder 编码同一个密码都是不一样的？”`的简单解答：

> 因为用到的随机密码盐每次都是不一样的，同一个密码和不同的密码盐组合计算出来的 Hash 值肯定不一样啦，所以编码同一个密码得到的结果都是不一样。

登录注册是每个系统都具备的功能，开发的同学记住一定不能保存明文密码，否则被脱库就会造成严重的后果。如果是通过上述的方法进行密码保存，即便拿到“密码”也非常难还原密码。

上述在密码编码的过程中的思想还是需要掌握：

1. 只是保存散列码是不安全的，但是我们可以为密码加盐再通过一些 Hash 值 低概率碰撞且计算速度慢 的散列算法计算 Hash 值保存。
2. Spring Security 每次 Hash 之前用的盐都是随机，盐可以保存在最终生成的“密码”中，这样每个密码都是用了相应不同的随机盐+原密码计算 Hash 值得到，暴力破解难度也变大了。

##### 授权流程

Spring Security可以通过 http.authorizeRequests() 对web请求进行授权保护。Spring Security使用标准Filter建立了对web请求的拦截,最终实现对资源的授权访问。

Spring Security的授权流程如下:

![UTOOLS1576738453686.png](https://i.loli.net/2019/12/19/Vf7UBSHDQvOlykd.png)

1. 拦截请求,已认证用户访问受保护的web资源将被SecurityFilterChain中的 FilterSecurityInterceptor 的子类拦截。

2. 获取资源访问策略,FilterSecurityInterceptor会从 SecurityMetadataSource 的子类DefaultFilterInvocationSecurityMetadataSource 获取要访问当前资源所需要的权限Collection<ConfigAttribute\> 。

   SecurityMetadataSource其实就是读取访问策略的抽象,而读取的内容,其实就是我们配置的访问规则, 读取访问策略如:

   ```java
    http
    .authorizeRequests()
    .antMatchers("/r/r1").hasAuthority("p1")
    .antMatchers("/r/r2").hasAuthority("p2")
    .antMatchers("/r/**").authenticated()
    .anyRequest().permitAll()
   ```

3. 最后,FilterSecurityInterceptor会调用 AccessDecisionManager 进行授权决策,若决策通过,则允许访问资源,否则将禁止访问。

AccessDecisionManager(访问决策管理器)的核心接口如下:

```java
public interface AccessDecisionManager {
/**
* 通过传递的参数来决定用户是否有访问对应受保护资源的权限
*/
	void decide(Authentication authentication, Object object,
			Collection<ConfigAttribute> configAttributes) throws AccessDeniedException,
			InsufficientAuthenticationException;

	boolean supports(ConfigAttribute attribute);

	boolean supports(Class<?> clazz);
}
```

这里着重说明一下decide的参数:

- authentication:要访问资源的访问者的身份
- object:要访问的受保护资源,web请求对应FilterInvocation
- configAttributes:是受保护资源的访问策略,通过SecurityMetadataSource获取。

decide接口就是用来鉴定当前用户是否有访问对应受保护资源的权限。

**授权决策**

AccessDecisionManager采用**投票**的方式来确定是否能够访问受保护资源。

![UTOOLS1576738705217.png](https://i.loli.net/2019/12/19/QwA9hnmzcb7KZCH.png)

通过上图可以看出,AccessDecisionManager中包含的一系列AccessDecisionVoter将会被用来对Authentication是否有权访问受保护对象进行投票,AccessDecisionManager根据投票结果,做出最终决策。

AccessDecisionVoter是一个接口,其中定义有三个方法,具体结构如下所示。

```java
public interface AccessDecisionVoter<S> {

	int ACCESS_GRANTED = 1;
	int ACCESS_ABSTAIN = 0;
	int ACCESS_DENIED = -1;

	boolean supports(ConfigAttribute attribute);

	boolean supports(Class<?> clazz);

	int vote(Authentication authentication, S object,
			Collection<ConfigAttribute> attributes);
}
```

vote()方法的返回结果会是AccessDecisionVoter中定义的三个常量之一。ACCESS_GRANTED表示同意,ACCESS_DENIED表示拒绝,ACCESS_ABSTAIN表示弃权。如果一个AccessDecisionVoter不能判定当前Authentication是否拥有访问对应受保护对象的权限,则其vote()方法的返回值应当为弃权ACCESS_ABSTAIN。

Spring Security内置了三个基于投票的AccessDecisionManager实现类如下,它们分别是AffirmativeBased、ConsensusBased和UnanimousBased

AffirmativeBased的逻辑是:

1. 只要有AccessDecisionVoter的投票为ACCESS_GRANTED则同意用户进行访问;
2. 如果全部弃权也表示通过;
3. 如果没有一个人投赞成票,但是有人投反对票,则将抛出AccessDeniedException。

Spring security默认使用的是AffirmativeBased。

ConsensusBased的逻辑是:

1. 如果赞成票多于反对票则表示通过。
2. 反过来,如果反对票多于赞成票则将抛出AccessDeniedException。
3. 如果赞成票与反对票相同且不等于0,并且属性allowIfEqualGrantedDeniedDecisions的值为true,则表示通过,否则将抛出异常AccessDeniedException。参数allowIfEqualGrantedDeniedDecisions的值默认为true。
4. 如果所有的AccessDecisionVoter都弃权了,则将视参数allowIfAllAbstainDecisions的值而定,如果该值为true则表示通过,否则将抛出异常AccessDeniedException。参数allowIfAllAbstainDecisions的值默认为false。

UnanimousBased的逻辑与另外两种实现有点不一样,另外两种会一次性把受保护对象的配置属性全部传递给AccessDecisionVoter进行投票,而UnanimousBased会一次只传递一个ConfigAttribute给AccessDecisionVoter进行投票。这也就意味着如果我们的AccessDecisionVoter的逻辑是只要传递进来的ConfigAttribute中有一个能够匹配则投赞成票,但是放到UnanimousBased中其投票结果就不一定是赞成了。

UnanimousBased的逻辑具体来说是这样的:

1. 如果受保护对象配置的某一个ConfigAttribute被任意的AccessDecisionVoter反对了,则将抛出AccessDeniedException。
2. 如果没有反对票,但是有赞成票,则表示通过。
3. 如果全部弃权了,则将视参数allowIfAllAbstainDecisions的值而定,true则通过,false则抛出AccessDeniedException。

Spring Security也内置一些投票者实现类如RoleVoter、AuthenticatedVoter和WebExpressionVoter等,可以自行查阅资料进行学习。

**权限表达式**

springsecurity是通过权限表达式控制授权，springsecurity的权限表达式及说明如下：

![UTOOLS1576739076644.png](https://i.loli.net/2019/12/19/Y9wxbMdrX2GcqkW.png)

**自定义认证**

Spring Security提供了非常好的认证扩展方法,比如:快速上手中将用户信息存储到内存中,实际开发中用户信息通常在数据库,Spring security可以实现从数据库读取用户信息,Spring security还支持多种授权方法。

上面的示例中我们并没有提供任何的HTML或JSP文件。Spring Security的默认配置没有明确设定一个登录页面的URL,因此Spring Security会根据启用的功能自动生成一个登录页面URL,并使用默认URL处理登录的提交内容,登录后跳转的到默认URL等等。尽管自动生成的登录页面很方便快速启动和运行,但大多数应用程序都希望定义自己的登录页面。

项目参考：<https://github.com/hanyunpeng0521/learn-sercurity/tree/master/security-spring-boot>

spring boot运行jsp需要添加依赖

```xml

<dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
 
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
 
        <!-- 添加servlet依赖模块 -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <scope>provided</scope>
        </dependency>
        <!-- 添加jstl标签库依赖模块 -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>jstl</artifactId>
        </dependency>
        <!--添加tomcat依赖模块.-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
            <scope>provided</scope>
        </dependency>
        <!-- 使用jsp引擎，springboot内置tomcat没有此依赖 -->
        <dependency>
            <groupId>org.apache.tomcat.embed</groupId>
            <artifactId>tomcat-embed-jasper</artifactId>
            <scope>provided</scope>
        </dependency>
 
    </dependencies>
```

其中最主要的，提供jsp引擎的就是

```
tomcat-embed-jasper这个依赖(一定要加)
```

然后修改配置文件中的Jsp文件访问路径(视图解析)

在application.properties文件中加入

```
spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp
```

配置完成后在webapp/WEB-INF/jsp文件夹下放jsp文件(必须有webapp/WEB-INF这个包，否则访问不到)
然后使用`mvn spring-boot:run`运行

**SpringSecurity处理CSRF攻击**

`CSRF（Cross-site request forgery）`跨站请求伪造，也被称为`One Click Attack`或者`Session Riding`，通常缩写为`CSRF`或`XSRF`，是一种对网站的恶意利用。尽管听起来像跨站脚本（`XSS`），但它与`XSS`非常不同，`XSS`利用站点内的信任用户，而`CSRF`则通过伪装成受信任用户的请求来利用受信任的网站。与`XSS`攻击相比，`CSRF`攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比`XSS`更具危险性。

`CSRF`是一种依赖web浏览器的、被混淆过的代理人攻击（`deputy attack`）。

1. 配置过滤器

   ```java
     /**
      * 配置CSRF过滤器
      *
      * @return {@link org.springframework.boot.web.servlet.FilterRegistrationBean}
      */
     @Bean
     public FilterRegistrationBean<CsrfFilter> csrfFilter() {
       FilterRegistrationBean<CsrfFilter> registration = new FilterRegistrationBean<>();
       registration.setFilter(new CsrfFilter(new HttpSessionCsrfTokenRepository()));
       registration.addUrlPatterns("/*");
       registration.setName("csrfFilter");
       return registration;
     }
   ```

2. 在form请求中添加CSRF的隐藏字段

   ```html
   <input name="${(_csrf.parameterName)}" value="${(_csrf.token)}" type="hidden" />
   ```

3. 在AJAX请求中添加header头

   ```js
   xhr.setRequestHeader("${_csrf.headerName}", "${_csrf.token}");
   ```

4. jQuery的Ajax全局配置

   ```js
   jQuery.ajaxSetup({
     "beforeSend": function (request) {
       request.setRequestHeader("${_csrf.headerName}", "${_csrf.token}");
     }
   });
   ```

另外一种方法则是直接关闭csrf认证，不推荐

```java
@Override
    protected void configure(HttpSecurity http) throws Exception {
     
        //关闭默认的csrf认证
        http.csrf().disable();

    }
```

**连接数据库认证**

前边的例子我们是将用户信息存储在内存中,实际项目中用户信息存储在数据库中，根据前边对认证流程研究,只需要重新定义UserDetailService即可实现根据用户账号查询数据库。

这里使用H2数据库

pom文件添加文件

```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring‐boot‐starter‐jdbc</artifactId>
        </dependency>

        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <version>1.4.200</version>
        </dependency>
```

application.properties文件添加

```sql
spring.datasource.url=jdbc:h2:mem:test_db
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=root
spring.datasource.password=123456
spring.datasource.schema=classpath:db/schema.sql
spring.datasource.data=classpath:db/data.sql
spring.h2.console.enabled=true
```

在db文件夹下创建schema.sql

```sql
CREATE TABLE `t_user`
(
  `id`       int   NOT NULL COMMENT '用户id',
  `username` varchar(64)  NOT NULL,
  `password` varchar(64)  NOT NULL,
  `fullname` varchar(255) NOT NULL COMMENT '用户姓名',
  `mobile`   varchar(11) DEFAULT NULL COMMENT '手机号'
);
```

在db文件夹下创建data.sql

```sql
insert into t_user values (1,'zhangsan','$2a$10$1b5mIkehqv5c4KRrX9bUj.A4Y2hug3IGCnMCL5i4RpQrYV12xNKye',"张三",'13811114444');
```

定义模型类型,在 model包定义UserDto:

```java
@Data
public class UserDto {
    private Integer id;
    private String username;
    private String password;
    private String fullname;
    private String mobile;
}
```

在dao包定义UserDao:

```java

@Repository
public class UserDao {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public UserDto getUserByUsername(String username) {
        String sql = "select id,username,password,fullname from t_user where username = ?";
        List<UserDto> list = jdbcTemplate.query(sql, new Object[]{username}, new
                BeanPropertyRowMapper<>(UserDto.class));
        if (list == null && list.size() <= 0) {
            return null;
        }
        return list.get(0);
    }
}
```

修改：SpringDataUserDetailsService

```java
@Service
public class SpringDataUserDetailsService implements UserDetailsService {

    @Autowired
    private UserDao userDao;

    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        System.out.println("username=" + s);

        //根据账号去数据库查询...
        UserDto user = userDao.getUserByUsername(s);
        if(user == null){
            return null;
        }
        // 这里暂时使用静态数据
        UserDetails userDetails =
                User.withUsername(user.getFullname()).password(user.getPassword()).authorities("p1").build();
        return userDetails;
    }
}

```

##### 会话

用户认证通过后,为了避免用户的每次操作都进行认证可将用户的信息保存在会话中。spring security提供会话管理,认证通过后将身份信息放入SecurityContextHolder上下文,SecurityContext与当前线程进行绑定,方便获取用户身份。

```java
    @RequestMapping(value = "/login‐success", produces = {"text/plain;charset=utf8"})
    public String loginSuccess() {
        String username = getUsername();
        return username + " 登录成功";
    }

    /**
     * 获取当前登录用户名
     *
     * @return
     */
    private String getUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (!authentication.isAuthenticated()) {
            return null;
        }
        Object principal = authentication.getPrincipal();
        String username = null;
        if (principal instanceof org.springframework.security.core.userdetails.UserDetails) {
            username =
                    ((org.springframework.security.core.userdetails.UserDetails) principal).getUsername();
        } else {
            username = principal.toString();
        }
        return username;
    }
```

我们可以通过以下选项准确控制会话何时创建以及Spring Security如何与之交互:

![UTOOLS1576747040198.png](https://i.loli.net/2019/12/19/WFzVAvlh4tHQZg6.png)

通过以下配置方式对该选项进行配置:

```java
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //会话控制
        http.sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED);
    }

```

默认情况下,Spring Security会为每个登录成功的用户会新建一个Session,就是ifRequired 。

若选用never,则指示Spring Security对登录成功的用户不创建Session了,但若你的应用程序在某地方新建了session,那么Spring Security会用它的。

若使用stateless,则说明Spring Security对登录成功的用户不会创建Session了,你的应用程序也不会允许新建session。并且它会暗示不使用cookie,所以每个请求都需要重新进行身份验证。这种无状态架构适用于REST API及其无状态认证机制。

1. 会话超时

   可以再sevlet容器中设置Session的超时时间,如下设置Session有效期为3600s;

   spring boot 配置文件:

   ```
   server.servlet.session.timeout=3600s
   ```

   session超时之后,可以通过Spring Security 设置跳转的路径。

   ```java
   http.sessionManagement()
   .expiredUrl("/login‐view?error=EXPIRED_SESSION")
   .invalidSessionUrl("/login‐view?error=INVALID_SESSION");
   ```

   expired指session过期,invalidSession指传入的sessionid无效。

2. 安全会话cookie

   我们可以使用httpOnly和secure标签来保护我们的会话cookie:

   - httpOnly :如果为true,那么浏览器脚本将无法访问cookie
   - secure :如果为true,则cookie将仅通过HTTPS连接发送

   spring boot 配置文件:

   ```
   server.servlet.session.cookie.http‐only=true
   server.servlet.session.cookie.secure=true
   ```

3. 会话固定攻击：利用服务器会话不变机制，借他人之手获取认证和授权，然后冒充他人。举例如下：

   1. A先打开一个网站 "http://unsafe"，然后服务器会回复他一个session id。比session id=mjg4qid0wioq, Mallory把这个id记下了;
   2. A给B发送一个电子邮件，他假装是银行在宣传自己的新业务，例如，我行推出了一项新服务，率先体验请点击："http://unsafe/?sessionId=mjg4qid0wioq"，sessionId后面是A自己的session id; 
   3. Alice被吸引了，点击了"http://unsafe/?sessionId=mjg4qid0wioq"，像往常一样，输入了自己的帐号和口令从而登录到银行网站;
   4. 因为服务器的session id不改变，现在A点击"http://unsafe/?SID=mjg4qid0wioq"后，他就拥有了B的身份。可以为所欲为了。 

   ![Qqci4K.png](https://s2.ax1x.com/2019/12/19/Qqci4K.png)

   spring security默认是开通session fixation防护的，如果想显示开通，可以通过以下代码实现：

   ```
   http.sessionManagement().sessionFixation().migrateSession()
   ```

   spring 防护的原理为，每当用户认证过后，就会重新生成一个新的session，并抛弃旧的session，下图是spring security的防护原理：

   ![QqcGvQ.png](https://s2.ax1x.com/2019/12/19/QqcGvQ.png)

   从上图中可知，SessionManagementFilter负责检查一个用户是否是新认证的用户，如果是则会调用接口SessionAuthenticationStrategy进行处理，SessionAuthenticationStrategy的实现类SessionFixationProtectionStrategy会为用户创建一个新的session 同时丢弃旧的session。

   spring security session的几个方法选项：

   - none() 关闭spring security的session防护功能，spring不会配置SessionManagementFilter类；
   - migrateSession() 用户认证之后，会重新创建一个新的session，并且将旧session中的属性，迁移到新的session中；
   - newSession（）用户认证之后，会新创建一个session，但是不会将旧的session中的属性，迁移到新的session中

4. 单用户并发session控制

   确保单个用户的单个账号，只有一个活跃的session，这也是一个常见的需求，先看下在Security.java中的代码配置：

   ```java
   http.sessionManagement().maximumSessions(1)
   
    @Bean
    public HttpSessionEventPublisher (){
         new HttpSessionEventPublisher();
    }
   ```

   **并发控制的原理**

   Spring security使用SessionRegistry来维护一个列表，列表记录了每一个活跃的session以及与之相关的认证用户，当session的生命周期发生变化时，容器会产生一个HttpSessionEventPublisher事件，SessionRegistry捕获到HttpSessionEventPublisher事件，并实时地更新列表。当用户访问一个受保护的站点时，SessionManagerFilter会通过SessionRegistry检查用户的激活session是否存在，若不存在，则将SessionRegistry中保存的激活session置为无效。另外，ConcurrentSessionFilter会识别session是否过期，若session过期则更新SessionRegistry。session的过期事件可能是由服务器产生，也可能是由ConcurrentSessionControlStrategy强制设置为过期。

   原理图如下所示：

   ![QqcbqA.png](https://s2.ax1x.com/2019/12/19/QqcbqA.png)

   **配置session过期重定位地址**
   当spring security检查到session过期后，若未做任何配置，spring security会返回一个用户不友好的页面，因此我们通常需要设置一个地址，当spring security检查到session过期后，将请求重定位到我们的地址上，设置代码如下所示：

   ```
   http.sessionManagement().expiredUrl("/login");
   ```

5. 阻止认证而不是强制退出

   当一个用户已经认证过了，在另外一个地方重新进行登录认证，spring security可以阻止其再次登录认证，从而保持原来的会话可用性；具体的代码设置如下所示：

   ```
   http.sessionManager().maximumSession(1).maxSessionsPreventsLogin(true);
   ```

   当时上述代码还存在一个问题，当用户登陆后，没有退出直接关闭浏览器，则再次打开浏览器时，此时浏览器的session若被删除的话，用户只能等到服务器的session过期后，才能再次登录。

**一些常见问题**

1. 当采用传统的UserDetails认证登录时，若UserDetails的equals方法和hashcode方法没有进行有效的实现，可能会导致，同一个用户多次登录，但是不会触发登录退出事件，这是因为SessionRegistry是使用内存map来存储UserDetails的，对UserDetails的比较会调用其自身的equal方法；
2. 当用户会话持久化到磁盘后，应用服务器重启时，会读取磁盘上的会话，这时已经使用有效会话登录的用户，应该是登录状态，但此时sessionRegistry的内存map是空，因此spring security会报告用户未登录，为解决该问题，有两种方法，一是自定义sessionRegistry的实现，并在容器中禁用会话持久化功能，二是必须实现容器特定的方式，以确保在启动时将持久化会话填充到内存映射中。
3. spring security较低的版本并没有在session的并发控制中实现‘记住我功能’；
4. session并发控制的缺省实现并不能用于集群环境中，因此其缺省实现是将session记录在内存map中，服务器1中记录的信息和服务器2记录的信息并不相同；

**认证信息和HttpSession的关系**

1. 在每一个request的开始，SecurityContextPersistenceFilter负责通过SecurityContextRepository获取SecurityContext的实现；并将其设置到SecurityContextHolder中，随后可以在controller中通过SecurityContextHolder访问SecurityContext;

2. 在请求结束，SecurityContextPersistenceFilter会从SecurityContextHolder中取出SecurityContext并将其保存到SecurityContextRepository中

   SecurityContextRepository的缺省实现HttpSessionSecurityContextRepository，使用HttpSession检索和保存SecurityContext的实现，spring security除了只提供了一个SecurityContextRepository的实现即为HttpSessionSecurityContextRepository，但是我们可以定义自己的SecurityContextRepository实现。

**典型的业务场景**

现在我们有这样一个业务场景，我允许用户多次登录，同时登录的用户可以查看相同的账号在不同的地方的登录session，并且对这些session进行管理，比如查看，删除等操作；如何使用spring security实现上述功能？
It is easy!

```java
http.sessionManagement().maximumSession(-1).sessionRegistry(sessionRegistryImp()).expiredUrl("login")

@Bean 
public SessionRegistry sessionRegistryImp(){
    return new SessionRegistryImp();
}
```

接下来，我们就可以将SessionRegistry实例注入到Controller里面，通过SessionRegistry获取与当前认证用户相关的所有session，示例代码如下所示：

```java
@GetMapping("/user/sessions/")
public String sessions(Authentication authentication,Model model){
    List<SessionInformation> list=sessionRegistry.getAllSessions(authentication.getPrincipal(),false);
}
```

##### 退出

在WebSecurityConfig的protected void configure(HttpSecurity http)中配置:

```
.and()
.logout()
.logoutUrl("/logout")
.logoutSuccessUrl("/login‐view?logout");
```

当退出操作出发时,将发生:

- 使 HTTP Session 无效
- 清除 SecurityContextHolder
- 跳转到 /login-view?logout

但是,类似于配置登录功能,咱们可以进一步自定义退出功能:

```java
http.
...
                //提供系统退出支持,使用 WebSecurityConfigurerAdapter 会自动被应用
                .logout()
                //设置触发退出操作的URL (默认是 /logout ).
                .logoutUrl("/logout")
                //(3)退出之后跳转的URL。默认是 /login?logout
                .logoutSuccessUrl("/login-view?logout")
                //定制的 LogoutSuccessHandler ,用于实现用户退出成功时的处理。如果指定了这个选项那么logoutSuccessUrl() 的设置会被忽略
                .logoutSuccessHandler(logoutSuccessHandler)
                //添加一个 LogoutHandler ,用于实现用户退出时的清理工作.默认 SecurityContextLogoutHandler 会被添加为最后一个 LogoutHandler
                .addLogoutHandler(logoutHandler)
                //指定是否在退出时让 HttpSession 无效。 默认设置为 true。
                .invalidateHttpSession(true)
    			.logoutRequestMatcher(new AntPathRequestMatcher("/logout","GET"));
```

注意:如果让logout在GET请求下生效,必须关闭防止CSRF攻击csrf().disable()。如果开启了CSRF,必须使用post方式请求/logout

在CSRF功能开启的情况下使用GET 去logout,该方法为HTTPSecurity的方法

```
logoutRequestMatcher(new AntPathRequestMatcher(logoutUrl, “GET”))
```

此时指定了提交方法去限制logout

**logoutHandler**:

一般来说, LogoutHandler 的实现类被用来执行必要的清理,因而他们不应该抛出异常。

下面是Spring Security提供的一些实现:

- PersistentTokenBasedRememberMeServices 基于持久化token的RememberMe功能的相关清理
- TokenBasedRememberMeService 基于token的RememberMe功能的相关清理
- CookieClearingLogoutHandler 退出时Cookie的相关清理
- CsrfLogoutHandler 负责在退出时移除csrfToken
- SecurityContextLogoutHandler 退出时SecurityContext的相关清理

链式API提供了调用相应的 LogoutHandler 实现的快捷方式,比如deleteCookies()。

#### 授权

授权的方式包括 web授权和方法授权,web授权是通过 url拦截进行授权,方法授权是通过 方法拦截进行授权。他们都会调用accessDecisionManager进行授权决策,若为web授权则拦截器为FilterSecurityInterceptor;若为方法授权则拦截器为MethodSecurityInterceptor。如果同时通过web授权和方法授权则先执行web授权,再执行方法授权,最后决策通过,则允许访问资源,否则将禁止访问

![Qqfrng.png](https://s2.ax1x.com/2019/12/19/Qqfrng.png)



角色表:

在db/schame.sql中添加

```sql
CREATE TABLE `t_role` (
`id` varchar(32) NOT NULL,
`role_name` varchar(255) DEFAULT NULL,
`description` varchar(255) DEFAULT NULL,
`create_time` datetime DEFAULT NULL,
`update_time` datetime DEFAULT NULL,
`status` char(1) NOT NULL,
PRIMARY KEY (`id`)
);
CREATE TABLE `t_user_role` (
`id` int   NOT NULL,
`user_id` int NOT NULL,
`role_id` int NOT NULL,
`create_time` datetime DEFAULT NULL,
`creator` varchar(255) DEFAULT NULL,
PRIMARY KEY (`id`)
);

CREATE TABLE `t_permission` (
`id` int NOT NULL,
`code` varchar(32) NOT NULL COMMENT '权限标识符',
`description` varchar(64) DEFAULT NULL COMMENT '描述',
`url` varchar(128) DEFAULT NULL COMMENT '请求地址',
PRIMARY KEY (`id`)
);

CREATE TABLE `t_role_permission` (
`id` int   NOT NULL,
`role_id` int NOT NULL,
`permission_id` int NOT NULL,
PRIMARY KEY (`id`)
) ;

```

在db/data.sql添加

```sql
insert
into `t_role`(`id`, `role_name`, `description`, `create_time`, `update_time`, `status`)
values (1, '管理员', NULL, NULL, NULL, '');

insert
into `t_user_role`(`id`, `user_id`, `role_id`, `create_time`, `creator`)
values (1, 1, 1, NULL, NULL);

insert
into `t_permission`(`id`, `code`, `description`, `url`)
values (1, 'p1', '测试资源1', '/r/r1'),
       (2, 'p3', '测试资源2', '/r/r2');

insert
into `t_role_permission`(`id`, `role_id`, `permission_id`)
values (1, 1, 1),
       (2, 1, 2);
```

增加PermissionDto

```java

@Data
public class PermissionDto {
    private Integer id;
    private String code;
    private String description;
    private String url;

}
```

UserDao增加方法

```java
    // 根据用户id查询用户权限
    public List<String> findPermissionsByUserId(Integer userId) {
        String sql = "SELECT * FROM t_permission WHERE id IN(\n" +
                "SELECT permission_id FROM t_role_permission WHERE role_id IN(\n" +
                "\tSELECT role_id FROM t_user_role WHERE user_id = ? \n" +
                ")\n" +
                ")";
        List<PermissionDto> list = jdbcTemplate.query(sql, new Object[]{userId}, new
                BeanPropertyRowMapper<>(PermissionDto.class));
        List<String> permissions = new ArrayList<>();
        list.iterator().forEachRemaining(
                c -> permissions.add(c.getCode())
        );
        return permissions;

    }

```

修改SpringDataUserDetailsService

```java
   @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        System.out.println("username=" + s);

        //根据账号去数据库查询...
        UserDto user = userDao.getUserByUsername(s);
        if (user == null) {
            return null;
        }

        //查询用户权限
        List<String> permissions = userDao.findPermissionsByUserId(user.getId());
        String[] perarray = new String[permissions.size()];
        permissions.toArray(perarray);

        //创建userDetails
        UserDetails userDetails =
                User.withUsername(user.getFullname()).password(user.getPassword()).authorities(perarray).build();
        return userDetails;
    }
```

##### web授权

在上面例子中我们完成了认证拦截,并对`/r/**`下的某些资源进行简单的授权保护,但是我们想进行灵活的授权控制该怎么做呢?通过给 http.authorizeRequests() 添加多个子节点来定制需求到我们的URL,如下代码:

```java
    @Override
    protected void configure(HttpSecurity http) throws Exception {
//http.authorizeRequests() 方法有多个子节点,每个macher按照他们的声明顺序执行
        http
                .authorizeRequests()
                .antMatchers("/r/r1").hasAuthority("p1")
                .antMatchers("/r/r2").hasAuthority("p2")
            //指定了"/r/r3"URL,同时拥有p1和p2权限才能够访问
                .antMatchers("/r/r3").access("hasAuthority('p1') and hasAuthority('p2')")
            //指定了除了r1、r2、r3之外"/r/**"资源,同时通过身份认证就能够访问,这里使用SpEL(Spring ExpressionLanguage)表达式。。
                .antMatchers("/r/**").authenticated()
            //剩余的尚未匹配的资源,不做保护。
                .anyRequest()
                .permitAll()
                .and()
                //允许表单登录
                .formLogin()
}
```

注意:

**规则的顺序是重要的,更具体的规则应该先写**.现在以/ admin开始的所有内容都需要具有ADMIN角色的身份验证用户,即使是`/admin/login`路径(因为`/admin/login`已经被`/admin/**`规则匹配,因此第二个规则被忽略).

```
.antMatchers("/admin/**").hasRole("ADMIN")
.antMatchers("/admin/login").permitAll()
```

因此,登录页面的规则应该在`/admin/**`规则之前.例如.

```
.antMatchers("/admin/login").permitAll()
.antMatchers("/admin/**").hasRole("ADMIN")
```

保护URL常用的方法有:

- authenticated() 保护URL,需要用户登录
- permitAll() 指定URL无需保护,一般应用与静态资源文件
- hasRole(String role) 限制单个角色访问,角色将被增加 “ROLE_” .所以”ADMIN” 将和“ROLE_ADMIN”进行比较.
- hasAuthority(String authority) 限制单个权限访问
- hasAnyRole(String... roles)允许多个角色访问.
- hasAnyAuthority(String... authorities) 允许多个权限访问.
- access(String attribute) 该方法使用 SpEL表达式, 所以可以创建复杂的限制.
- hasIpAddress(String ipaddressExpression) 限制IP地址或子网

##### 方法授权

现在我们已经掌握了使用如何使用 http.authorizeRequests() 对web资源进行授权保护,从Spring Security2.0版本开始,它支持服务层方法的安全性的支持,我们可以在任何 @Configuration 实例上使用@EnableGlobalMethodSecurity 注释来启用基于注解的安全性。

以下内容将启用Spring Security的 @Secured 注释。

```java
@EnableGlobalMethodSecurity(securedEnabled = true)
public class MethodSecurityConfig {// ...}
```

然后向方法(在类或接口上)添加注解就会限制对该方法的访问。 Spring Security的原生注释支持为该方法定义了一组属性。 这些将被传递给AccessDecisionManager以供它作出实际的决定:

```java
public  class UserController  {
@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account readAccount(Long id){}
@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account[] findAccounts(){}
@Secured("ROLE_TELLER")
public Account post(Account account, double amount){}
}
```

以上配置标明readAccount、findAccounts方法可匿名访问,底层使用WebExpressionVoter投票器,可从
AffirmativeBased第23行代码跟踪。

post方法需要有TELLER角色才能访问,底层使用RoleVoter投票器。

使用如下代码可启用prePost注解的支持

```java
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig {
// ...
}
```

相应Java代码如下:

```java
public class UserController {
@PreAuthorize("isAnonymous()")
public Account readAccount(Long id){}
@PreAuthorize("isAnonymous()")
public Account[] findAccounts(){}
@PreAuthorize("hasAuthority('p_transfer') and hasAuthority('p_read_account')")
public Account post(Account account, double amount){}
}
```

以上配置标明readAccount、findAccounts方法可匿名访问,post方法需要同时拥有p_transfer和p_read_account权限才能访问,底层使用WebExpressionVoter投票器,可从AffirmativeBased第23行代码跟踪。



### 参考

1. [Spring Security PasswordEncoder 密码校验和密码加密流程](https://blog.csdn.net/hdfg159/article/details/90677404)
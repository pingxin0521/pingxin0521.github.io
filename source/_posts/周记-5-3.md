---
title: 第六周--SSL\TLS
date: 2019-12-19 18:18:59
tags:
 - 周记
categories:
 - 周记
---

#### 本周速记

**方法论**

本周来学习一下网站新技术

1. servlet 4
2. http 2与http 3 
3. serverless
4. SSL\TLS

<!--more-->

### SSL\TLS

**什么是SSL/TLS协议？**

SSL“安全套接层”协议，TLS“安全传输层”协议，都属于是加密协议，在其网络数据传输中起到保护隐私和数据的完整性。保证该网络传输的信息不会被未经授权的元素拦截或修改，从而确保只有合法的发送者和接收者才能完全访问并传输信息。

SSL（安全套接字层）是一种标准安全协议，用于在在线通信中建立Web服务器和浏览器之间的加密链接。

那TLS又是什么？Transport Layer Security (TLS)是SSL协议（Secure Sockets Layer）的升级版，TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。现在习惯将这个两个组合在一起称为SSL/TLS，只要知道它是一种用于加密的安全协议就好了。

![QHkIUA.png](https://s2.ax1x.com/2019/12/18/QHkIUA.png)

当网页期望用户提交机密数据（包括个人信息，密码或信用卡详细信息）时，网页应使用加密，这个时候web服务器就应该使用HTTPS协议来传输数据，它其实就是HTTP和SSL/TLS结合实现的；同样的还有SMTPS，它是加密的简单邮件通信协议，这样在传输邮件的时候就不是明文传输了，一般我们在设置邮箱服务器的时候可以选择是否勾选SSL/TLS的，如果没有勾选的话邮件就是明文传输了。

![QHC9d1.png](https://s2.ax1x.com/2019/12/18/QHC9d1.png)

**SSL/TLS有什么作用？**

这里参考了网上的一些观点：

 不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。

- 窃听风险（eavesdropping）：第三方可以获知通信内容。
- 篡改风险（tampering）：第三方可以修改通信内容。
- 冒充风险（pretending）：第三方可以冒充他人身份参与通信。

SSL/TLS协议是为了解决这三大风险而设计的，希望达到

- 所有信息都是加密传播，第三方无法窃听。
- 具有校验机制，一旦被篡改，通信双方会立刻发现。
- 配备身份证书，防止身份被冒充。

#### SSL证书

先说明一下：SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

在讲SSL/TLS的工作流程之前，先要说明一下SSL证书这个东西，来思考一个问题：

基本思路里面的公钥加密法，如何保证公钥不被篡改？答案是：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。

那SSL证书是什么？怎么保证它是可信任的？

SSL 证书就是遵守 SSL协议，由`受信任的数字证书颁发机构CA`，在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能。

怎么才能申请到SSL证书？或者说影响该证书申请的因素有哪些？

影响证书的因素：申请中提到的企业/公司是否有合法身份以及申请人是否控制证书​​中提到的域名。

**先来看看数字证书都有哪些内容**

1. Issuer--证书的发布机构
   发布证书的机构，指明证书是哪个公司创建的（并不是指使用证书的公司）。出了问题具体的颁发机构是要负责的
2. Valid from，Valid to--证书的有效期
   证书的使用期限。过了这个期限证书就会作废，不能使用。

3. Public key--公钥
   刚开始的时候介绍过公钥的概念，用于对消息加密的。

4. Subject--主题
   证书是颁发给谁了，一般是个人或公司名称或机构名称或公司网站的网址。

5. Signature algorithm--签名所使用的算法
   数字证书的数字签名所使用的加密算法，根据这个算法可以对指纹解密。指纹加密的结果就是数字签名。
6. Thumbprint，Thumbprint algorithm--指纹以及指纹算法（一种HASH算法）
   指纹和指纹算法会使用证书机构的私钥加密后和证书放在一起。主要用来保证证书的完整性，确保证书没有修改过。使用者在打开证书时根据指纹算法计算证书的hash值，和刚开始的值一样，则表示没有被修改过。

**申请到证书的步骤是怎么样的？**

1. 制作CSR文件
    CSR就是Certificate Signing Request证书请求文件。这个文件是由申请人制作，在制作的同时，系统会产生2个密钥，一个是公钥就是这个CSR文件，另外一个是私钥，存放在服务器上。要制作CSR文件，申请人可以参考WEB SERVER的文档，一般APACHE等，使用OPENSSL命令行来生成KEY+CSR2个文件。
2. CA认证
    域名认证，一般通过对管理员邮箱认证的方式，这种方式认证速度快，但是签发的证书中没有企业的名称；
    企业文档认证，需要提供企业的营业执照。一般需要3-5个工作日。 也有需要同时认证以上2种方式的证书，叫EV证书，这种证书可以使IE7以上的浏览器地址栏变成绿色，所以认证也最严格。
3. 证书的安装
    在收到CA的证书后，可以将证书部署上服务器，一般APACHE文件直接将KEY+CER复制到文件上，然后修改HTTPD.CONF文件。

注意：证书分为单域证书、通配符证书、多域证书、扩展验证证书，申请证书的时候要看是申请那一类了。

证书在什么情况下被使用？是怎么使用的？

1. 我们在点击web站点的时候，比如输入https://www.domain.com ，进行dns解析后web服务器进行响应，web服务器自动传送https://www.domain.com 网站的数字证书给用户，上文说到了，证书是安装在web服务器里面的，证书里面含有公钥，所以这里相当于服务器把公钥传递给了客户端，当然服务器那里还有自己的私钥，具体过程如下图。

   ![QH9ZEq.png](https://s2.ax1x.com/2019/12/18/QH9ZEq.png)

2. 客户端是使用浏览器进行操作的，不同版本的浏览器自动产生40位或128位的会话密钥，用于对交易的信息进行加密，也就是说客户向服务器索要公钥后还要与服务器协商生成一个“会话秘钥”。

    如下图，第三步获取到crt证书后，需要检验证书是否有效，如果无效则会显示警告信息，有效则生成一个随机数，即会话密钥，这个会话密钥再使用crt里面的公钥加密后传输给web服务器，服务器使用自己的私钥进行解密，获取浏览器生成的随机“会话密钥”，现在客户端服务器都知道这个“会话密钥”了，后续通信都用这个会话密钥进行加密通信了。

   ![QH9t56.png](https://s2.ax1x.com/2019/12/18/QH9t56.png)

#### SSL是怎么工作的？

简单概括就是：

1. 客户端向服务器端索要并验证公钥。

2. 双方协商生成"对话密钥"。

3. 双方采用"对话密钥"进行加密通信。

   具体是怎么协商生成“会话密钥”的，上文提到了，这里还有一个疑问，为什么不直接使用crt证书里面的公钥进行加密，再使用服务器里面的私钥进行解密呢？更何况服务器里面的私钥也可以进行加密，crt里面的证书再进行解密即可。

   原因为：每一次对话（session），客户端和服务器端都生成一个"会话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥加密是非对称加密，比较耗时间，所以证书里面的公钥只用于加密"会话密钥"本身，这样就减少了加密运算的消耗时间。

那么会话密钥和公钥有什么区别呢？

1. 会话加密是非对称加密，服务器和客户端协商后生产一个会话密钥，所以服务器和客户端是共享一个相同的密钥的，当然不是服务器和所有客户端共享一个相同的密钥，而是每个客户端都有自己的密钥，比较这个会话密钥是客户端（浏览器）随机生成的，所以服务器需要维护多个密钥。
2. 公钥是采用的非对称加密，服务器把证书（公钥）下发给每个用户正在使用的客户端（浏览器），所以是客户端共享公钥，服务器只掌控私钥，服务端与客户端密钥是一个1对多的关系，客户端发送的加密信息只能服务端解密，安全级别也更高，但是由于非对称加密太慢了，才采用了不同客户端不同密钥的“会话密钥”来解决这个问题。

具体TLS/SSL里面涉及到的非对称加密和对称加密的区别以及算法如下图所示：

![QHp5Ax.png](https://s2.ax1x.com/2019/12/18/QHp5Ax.png)

总的来说，客户端（浏览器）与web服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容，会话密钥即图中的随机数。

#### 通信步骤

![1RwYIP.png](https://s2.ax1x.com/2020/02/08/1RwYIP.png)

1. 步骤 1: 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件(Cipher Suite)列表(所使用的加密算法及密钥长度等)。
2. 步骤 2: 服务器可进行 SSL 通信时,会以 Server Hello 报文作为应答。和客户端一样,在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。
3. 步骤 3: 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。
4. 步骤 4: 最后服务器发送 Server Hello Done 报文通知客户端,最初阶段的 SSL 握手协商部分结束。
5. 步骤 5: SSL 第一次握手结束之后,客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-mastersecret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。
6. 步骤 6: 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器,在此报文之后的通信会采用 Pre-master secret 密钥加密。
7. 步骤 7: 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功,要以服务器是否能够正确解密该报文作为判定标准。
8. 步骤 8: 服务器同样发送 Change Cipher Spec 报文。
9. 步骤 9: 服务器同样发送 Finished 报文。
10. 步骤 10: 服务器和客户端的 Finished 报文交换完毕之后,SSL 连接就算建立完成。当然,通信会受到 SSL 的保护。从此处开始进行应用层协议的通信,即发送 HTTP 请求。
11. 步骤 11: 应用层协议通信,即发送 HTTP 响应。
12. 步骤 12: 最后由客户端断开连接。断开连接时,发送 close_notify 报文。上图做了一些省略,这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。

在以上流程中,应用层发送数据时会附加一种叫做 MAC(MessageAuthentication Code)的报文摘要。MAC 能够查知报文是否遭到篡改,从而保护报文的完整性。

下面是对整个流程的图解。图中说明了从仅使用服务器端的公开密钥证书(服务器证书)建立 HTTPS 通信的整个过程。

![1RwsZn.png](https://s2.ax1x.com/2020/02/08/1RwsZn.png)



#### TLS 1.3

TLS 1.3 协议针对安全强化及效率提升等方面进行了大量修改，相继推出 20 多个草案版本，即将完成最终的标准化。标准完成后，OpenSSL 组织将推出 OpenSSL 1.1.1 版本，对 TLS1.3 协议标准提供支持。

在谈 TLS 1.3 之前，我们先来看下 TLS 1.2 的工作模式，如图所示是 TLS 1.2 客户端和服务端交互的过程，如图所示:

![QHFy6S.png](https://s2.ax1x.com/2019/12/18/QHFy6S.png)

以 ECDHE 密钥交换算法为例，TLS1.2 协议完整的SSL握手过程如下:

- 第一步，首先客户端发送 ClientHello 消息，该消息中主要包括客户端支持的协议版本、加密套件列表及握手过程需要用到的 ECC 扩展信息；
- 第二步，服务端回复 ServerHello，包含选定的加密套件和 ECC 扩展；发送证书给客户端；选用客户端提供的参数生成 ECDH 临时公钥，同时回复 ServerKeyExchange 消息；
- 第三步，客户端接收 ServerKeyExchange 后，使用证书公钥进行签名验证，获取服务器端的 ECDH 临时公钥，生成会话所需要的共享密钥；生成 ECDH 临时公钥和 ClientKeyExchange 消息发送给服务端；
- 第四步，服务器处理 ClientKeyExchange 消息，获取客户端 ECDH 临时公钥；服务器生成会话所需要的共享密钥；发送密钥协商完成消息给客户端；
- 第五步，双方使用生成的共享密钥对消息加密传输，保证消息安全。

可以看到，TLS1.2 协议中需要加密套件协商、密钥信息交换、ChangeCipherSpec 协议通告等过程，需要消耗 2-RTT 的握手时间，这也是造成 HTTPS 协议慢的一个重要原因之一。

我们来看下 TLS 1.3 的的交互过程，如图所示:

![QHFRTs.png](https://s2.ax1x.com/2019/12/18/QHFRTs.png)

在 TLS 1.3 中，客户端首先不仅发送 ClientHello 支持的密码列表，而且还猜测服务器将选择哪种密钥协商算法，并发送密钥共享,这可以节省很大一部分的开销，从而提高了速度。

TLS1.3 提供 1-RTT 的握手机制，还是以 ECDHE 密钥交换过程为例，握手过程如下。将客户端发送 ECDH 临时公钥的过程提前到 ClientHello，同时删除了 ChangeCipherSpec 协议简化握手过程，使第一次握手时只需要 1-RTT，来看具体的流程:

- 客户端发送 ClientHello 消息，该消息主要包括客户端支持的协议版本、DH 密钥交换参数列表 KeyShare；
- 服务端回复 ServerHello，包含选定的加密套件；发送证书给客户端；使用证书对应的私钥对握手消息签名，将结果发送给客户端；选用客户端提供的参数生成 ECDH 临时公钥，结合选定的 DH 参数计算出用于加密 HTTP 消息的共享密钥；服务端生成的临时公钥通过 KeyShare 消息发送给客户端；
- 客户端接收到 KeyShare 消息后，使用证书公钥进行签名验证，获取服务器端的 ECDH 临时公钥，生成会话所需要的共享密钥；
- 双方使用生成的共享密钥对消息加密传输，保证消息安全。

如果客户端之前已经连接，我们有办法在 1.2 中进行 1-RTT 连接，而在 TLS 1.3 中允许我们执行 0-RTT 连接，如图所示:

![QHki0H.png](https://s2.ax1x.com/2019/12/18/QHki0H.png)

需要说明的是，如需查看 TLS 1.3 的报文，需要使用 2.5 版本的 wireshark

**TLS 1.3 的新特性**

1. 废除不支持前向安全性的 RSA 和 DH 密钥交换算法；

2. MAC 只使用 AEAD 算法；

3. 禁用 RC4 / SHA1 等不安全的算法；

4. 加密握手消息；

5. 减少往返时延 RTT，支持 0-RTT；

6. 兼容中间设备 TLS 1.2；

7. 加密握手消息：

   TLS1.2 及之前版本的协议中各种扩展信息在 ServerHello 中以明文方式发送，但是 TLS 1.3 协议要求 ServerHello 消息之后的握手信息都需要加密。

TLS 1.3 在 之前版本的基础上删除了那些不安全的加密算法，这些加密算法包括：

- RSA 密钥传输 —— 不支持前向安全性
- CBC 模式密码 —— 易受 BEAST 和 Lucky 13 攻击
- RC4 流密码 —— 在 HTTPS 中使用并不安全
- SHA-1 哈希函数 —— 建议以  SHA-2  取而代之
- 任意 Diffie-Hellman 组——  CVE-2016-0701 漏洞
- 输出密码 —— 易受 FREAK 和 LogJam 攻击

LS 1.3 目前支持以下加密套件：

```text
TLS13-AES128-GCM-SHA256
TLS13-AES256-GCM-SHA384
TLS13-CHACHA20-POLY1305-SHA256
TLS13-AES128-CCM-SHA256
TLS13-AES128-CCM-8-SHA256 
```

新的加密套件只能在 TLS 1.3  中使用，旧的套件不能用于 TLS 1.3 连接。总之，TLS 1.3 相比老版本的 TLS 协议将会更加安全，这也代表着互联网安全的一大进步。

#### 开启TLS 1.3

开启 TLS1.3，需要浏览器以及服务端都支持 TLS 1.3，才可以使用 TLS 1.3 进行通信。

目前最新的 Chrome 和 Firefox 都已支持 TLS 1.3，但需要手动开启：

Chrome 中需要将 chrome://flags/ 中的 Maximum TLS version enabled 改为 TLS 1.3（Chrome 62 中需要将 TLS 1.3 改为 Enabled (Draft)

Firefox 中，将 about:config 中的 security.tls.version.max 改为 4；

#### HTTPS

HTTPS实际上就是HTTP穿上了SSL/TLS的外套，我们都知道HTTP属于应用层的协议，是离程序员比较近的，而SSL（安全套接字）与TLS（运输层安全）都属于运输层协议。其实SSL与TLS都是上个世纪的产物，最新版本的TLS建立在SSL 3.0协议规范之上。

**HTTPS的验证流程**

1. 客户端发起一个http请求，连接到服务器的443端口。

2. 服务端把自己的信息以数字证书的形式返回给客户端（证书内容有密钥公钥，网站地址，证书颁发机构，失效日期等）。证书中有一个公钥来加密信息，私钥由服务器持有。

3. 验证证书的合法性

   客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）。

4. 生成随机密码（RSA签名）

   如果验证通过，或用户接受了不受信任的证书，浏览器就会生成一个随机的对称密钥（session key）并用公钥加密，让服务端用私钥解密，解密后就用这个对称密钥进行传输了，并且能够说明服务端确实是私钥的持有者。

5. 生成对称加密算法

   验证完服务端身份后，客户端生成一个对称加密的算法和对应密钥，以公钥加密之后发送给服务端。此时被黑客截获也没用，因为只有服务端的私钥才可以对其进行解密。之后客户端与服务端可以用这个对称加密算法来加密和解密通信内容了。



### 参考

1. [SSL与TLS的区别以及介绍](https://kb.cnblogs.com/page/197396/)

2. [浅谈SSL/TLS工作原理](https://zhuanlan.zhihu.com/p/36981565)

3. [TLS1.3 VS TLS1.2，让你明白TLS1.3的强大](https://zhuanlan.zhihu.com/p/44980381)

4. [让Nginx快速支持TLS1.3协议](https://mp.weixin.qq.com/s/cscowtiUyAraker_CXjDQQ)

5. [HTTPS 之 SSL/TLS 握手协议（Handshake Protocol）全过程解析](https://www.jianshu.com/p/07a1e362e1ba)

   
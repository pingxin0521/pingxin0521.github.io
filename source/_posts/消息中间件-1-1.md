---
title: 消息中间件--入门
date: 2019-06-03  21:18:59
tags:
 - 消息中间件
categories:
 - 消息中间件
---

### 基础概念

Java 消息服务（Java Message Service，JMS）应用程序接口是一个Java 平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java 消息服务是一个与具体平台无关的 API，绝大多数 MOM 提供商都对 JMS 提供支持。

### 消息队列

**消息队列** 已经逐渐成为企业应用系统 **内部通信** 的核心手段。它具有 **低耦合**、**可靠投递**、**广播**、**流量控制**、**最终一致性** 等一系列功能。

当前使用较多的 **消息队列** 有 RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMQ 等，

而部分 **数据库** 如 Redis、MySQL 以及 phxsql 也可实现消息队列的功能。

<!--more-->

#### 概述

**消息队列** 是指利用 **高效可靠** 的 **消息传递机制** 进行与平台无关的 **数据交流**，并基于 **数据通信**来进行分布式系统的集成。

![8.jpeg](https://i.loli.net/2019/06/07/5cfa01e0f1ab753308.jpeg)

通过提供 **消息传递** 和 **消息排队** 模型，它可以在 **分布式环境** 下提供 **应用解耦**、**弹性伸缩**、**冗余存储**、**流量削峰**、**异步通信**、**数据同步** 等等功能，其作为 **分布式系统架构** 中的一个重要组件，有着举足轻重的地位。

#### 特点

**采用异步处理模式**

**消息发送者** 可以发送一个消息而无须等待响应。**消息发送者** 将消息发送到一条 **虚拟的通道**（**主题** 或 **队列**）上，**消息接收者** 则 **订阅** 或是 **监听** 该通道。一条信息可能最终转发给 **一个或多个** 消息接收者，这些接收者都无需对 **消息发送者** 做出 **同步回应**。整个过程都是 **异步的**。

**应用系统之间解耦合**

主要体现在如下两点：

1. 发送者和接受者不必了解对方、只需要 **确认消息**；
2. 发送者和接受者 **不必同时在线**。

比如在线交易系统为了保证数据的 **最终一致**，在 **支付系统** 处理完成后会把 **支付结果** 放到 **消息中间件** 里，通知 **订单系统** 修改 **订单支付状态**。两个系统是通过消息中间件解耦的。

#### 传递服务模型

消息队列的 **传递服务模型** 如下图所示：

![9.jpeg](https://i.loli.net/2019/06/07/5cfa022361f0080954.jpeg)

#### 传输模式

**点对点模型**

**点对点模型** 用于 **消息生产者** 和 **消息消费者** 之间 **点到点** 的通信。消息生产者将消息发送到由某个名字标识的特定消费者。这个名字实际上对于消费服务中的一个 **队列**（Queue），在消息传递给消费者之前它被 **存储** 在这个队列中。**队列消息** 可以放在 **内存** 中也可以 **持久化**，以保证在消息服务出现故障时仍然能够传递消息。

传统的点对点消息中间件通常由 **消息队列服务**、**消息传递服务**、**消息队列** 和 **消息应用程序接口** API 组成，其典型的结构如下图所示。

![10.jpeg](https://i.loli.net/2019/06/07/5cfa0254ccdd964488.jpeg)

**特点：**

1. 每个消息只用一个消费者；
2. 发送者和接受者没有时间依赖；
3. 接受者确认消息接受和处理成功。

**示意图如下所示：**

![11.jpeg](https://i.loli.net/2019/06/07/5cfa02759156298227.jpeg)

**发布/订阅模型（Pub/Sub）**

**发布者/订阅者** 模型支持向一个特定的 **消息主题** 生产消息。0 或 **多个订阅者** 可能对接收来自 **特定消息主题** 的消息感兴趣。

在这种模型下，发布者和订阅者彼此不知道对方，就好比是匿名公告板。这种模式被概况为：多个消费者可以获得消息，在 **发布者** 和 **订阅者** 之间存在 **时间依赖性**。发布者需要建立一个 **订阅**（subscription），以便消费者能够订阅。**订阅者** 必须保持 **持续的活动状态** 并 **接收消息**。

在这种情况下，在订阅者 **未连接时**，发布的消息将在订阅者 **重新连接** 时 **重新发布**，如下图所示：

![12.jpeg](https://i.loli.net/2019/06/07/5cfa029c51a1d66237.jpeg)

**特性：**

1. 每个消息可以有多个订阅者；
2. 客户端只有订阅后才能接收到消息；
3. 持久订阅和非持久订阅。

**注意**：

- 发布者和订阅者有时间依赖：接受者和发布者只有建立订阅关系才能收到消息；
- 持久订阅：订阅关系建立后，消息就不会消失，不管订阅者是否都在线；
- 非持久订阅：订阅者为了接受消息，必须一直在线。 当只有一个订阅者时约等于点对点模式

#### 消息队列应用场景

当你需要使用 消息队列 时，首先需要考虑它的必要性。可以使用消息队列的场景有很多，最常用的几种，是做 应用程序松耦合、异步处理模式、发布与订阅、最终一致性、错峰流控 和 日志缓冲 等。反之，如果需要 强一致性，关注业务逻辑的处理结果，则使用 RPC 显得更为合适。

1. 异步处理

   非核心 流程 异步化，减少系统 响应时间，提高 吞吐量。例如：短信通知、终端状态推送、App 推送、用户注册 等。

   消息队列 一般都内置了 高效的通信机制，因此也可以用于单纯的消息通讯，比如实现 点对点消息队列 或者 聊天室 等。

2. 系统解耦

   系统之间不是 强耦合的，消息接受者 可以随意增加，而不需要修改 消息发送者的代码。消息发送者 的成功不依赖 消息接受者（比如：有些银行接口不稳定，但调用方并不需要依赖这些接口）。

   不强依赖 于非本系统的核心流程，对于 非核心流程，可以放到消息队列中让 消息消费者 去按需消费，而 不影响核心主流程。

3. 最终一致性

   最终一致性 不是 消息队列 的必备特性，但确实可以依靠 消息队列 来做 最终一致性 的事情。

   先写消息再操作，确保操作完成后再修改消息状态。定时任务补偿机制 实现消息 可靠发送接收、业务操作的可靠执行，要注意 消息重复 与 幂等设计。

   所有不保证 100% 不丢消息 的消息队列，理论上无法实现 最终一致性。

   像 Kafka 一类的设计，在设计层面上就有 丢消息 的可能（比如 定时刷盘，如果掉电就会丢消息）。哪怕只丢千分之一的消息，业务也必须用其他的手段来保证结果正确。

4. 广播

   生产者/消费者 模式，只需要关心消息是否 送达队列，至于谁希望订阅和需要消费，是 下游的事情，无疑极大地减少了开发和联调的工作量。

   ![2.jpeg](https://i.loli.net/2019/06/07/5cfa0efabb79d14303.jpeg)

5.  流量削峰和流控

   当 上下游系统 处理能力存在差距的时候，利用 消息队列 做一个通用的 “漏斗”，进行 限流控制。在下游有能力处理的时候，再进行分发。

6. 日志处理

   将消息队列用在 日志处理 中，比如 Kafka 的应用，解决 海量日志 传输和缓冲的问题。

7. 消息通讯

   消息队列一般都内置了 高效的通信机制，因此也可以用于单纯的 消息通讯，比如实现 点对点消息队列 或者 聊天室 等。

 **为什么使用消息队列？**

其实这个话题也是面试官经常问询的问题，问问你消息队列都有哪些使用场景，然后你项目里具体是什么场景，说说你在这个场景里用消息队列是什么

期望的一个回答是说，你们公司有个什么业务场景，这个业务场景有个什么技术挑战，如果不用MQ可能会很麻烦，但是你现在用了MQ之后带给了你很多的好处

现在你可以下想想你如何回答上述问题，想不起来？  好吧我这里先介绍几个常见使用场景，提醒下。。。

**解耦**：现场画个图来说明一下，

![2.png](https://i.loli.net/2019/06/07/5cfa0e104181268129.png)

A系统发送个数据到BCD三个系统，接口调用发送，那如果E系统也要这个数据呢？那如果C系统现在不需要了呢？现在A系统又要发送第二种数据了呢？A系统负责人濒临崩溃中。。。再来点更加崩溃的事儿，A系统要时时刻刻考虑BCDE四个系统如果挂了咋办？我要不要重发？我要不要把消息存起来？头发都白了啊。。。

![3.png](https://i.loli.net/2019/06/07/5cfa0e1158ec759961.png)

这是你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用MQ给他异步化解耦，也是可以的，你就需要去考虑在你的项目里（做过微服务项目的同学这里是不是考虑下  消息总线 搭配Rabbitmq 做解耦 用于广播配置文件的更改或者服务间的通讯？），是不是可以运用这个MQ去进行系统的解耦。在简历中体现出来这块东西，用MQ作解耦。

**异步**：现场画个图来说明一下，

![4.png](https://i.loli.net/2019/06/07/5cfa0e11aa51d50894.png)

![5.png](https://i.loli.net/2019/06/07/5cfa0e11059d945831.png)

A系统接收一个请求，需要在自己本地写库，还需要在BCD三个系统写库，自己本地写库要3ms，BCD三个系统分别写库要300ms、450ms、200ms。最终请求总延时是3 + 300 + 450 + 200 = 953ms，接近1s，用户感觉搞个什么东西，慢死了慢死了。

更改为 异步后当消息发送到消息队列  自行让对应系统进行消费即可  所以给用户的体验为20 + 5 = 25ms  ,快 好快！

**削峰**：每天0点到11点，A系统风平浪静，每秒并发请求数量就100个。结果每次一到11点~1点，每秒并发请求数量突然会暴增到1万条。但是系统最大的处理能力就只能是每秒钟处理1000个请求啊。。。尴尬了，系统会死。。。

![6.png](https://i.loli.net/2019/06/07/5cfa0e118bdc399569.png)

![7.png](https://i.loli.net/2019/06/07/5cfa0e11432c275288.png)



**缺点**

![1.png](https://i.loli.net/2019/06/07/5cfa0d42cfd2438303.png)

**系统可用性降低**：系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好了，人ABCD四个系统好好的，没啥问题，你偏加个MQ进来，万一MQ挂了咋整？MQ挂了，整套系统崩溃了，你不就完了么。

**系统复杂性提高**：硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已

**一致性问题**：A系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，咋整？你这数据就不一致了。

所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，最好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了10倍。但是关键时刻，用，还是得用的。。。



#### 应用场景举例

**异步处理**

场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种 1.串行的方式；2.并行方式

1. 串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端

   ![1.png](https://i.loli.net/2019/06/07/5cf9fb11717fa14948.png)

2. 并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间

   ![2.png](https://i.loli.net/2019/06/07/5cf9fb2c7eb4380694.png)

假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。

因为CPU在单位时间内处理的请求数是一定的，假设CPU1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求量是10次（1000/100）

> 如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？

引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下：

![3.png](https://i.loli.net/2019/06/07/5cf9fb68f39a168462.png)

按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20QPS。比串行提高了3倍，比并行提高了两倍

**应用解耦**

- 系统之间不是 强耦合的，消息接受者 可以随意增加，而不需要修改 消息发送者的代码。消息发送者 的成功不依赖 消息接受者（比如：有些银行接口不稳定，但调用方并不需要依赖这些接口）。
- 不强依赖 于非本系统的核心流程，对于 非核心流程，可以放到消息队列中让 消息消费者 去按需消费，而 不影响核心主流程。

场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图

![4.png](https://i.loli.net/2019/06/07/5cf9fbdabee3336325.png)

传统模式的缺点：

- 假如库存系统无法访问，则订单减库存将失败，从而导致订单失败
- 订单系统与库存系统耦合

如何解决以上问题呢？引入应用消息队列后的方案，如下图：

![5.png](https://i.loli.net/2019/06/07/5cf9fbdad73e873789.png)

- 订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功
- 库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作

假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦

**流量削锋**

流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛

应用场景：用户在支付系统成功结账后，订单系统会通过短信系统向用户推送扣费通知。 **短信系统** 可能由于 **短板效应**，速度卡在 **网关** 上（每秒几百次请求），跟 **前端的并发量** 不是一个数量级。 于是，就造成 **支付系统** 和 **短信系统** 的处理能力出现差异化。

然而用户晚上个半分钟左右收到短信，一般是不会有太大问题的。如果没有消息队列，两个系统之间通过 **协商**、**滑动窗口** 等复杂的方案也不是说不能实现。但 **系统复杂性** 指数级增长，势必在 **上游** 或者 **下游** 做 **存储**，并且要处理 **定时**、**拥塞** 等一系列问题。而且每当有 **处理能力有差距** 的时候，都需要 **单独** 开发一套逻辑来维护这套逻辑。

所以，利用中间系统转储两个系统的通信内容，并在下游系统有能力处理这些消息的时候，再处理这些消息，是一套相对较通用的方式。

- 可以控制活动的人数
- 可以缓解短时间内高流量压垮应用

![6.png](https://i.loli.net/2019/06/07/5cf9fc8866cb772192.png)

- 用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面
- 秒杀业务根据消息队列中的请求信息，再做后续处理

**日志处理**

日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下

![7.png](https://i.loli.net/2019/06/07/5cf9fca1a65d375830.png)

- 日志采集客户端，负责日志数据采集，定时写受写入Kafka队列
- Kafka消息队列，负责日志数据的接收，存储和转发
- 日志处理应用：订阅并消费kafka队列中的日志数据

以下是新浪kafka日志处理应用案例：转自（http://cloud.51cto.com/art/201507/484338.htm）

![8.png](https://i.loli.net/2019/06/07/5cf9fcc05f7b338364.png)



1. Kafka：接收用户日志的消息队列

2. Logstash：做日志解析，统一成JSON输出给Elasticsearch

3. Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能

4. Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因

**消息通讯**

消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等

点对点通讯：

![9.png](https://i.loli.net/2019/06/07/5cf9fd13b1ac839535.png)

客户端A和客户端B使用同一队列，进行消息通讯。

聊天室通讯：

![10.png](https://i.loli.net/2019/06/07/5cf9fd13c9bb116332.png)

客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。

以上实际是消息队列的两种消息模式，点对点或发布订阅模式。模型为示意图，供参考。

#### 消息中间件示例

**电商系统**

![1.jpeg](https://i.loli.net/2019/06/07/5cf9fdf34348c38784.jpeg)

消息队列采用高可用，可持久化的消息中间件。比如Active MQ，Rabbit MQ，Rocket Mq。

1. 应用将主干逻辑处理完成后，写入消息队列。消息发送是否成功可以开启消息的确认模式。（消息队列返回消息接收成功状态后，应用再返回，这样保障消息的完整性）

2. 已经有很多人总结了这5种场景下的RabbitMQ实际应用。

   推荐阅读：猛击[这里](http://www.cnblogs.com/sa扩展流程（发短信，配送处理）订阅队列消息。采用推或拉的方式获取消息并处理。

3. 消息将应用解耦的同时，带来了数据一致性问题，可以采用最终一致性方式解决。比如主数据写入数据库，扩展应用根据消息队列，并结合数据库方式实现基于消息队列的后续处理。

**日志收集系统**

![2.jpeg](https://i.loli.net/2019/06/07/5cf9fdf365de690876.jpeg)

分为Zookeeper注册中心，日志收集客户端，Kafka集群和Storm集群（OtherApp）四部分组成。

- Zookeeper注册中心，提出负载均衡和地址查找服务
- 日志收集客户端，用于采集应用系统的日志，并将数据推送到kafka队列
- Kafka集群：接收，路由，存储，转发等消息处理

- Storm集群：与OtherApp处于同一级别，采用拉的方式消费队列中的数据

#### 推拉模型

1. Push推消息模型

   **消息生产者** 将消息发送给 **消息队列**，**消息队列** 又将消息推给 **消息消费者**。

2. Pull拉消息模型

   **消费者** 请求 **消息队列** 接受消息，**消息生产者** 从 **消息队列** 中拉该消息。

两种类型的区别

![14.jpeg](https://i.loli.net/2019/06/07/5cfa04989a0ca80290.jpeg)

#### 消息中间件常用协议

**AMQP协议**

AMQP即Advanced Message Queuing  Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。

优点：可靠、通用

 **MQTT协议**

MQTT（Message Queuing Telemetry  Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器（比如通过Twitter让房屋联网）的通信协议。

 优点：格式简洁、占用带宽小、移动端通信、PUSH、嵌入式系统

**STOMP协议**

STOMP（Streaming Text Orientated Message  Protocol）是流文本定向消息协议，是一种为MOM(Message Oriented  Middleware，面向消息的中间件)设计的简单文本协议。STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。

优点：命令模式（非topic\queue模式）

**XMPP协议**

XMPP（可扩展消息处理现场协议，Extensible Messaging and Presence  Protocol）是基于可扩展标记语言（XML）的协议，多用于即时消息（IM）以及在线现场探测。适用于服务器之间的准即时操作。核心是基于XML流传输，这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息，即使其操作系统和浏览器不同。

优点：通用公开、兼容性强、可扩展、安全性高，但XML编码格式占用带宽大

**其他基于TCP/IP自定义的协议**

有些特殊框架（如：redis、kafka、zeroMq等）根据自身需要未严格遵循MQ规范，而是基于TCP\IP自行封装了一套协议，通过网络socket接口进行传输，实现了MQ的功能。

### 常用消息队列

本部分主要介绍四种常用的消息队列（ActiveMQ / RabbitMQ / RocketMQ / Kafka）的主要特性、优点、缺点。 

#### ActiveMQ

**ActiveMQ 是由 Apache 出品，**ActiveMQ 是一个完全支持JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现。它非常快速，支持 **多种语言的客户端** 和 **协议**，而且可以非常容易的嵌入到企业的应用环境中，并有许多高级功能。

![3.jpeg](https://i.loli.net/2019/06/07/5cf9ffd51eab250588.jpeg)

 **主要特性**

1. **服从JMS规范**：JMS 规范提供了良好的标准和保证，包括：**同步** 或 **异步** 的消息分发，一次和仅一次的消息分发，**消息接收** 和 **订阅** 等等。遵从 JMS 规范的好处在于，不论使用什么 JMS 实现提供者，这些基础特性都是可用的；
2. **连接灵活性**：ActiveMQ 提供了广泛的 **连接协议**，支持的协议有：HTTP/S，IP **多播**，SSL，TCP，UDP 等等。对众多协议的支持让 ActiveMQ 拥有了很好的灵活性；
3. **支持的协议种类多**：OpenWire、STOMP、REST、XMPP、AMQP；
4. **持久化插件和安全插件**：ActiveMQ 提供了 **多种持久化** 选择。而且，ActiveMQ 的安全性也可以完全依据用户需求进行 **自定义鉴权** 和 **授权**；
5. **支持的客户端语言种类多**：除了 Java 之外，还有：C/C++，.NET，Perl，PHP，Python，Ruby；
6. **代理集群**：多个 ActiveMQ **代理** 可以组成一个 **集群** 来提供服务；
7. **异常简单的管理**：ActiveMQ 是以开发者思维被设计的。所以，它并不需要专门的管理员，因为它提供了简单又使用的管理特性。有很多中方法可以 **监控** ActiveMQ 不同层面的数据，包括使用在 JConsole 或者在 ActiveMQ 的 Web Console 中使用 JMX。通过处理 JMX 的告警消息，通过使用 **命令行脚本**，甚至可以通过监控各种类型的 **日志**。

**部署环境**

ActiveMQ 可以运行在 Java 语言所支持的平台之上。使用 ActiveMQ 需要：

- Java JDK
- ActiveMQ 安装包

 **优点**

1. **跨平台** (JAVA 编写与平台无关，ActiveMQ 几乎可以运行在任何的 JVM 上)；
2. 可以用 JDBC：可以将 **数据持久化** 到数据库。虽然使用 JDBC 会降低 ActiveMQ 的性能，但是数据库一直都是开发人员最熟悉的存储介质；
3. 支持 JMS 规范：支持 JMS 规范提供的 **统一接口**;
4. 支持 **自动重连** 和 **错误重试机制**；
5. 有安全机制：支持基于 shiro，jaas 等多种 **安全配置机制**，可以对 Queue/Topic 进行 **认证和授权**；
6. 监控完善：拥有完善的 **监控**，包括 Web Console，JMX，Shell 命令行，Jolokia 的 RESTful API；
7. 界面友善：提供的 Web Console 可以满足大部分情况，还有很多 **第三方的组件** 可以使用，比如 hawtio；

 **缺点**

1. 社区活跃度不及 RabbitMQ 高；
2. 根据其他用户反馈，会出莫名其妙的问题，会 **丢失消息**；
3. 目前重心放到 activemq 6.0 产品 Apollo，对 5.x 的维护较少；
4. 不适合用于 **上千个队列** 的应用场景；

#### RabbitMQ

**RabbitMQ 于 2007 年发布，是一个在 AMQP (高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。**

![4.jpeg](https://i.loli.net/2019/06/07/5cf9ffd4a2d0212535.jpeg)

**主要特性**

1. **可靠性**：提供了多种技术可以让你在 **性能** 和 **可靠性** 之间进行 **权衡**。这些技术包括 **持久性机制**、**投递确认**、**发布者证实** 和 **高可用性机制**；
2. **灵活的路由**：消息在到达队列前是通过 **交换机** 进行 **路由** 的。RabbitMQ 为典型的路由逻辑提供了 **多种内置交换机** 类型。如果你有更复杂的路由需求，可以将这些交换机组合起来使用，你甚至可以实现自己的交换机类型，并且当做 RabbitMQ 的 **插件**来使用；
3. **消息集群**：在相同局域网中的多个 RabbitMQ 服务器可以 **聚合** 在一起，作为一个独立的逻辑代理来使用；
4. **队列高可用**：队列可以在集群中的机器上 **进行镜像**，以确保在硬件问题下还保证 **消息安全**；
5. **支持多种协议**：支持 **多种消息队列协议**；
6. **支持多种语言**：用 Erlang 语言编写，支持只要是你能想到的 **所有编程语言**；
7. **管理界面**： RabbitMQ 有一个易用的 **用户界面**，使得用户可以 **监控** 和 **管理** 消息 Broker 的许多方面；
8. **跟踪机制**：如果 **消息异常**，RabbitMQ 提供消息跟踪机制，使用者可以找出发生了什么；
9. **插件机制**：提供了许多 **插件**，来从多方面进行扩展，也可以编写自己的插件。

 **部署环境**

RabbitMQ 可以运行在 Erlang 语言所支持的平台之上，包括 Solaris，BSD，Linux，MacOSX，TRU64，Windows 等。使用 RabbitMQ 需要：

- ErLang 语言包
- RabbitMQ 安装包

**优点**

1. 由于 Erlang 语言的特性，消息队列性能较好，支持 **高并发**；
2. 健壮、稳定、易用、**跨平台**、支持 **多种语言**、文档齐全；
3. 有消息 **确认机制** 和 **持久化机制**，可靠性高；
4. 高度可定制的 **路由**；
5. **管理界面** 较丰富，在互联网公司也有较大规模的应用，社区活跃度高。

**缺点**

1. 尽管结合 Erlang 语言本身的并发优势，性能较好，但是不利于做 **二次开发和维护**；
2. 实现了 **代理架构**，意味着消息在发送到客户端之前可以在 **中央节点** 上排队。此特性使得 RabbitMQ 易于使用和部署，但是使得其 **运行速度较慢**，因为中央节点 **增加了延迟**，**消息封装后** 也比较大；
3. 需要学习 **比较复杂** 的 **接口和协议**，学习和维护成本较高。

#### RocketMQ

RocketMQ 出自 **阿里** 的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进，**消息可靠性上** 比 Kafka 更好。RocketMQ 在阿里内部被广泛应用在 **订单**，**交易**，**充值**，**流计算**，**消息推送**，**日志流式处理**，binglog **分发** 等场景。

![5.jpeg](https://i.loli.net/2019/06/07/5cf9ffd5645cf64448.jpeg)

**主要特性**

1. 基于 **队列模型**：具有 **高性能**、**高可靠**、**高实时**、**分布式** 等特点；
2. Producer、Consumer、**队列** 都支持 **分布式**；
3. Producer 向一些队列轮流发送消息，**队列集合** 称为 Topic。Consumer 如果做 **广播消费**，则一个 Consumer 实例消费这个 Topic 对应的 **所有队列**；如果做 **集群消费**，则 **多个** Consumer 实例 **平均消费** 这个 Topic 对应的队列集合；
4. 能够保证 **严格的消息顺序**；
5. 提供丰富的 **消息拉取模式**；
6. 高效的订阅者 **水平扩展**能力；
7. **实时** 的 **消息订阅机制**；
8. 亿级 **消息堆积** 能力；
9. 较少的外部依赖。

 **部署环境**

RocketMQ 可以运行在 Java 语言所支持的平台之上。使用 RocketMQ 需要：

- Java JDK
- 安装 git、Maven
- RocketMQ 安装包

**优点**

1. **单机** 支持 1 万以上 **持久化队列**；
2. RocketMQ 的所有消息都是 **持久化的**，先写入系统 PAGECACHE，然后 **刷盘**，可以保证 **内存** 与 **磁盘** 都有一份数据，而 **访问** 时，直接 **从内存读取**。
3. 模型简单，接口易用（JMS 的接口很多场合并不太实用）；
4. **性能非常好**，可以允许 **大量堆积消息** 在 Broker 中；
5. 支持 **多种消费模式**，包括 **集群消费**、**广播消费**等；
6. 各个环节 **分布式扩展设计**，支持 **主从** 和 **高可用**；
7. 开发度较活跃，版本更新很快。

**缺点**

1. 支持的 **客户端语言** 不多，目前是 Java 及 C++，其中 C++ 还不成熟；
2. RocketMQ 社区关注度及成熟度也不及前两者；
3. 没有 Web 管理界面，提供了一个 CLI (命令行界面) 管理工具带来 **查询**、**管理** 和 **诊断各种问题**；
4. 没有在 MQ 核心里实现 JMS 等接口；

#### Kafka

Apache Kafka 是一个 **分布式消息发布订阅** 系统。它最初由 LinkedIn 公司基于独特的设计实现为一个 **分布式的日志提交系统** (a distributed commit log)，之后成为 Apache 项目的一部分。Kafka **性能高效**、**可扩展良好** 并且 **可持久化**。它的 **分区特性**，**可复制** 和 **可容错** 都是其不错的特性。

![6.jpeg](https://i.loli.net/2019/06/07/5cf9ffd4dc0c189636.jpeg)

**主要特性**

1. **快速持久化**：可以在 O(1) 的系统开销下进行 **消息持久化**；
2. **高吞吐**：在一台普通的服务器上既可以达到 10W/s 的 **吞吐速率**；
3. **完全的分布式系统**：Broker、Producer 和 Consumer 都原生自动支持 **分布式**，自动实现 **负载均衡**；
4. 支持 **同步** 和 **异步** 复制两种 **高可用机制**；
5. 支持 **数据批量发送** 和 **拉取**；
6. **零拷贝技术(zero-copy)**：减少 IO 操作步骤，提高 **系统吞吐量**；
7. **数据迁移**、**扩容** 对用户透明；
8. **无需停机** 即可扩展机器；
9. **其他特性**：丰富的 **消息拉取模型**、高效 **订阅者水平扩展**、实时的 **消息订阅**、亿级的 **消息堆积能力**、定期删除机制；

**部署环境**

使用 Kafka 需要：

- Java JDK
- Kafka 安装包

**优点**

1. **客户端语言丰富**：支持 Java、.Net、PHP、Ruby、Python、Go 等多种语言；
2. **高性能**：单机写入 TPS 约在 100 万条/秒，消息大小 10 个字节；
3. 提供 **完全分布式架构**，并有 replica 机制，拥有较高的 **可用性** 和 **可靠性**，理论上支持 **消息无限堆积**；
4. 支持批量操作；
5. **消费者** 采用 Pull 方式获取消息。**消息有序**，**通过控制** 能够保证所有消息被消费且仅被消费 **一次**；
6. 有优秀的第三方 Kafka Web 管理界面 Kafka-Manager；
7. 在 **日志领域** 比较成熟，被多家公司和多个开源项目使用。

**缺点**

1. Kafka 单机超过 64 个 **队列/分区** 时，Load 时会发生明显的飙高现象。**队列** 越多，**负载** 越高，发送消息 **响应时间变长**；
2. 使用 **短轮询方式**，**实时性** 取决于 **轮询间隔时间**；
3. 消费失败 **不支持重试**；
4. 支持 **消息顺序**，但是 **一台代理宕机** 后，就会产生 **消息乱序**；
5. 社区更新较慢。

#### 几种消息队列对比

这里列举了上述四种消息队列的差异对比：

![7.jpeg](https://i.loli.net/2019/06/07/5cf9ffd5ac5f022471.jpeg)

综上所述，各种对比之后，总结如下：

一般的业务系统要引入MQ，最早大家都用ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；

后来大家开始用RabbitMQ，但是确实erlang语言阻止了大量的java工程师去深入研究和掌控他，对公司而言，几乎处于不可控的状态，但是确实人是开源的，比较稳定的支持，活跃度也高；

不过现在确实越来越多的公司，会去用RocketMQ，确实很不错，但是我提醒一下自己想好社区万一突然黄掉的风险，对自己公司技术实力有绝对自信的，我推荐用RocketMQ，否则回去老老实实用RabbitMQ吧，人是活跃开源社区，绝对不会黄

所以中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择（我们项目也正在使用这个^_^）；大型公司，基础架构研发实力较强，用RocketMQ是很好的选择

如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范


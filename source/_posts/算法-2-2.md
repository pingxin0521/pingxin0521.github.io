---
title: 剑指offer（二）
date: 2019-05-28 23:18:59
tags:
 - 算法
categories:
 - 算法
---

练习网站：<https://www.nowcoder.com/ta/coding-interviews>

语言：java 8

<!--more-->

#### 整数中1出现的次数（从1到n整数中1出现的次数)

求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。

思路:像类似这样的问题，我们可以通过归纳总结来获取相关的东西。

- 个位

  我们知道在个位数上，1会每隔10出现一次，例如1、11、21等等，我们发现以10为一个阶梯的话，每一个完整的阶梯里面都有一个1，例如数字22，按照10为间隔来分三个阶梯，在完整阶梯0-9，10-19之中都有一个1，但是19之后有一个不完整的阶梯，我们需要去判断这个阶梯中会不会出现1，易推断知，如果最后这个露出来的部分小于1，则不可能出现1（这个归纳换做其它数字也成立）。

  我们可以归纳个位上1出现的个数为：

  ```
  n/10 * 1+(n%10!=0 ? 1 : 0)
  ```

- 十位

  现在说十位数，十位数上出现1的情况应该是10-19，依然沿用分析个位数时候的阶梯理论，我们知道10-19这组数，每隔100出现一次，这次我们的阶梯是100，例如数字317，分析有阶梯0-99，100-199，200-299三段完整阶梯，每一段阶梯里面都会出现10次1（从10-19），最后分析露出来的那段不完整的阶梯。我们考虑如果露出来的数大于19，那么直接算10个1就行了，因为10-19肯定会出现；如果小于10，那么肯定不会出现十位数的1；如果在10-19之间的，我们计算结果应该是k - 10 + 1。例如我们分析300-317，17个数字，1出现的个数应该是17-10+1=8个。

  那么现在可以归纳：十位上1出现的个数为：

  ```
  设k = n % 100，即为不完整阶梯段的数字
  归纳式为：(n / 100) * 10 + (if(k > 19) 10 else if(k < 10) 0 else k - 10 + 1)
  ```

- 百位

  现在说百位1，我们知道在百位，100-199都会出现百位1，一共出现100次，阶梯间隔为1000，100-199这组数，每隔1000就会出现一次。这次假设我们的数为2139。跟上述思想一致，先算阶梯数 * 完整阶梯中1在百位出现的个数，即n/1000 * 100得到前两个阶梯中1的个数，那么再算漏出来的部分139，沿用上述思想，不完整阶梯数k199，得到100个百位1，100<=k<=199则得到k - 100 + 1个百位1。

  那么继续归纳百位上出现1的个数：

  ```
  设k = n % 1000
  归纳式为：(n / 1000) * 100 + (if(k >199) 100 else if(k < 100) 0 else k - 100 + 1)
  ```

- 再次回顾

  我们把个位数上算1的个数的式子也纳入归纳式中

      k = n % 10
      个位数上1的个数为：n / 10 * 1 + (if(k > 1) 1 else if(k < 1) 0 else k - 1 + 1)

  完美！归纳式看起来已经很规整了。 来一个更抽象的归纳，设i为计算1所在的位数，i=1表示计算个位数的1的个数，10表示计算十位数的1的个数等等。

          k = n % (i * 10)
          count(i) = (n / (i * 10)) * i + (if(k > i * 2 - 1) i else if(k < i) 0 else k - i + 1)

  好了，这样从10到10的n次方的归纳就完成了。

          sum1 = sum(count(i))，i = Math.pow(10, j), 0<=j<=log10(n)

  但是有一个地方值得我们注意的，就是代码的简洁性来看，有多个ifelse不太好，能不能进一步简化呢？ 我们可以把后半段简化成这样，我们不去计算i * 2 - 1了，我们只需保证k - i + 1在[0, i]区间内就行了，最后后半段可以写成这样

      min(max((n mod (i*10))−i+1,0),i)

代码：

```java
public class Solution {
     public int NumberOf1Between1AndN_Solution(int n) {
         if(n <= 0)
             return 0;
         int count = 0;
         for(long i = 1; i <= n; i *= 10){
             long diviver = i * 10;          
             count += (n / diviver) * i + Math.min(Math.max(n % diviver - i + 1, 0), i);
        }
         return count;
     }
 }
```

#### 把数组排成最小的数

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

```java
/** 解题思路：
* 先将整型数组转换成String数组，然后将String数组排序，最后将排好序的字符串数组拼接出来。关键就是制定排序规则。
* 排序规则如下：
* 若ab > ba 则 a > b，
* 若ab < ba 则 a < b，
* 若ab = ba 则 a = b；
* 解释说明：
* 比如 "3" < "31"但是 "331" > "313"，所以要将二者拼接起来进行比较
**/
public String PrintMinNumber(int[] numbers) {
        int n;
        StringBuilder s = new StringBuilder();
        ArrayList<Integer> list = new ArrayList<>();
        n = numbers.length;
        for (int i = 0; i < n; i++) {
            list.add(numbers[i]);
        }
        Collections.sort(list, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                String s1 = o1 + "" + o2;
                String s2 = o2 + "" + o1;
                return s1.compareTo(s2);
            }
        });
        for (Integer i : list) {
            s.append(i);
        }
        return s.toString();
    }
```

#### 丑数

把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

```java
    /**
     * 说下思路，如果p是丑数，那么p=2^x * 3^y * 5^z
     * 那么只要赋予x,y,z不同的值就能得到不同的丑数。
     * 如果要顺序找出丑数，要知道下面几个特（fei）点（hua）。
     * 对于任何丑数p：
     * （一）那么2*p,3*p,5*p都是丑数，并且2*p<3*p<5*p
     * （二）如果p<q, 那么2*p<2*q,3*p<3*q,5*p<5*q
     * 现在说说算法思想：
     * 由于1是最小的丑数，那么从1开始，把2*1，3*1，5*1，进行比较，得出最小的就是1
     * 的下一个丑数，也就是2*1，
     * 这个时候，多了一个丑数‘2’，也就又多了3个可以比较的丑数，2*2，3*2，5*2，
     * 这个时候就把之前‘1’生成的丑数和‘2’生成的丑数加进来也就是
     * (3*1,5*1,2*2，3*2，5*2)进行比较，找出最小的。。。。如此循环下去就会发现，
     * 每次选进来一个丑数，该丑数又会生成3个新的丑数进行比较。
     * 上面的暴力方法也应该能解决，但是如果在面试官用这种方法，估计面试官只会摇头吧
     * 。下面说一个O（n）的算法。
     * 在上面的特（fei）点（hua）中，既然有p<q, 那么2*p<2*q，那么
     * “我”在前面比你小的数都没被选上，你后面生成新的丑数一定比“我”大吧，那么你乘2
     * 生成的丑数一定比我乘2的大吧，那么在我选上之后你才有机会选上。
     * 其实每次我们只用比较3个数：用于乘2的最小的数、用于乘3的最小的数，用于乘5的最小的
     * 数。也就是比较(2*x , 3*y, 5*z) ，x>=y>=z的，
     * 重点说说下面代码中p的作用：int p[] = new int[] { 0, 0, 0 }; p[0]表示最小用于
     * 乘2比较数在数组a中的【位置】。
     **/
    final int d[] = {2, 3, 5};

    public int GetUglyNumber_Solution(int index) {


        if (index == 0) return 0;
        int a[] = new int[index];
        a[0] = 1;
        int p[] = new int[]{0, 0, 0};
        int num[] = new int[]{2, 3, 5};
        int cur = 1;

        while (cur < index) {
            int m = finMin(num[0], num[1], num[2]);
            if (a[cur - 1] < num[m])
                a[cur++] = num[m];
            p[m] += 1;
            num[m] = a[p[m]] * d[m];
        }
        return a[index - 1];
    }


    private int finMin(int num2, int num3, int num5) {
        int min = Math.min(num2, Math.min(num3, num5));
        return min == num2 ? 0 : min == num3 ? 1 : 2;
    }
```

#### 第一个只出现一次的字符

在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.

1. 使用map

   ```
   public int FirstNotRepeatingChar(String str) {
           if (null == str || str.length() == 0) {
               return -1;
           }
           int len = str.length();
           LinkedHashMap<Character, Integer> map = new LinkedHashMap<>();
           for (int i = 0; i < len; i++) {
               char c = str.charAt(i);
               if (map.containsKey(c)) {
                   Integer count = map.get(c);
                   count++;
                   map.put(c, count);
               } else {
                   map.put(c, 1);
               }
           }
   
           int pos = -1;
           int i = 0;
           for (; i < str.length(); i++) {
               char c = str.charAt(i);
               if (map.get(c) == 1) {
                   return i;
               }
           }
           return pos;
       }
   ```

#### 数组中的逆序对

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007

输入描述:

```
题目保证输入的数组中没有的相同的数字
数据范围：
    对于%50的数据,size<=10^4
    对于%75的数据,size<=10^5
    对于%100的数据,size<=2*10^5
```

示例1 

输入

```
1,2,3,4,5,6,7,0
```

输出

```
7
```

代码：

```java
/**
     * 归并排序的改进，把数据分成前后两个数组(递归分到每个数组仅有一个数据项)，
     * 合并数组，合并时，出现前面的数组值array[i]大于后面数组值array[j]时；则前面
     * 数组array[i]~array[mid]都是大于array[j]的，count += mid+1 - i
     * 参考剑指Offer，但是感觉剑指Offer归并过程少了一步拷贝过程。
     * 还有就是测试用例输出结果比较大，对每次返回的count mod(1000000007)求余
     */
public int InversePairs(int[] array) {

    if (array == null || array.length == 0) {
        return 0;
    }
    int[] copy = new int[array.length];
    for (int i = 0; i < array.length; i++) {
        copy[i] = array[i];
    }
    int count = InversePairsCore(array, copy, 0, array.length - 1);//数值过大求余
    return count;
}


private int InversePairsCore(int[] array, int[] copy, int low, int high) {
    if (low == high) {
        return 0;
    }
    int mid = (low + high) >> 1;
    int leftCount = InversePairsCore(array, copy, low, mid) % 1000000007;
    int rightCount = InversePairsCore(array, copy, mid + 1, high) % 1000000007;
    int count = 0;
    int i = mid;
    int j = high;
    int locCopy = high;
    while (i >= low && j > mid) {
        if (array[i] > array[j]) {
            count += j - mid;
            copy[locCopy--] = array[i--];
            if (count >= 1000000007)//数值过大求余
            {
                count %= 1000000007;
            }
        } else {
            copy[locCopy--] = array[j--];
        }
    }
    for (; i >= low; i--) {
        copy[locCopy--] = array[i];
    }
    for (; j > mid; j--) {
        copy[locCopy--] = array[j];
    }
    for (int s = low; s <= high; s++) {
        array[s] = copy[s];
    }
    return (leftCount + rightCount + count) % 1000000007;
}
```

#### 两个链表的第一个公共结点

输入两个链表，找出它们的第一个公共结点。

解法：先行者

```java

public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
          ListNode p1=pHead1;
        ListNode p2=pHead2;
        while (p1!=p2)
        {
            p1=(p1==null?pHead2:p1.next);
            p2=(p2==null?pHead1:p2.next);
        }
        return p1;
    }
}
```

#### 数字在排序数组中出现的次数

统计一个数字在排序数组中出现的次数。

```java

    public int GetNumberOfK(int[] array, int k) {
        if (null == array || array.length == 0) {
            return 0;
        }


        int count = 0;

        for (int i = 0; i < array.length; i++) {
            if (array[i] > k) {
                break;
            }
            if (array[i] < k) {
                continue;
            }
            count++;
        }

        return count;
    }
```

#### 二叉树的深度

输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

```java
 public int TreeDepth(TreeNode pRoot) {
        if (pRoot == null)
            return 0;
        if (pRoot.left == null && pRoot.right == null)
            return 1;
        int left = TreeDepth(pRoot.left);
        int right = TreeDepth(pRoot.right);

        return left > right ? left + 1 : right + 1;
    }
```

#### 平衡二叉树

输入一棵二叉树，判断该二叉树是否是平衡二叉树。

```java
 //后续遍历时，遍历到一个节点，其左右子树已经遍历  依次自底向上判断，每个节点只需要遍历一次

    private boolean isBalanced = true;

    public boolean IsBalanced_Solution(TreeNode root) {
        getDepth(root);
        return isBalanced;
    }

    public int getDepth(TreeNode root) {
        if (root == null)
            return 0;

        int left = getDepth(root.left);
        int right = getDepth(root.right);

        if (Math.abs(left - right) > 1) {
            isBalanced = false;
        }
        return right > left ? right + 1 : left + 1;

    }
```

#### 数组中只出现一次的数字

一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

```java
    //num1,num2分别为长度为1的数组。传出参数
    //将num1[0],num2[0]设置为返回结果
    public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) {
        if (null == array || array.length == 0) {
            return;
        }
        if (array.length == 1) {
            num1[0] = num2[0] = array[0];
        } else if (array.length == 2) {
            num1[0] = array[0];
            num2[0] = array[1];
        } else {

            HashMap<Integer, Integer> map = new HashMap<>();
            for (int i : array) {
                if (map.containsKey(i)) {
                    int c = map.get(i);
                    c++;
                    map.put(i, c);
                } else {
                    map.put(i, 1);
                }
            }
            boolean ok = false;
            Object[] set = map.keySet().toArray();
            for (int j = 0; j < set.length; j++) {
                int i = (int) set[j];
                if (map.get(i) == 1) {
                    if (ok) {
                        num2[0] = i;
                        break;
                    } else {
                        num1[0] = i;
                        ok=true;
                    }

                }
            }

        }

    }
```

#### 为S的连续正数序列

小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!

##### **输出描述:**

```
输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
```

代码：

```java
// 在答案区找到一个答案，说的很好，叫做双指针技术，就是相当于有一个窗口，
// 窗口的左右两边就是两个指针，我们根据窗口内值之和来确定窗口的位置和宽度。
// 非常牛逼的思路，虽然双指针或者所谓的滑动窗口技巧还是蛮常见的，但是这一题还真想不到这个思路。

    public ArrayList<ArrayList<Integer>> FindContinuousSequence(int sum) {

        //存放结果
        ArrayList<ArrayList<Integer>> result = new ArrayList<>();
        //两个起点，相当于动态窗口的两边，根据其窗口内的值的和来确定窗口的位置和大小
        int plow = 1, phigh = 2;
        while (phigh > plow) {
            //由于是连续的，差为1的一个序列，那么求和公式是(a0+an)*n/2
            int cur = (phigh + plow) * (phigh - plow + 1) / 2;
            //相等，那么就将窗口范围的所有数添加进结果集
            if (cur == sum) {
                ArrayList<Integer> list = new ArrayList<>();
                for (int i = plow; i <= phigh; i++) {
                    list.add(i);
                }
                result.add(list);
                plow++;
                //如果当前窗口内的值之和小于sum，那么右边窗口右移一下
            } else if (cur < sum) {
                phigh++;
            } else {
                //如果当前窗口内的值之和大于sum，那么左边窗口右移一下
                plow++;
            }
        }
        return result;
    }
```

#### 和为S的两个数字

输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。

##### **输出描述:**

```
对应每个测试案例，输出两个数，小的先输出。
```

思路：

数列满足递增，设两个头尾两个指针i和j，
若ai + aj == sum，就是答案（相差越远乘积越小）
若ai + aj > sum，aj肯定不是答案之一（前面已得出 i 前面的数已是不可能），j -= 1
若ai + aj < sum，ai肯定不是答案之一（前面已得出 j 后面的数已是不可能），i += 1
时间复杂度：O(n) 

```java
 public ArrayList<Integer> FindNumbersWithSum(int[] array, int sum) {
        ArrayList<Integer> list = new ArrayList<>();
        if (null == array || array.length == 0) {
            return list;
        }
        int len = array.length;
        int i = 0;
        int j = len - 1;
        while (i < j) {
            if (array[i] + array[j] == sum) {
                list.add(array[i]);
                list.add(array[j]);
                break;
            }
            while (i < j && array[i] + array[j] > sum) --j;
            while (i < j && array[i] + array[j] < sum) ++i;
        }
        return list;

    }
```

#### 左旋转字符串

汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！

```java
 public String LeftRotateString(String str, int n) {
        if (null == str || str.length() == 0) {
            return "";
        }
        n = n % str.length();
        StringBuffer buffer = new StringBuffer();
        buffer.append(str, n, str.length() );
        buffer.append(str, 0, n);

        return buffer.toString();
    }
```

#### 翻转单词顺序列

 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？

```java
    public String ReverseSentence(String str) {
        if (str.trim().equals("")) {
            return str;
        }
        System.out.println(str + 2);
        String[] strs = str.split(" ");
        StringBuffer buffer = new StringBuffer();
        for (int i = strs.length - 1; i >= 0; i--) {
            String s = strs[i];
            buffer.append(s);
            if (i != 0) {
                buffer.append(" ");
            }
        }

        return buffer.toString();

    }
```

#### 扑克牌顺子

LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。

```java
//max 记录 最大值
//min 记录  最小值
//min ,max 都不记0
//满足条件 1 max - min <5
//        2 除0外没有重复的数字(牌)
//           3 数组长度 为5
    public boolean isContinuous(int[] numbers) {
        if (numbers.length == 0) {
            return false;
        }

        int[] d = new int[14];
        d[0] = -5;
        int len = numbers.length;
        int max = -1;
        int min = 14;
        for (int i = 0; i < len; i++) {
            d[numbers[i]]++;
            if (numbers[i] == 0) {
                continue;
            }
            if (d[numbers[i]] > 1) {
                return false;
            }
            if (numbers[i] > max) {
                max = numbers[i];
            }
            if (numbers[i] < min) {
                min = numbers[i];
            }

        }
        if (max - min < 5) {
            return true;
        }
        return false;
    }
```

#### 孩子们的游戏(圆圈中最后剩下的数)

每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)

```java
//
//令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]。
//
//递推公式
//
//f[1]=0;
//
//f[i]=(f[i-1]+m)%i;  (i>1)
//
//有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。 因为实际生活中编号总是从1开始，我们输出f[n]+1。

    public int LastRemaining_Solution(int n, int m) {
        if (n == 0) {
            return -1;
        }
        if (n == 1) {
            return 0;
        } else {
            return (LastRemaining_Solution(n - 1, m) + m) % n;
        }
    }
```

#### 求1+2+3+...+n

求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

解题思路：

1. 需利用逻辑与的短路特性实现递归终止。
2. 当n==0时，(n>0)&&((sum+=Sum_Solution(n-1))>0)只执行前面的判断，为false，然后直接返回0；
3. 当n>0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。

```java
public int Sum_Solution(int n) {
        int sum = n;
        boolean ans = (n>0)&&((sum+=Sum_Solution(n-1))>0);
        return sum;
    }
```

#### 不用加减乘除做加法

写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

```java
    public int Add(int num1, int num2) {

        int a = num1 ^ num2;
        int b = num1 & num2;//获取进位位
        int c = b << 1;
        if (b != 0) {
            a = Add(a, c);
        }

        return a;
    }
```

#### 把字符串转换成整数

将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。

输入描述:

```
输入一个字符串,包括数字字母符号,可以为空
```

输出描述:

```
如果是合法的数值表达则返回该数字，否则返回0
```

代码：

```java
 public boolean flag;

    public int StrToInt(String str) {

        flag = false;
        //判断输入是否合法
        if (str == null || str.trim().equals("")) {
            flag = true;
            return 0;
        }
        // symbol=0,说明该数为正数;symbol=1，该数为负数;start用来区分第一位是否为符号位
        int symbol = 0;
        int start = 0;
        char[] chars = str.trim().toCharArray();
        if (chars[0] == '+') {
            start = 1;
        } else if (chars[0] == '-') {
            start = 1;
            symbol = 1;
        }
        int result = 0;
        for (int i = start; i < chars.length; i++) {
            if (chars[i] > '9' || chars[i] < '0') {
                flag = true;
                return 0;
            }
            int sum = result * 10 + (int) (chars[i] - '0');


            if ((sum - (int) (chars[i] - '0')) / 10 != result) {
                flag = true;
                return 0;
            }

            result = result * 10 + (int) (chars[i] - '0');
            /*
             * 本人认为java热门第一判断是否溢出是错误的，举个反例
             * 当输入为value=2147483648时，在计算机内部的表示应该是-2147483648
             * 显然value>Integer.MAX_VALUE是不成立的
             */
        }
        // 注意：java中-1的n次方不能用：(-1)^n .'^'异或运算
        // 注意，当value=-2147483648时，value=-value
        result = (int) Math.pow(-1, symbol) * result;
        return result;
    }
```

#### 数组中重复的数字

在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

```java
    // Parameters:
    //    numbers:     an array of integers
    //    length:      the length of array numbers
    //    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;
    //                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++
    //    这里要特别注意~返回任意重复的一个，赋值duplication[0]
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
    public boolean duplicate(int numbers[], int length, int[] duplication) {


        boolean[] k = new boolean[length];
        for (int i = 0; i < k.length; i++) {
            if (k[numbers[i]]) {
                duplication[0] = numbers[i];
                return true;
            }
            k[numbers[i]] = true;
        }
        return false;
    }
```

#### 构建乘积数组

给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素`B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]`。不能使用除法。

![1.jpeg](https://i.loli.net/2019/07/07/5d21975c6147e59932.jpeg)

```java
//    B[i]的值可以看作上图的矩阵中每行的乘积。
//    下三角用连乘可以很容求得，上三角，从下向上也是连乘。
//    因此我们的思路就很清晰了，先算下三角中的连乘，即我们先算出B[i]中的一部分，
//    然后倒过来按上三角中的分布规律，把另一部分也乘进去。
    public int[] multiply(int[] A) {

        int length = A.length;
        int[] B = new int[length];
        if (length != 0) {
            B[0] = 1;
            //计算下三角连乘
            for (int i = 1; i < length; i++) {
                B[i] = B[i - 1] * A[i - 1];
            }
            int temp = 1;
            //计算上三角
            for (int j = length - 2; j >= 0; j--) {
                temp *= A[j + 1];
                B[j] *= temp;
            }
        }
        return B;
    }
```

#### 正则表达式匹配

请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和`"ab*ac*a"`匹配，但是与`"aa.a"`和`"ab*a"`均不匹配

```java
//当模式中的第二个字符不是“*”时：
//        1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。
//        2、如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。
//
//而当模式中的第二个字符是“*”时：
//如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：
//        1、模式后移2字符，相当于x*被忽略；
//        2、字符串后移1字符，模式后移2字符；
//        3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；
// 这里需要注意的是：Java里，要时刻检验数组是否越界。
    public boolean match(char[] str, char[] pattern) {


        if (str == null || pattern == null) {
            return false;
        }
        int strIndex = 0;
        int patternIndex = 0;
        return matchCore(str, strIndex, pattern, patternIndex);
    }


    public boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) {
        //有效性检验：str到尾，pattern到尾，匹配成功
        if (strIndex == str.length && patternIndex == pattern.length) {
            return true;
        }
        //pattern先到尾，匹配失败
        if (strIndex != str.length && patternIndex == pattern.length) {
            return false;
        }
        //模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位
        if (patternIndex + 1 < pattern.length && pattern[patternIndex + 1] == '*') {
            if ((strIndex != str.length && pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' && strIndex != str.length)) {
                return matchCore(str, strIndex, pattern, patternIndex + 2)//模式后移2，视为x*匹配0个字符
                        || matchCore(str, strIndex + 1, pattern, patternIndex + 2)//视为模式匹配1个字符
                        || matchCore(str, strIndex + 1, pattern, patternIndex);//*匹配1个，再匹配str中的下一个
            } else {
                return matchCore(str, strIndex, pattern, patternIndex + 2);
            }
        }
        //模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false
        if ((strIndex != str.length && pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' && strIndex != str.length)) {
            return matchCore(str, strIndex + 1, pattern, patternIndex + 1);
        }
        return false;
    }
```

#### 表示数值的字符串

 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。

```java
    /**
     * 以下对正则进行解释:
     * [\\+\\-]?            -> 正或负符号出现与否
     * \\d*                 -> 整数部分是否出现，如-.34 或 +3.34均符合
     * (\\.\\d+)?           -> 如果出现小数点，那么小数点后面必须有数字；
     * 否则一起不出现
     * ([eE][\\+\\-]?\\d+)? -> 如果存在指数部分，那么e或E肯定出现，+或-可以不出现，
     * 紧接着必须跟着整数；或者整个部分都不出现
     */
    public boolean isNumeric(char[] str) {
        String string = String.valueOf(str);
        return string.matches(
                "[+\\-]?\\d*(\\.\\d+)?([eE][+\\-]?\\d+)?");

    }
    private int index = 0;



    public boolean isNumeric2(char[] str) {
        if (str.length < 1)
            return false;

        boolean flag = scanInteger(str);

        if (index < str.length && str[index] == '.') {
            index++;
            flag = scanUnsignedInteger(str) || flag;
        }

        if (index < str.length && (str[index] == 'E' || str[index] == 'e')) {
            index++;
            flag = flag && scanInteger(str);
        }

        return flag && index == str.length;

    }

    private boolean scanInteger(char[] str) {
        if (index < str.length && (str[index] == '+' || str[index] == '-') )
            index++;
        return scanUnsignedInteger(str);

    }

    private boolean scanUnsignedInteger(char[] str) {
        int start = index;
        while (index < str.length && str[index] >= '0' && str[index] <= '9')
            index++;
        return start < index; //是否存在整数
    }

```

#### 字符流中第一个不重复的字符

请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。

##### **输出描述:**

```
如果当前字符流没有存在出现一次的字符，返回#字符。
```

代码：

```java
// 一个字符占8位，因此不会超过256个，可以申请一个256大小的数组来实现一个简易的哈希表。
// 时间复杂度为O(n)，空间复杂度O(n).

    int[] hashtable = new int[256];
    StringBuffer s = new StringBuffer();

    //Insert one char from stringstream
    public void Insert(char ch) {
        s.append(ch);
        if (hashtable[ch] == 0)
            hashtable[ch] = 1;
        else hashtable[ch] += 1;
    }

    //return the first appearence once char in current stringstream
    public char FirstAppearingOnce() {
        char[] str = s.toString().toCharArray();
        for (char c : str) {
            if (hashtable[c] == 1)
                return c;
        }
        return '#';
    }
```

#### 链表中环的入口结点

给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。

```java

//如果链表中环 有n个结点，指针P1在链表上向前移动n步，然后两个指针以相同的速度向前移动。
// 当第二个指针指向环的入口结点时，第一个指针已经围绕着环走了一圈又回到了入口结点。
//所以首先要得到环中结点的数目。

    public ListNode EntryNodeOfLoop(ListNode pHead) {


        ListNode meetingNode = meetingNode(pHead);
        if (meetingNode == null)
            return null;
//      得到环中的节点个数
        int nodesInLoop = 1;
        ListNode p1 = meetingNode;
        while (p1.next != meetingNode) {
            p1 = p1.next;
            ++nodesInLoop;
        }
//      移动p1
        p1 = pHead;
        for (int i = 0; i < nodesInLoop; i++) {
            p1 = p1.next;
        }
//      移动p1，p2
        ListNode p2 = pHead;
        while (p1 != p2) {
            p1 = p1.next;
            p2 = p2.next;
        }
        return p1;
    }

    //找到一快一满指针相遇处的节点，相遇的节点一定是在环中
    public static ListNode meetingNode(ListNode head) {
        if (head == null)
            return null;

        ListNode slow = head.next;
        if (slow == null)
            return null;

        ListNode fast = slow.next;
        while (slow != null && fast != null) {
            if (slow == fast) {
                return fast;
            }
            slow = slow.next;
            fast = fast.next;

            if (fast != slow) {
                fast = fast.next;
            }
        }
        return null;
    }


    public ListNode EntryNodeOfLoop1(ListNode pHead) {
        ///
        if (pHead == null || pHead.next == null || pHead.next.next == null) return null;
        ListNode fast = pHead.next.next;
        ListNode slow = pHead.next;
        /////先判断有没有环
        while (fast != slow) {
            if (fast.next != null && fast.next.next != null) {
                fast = fast.next.next;
                slow = slow.next;
            } else {
                //没有环,返回
                return null;
            }
        }
        //循环出来的话就是有环，且此时fast==slow.
        fast = pHead;
        while (fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
```

#### 删除链表中重复的结点

在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

```java
    public ListNode deleteDuplication(ListNode pHead) {
        if (null == pHead || pHead.next == null) {
            return pHead;
        }
        ListNode current;
        if (pHead.next.val == pHead.val) {
            current = pHead.next.next;
            while (current != null && current.val == pHead.val) {
                current = current.next;
            }
            return deleteDuplication(current);
        } else {
            current = pHead.next;
            pHead.next = deleteDuplication(current);
            return pHead;
        }

    }
```

#### 二叉树的下一个结点

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

```java
class TreeLinkNode {
//    int val;
//    TreeLinkNode left = null;
//    TreeLinkNode right = null;
//    TreeLinkNode next = null;
//
//    TreeLinkNode(int val) {
//        this.val = val;
//    }
//}
//分析二叉树的下一个节点，一共有以下情况：
//1.二叉树为空，则返回空；
//2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，
//    一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；
//3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；
//    否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。

    public TreeLinkNode GetNext(TreeLinkNode pNode) {
        if (null==pNode)
        {
            return pNode;
        }
        if (pNode.right!=null)
        {
            pNode=pNode.right;
            while (pNode.left != null) {
                pNode=pNode.left;
            }
            return pNode;
        }
        while (pNode.next != null) {
            TreeLinkNode proot=pNode.next;
            if (proot.left==pNode) {
                return proot;
            }
            pNode=pNode.next;
        }
        return null;
    }
```

#### 对称的二叉树

请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

```java
   /*思路：首先根节点以及其左右子树，左子树的左子树和右子树的右子树相同
     * 左子树的右子树和右子树的左子树相同即可，采用递归
     * 非递归也可，采用栈或队列存取各级子树根节点
     */
    boolean isSymmetrical(TreeNode pRoot) {


        if (pRoot == null) {
            return true;
        }
        return comRoot(pRoot.left, pRoot.right);
    }

    private boolean comRoot(TreeNode left, TreeNode right) {
        // TODO Auto-generated method stub
        if (left == null) return right == null;
        if (right == null) return false;
        if (left.val != right.val) return false;
        return comRoot(left.right, right.left) && comRoot(left.left, right.right);
    }
```

#### "之"字形打印矩阵

之字形打印一个矩阵

![3iJTUg.png](https://s2.ax1x.com/2020/02/17/3iJTUg.png)

例如：

```
1 2 3 4
5 6 7 8
9 10 11 12
```

打印结果是1, 2,5, 9,6,3, 4,7,10, 11,8, 12。
要求额外空间复杂度是`O(1)`

**思路**

两个坐标进行记录，都从0,0点开始。一个往右移动，移动到最右往下移动；另一个往下移动，移动到最下往右移动，两个坐标始终处于一条斜线，然后打印斜线上的元素就行。

**做法**

![3iJOvq.png](https://s2.ax1x.com/2020/02/17/3iJOvq.png)

设置两个点A(aR,aC),B(bR,bC)（行，列），都从0,0点开始。

- 宏观
   A向右走，当到最右点的时候（走过了 `endC = matrix[0].length-1`列），向下走
   B向下走，当到最下点的时候（走过了 `endR = matrix.length-1`行），向右走
- 打印方向
   设置一个布尔变量表示从上到下还是从下到上打印
- 结束
   当aR到最后一行的时候 或者 当bC到最后一列的时候标志着打印结束

**代码实现**

```java
public class ZigZagPrintMatrix {
    public static void zigZagPrintMatrix(int[][]matrix){
        if(matrix==null || matrix.length==0 || matrix[0].length==0){
            return ;
        }
        int aR = 0;//行
        int aC = 0;//列
        int bR = 0;//行
        int bC = 0;//列
        int endR = matrix.length-1;//行结束位置，的索引
        int endC = matrix[0].length-1;//列结束位置，的索引
        boolean fromUp = false;
        while(aR != matrix.length){//当aR到最后一行的时候 
            printMatrix(matrix, aR, aC, bR, bC, fromUp);
            aR = aC==endC ? aR+1 : aR;
            aC = aC==endC ? aC : aC+1;
            bC = bR==endR ? bC+1 : bC;
            bR = bR==endR ? bR : bR+1;
            fromUp = !fromUp;
        }
    }

    public static void printMatrix(int[][]matrix,int aR,int aC,
                                int bR,int bC,boolean fromUp){
        if(fromUp){//从右上到左下
            while(aR!= bR+1){//一行一行扫过来
                System.out.print(matrix[aR++][aC--]+" ");
            }
        }else {
            while(bR != aR-1){
                System.out.print(matrix[bR--][bC++]+" ");
            }
        }
    }
    public static void main(String[] args) {
        int matrix[][] = new int[][]{
            {1, 2, 3,  4},
            {5, 6, 7,  8},
            {9, 10,11, 12},
            {13,14,15, 16}
        };
        zigZagPrintMatrix(matrix);
    }
}
```

#### 顺时针打印矩阵

**题目描述：**

 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10。

**解题思路**

分别设置上下左右四个墙壁，当一行或一列全部输出时，就把对应墙壁向内移动。

 设置flag，标志着现在该横向还是纵向移动。设置colFlag和rowFlag，分别代表着横向和纵向移动的方向(向左，向右，向下，向上)。

 当移动到转换横纵移动方向时，要把循环最后越界的数据下标，恢复到转换方向后正确的下标。
 每次循环后，判断墙壁是否重复，重复就证明矩阵中数字已经遍历完全。

**提交代码**

```java
    public static ArrayList<Integer> printMatrix(int[][] matrix) {
        ArrayList<Integer> list = new ArrayList<>();
        if (matrix == null || matrix.length == 0) {
            return list;
        }
        // 四个边界值
        int top = 0;
        int left = 0;
        int right = matrix[0].length;
        int bottom = matrix.length;
        // 横着和竖着相加的值（1/-1）
        int colFlage = 1;
        int rowFlage = 1;
        //  现在是否是横着移动
        boolean flag = true;
        int i = 0;
        int j = 0;

        while (bottom != top && right != left) {
            // 横向移动
            if (flag) {
                for (; j < right && j >= left; j += rowFlage) {
                    list.add(matrix[i][j]);
                }
                // 缩小墙壁
                if (rowFlage > 0) {
                    top++;
                } else {
                    bottom--;
                }
                // 指针恢复
                i += rowFlage;
                // 切换下次横向移动方向
                rowFlage = -rowFlage;
                j += rowFlage;
            }
            // 纵向移动
            if (!flag) {
                for (; i < bottom && i >= top; i += colFlage) {
                    list.add(matrix[i][j]);
                }
                // 缩小墙壁
                if (colFlage > 0) {
                    right--;
                } else {
                    left++;
                }
                // 切换下次纵向移动方向
                colFlage = -colFlage;
                // 恢复指针位置
                i += colFlage;
                j += colFlage;
            }
            // 切换横向和竖向移动
            flag = !flag;
        }

        return list;


    }
```

#### 按之字形顺序打印二叉树

请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。

```java
   /**
     * 大家的实现很多都是将每层的数据存进ArrayList中，偶数层时进行reverse操作，
     * 在海量数据时，这样效率太低了。
     * （我有一次面试，算法考的就是之字形打印二叉树，用了reverse，
     * 直接被鄙视了，面试官说海量数据时效率根本就不行。）
     * <p>
     * 下面的实现：不必将每层的数据存进ArrayList中，偶数层时进行reverse操作，直接按打印顺序存入
     * 思路：利用Java中的LinkedList的底层实现是双向链表的特点。
     * 1)可用做队列,实现树的层次遍历
     * 2)可双向遍历,奇数层时从前向后遍历，偶数层时从后向前遍历
     */
    public ArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {

        ArrayList<ArrayList<Integer>> ret = new ArrayList<>();
        if (pRoot == null) {
            return ret;
        }
        ArrayList<Integer> list = new ArrayList<>();
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.addLast(null);//层分隔符
        queue.addLast(pRoot);
        boolean leftToRight = true;

        while (queue.size() != 1) {
            TreeNode node = queue.removeFirst();
            if (node == null) {//到达层分隔符
                Iterator<TreeNode> iter = null;
                if (leftToRight) {
                    iter = queue.iterator();//从前往后遍历
                } else {
                    iter = queue.descendingIterator();//从后往前遍历
                }
                leftToRight = !leftToRight;
                while (iter.hasNext()) {
                    TreeNode temp = (TreeNode) iter.next();
                    list.add(temp.val);
                }
                ret.add(new ArrayList<Integer>(list));
                list.clear();
                queue.addLast(null);//添加层分隔符
                continue;//一定要continue
            }
            if (node.left != null) {
                queue.addLast(node.left);
            }
            if (node.right != null) {
                queue.addLast(node.right);
            }
        }

        return ret;
    }
```

#### 把二叉树打印成多行

从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。

```java
    ArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {
        ArrayList<ArrayList<Integer>> result
                = new ArrayList<>();
        if (null == pRoot) {
            return result;
        }
        Queue<TreeNode> layer = new LinkedList<TreeNode>();
        ArrayList<Integer> layerList = new ArrayList<Integer>();
        layer.add(pRoot);
        int start = 0, end = 1;
        while (!layer.isEmpty()) {
            TreeNode cur = layer.remove();
            layerList.add(cur.val);
            start++;
            if (cur.left != null) {
                layer.add(cur.left);
            }
            if (cur.right != null) {
                layer.add(cur.right);
            }
            if (start == end) {
                end = layer.size();
                start = 0;
                result.add(layerList);
                layerList = new ArrayList<Integer>();
            }
        }
        return result;

    }
```

#### 序列化二叉树

请实现两个函数，分别用来序列化和反序列化二叉树

```java
    public int index = -1;

    String Serialize(TreeNode root) {
        StringBuffer sb = new StringBuffer();
        if (root == null) {
            sb.append("#,");
            return sb.toString();
        }
        sb.append(root.val + ",");
        sb.append(Serialize(root.left));
        sb.append(Serialize(root.right));
        return sb.toString();
    }

    TreeNode Deserialize(String str) {
        index++;
        int len = str.length();
        if (index >= len) {
            return null;
        }
        String[] strr = str.split(",");
        TreeNode node = null;
        if (!strr[index].equals("#")) {
            node = new TreeNode(Integer.valueOf(strr[index]));
            node.left = Deserialize(str);
            node.right = Deserialize(str);
        }

        return node;
    }
```

#### 二叉搜索树的第k个结点

给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。

```java
//思路：二叉搜索树按照中序遍历的顺序打印出来正好就是排序好的顺序。
//     所以，按照中序遍历顺序找到第k个结点就是结果。
    int index = 0; //计数器

    TreeNode KthNode(TreeNode root, int k) {

        if (root != null) { //中序遍历寻找第k个
            TreeNode node = KthNode(root.left, k);
            if (node != null)
                return node;
            index++;
            if (index == k)
                return root;
            node = KthNode(root.right, k);
            if (node != null)
                return node;
        }
        return null;
    }
```

#### 数据流中的中位数

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。

```java
//前言：
//Java的PriorityQueue 是从JDK1.5开始提供的新的数据结构接口，默认内部是自然排序，结果为小顶堆，也可以自定义排序器，比如下面反转比较，完成大顶堆。
//
//思路：
//为了保证插入新数据和取中位数的时间效率都高效，这里使用大顶堆+小顶堆的容器，并且满足：
//        1、两个堆中的数据数目差不能超过1，这样可以使中位数只会出现在两个堆的交接处；
//        2、大顶堆的所有数据都小于小顶堆，这样就满足了排序要求。

    int count;
    PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();
    PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(11, new Comparator<Integer>() {
        @Override
        public int compare(Integer o1, Integer o2) {
            //PriorityQueue默认是小顶堆，实现大顶堆，需要反转默认排序器
            return o2.compareTo(o1);
        }
    });

    public void Insert(Integer num) {


        count++;
        if ((count & 1)==0){ // 判断偶数的高效写法

            if (!maxHeap.isEmpty() && num < maxHeap.peek()) {
                maxHeap.offer(num);
                num = maxHeap.poll();
            }
            minHeap.offer(num);

        } else{

            if (!minHeap.isEmpty() && num > minHeap.peek()) {
                minHeap.offer(num);
                num = minHeap.poll();
            }
            maxHeap.offer(num);
        }

    }

    public Double GetMedian() {

        if (count == 0)
            throw new RuntimeException("no available number!");
        double result;
        //总数为奇数时，大顶堆堆顶就是中位数
        if ((count & 1) == 1)
            result = maxHeap.peek();
        else
            result = (minHeap.peek() + maxHeap.peek()) / 2.0;
        return result;
    }

```

#### 滑动窗口的最大值

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。

```java
    /**
     * 用一个双端队列，队列第一个位置保存当前窗口的最大值，当窗口滑动一次
     * 1.判断当前最大值是否过期
     * 2.新增加的值从队尾开始比较，把所有比他小的值丢掉
     */
    public ArrayList<Integer> maxInWindows(int[] num, int size) {

        ArrayList<Integer> res = new ArrayList<>();
        if (size == 0) return res;
        int begin;
        ArrayDeque<Integer> q = new ArrayDeque<>();
        for (int i = 0; i < num.length; i++) {
            begin = i - size + 1;
            if (q.isEmpty())
                q.add(i);
            else if (begin > q.peekFirst())
                q.pollFirst();

            while ((!q.isEmpty()) && num[q.peekLast()] <= num[i])
                q.pollLast();
            q.add(i);
            if (begin >= 0)
                res.add(num[q.peekFirst()]);
        }
        return res;
    }
```

#### 矩阵中的路径

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。

```java
//
//回溯
//    基本思想：
//0.根据给定数组，初始化一个标志位数组，初始化为false，表示未走过，true表示已经走过，不能走第二次
//1.根据行数和列数，遍历数组，先找到一个与str字符串的第一个元素相匹配的矩阵元素，进入judge
//2.根据i和j先确定一维数组的位置，因为给定的matrix是一个一维数组
//3.确定递归终止条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的，这三类情况，都直接false，说明这条路不通
//4.若k，就是待判定的字符串str的索引已经判断到了最后一位，此时说明是匹配成功的
//5.下面就是本题的精髓，递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。
//6.走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。

    public boolean hasPath(char[] matrix, int rows, int cols, char[] str) {


//标志位，初始化为false
        boolean[] flag = new boolean[matrix.length];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                //循环遍历二维数组，找到起点等于str第一个元素的值，再递归判断四周是否有符合条件的----回溯法
                if (judge(matrix, i, j, rows, cols, flag, str, 0)) {
                    return true;
                }
            }
        }
        return false;

    }


    //judge(初始矩阵，索引行坐标i，索引纵坐标j，矩阵行数，矩阵列数，待判断的字符串，字符串索引初始为0即先判断字符串的第一位)
    private boolean judge(char[] matrix, int i, int j, int rows, int cols, boolean[] flag, char[] str, int k) {
        //先根据i和j计算匹配的第一个元素转为一维数组的位置
        int index = i * cols + j;
        //递归终止条件
        if (i < 0 || j < 0 || i >= rows || j >= cols || matrix[index] != str[k] || flag[index] == true)
            return false;
        //若k已经到达str末尾了，说明之前的都已经匹配成功了，直接返回true即可
        if (k == str.length - 1)
            return true;
        //要走的第一个位置置为true，表示已经走过了
        flag[index] = true;

        //回溯，递归寻找，每次找到了就给k加一，找不到，还原
        if (judge(matrix, i - 1, j, rows, cols, flag, str, k + 1) ||
                judge(matrix, i + 1, j, rows, cols, flag, str, k + 1) ||
                judge(matrix, i, j - 1, rows, cols, flag, str, k + 1) ||
                judge(matrix, i, j + 1, rows, cols, flag, str, k + 1)) {
            return true;
        }
        //走到这，说明这一条路不通，还原，再试其他的路径
        flag[index] = false;
        return false;
    }
```

#### 机器人的运动范围

地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？

```java
//思路：dfs,搜索四个方向，vis记录该方格是否被搜索过，
// 预判方格是否合法，合法就从该方格接着搜索
    public int movingCount(int threshold, int rows, int cols) {
        int[][] flag = new int[rows][cols]; //记录是否已经走过
        return helper(0, 0, rows, cols, flag, threshold);
    }

    private int helper(int i, int j, int rows, int cols, int[][] flag, int threshold) {
        if (i < 0 || i >= rows || j < 0 || j >= cols || numSum(i) + numSum(j) > threshold || flag[i][j] == 1) return 0;
        flag[i][j] = 1;
        return helper(i - 1, j, rows, cols, flag, threshold)
                + helper(i + 1, j, rows, cols, flag, threshold)
                + helper(i, j - 1, rows, cols, flag, threshold)
                + helper(i, j + 1, rows, cols, flag, threshold)
                + 1;
    }

    private int numSum(int i) {
        int sum = 0;
        do {
            sum += i % 10;
        } while ((i = i / 10) > 0);
        return sum;
    }
```


---
title: Spring MVC 原理 (二)
date: 2019-12-10 19:18:59
tags:
 - Java
 - 框架
categories:
 - Java
 - 框架
---

### @RequestBody和@ResponseBody

在SpringMVC的使用时，往往会用到@RequestBody和@ResponseBody两个注解，尤其是处理ajax请求必然要使用@ResponseBody注解。这两个注解对应着Controller方法的参数解析和返回值处理，开始时都是只知其用，不知原理。我们来看个例子。

```java
@RequestMapping("/requestBody")
public void requestBody(@RequestBody String body, Writer writer) throws IOException{
    writer.write(body);
}

@RequestMapping(value="/responseBody", produces="application/json")
@ResponseBody
public Map<String, Object> responseBody(){
    Map<String, Object> retMap = new HashMap<>();
    retMap.put("param1", "abc");
    return retMap;
}
```

第一个requestBody请求，使用@RequestBody将HTTP请求体转换成String类型，第二个responseBody请求，将Map对象转换成json格式输出到HTTP响应中。这两个请求方法没有什么特殊，就是一个在参数前加了@RequestBody注解，一个在方法上加了@ResponseBody注解。而这两个注解是怎么完成HTTP报文信息同Controller方法中对象的转换的呢？

SpringMVC处理请求和响应时，支持多种类型的请求参数和返回类型，而此种功能的实现就需要对HTTP消息体和参数及返回值进行转换，为此SpringMVC提供了大量的转换类，所有转换类都实现了HttpMessageConverter接口。

```java
public interface HttpMessageConverter<T> {

    // 当前转换器是否能将HTTP报文转换为对象类型
    boolean canRead(Class<?> clazz, MediaType mediaType);

    // 当前转换器是否能将对象类型转换为HTTP报文
    boolean canWrite(Class<?> clazz, MediaType mediaType);

    // 转换器能支持的HTTP媒体类型
    List<MediaType> getSupportedMediaTypes();

    // 转换HTTP报文为特定类型
    T read(Class<? extends T> clazz, HttpInputMessage inputMessage)
            throws IOException, HttpMessageNotReadableException;

    // 将特定类型对象转换为HTTP报文
    void write(T t, MediaType contentType, HttpOutputMessage outputMessage)
            throws IOException, HttpMessageNotWritableException;

}
```

HttpMessageConverter接口定义了5个方法，用于将HTTP请求报文转换为java对象，以及将java对象转换为HTTP响应报文。

对应到SpringMVC的Controller方法，read方法即是读取HTTP请求转换为参数对象，write方法即是将返回值对象转换为HTTP响应报文。SpringMVC定义了两个接口来操作这两个过程：参数解析器HandlerMethodArgumentResolver和返回值处理器HandlerMethodReturnValueHandler。

```java
// 参数解析器接口
public interface HandlerMethodArgumentResolver {

    // 解析器是否支持方法参数
    boolean supportsParameter(MethodParameter parameter);

    // 解析HTTP报文中对应的方法参数
    Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
            NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception;

}

// 返回值处理器接口
public interface HandlerMethodReturnValueHandler {

    // 处理器是否支持返回值类型
    boolean supportsReturnType(MethodParameter returnType);

    // 将返回值解析为HTTP响应报文
    void handleReturnValue(Object returnValue, MethodParameter returnType,
            ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;

}
```

参数解析器和返回值处理器在底层处理时，都是通过HttpMessageConverter进行转换。流程如下：

![lmbnjU.png](https://s2.ax1x.com/2019/12/28/lmbnjU.png)

SpringMVC为@RequestBody和@ResponseBody两个注解实现了统一处理类RequestResponseBodyMethodProcessor，实现了HandlerMethodArgumentResolver和HandlerMethodReturnValueHandler两个接口。

 由上一篇文章我们可以知道，Controller方法被封装成ServletInvocableHandlerMethod类，并且由invokeAndHandle方法完成请求处理。

```java
public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,
        Object... providedArgs) throws Exception {

    // 执行请求
    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
    
    // 返回值处理
    try {
        this.returnValueHandlers.handleReturnValue(
                returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
    }
    catch (Exception ex) {
        if (logger.isTraceEnabled()) {
            logger.trace(getReturnValueHandlingErrorMessage("Error handling return value", returnValue), ex);
        }
        throw ex;
    }
}

public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer,
        Object... providedArgs) throws Exception {
    // 参数解析
    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
    // invoke Controller方法
    Object returnValue = doInvoke(args);
    return returnValue;
}
```

在invoke Controller方法的前后分别执行了方法参数的解析和返回值的处理，我们分别来看。

#### 参数解析

```java
private Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer,
        Object... providedArgs) throws Exception {

    MethodParameter[] parameters = getMethodParameters();
    Object[] args = new Object[parameters.length];

    // 遍历所有参数，逐个解析
    for (int i = 0; i < parameters.length; i++) {
        MethodParameter parameter = parameters[i];
        parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
        args[i] = resolveProvidedArgument(parameter, providedArgs);
        if (args[i] != null) {
            continue;
        }

        // 参数解析器解析HTTP报文到参数
        if (this.argumentResolvers.supportsParameter(parameter)) {
            args[i] = this.argumentResolvers.resolveArgument(
                    parameter, mavContainer, request, this.dataBinderFactory);
            continue;
        }
    }
    return args;
}
```

getMethodArgumentValues方法中的argumentResolvers就是多个HandlerMethodArgumentResolver的集合体，supportsParameter方法寻找参数合适的解析器，resolveArgument调用具体解析器的resolveArgument方法执行。

我们从RequestResponseBodyMethodProcessor看看@RequestBody的解析过程。RequestResponseBodyMethodProcessor的supportsParameter定义了它支持的参数类型，即必须有@RequestBody注解。

```
public boolean supportsParameter(MethodParameter parameter) {
    return parameter.hasParameterAnnotation(RequestBody.class);
}
```

再来看resolveArgument方法

 

```java
public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {

    parameter = parameter.nestedIfOptional();
    // 通过HttpMessageConverter读取HTTP报文
    Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());
    String name = Conventions.getVariableNameForParameter(parameter);

    WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);
    if (arg != null) {
        validateIfApplicable(binder, parameter);
        if (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {
            throw new MethodArgumentNotValidException(parameter, binder.getBindingResult());
        }
    }
    mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());

    return adaptArgumentIfNecessary(arg, parameter);
}
```

具体实现由HttpMessageConverter来完成

```java
protected <T> Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter,
        Type targetType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {

    ....

    try {
        inputMessage = new EmptyBodyCheckingHttpInputMessage(inputMessage);

        for (HttpMessageConverter<?> converter : this.messageConverters) {
            Class<HttpMessageConverter<?>> converterType = (Class<HttpMessageConverter<?>>) converter.getClass();
            ....
            // 判断转换器是否支持参数类型
            if (converter.canRead(targetClass, contentType)) {
                if (inputMessage.getBody() != null) {
                    inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType);
                    // read方法执行HTTP报文到参数的转换
                    body = ((HttpMessageConverter<T>) converter).read(targetClass, inputMessage);
                    body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType);
                }
                else {
                    body = getAdvice().handleEmptyBody(null, inputMessage, parameter, targetType, converterType);
                }
                break;
            }
            ...
        }
    }
    catch (IOException ex) {
        throw new HttpMessageNotReadableException("I/O error while reading input message", ex);
    }

    ....

    return body;
}
```

代码部分省略了，关键部分即是遍历所有的HttpMessageConverter，通过canRead方法判断转换器是否支持对参数的转换，然后执行read方法完成转换。

#### 返回值处理

完成Controller方法的调用后，在ServletInvocableHandlerMethod的invokeAndHandle中，使用返回值处理器对返回值进行转换。

```
this.returnValueHandlers.handleReturnValue(
                returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
```

这里的returnValueHandlers也是HandlerMethodReturnValueHandler的集合体HandlerMethodReturnValueHandlerComposite

```java
public void handleReturnValue(Object returnValue, MethodParameter returnType,
        ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {

    // 选择合适的HandlerMethodReturnValueHandler，如果没有用@ResposeBody注解和用了注解其返回值处理器肯定不同
    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);
    if (handler == null) {
        throw new IllegalArgumentException("Unknown return value type: " + returnType.getParameterType().getName());
    }
    // 执行返回值处理
    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
}
```

selectHandler方法遍历所有HandlerMethodReturnValueHandler，调用其supportsReturnType方法选择合适的HandlerMethodReturnValueHandler，然后调用其handleReturnValue方法完成处理。

这里还是以RequestResponseBodyMethodProcessor来分析下@ResponseBody的处理，它的具体实现在AbstractMessageConverterMethodProcessor抽象基类中。

![lmjWAe.png](https://s2.ax1x.com/2019/12/28/lmjWAe.png)

```java
public boolean supportsReturnType(MethodParameter returnType) {
    return (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) ||
            returnType.hasMethodAnnotation(ResponseBody.class));
}
```

RequestResponseBodyMethodProcessor要求方法上有@ResponseBody注解或者方法所在的Controller类上有@ResponseBody的注解。这就是常常用@RestController注解代替@Controller注解的原因，因为@RestController注解自带@ResponseBody。

handleReturnValue方法实际也是调用HttpMessageConverter来完成转换处理

```java
public void handleReturnValue(Object returnValue, MethodParameter returnType,
        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)
        throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {

    mavContainer.setRequestHandled(true);
    ServletServerHttpRequest inputMessage = createInputMessage(webRequest);
    ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);

    // 调用HttpMessageConverter执行
    writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);
}

protected <T> void writeWithMessageConverters(T value, MethodParameter returnType,
        ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)
        throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {

    ....

    if (selectedMediaType != null) {
        selectedMediaType = selectedMediaType.removeQualityValue();
        for (HttpMessageConverter<?> messageConverter : this.messageConverters) {
            // 判断是否支持返回值类型，返回值类型很有可能不同，如String，Map，List等
            if (messageConverter.canWrite(valueType, selectedMediaType)) {
                outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,
                        (Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),
                        inputMessage, outputMessage);
                if (outputValue != null) {
                    addContentDispositionHeader(inputMessage, outputMessage);
                    // 执行返回值转换
                    ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);
                    ...
                }
                return;
            }
        }
    }
    ....
}
```

使用canWrite方法选择合适的HttpMessageConverter，然后调用write方法完成转换。

![lmjcnK.png](https://s2.ax1x.com/2019/12/28/lmjcnK.png)

 我们看看传入的参数 **ServletServerHttpResponse outputMessage** **= createOutputMessage(webRequest);**

```java
protected ServletServerHttpResponse createOutputMessage(NativeWebRequest webRequest) {
    //获取HttpServletResponse
    HttpServletResponse response = (HttpServletResponse)webRequest.getNativeResponse(HttpServletResponse.class);
    Assert.state(response != null, "No HttpServletResponse");
    return new ServletServerHttpResponse(response);
}

public class ServletServerHttpResponse implements ServerHttpResponse {
    private final HttpServletResponse servletResponse;
    private final HttpHeaders headers;
    private boolean headersWritten = false;
    private boolean bodyUsed = false;

    public ServletServerHttpResponse(HttpServletResponse servletResponse) {
        Assert.notNull(servletResponse, "HttpServletResponse must not be null");
        //将获取的HttpServletResponse作为ServletServerHttpResponse的属性值
        this.servletResponse = servletResponse;
        this.headers = new ServletServerHttpResponse.ServletResponseHttpHeaders();
    }
}

public interface ServletResponse {
    String getCharacterEncoding();

    String getContentType();
    
    //ServletResponse有一个输出流对象，保存需要相应客户端的字节流
    ServletOutputStream getOutputStream() throws IOException;

    PrintWriter getWriter() throws IOException;

    void setCharacterEncoding(String var1);

    void setContentLength(int var1);

    void setContentLengthLong(long var1);

    void setContentType(String var1);

    void setBufferSize(int var1);

    int getBufferSize();

    void flushBuffer() throws IOException;

    void resetBuffer();

    boolean isCommitted();

    void reset();

    void setLocale(Locale var1);

    Locale getLocale();
}
```

我们具体看看 **((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);**

```java
protected void writeInternal(Object obj, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {
    HttpHeaders headers = outputMessage.getHeaders();
    //创建一个数组字节流缓冲对象
    ByteArrayOutputStream outnew = new ByteArrayOutputStream();
    //将obj对象转换成JSON并写入ByteArrayOutputStream中
    int len = JSON.writeJSONString(outnew, this.fastJsonConfig.getCharset(), obj, this.fastJsonConfig.getSerializeConfig(), this.fastJsonConfig.getSerializeFilters(), this.fastJsonConfig.getDateFormat(), JSON.DEFAULT_GENERATE_FEATURE, this.fastJsonConfig.getSerializerFeatures());
    headers.setContentLength((long)len);
    //获取ServletResponse的输出流对象    
    OutputStream out = outputMessage.getBody();
    //将转换后的outnew写入ServletResponse的输出流对象，这样就可以给客户端响应数据了
    outnew.writeTo(out);
    outnew.close();
}

public OutputStream getBody() throws IOException {
    this.bodyUsed = true;
    this.writeHeaders();
    //获取ServletResponse的输出流对象    
    //ServletOutputStream getOutputStream() throws IOException;
    return this.servletResponse.getOutputStream();
}
```

![lmjdk4.png](https://s2.ax1x.com/2019/12/28/lmjdk4.png)

最后我们看看JSON是怎么将obj对象转换成JSON对象的流

![lmjwtJ.png](https://s2.ax1x.com/2019/12/28/lmjwtJ.png)

就是做一些循环拼接。

 至此我们基本走完了一个HTTP请求报文经过处理后到HTTP响应报文的转换过程。现在你可能有个疑惑，SpringMVC我们都是开箱即用，这些参数解析器和返回值处理器在哪里定义的呢？在核心的HandlerAdapter实现类RequestMappingHandlerAdapter的初始化方法中定义的。

而在RequestMappingHandlerAdapter构造时，也同时初始化了众多的HttpMessageConverter，以支持多样的转换需求。

```java
WebMvcConfigurationSupport.java

protected final void addDefaultHttpMessageConverters(List<HttpMessageConverter<?>> messageConverters) {
    StringHttpMessageConverter stringConverter = new StringHttpMessageConverter();
    stringConverter.setWriteAcceptCharset(false);

    messageConverters.add(new ByteArrayHttpMessageConverter());
    messageConverters.add(stringConverter);
    messageConverters.add(new ResourceHttpMessageConverter());
    messageConverters.add(new SourceHttpMessageConverter<Source>());
    messageConverters.add(new AllEncompassingFormHttpMessageConverter());

    if (romePresent) {
        messageConverters.add(new AtomFeedHttpMessageConverter());
        messageConverters.add(new RssChannelHttpMessageConverter());
    }

    if (jackson2XmlPresent) {
        ObjectMapper objectMapper = Jackson2ObjectMapperBuilder.xml().applicationContext(this.applicationContext).build();
        messageConverters.add(new MappingJackson2XmlHttpMessageConverter(objectMapper));
    }
    else if (jaxb2Present) {
        messageConverters.add(new Jaxb2RootElementHttpMessageConverter());
    }

    if (jackson2Present) {
        ObjectMapper objectMapper = Jackson2ObjectMapperBuilder.json().applicationContext(this.applicationContext).build();
        messageConverters.add(new MappingJackson2HttpMessageConverter(objectMapper));
    }
    else if (gsonPresent) {
        messageConverters.add(new GsonHttpMessageConverter());
    }
}
```

对于json或xml的转换方式，只要引入了jackson的依赖，即可自动发现，并注册相关的转换器。

```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.9.0</version>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-xml</artifactId>
    <version>2.9.0</version>
</dependency>
```

现在明白了SpringMVC做到了灵活又便捷的使用方式，其实在内部是做了大量的准备工作的。

### 异常的统一处理机制

SpringMVC除了对请求URL的路由处理特别方便外，还支持对异常的统一处理机制，可以对业务操作时抛出的异常，unchecked异常以及状态码的异常进行统一处理。SpringMVC既提供简单的配置类，也提供了细粒度的异常控制机制。

SpringMVC中所有的异常处理通过接口HandlerExceptionResolver来实现，接口中只定义了一个方法

```java
public interface HandlerExceptionResolver {

    ModelAndView resolveException(
        HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex);
}
```

方法中接受request和response信息，以及当前的处理Handler，和抛出的异常对象。并且提供抽象类AbstractHandlerExceptionResolver，实现resolveException方法，支持前置判断和处理，将实际处理抽象出doResolveException方法由子类来实现。

#### @ControllerAdvice和@ExceptionHandler的简单使用

```java
@ControllerAdvice
public class ExceptionAdvice {

    @ExceptionHandler({ArrayIndexOutOfBoundsException.class})
    @ResponseBody
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ResponseDTO handleArrayIndexOutOfBoundsException(ArrayIndexOutOfBoundsException e) {
        // TODO 记录log日志
        e.printStackTrace();
        ResponseDTO responseDTO = new ResponseDTO();
        responseDTO.wrapResponse(ServiceCodeEnum.E999997, "数组越界异常");

        return responseDTO;
    }

    @ExceptionHandler(value = ParamException.class)
    @ResponseBody
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ResponseDTO handleParamException(ParamException e) {
        // TODO 记录log日志
        e.printStackTrace();
        ResponseDTO responseDTO = new ResponseDTO();
        responseDTO.wrapResponse(ServiceCodeEnum.E999998, "输入参数错误");

        return responseDTO;
    }
  
    @ExceptionHandler({Exception.class})
    @ResponseBody
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ResponseDTO handleException(Exception e) {
        // TODO 记录log日志
        e.printStackTrace();
        ResponseDTO responseDTO = new ResponseDTO();
        responseDTO.wrapResponse(ServiceCodeEnum.E999999, "未知异常");
        return responseDTO;
    }

}
```

我们看看 @ControllerAdvice

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface ControllerAdvice {
    @AliasFor("basePackages")
    String[] value() default {};

    @AliasFor("value")
    String[] basePackages() default {};

    Class<?>[] basePackageClasses() default {};

    Class<?>[] assignableTypes() default {};

    Class<? extends Annotation>[] annotations() default {};
}
```

ControllerAdvice 被 @Component 修饰，则说明标记 @ControllerAdvice 会被扫描到容器中

Spring mvc 的配置如下(这里用到了**mvc:annotation-driven**)：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:cxf="http://cxf.apache.org/core"
    xmlns:p="http://cxf.apache.org/policy" xmlns:ss="http://www.springframework.org/schema/security"
    xmlns:jaxws="http://cxf.apache.org/jaxws" xmlns:jee="http://www.springframework.org/schema/jee"
    xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd 
    http://cxf.apache.org/core http://cxf.apache.org/schemas/core.xsd 
    http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd 
    http://cxf.apache.org/policy http://cxf.apache.org/schemas/policy.xsd
    http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd
    http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd
    http://cxf.apache.org/bindings/soap http://cxf.apache.org/schemas/configuration/soap.xsd 
    http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd 
    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">

    <context:component-scan
        base-package="frame.web.controller;frame.web.advice" />

    <!--===================== view resovler ===================== -->
    <bean id="jstlViewResolver"
        class="org.springframework.web.servlet.view.UrlBasedViewResolver">
        <property name="order" value="1" />
        <property name="viewClass"
            value="org.springframework.web.servlet.view.JstlView" />
        <property name="prefix" value="/WEB-INF/jsp/" />
    </bean>

    <mvc:annotation-driven/>


    <!-- 自定义参数转换 -->
    <bean id="conversionService"
        class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
    </bean>

</beans>
```

AnnotationDrivenBeanDefinitionParser类就是用于解析`<mvc:annotation-drive>`标签的。下面是AnnotationDrivenBeanDefinitionParser的部分源码：

```java
package org.springframework.web.servlet.config;

class AnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser {

    /**
    *parse是这个类的核心方法，它用于解析 annotation-drive标签里的内容，根据标签里的内容往spring ioc容器里注入具体的对象。
    **/
    @Override
    public BeanDefinition parse(Element element, ParserContext parserContext) {
        Object source = parserContext.extractSource(element);
        XmlReaderContext readerContext = parserContext.getReaderContext();

        CompositeComponentDefinition compDefinition = new CompositeComponentDefinition(element.getTagName(), source);
        parserContext.pushContainingComponent(compDefinition);

        RuntimeBeanReference contentNegotiationManager = getContentNegotiationManager(element, source, parserContext);
        //这里有我们熟悉的RequestMappingHandlerMapping，
        RootBeanDefinition handlerMappingDef = new RootBeanDefinition(RequestMappingHandlerMapping.class);
        handlerMappingDef.setSource(source);
        handlerMappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
        handlerMappingDef.getPropertyValues().add("order", 0);
        handlerMappingDef.getPropertyValues().add("contentNegotiationManager", contentNegotiationManager);

        if (element.hasAttribute("enable-matrix-variables")) {
            Boolean enableMatrixVariables = Boolean.valueOf(element.getAttribute("enable-matrix-variables"));
            handlerMappingDef.getPropertyValues().add("removeSemicolonContent", !enableMatrixVariables);
        }
        else if (element.hasAttribute("enableMatrixVariables")) {
            Boolean enableMatrixVariables = Boolean.valueOf(element.getAttribute("enableMatrixVariables"));
            handlerMappingDef.getPropertyValues().add("removeSemicolonContent", !enableMatrixVariables);
        }

        configurePathMatchingProperties(handlerMappingDef, element, parserContext);
        readerContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME , handlerMappingDef);

        RuntimeBeanReference corsConfigurationsRef = MvcNamespaceUtils.registerCorsConfigurations(null, parserContext, source);
        handlerMappingDef.getPropertyValues().add("corsConfigurations", corsConfigurationsRef);

        //这里会注入具体的ConversionService用于将json,xml转成Spring mvc里的请求和返回对象
        RuntimeBeanReference conversionService = getConversionService(element, source, parserContext);

        RuntimeBeanReference validator = getValidator(element, source, parserContext);
        RuntimeBeanReference messageCodesResolver = getMessageCodesResolver(element);

        RootBeanDefinition bindingDef = new RootBeanDefinition(ConfigurableWebBindingInitializer.class);
        bindingDef.setSource(source);
        bindingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
        bindingDef.getPropertyValues().add("conversionService", conversionService);
        bindingDef.getPropertyValues().add("validator", validator);
        bindingDef.getPropertyValues().add("messageCodesResolver", messageCodesResolver);

        ManagedList<?> messageConverters = getMessageConverters(element, source, parserContext);
        ManagedList<?> argumentResolvers = getArgumentResolvers(element, parserContext);
        ManagedList<?> returnValueHandlers = getReturnValueHandlers(element, parserContext);
        String asyncTimeout = getAsyncTimeout(element);
        RuntimeBeanReference asyncExecutor = getAsyncExecutor(element);
        ManagedList<?> callableInterceptors = getCallableInterceptors(element, source, parserContext);
        ManagedList<?> deferredResultInterceptors = getDeferredResultInterceptors(element, source, parserContext);
        //RequestMappingHandlerAdapter也会在这里注入
        RootBeanDefinition handlerAdapterDef = new RootBeanDefinition(RequestMappingHandlerAdapter.class);
        handlerAdapterDef.setSource(source);
        handlerAdapterDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
        handlerAdapterDef.getPropertyValues().add("contentNegotiationManager", contentNegotiationManager);
        handlerAdapterDef.getPropertyValues().add("webBindingInitializer", bindingDef);
        handlerAdapterDef.getPropertyValues().add("messageConverters", messageConverters);
        addRequestBodyAdvice(handlerAdapterDef);
        addResponseBodyAdvice(handlerAdapterDef);

        if (element.hasAttribute("ignore-default-model-on-redirect")) {
            Boolean ignoreDefaultModel = Boolean.valueOf(element.getAttribute("ignore-default-model-on-redirect"));
            handlerAdapterDef.getPropertyValues().add("ignoreDefaultModelOnRedirect", ignoreDefaultModel);
        }
        else if (element.hasAttribute("ignoreDefaultModelOnRedirect")) {
            // "ignoreDefaultModelOnRedirect" spelling is deprecated
            Boolean ignoreDefaultModel = Boolean.valueOf(element.getAttribute("ignoreDefaultModelOnRedirect"));
            handlerAdapterDef.getPropertyValues().add("ignoreDefaultModelOnRedirect", ignoreDefaultModel);
        }

        if (argumentResolvers != null) {
            handlerAdapterDef.getPropertyValues().add("customArgumentResolvers", argumentResolvers);
        }
        if (returnValueHandlers != null) {
            handlerAdapterDef.getPropertyValues().add("customReturnValueHandlers", returnValueHandlers);
        }
        if (asyncTimeout != null) {
            handlerAdapterDef.getPropertyValues().add("asyncRequestTimeout", asyncTimeout);
        }
        if (asyncExecutor != null) {
            handlerAdapterDef.getPropertyValues().add("taskExecutor", asyncExecutor);
        }

        handlerAdapterDef.getPropertyValues().add("callableInterceptors", callableInterceptors);
        handlerAdapterDef.getPropertyValues().add("deferredResultInterceptors", deferredResultInterceptors);
        readerContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME , handlerAdapterDef);

        String uriCompContribName = MvcUriComponentsBuilder.MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME;
        RootBeanDefinition uriCompContribDef = new RootBeanDefinition(CompositeUriComponentsContributorFactoryBean.class);
        uriCompContribDef.setSource(source);
        uriCompContribDef.getPropertyValues().addPropertyValue("handlerAdapter", handlerAdapterDef);
        uriCompContribDef.getPropertyValues().addPropertyValue("conversionService", conversionService);
        readerContext.getRegistry().registerBeanDefinition(uriCompContribName, uriCompContribDef);

        RootBeanDefinition csInterceptorDef = new RootBeanDefinition(ConversionServiceExposingInterceptor.class);
        csInterceptorDef.setSource(source);
        csInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, conversionService);
        RootBeanDefinition mappedCsInterceptorDef = new RootBeanDefinition(MappedInterceptor.class);
        mappedCsInterceptorDef.setSource(source);
        mappedCsInterceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
        mappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, (Object) null);
        mappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(1, csInterceptorDef);
        String mappedInterceptorName = readerContext.registerWithGeneratedName(mappedCsInterceptorDef);

        //这里有我们需要找的ExceptionHandlerExceptionResolver，
        RootBeanDefinition exceptionHandlerExceptionResolver = new RootBeanDefinition(ExceptionHandlerExceptionResolver.class);
        exceptionHandlerExceptionResolver.setSource(source);
        exceptionHandlerExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
        exceptionHandlerExceptionResolver.getPropertyValues().add("contentNegotiationManager", contentNegotiationManager);
        exceptionHandlerExceptionResolver.getPropertyValues().add("messageConverters", messageConverters);
        exceptionHandlerExceptionResolver.getPropertyValues().add("order", 0);
        addResponseBodyAdvice(exceptionHandlerExceptionResolver);

        if (argumentResolvers != null) {
            exceptionHandlerExceptionResolver.getPropertyValues().add("customArgumentResolvers", argumentResolvers);
        }
        if (returnValueHandlers != null) {
            exceptionHandlerExceptionResolver.getPropertyValues().add("customReturnValueHandlers", returnValueHandlers);
        }

        String methodExceptionResolverName = readerContext.registerWithGeneratedName(exceptionHandlerExceptionResolver);

        RootBeanDefinition responseStatusExceptionResolver = new RootBeanDefinition(ResponseStatusExceptionResolver.class);
        responseStatusExceptionResolver.setSource(source);
        responseStatusExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
        responseStatusExceptionResolver.getPropertyValues().add("order", 1);
        String responseStatusExceptionResolverName =
                readerContext.registerWithGeneratedName(responseStatusExceptionResolver);

        RootBeanDefinition defaultExceptionResolver = new RootBeanDefinition(DefaultHandlerExceptionResolver.class);
        defaultExceptionResolver.setSource(source);
        defaultExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
        defaultExceptionResolver.getPropertyValues().add("order", 2);
        String defaultExceptionResolverName =
                readerContext.registerWithGeneratedName(defaultExceptionResolver);

        parserContext.registerComponent(new BeanComponentDefinition(handlerMappingDef, HANDLER_MAPPING_BEAN_NAME));
        parserContext.registerComponent(new BeanComponentDefinition(handlerAdapterDef, HANDLER_ADAPTER_BEAN_NAME));
        parserContext.registerComponent(new BeanComponentDefinition(uriCompContribDef, uriCompContribName));
        parserContext.registerComponent(new BeanComponentDefinition(exceptionHandlerExceptionResolver, methodExceptionResolverName));
        parserContext.registerComponent(new BeanComponentDefinition(responseStatusExceptionResolver, responseStatusExceptionResolverName));
        parserContext.registerComponent(new BeanComponentDefinition(defaultExceptionResolver, defaultExceptionResolverName));
        parserContext.registerComponent(new BeanComponentDefinition(mappedCsInterceptorDef, mappedInterceptorName));

        // Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not "turned off"
        MvcNamespaceUtils.registerDefaultComponents(parserContext, source);

        parserContext.popAndRegisterContainingComponent();

        return null;
    }
}
```

通过上面代码的分析， 我们可以找到ExceptionHandlerExceptionResolver这个类来用于处理Spring MVC的各种异常，那ExceptionHandlerExceptionResolver具体又是如何跟ControllerAdvice配合使用来处理各种异常的呢?我们来看看ExceptionHandlerExceptionResolver里的关键代码：

```java
package org.springframework.web.servlet.mvc.method.annotation;

//我们考到这个类实现了InitializingBean，则容器初始化的时候在实例化此Bean后会调用afterPropertiesSet()
public class ExceptionHandlerExceptionResolver extends AbstractHandlerMethodExceptionResolver
        implements ApplicationContextAware, InitializingBean {
    //这里有个map用于保存ControllerAdviceBean和ExceptionHandlerMethodResolver
    private final Map<ControllerAdviceBean, ExceptionHandlerMethodResolver> exceptionHandlerAdviceCache =
            new LinkedHashMap<ControllerAdviceBean, ExceptionHandlerMethodResolver>();

    //这个方法是由spring 容器调用的
    @Override
    public void afterPropertiesSet() {
        // Do this first, it may add ResponseBodyAdvice beans
        //这个方法里会处理ExceptionHandler
        initExceptionHandlerAdviceCache();

        if (this.argumentResolvers == null) {
            List<HandlerMethodArgumentResolver> resolvers = getDefaultArgumentResolvers();
            this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
        }
        if (this.returnValueHandlers == null) {
            List<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();
            this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);
        }
    }

    /**
    *这个方法里会在spring ioc容器里找出标注了@ControllerAdvice的类，如果有方法标注了@ExceptionHandler会生成一个ExceptionHandlerMethodResolver类用于处理异常并放到exceptionHandlerAdviceCache这个map缓存类里。
    **/
    private void initExceptionHandlerAdviceCache() {
        if (getApplicationContext() == null) {
            return;
        }
        if (logger.isDebugEnabled()) {
            logger.debug("Looking for exception mappings: " + getApplicationContext());
        }
        //这里会找到容器里标注了@ControllerAdvice注解的类
        List<ControllerAdviceBean> adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());
        AnnotationAwareOrderComparator.sort(adviceBeans);

        for (ControllerAdviceBean adviceBean : adviceBeans) {
            //这个构造方法里会检查ControllerAdvice类里是否有@ExceptionHandler标注的方法，在ExceptionHandlerMethodResolver 有个异常的map。
            //在ExceptionHandlerMethodResolver构造器中会通过反射拿到所有标注@ExceptionHandler的方法并加入ExceptionHandlerMethodResolver的map中
            //key为  @ExceptionHandler(value = ParamException.class) 标注的value,这里就是ParamException.class，值为标注@ExceptionHandler的Method
            ExceptionHandlerMethodResolver resolver = new ExceptionHandlerMethodResolver(adviceBean.getBeanType());
            if (resolver.hasExceptionMappings()) {
                //如果有@ExceptionHandler方法，会执行下面的逻辑
                //将标注@ControllerAdvice的类Bean，和此Bean中封装了所有Exception为key，Method为value的Map的ExceptionHandlerMethodResolver对象加入到exceptionHandlerAdviceCache的缓存中
                this.exceptionHandlerAdviceCache.put(adviceBean, resolver);
                if (logger.isInfoEnabled()) {
                    logger.info("Detected @ExceptionHandler methods in " + adviceBean);
                }
            }
            if (ResponseBodyAdvice.class.isAssignableFrom(adviceBean.getBeanType())) {
                this.responseBodyAdvice.add(adviceBean);
                if (logger.isInfoEnabled()) {
                    logger.info("Detected ResponseBodyAdvice implementation in " + adviceBean);
                }
            }
        }
    }

    /**
    ** 这个方法会根据exceptionHandlerAdviceCache这个找到具体需要处理异常的方法，这个后面再讲
    */
    protected ServletInvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception) {
        Class<?> handlerType = (handlerMethod != null ? handlerMethod.getBeanType() : null);

        if (handlerMethod != null) {
            ExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.get(handlerType);
            if (resolver == null) {
                resolver = new ExceptionHandlerMethodResolver(handlerType);
                this.exceptionHandlerCache.put(handlerType, resolver);
            }
            Method method = resolver.resolveMethod(exception);
            if (method != null) {
                return new ServletInvocableHandlerMethod(handlerMethod.getBean(), method);
            }
        }

        for (Entry<ControllerAdviceBean, ExceptionHandlerMethodResolver> entry : this.exceptionHandlerAdviceCache.entrySet()) {
            if (entry.getKey().isApplicableToBeanType(handlerType)) {
                ExceptionHandlerMethodResolver resolver = entry.getValue();
                //根据具体的异常找到处理异常的方法，然后调用
                Method method = resolver.resolveMethod(exception);
                if (method != null) {
                    return new ServletInvocableHandlerMethod(entry.getKey().resolveBean(), method);
                }
            }
        }

        return null;
    }
}
```

我们来看看 ExceptionHandlerMethodResolver这个类

```java
public class ExceptionHandlerMethodResolver {
    public static final MethodFilter EXCEPTION_HANDLER_METHODS = new MethodFilter() {
        public boolean matches(Method method) {
            return AnnotationUtils.findAnnotation(method, ExceptionHandler.class) != null;
        }
    };
    private static final Method NO_METHOD_FOUND = ClassUtils.getMethodIfAvailable(System.class, "currentTimeMillis", new Class[0]);
    //此缓存Map存放了@ControllerAdvice中所有注解了@ExceptionHandler的方法，其中@ExceptionHandler的value也就是Exception做为Key，值为当前Method
    private final Map<Class<? extends Throwable>, Method> mappedMethods = new ConcurrentHashMap(16);
    private final Map<Class<? extends Throwable>, Method> exceptionLookupCache = new ConcurrentHashMap(16);

    public ExceptionHandlerMethodResolver(Class<?> handlerType) {
        //通过反射拿到当前Class的所有方法，也就是标注了@ControllerAdvice的所有方法
        Iterator var2 = MethodIntrospector.selectMethods(handlerType, EXCEPTION_HANDLER_METHODS).iterator();

        //遍历所有的方法，寻找标注了@ExceptionHandler的方法
        while(var2.hasNext()) {
            Method method = (Method)var2.next();
            //这里获取到标注了@ExceptionHandler的方法上所有的@ExceptionHandler中的value
            //如{ArrayIndexOutOfBoundsException.class,ParamException.calss}
            Iterator var4 = this.detectExceptionMappings(method).iterator();

            while(var4.hasNext()) {
                Class<? extends Throwable> exceptionType = (Class)var4.next();
                //将ArrayIndexOutOfBoundsException.class作为key,method做为value加入到map缓存中
                this.addExceptionMapping(exceptionType, method);
            }
        }

    }
    
    private List<Class<? extends Throwable>> detectExceptionMappings(Method method) {
        List<Class<? extends Throwable>> result = new ArrayList();
        //这里获取到标注了@ExceptionHandler的方法上所有的@ExceptionHandler中的value
        //如{ArrayIndexOutOfBoundsException.class,ParamException.calss}
        this.detectAnnotationExceptionMappings(method, result);
        if (result.isEmpty()) {
            Class[] var3 = method.getParameterTypes();
            int var4 = var3.length;

            for(int var5 = 0; var5 < var4; ++var5) {
                Class<?> paramType = var3[var5];
                if (Throwable.class.isAssignableFrom(paramType)) {
                    result.add(paramType);
                }
            }
        }

        Assert.notEmpty(result, "No exception types mapped to {" + method + "}");
        return result;
    }
    
    protected void detectAnnotationExceptionMappings(Method method, List<Class<? extends Throwable>> result) {
        //判断此方法是否标记@ExceptionHandler，如果没有则返回null，如果有标记则返回ExceptionHandler
        ExceptionHandler ann = (ExceptionHandler)AnnotationUtils.findAnnotation(method, ExceptionHandler.class);
        //获取ExceptionHandler注解的所有值，这里是一个数组，有可能有多个，如@ExceptionHandler({ArrayIndexOutOfBoundsException.class,ParamException.calss})
        result.addAll(Arrays.asList(ann.value()));
    }

}
```

#### 异常处理原理

SpringMVC怎么在请求处理的过程中完成对异常的统一处理的呢？我们从源码来深度解读。

回到DispatcherServlet的doDispatcher方法

```java
try {
    processedRequest = checkMultipart(request);
    multipartRequestParsed = (processedRequest != request);

    // Determine handler for the current request.
    mappedHandler = getHandler(processedRequest);
    if (mappedHandler == null || mappedHandler.getHandler() == null) {
        noHandlerFound(processedRequest, response);
        return;
    }

    // Determine handler adapter for the current request.
    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

    if (!mappedHandler.applyPreHandle(processedRequest, response)) {
        return;
    }

    // Actually invoke the handler.
    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

    if (asyncManager.isConcurrentHandlingStarted()) {
        return;
    }

    applyDefaultViewName(processedRequest, mv);
    mappedHandler.applyPostHandle(processedRequest, response, mv);
}
catch (Exception ex) {
    dispatchException = ex;
}
catch (Throwable err) {
    dispatchException = new NestedServletException("Handler dispatch failed", err);
}
processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
```

可以看到对请求处理的核心处理使用一个大的try/catch，如果出现异常，统一封装成dispatchException交给processDispatchResult方法进行处理。我们知道processDispatchResult方法用来对返回视图进行操作，而同时也对异常进行统一处理。

在processDispatchResult中，首先对异常进行判断。

```java
if (exception != null) {
    if (exception instanceof ModelAndViewDefiningException) {
        logger.debug("ModelAndViewDefiningException encountered", exception);
        mv = ((ModelAndViewDefiningException) exception).getModelAndView();
    }
    else {
        Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
        mv = processHandlerException(request, response, handler, exception);
        errorView = (mv != null);
    }
}
```

如果不是特殊的ModelAndViewDefiningException，则由processHandlerException来操作。

```java
protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,
        Object handler, Exception ex) throws Exception {

    // Check registered HandlerExceptionResolvers...
    ModelAndView exMv = null;
    // 遍历所有注册的异常处理器，由异常处理器进行处理
    for (HandlerExceptionResolver handlerExceptionResolver : this.handlerExceptionResolvers) {
        exMv = handlerExceptionResolver.resolveException(request, response, handler, ex);
        if (exMv != null) {
            break;
        }
    }
    // 如果异常视图存在，则转向异常视图
    if (exMv != null) {
        if (exMv.isEmpty()) {
            request.setAttribute(EXCEPTION_ATTRIBUTE, ex);
            return null;
        }
        // We might still need view name translation for a plain error model...
        if (!exMv.hasView()) {
            exMv.setViewName(getDefaultViewName(request));
        }
        if (logger.isDebugEnabled()) {
            logger.debug("Handler execution resulted in exception - forwarding to resolved error view: " + exMv, ex);
        }
        WebUtils.exposeErrorRequestAttributes(request, ex, getServletName());
        return exMv;
    }

    throw ex;
}
```

我们主要关注异常处理器对异常的处理，SpringMVC通过HandlerExceptionResolver的resolveException调用实现类的实际实现方法doResolveException。

#### ExceptionHandlerExceptionResolver

ExceptionHandlerExceptionResolver支持了@ExceptionHandler注解的实现。它的抽象基类AbstractHandlerMethodExceptionResolver继承了AbstractHandlerExceptionResolver，doResolveException方法实际调用ExceptionHandlerExceptionResolver的doResolveHandlerMethodException方法。

```java
protected final ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
    return this.doResolveHandlerMethodException(request, response, (HandlerMethod)handler, ex);
}

protected ModelAndView doResolveHandlerMethodException(HttpServletRequest request,
        HttpServletResponse response, HandlerMethod handlerMethod, Exception exception) {

    // 根据HandlerMethod和exception获取异常处理的Method
    ServletInvocableHandlerMethod exceptionHandlerMethod = getExceptionHandlerMethod(handlerMethod, exception);
    if (exceptionHandlerMethod == null) {
        return null;
    }

    // 设置异常处理方法的参数解析器和返回值解析器
    exceptionHandlerMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
    exceptionHandlerMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);

    ServletWebRequest webRequest = new ServletWebRequest(request, response);
    ModelAndViewContainer mavContainer = new ModelAndViewContainer();

    // 执行异常处理方法
    try {
        if (logger.isDebugEnabled()) {
            logger.debug("Invoking @ExceptionHandler method: " + exceptionHandlerMethod);
        }
        Throwable cause = exception.getCause();
        if (cause != null) {
            // Expose cause as provided argument as well
            exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, cause, handlerMethod);
        }
        else {
            // Otherwise, just the given exception as-is
            exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, handlerMethod);
        }
    }
    catch (Throwable invocationEx) {
        // Any other than the original exception is unintended here,
        // probably an accident (e.g. failed assertion or the like).
        if (invocationEx != exception && logger.isWarnEnabled()) {
            logger.warn("Failed to invoke @ExceptionHandler method: " + exceptionHandlerMethod, invocationEx);
        }
        // Continue with default processing of the original exception...
        return null;
    }

    // 对返回的视图模型进行处理
    if (mavContainer.isRequestHandled()) {
        return new ModelAndView();
    }
    else {
        ModelMap model = mavContainer.getModel();
        HttpStatus status = mavContainer.getStatus();
        ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, status);
        mav.setViewName(mavContainer.getViewName());
        if (!mavContainer.isViewReference()) {
            mav.setView((View) mavContainer.getView());
        }
        if (model instanceof RedirectAttributes) {
            Map<String, ?> flashAttributes = ((RedirectAttributes) model).getFlashAttributes();
            request = webRequest.getNativeRequest(HttpServletRequest.class);
            RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);
        }
        return mav;
    }
}
```

我们主要关注的是如何匹配到异常处理方法的，也就是 **ExceptionHandlerExceptionResolver中的** **getExceptionHandlerMethod**

```java
protected ServletInvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception) {
    Class<?> handlerType = (handlerMethod != null ? handlerMethod.getBeanType() : null);

    // 从当前Controller中匹配异常处理Method，此处我们暂时不分析
    if (handlerMethod != null) {
        ExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.get(handlerType);
        if (resolver == null) {
            resolver = new ExceptionHandlerMethodResolver(handlerType);
            this.exceptionHandlerCache.put(handlerType, resolver);
        }
        Method method = resolver.resolveMethod(exception);
        if (method != null) {
            return new ServletInvocableHandlerMethod(handlerMethod.getBean(), method);
        }
    }

    // 从ControllerAdvice中匹配异常处理Method
    // 我们知道容器初始化的时候，已经寻找所有标注了@ControllerAdvice的类，并将此类标注了@ExceptionHandler的方法放到当前类的exceptionHandlerAdviceCache中
    //遍历所有的@ControllerAdvice生成的缓存
    for (Entry<ControllerAdviceBean, ExceptionHandlerMethodResolver> entry : this.exceptionHandlerAdviceCache.entrySet()) {
        if (entry.getKey().isApplicableToBeanType(handlerType)) {
            //拿到ExceptionHandlerMethodResolver，这个对象里包含了标注为@ExceptionHandler的Key为Excpthion，value为Method的缓存Map
            ExceptionHandlerMethodResolver resolver = entry.getValue();
            //寻找ExceptionHandlerMethodResolver有没有标注@ExceptionHandler能匹配当前异常的方法
            Method method = resolver.resolveMethod(exception);
            if (method != null) {
                return new ServletInvocableHandlerMethod(entry.getKey().resolveBean(), method);
            }
        }
    }

    return null;
}

public Method resolveMethod(Exception exception) {
    Method method = this.resolveMethodByExceptionType(exception.getClass());
    if (method == null) {
        Throwable cause = exception.getCause();
        if (cause != null) {
            method = this.resolveMethodByExceptionType(cause.getClass());
        }
    }

    return method;
}

public Method resolveMethodByExceptionType(Class<? extends Throwable> exceptionType) {
    //先从exceptionLookupCache缓存中拿，第一次肯定拿不到，因为我们是存在mappedMethods这个缓存中
    Method method = (Method)this.exceptionLookupCache.get(exceptionType);
    if (method == null) {
        method = this.getMappedMethod(exceptionType);
        this.exceptionLookupCache.put(exceptionType, method != null ? method : NO_METHOD_FOUND);
    }

    return method != NO_METHOD_FOUND ? method : null;
}

private Method getMappedMethod(Class<? extends Throwable> exceptionType) {
    List<Class<? extends Throwable>> matches = new ArrayList();
    //拿到所有的Key
    Iterator var3 = this.mappedMethods.keySet().iterator();

    while(var3.hasNext()) {
        Class<? extends Throwable> mappedException = (Class)var3.next();
        //判断exceptionType是不是mappedException本身或者其子类
        if (mappedException.isAssignableFrom(exceptionType)) {
            matches.add(mappedException);
        }
    }

    if (!matches.isEmpty()) {
        Collections.sort(matches, new ExceptionDepthComparator(exceptionType));
        //返回匹配到异常的Method
        return (Method)this.mappedMethods.get(matches.get(0));
    } else {
        return null;
    }
}
```

匹配到exceptionHandlerMethod后，设置一些方法执行的环境，然后调用ServletInvocableHandlerMethod中的invokeAndHandle去执行，这个调用过程和正常请求的调用就是一致了。

```
  exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, new Object[]{exception, cause, handlerMethod});
```

这里就是调用异常处理的方法，总体来说，就是SpringMvc启动的时候初始化异常处理的组件，将 @ControllerAdvice标记的特殊类和@ExceptionHandler 标记的方法存入缓存中，当目标Controller出现异常的时候，就通过抛出的异常在缓存中找到对应的处理方法，然后去调用对应的异常处理方法就OK了。
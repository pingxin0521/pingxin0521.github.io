---
title: Linux-文本处理三剑客--sed
date: 2019-03-20 16:56:22
tags: 
 - Linux
category: 
 - Linux
 - 基础
---

sed是一种流编编器，它是文本处理中非常中的工具，能够完美的配合正则表达式便用，功物能不同凡响。

![image.png](https://i.loli.net/2019/10/10/Bls6LD7VargdMAF.png)

处理时，把当前处理的行存储在临时缓冲区中，称为”模式空间”（ oattern space），接看用sed命令处理缓冲区中的内容，处理成后，把缓冲区的内容送往屏幕显示。

<!--more-->

接着理下一行，这样不断重复，直到文件末。文件内容没有改改变，除非使用了写入的命令，将内容更新。

定址用于决定对哪些行进行编辑。地址的形式可以是数字、正则表达式、或二者的结合。如果没有指定地址，sed将处理输入文件的所有行。

Sed 主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序

**命令格式**

```
sed [options] 'command' file(s)
sed [options] -f scriptfile file(s)
```

注：sed 和 grep 不一样，不管是否找到指定的模式，它的退出状态都是 0

只有当命令存在语法错误时，sed 的退出状态才是非

> 可以通过定址来定位你所希望编辑的行，该地址用数字构成，用逗号分隔的两个行数表示以这两行为起止的行的范围（包括行数表示的那两行）。如1，3表示1，2，3行，美元符号($)表示最后一行。范围可以通过数据，正则表达式或者二者结合的方式确定 。

**支持正则表达式**

与 grep 一样，sed 在文件中查找模式时也可以使用正则表达式(RE)和各种元字符。正则表达
式是
括在斜杠间的模式，用于查找和替换，以下是 sed 支持的元字符。
使用基本元字符集 `^, $, ., *, [], [^], \< \>,\(\),\{\}`
使用扩展元字符集 `?, +, { }, |, ( )`
使用扩展元字符的方式：

```
\+
sed -r
```

| 元字符   | 功 能                         | 示 例          | 示例的匹配对象                                               |
| -------- | ----------------------------- | -------------- | ------------------------------------------------------------ |
| ^        | 行首定位符                    | /^love/        | 匹配所有以 love 开头的行                                     |
| $        | 行尾定位符                    | /love$/        | 匹配所有以 love 结尾的行                                     |
| .        | 匹配除换行外的单 个字符       | /l..e/         | 匹配包含字符 l、后跟两个任意 字符、再跟字母 e 的行           |
| *        | 匹配零个或多个前 导字符       | /*love/        | 匹配在零个或多个空格紧跟着 模式 love 的行                    |
| []       | 匹配指定字符组内 任一字符     | /[Ll]ove/      | 匹配包含 love 和 Love 的行                                   |
| [^]      | 匹配不在指定字符 组内任一字符 | /[^A-KM-Z]ove/ | 匹配包含 ove，但 ove 之前的那 个字符不在 A 至 K 或 M 至 Z 间 的行 |
| \(..\)   | 保存已匹配的字符              |                |                                                              |
| &        | 保存查找串以便在 替换串中引用 | s/love/**&**/  | 符号&代表查找串。字符串 love 将替换前后各加了两个**的引 用，即 love 变成**love** |
| \<       | 词首定位符                    | /\<love/       | 匹配包含以 love 开头的单词的 行                              |
| \>       | 词尾定位符                    | /love\>/       | 匹配包含以 love 结尾的单词的 行                              |
| x\{m\}   | 连续 m 个 x                   | /o\{5\}/       | 分别匹配出现连续 5 个字母 o、 至少 5 个连续的 o、或 5~10 个 连续的 o 的行 |
| x\{m,\}  | 至少 m 个 x                   | /o\{5,\}/      |                                                              |
| x\{m,n\} | 至少 m 个 x，但不 超过 n 个 x | /o\{5,10\}/    |                                                              |

**sed操作命令**

sed 操作命令告诉 sed 如何处理由地址指定的各输入行。如果没有指定地址， sed 就会处理输入的所有的行

| 命 令 | 说 明                                                        |
| ----- | ------------------------------------------------------------ |
| a\    | 在当前行后添加一行或多行                                     |
| c\    | 用新文本修改（替换）当前行中的文本                           |
| d     | 删除行                                                       |
| i\    | 在当前行之前插入文本                                         |
| h     | 把模式空间里的内容复制到暂存缓存区                           |
| H     | 把模式空间里的内容追加到暂存缓存区                           |
| g     | 取出暂存缓冲区里的内容，将其复制到模式空间，覆盖该处原有内容 |
| G     | 取出暂存缓冲区里的内容，将其复制到模式空间，追加在原有内容后面 |
| l     | 列出非打印字符                                               |
| p     | 打印行                                                       |
| n     | 读入下一输入行，并从下一条命令而不是第一条命令开始处理       |
| q     | 结束或退出 sed                                               |
| r     | 从文件中读取输入行                                           |
| ！    | 对所选行意外的所有行应用命令                                 |
| s     | 用一个字符串替换另一个                                       |

替换标志

| g    | 在行内进行全局替换                                  |
| ---- | --------------------------------------------------- |
| p    | 打印行                                              |
| w    | 将行写入文件                                        |
| x    | 交换暂存缓冲区与模式空间的内容                      |
| y    | 将字符转换为另一字符（不能对正则表达式使用 y 命令） |

**sed常用选项**

| 选项 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| -n   | 使用安静模式，在一般情况所有的 STDIN 都会输出到屏幕上，加入-n 后只打印 被 sed 特殊处理的行 |
| -e   | 多重编辑，且命令顺序会影响结果                               |
| -f   | 指定一个 sed 脚本文件到命令行执行，                          |
| -r   | Sed 使用扩展正则                                             |
| -i   | 直接修改文档读取的内容，不在屏幕上输出                       |

#### 常用的命令展示

**替换标记**

```
１）g表示行内全面替换。    
２）p表示打印行。    
３）w表示把行写入一个文件。    
４）x表示互换模板块中的文本和缓冲区中的文本。    
５）y表示把一个字符翻译为另外的字符（但是不用于正则表达式
```

**删除：d命令**

```
$ sed '2d' example-----删除example文件的第二行。            
$ sed '2,$d' example-----删除example文件的第二行到末尾所有行。    
$ sed '$d' example-----删除example文件的最后一行。    
$ sed '/test/'d example-----删除example文件所有包含test的行。
```

**替换：s命令**

```
a)   sed 's/test/mytest/g' example-----在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest。    
b)   $ sed -n 's/^test/mytest/p' example-----(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。      
c)   $ sed 's/^192.168.0.1/&localhost/' example-----&符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加 localhost，变成192.168.0.1localhost。    
d)   $ sed -n 's/\(love\)able/\1rs/p' example-----love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。    
e)   $ sed 's#10#100#g' example-----不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。    
f)   选定行的范围：逗号    
g)   $ sed -n '/test/,/check/p' example-----所有在模板test和check所确定的范围内的行都被打印。    
h)   $ sed -n '5,/^test/p' example-----打印从第五行开始到第一个包含以test开始的行之间的所有行。    
i)   $ sed '/test/,/check/s/$/sed test/' example-----对于模板test和west之间的行，每行的末尾用字符串sed test替换。  
j) $ sed 's/^\(.\)/\u\1/'  example ---------将每行开头的第一个字母换成大写
```

**编辑：e命令**

```
a)  $ sed -e '1,5d' -e 's/test/check/' example-----(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执 行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。    
b)  $ sed --expression='s/test/check/' --expression='/love/d' example-----一个比-e更好的命令是--expression。它能给sed表达式赋值。
```

**从文件读入：r命令**

```
a)  $ sed '/test/r file' example-----file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。    
b)  写入文件：w命令    
c)  $ sed -n '/test/w file' example-----在example中所有包含test的行都被写入file里。
```

**追加命令：a命令**

```
a)   $ sed '/^test/a\\--->this is a example' example<-----'this is a example'被追加到以test开头的行后面，sed要求命令a后面有一个反斜杠。
```

**插入：i命令**

```bash
a)  $ sed '/test/i\\    
b)  new line    
c)  -------------------------' example    
d)  如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。  
```

**下一个n命令**

```bash
a)  $ sed '/test/{ n; s/aa/bb/; }' example-----如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。    
```

**变形：y命令**

```ruby
a)  $ sed '1,10y/abcde/ABCDE/' example-----把1--10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。    
```

**退出：q命令**

```ruby
a)  $ sed '10q' example-----打印完第10行后，退出sed。  
```

**保持和获取：h命令和G命令**

```ruby
a)  $ sed -e '/test/h' -e '$G' example
```

**示例**

sed擅长行输出，附源文件：

```
hhh     pts/1        192.168.25.1     Sat Jun 30 22:04   still logged in  
reboot   system boot  2.6.32-358.el6.i Sat Jun 30 22:04 - 22:43  (00:38)    
omc     pts/0        192.168.25.1     Sat Jun 30 20:16 - down   (00:00)    
reboot   system boot  2.6.32-358.el6.i Sat Jun 30 19:38 - 20:16  (00:37)    
root     pts/1        192.168.25.1     Sat Jun 30 12:20 - down   (00:55)    
root     pts/0        192.168.25.1     Sat Jun 30 11:53 - down   (01:22)    
reboot   system boot  2.6.32-358.el6.i Sat Jun 30 11:52 - 13:15  (01:23)    
root     pts/0        192.168.25.1     Sat Jun 30 05:40 - down   (02:51)    
reboot   system boot  2.6.32-358.el6.i Sat Jun 30 05:38 - 08:32  (02:54)    
root     pts/0        192.168.25.1     Fri Jun 29 21:01 - down   (06:21)    
 
wtmp begins Tue Jun  9 03:57:56 2015
```

1. 只打印第三行

   ```
   sed -n '3p' test
   ```

2. 只查看文件的第3行到第9行

   ```
   sed -n '3,9p' test
   ```

3. 过滤特定字符串,显示正行内容  

   ```
   sed -n '/root/p' test 
   ```

4. 显示包含"hhh"的行到包含"omc"的行之间的行

   ```
   sed -n '/hhh/,/omc/p' test
   ```

5. 打印1-5行，并显示行号

   ```
   sed -n -e '1,5p' -e '=' test
   ```

6. 仅仅显示匹配字符串的行号

   ```
   sed -n '/root/p' test
   ```

7. 打印匹配行的内容和符号【相当于后面又根据关键词查询了一次】

   ```
   sed -n -e '/root/p' -e '/root/='  test
   ```

8. 用world 替换yum.log文件中的root

   ```
   sed -i 's/root/world/g' test
   ==>sed -i 's#hhh#HHHH#g' h.txt     与上同
                 s==search  查找并替换
                 g==global  全部替换
                 -i: implace
   ```

9. 打印最后一行

   ```
   sed -n '$p' test
   ```

10. 打印1-5行，并显示行号

    ```
    sed -n -e '1,5p' -e '=' test
    ```

#### 参考

1.[https://www.cnblogs.com/ginvip/p/6376049.html](https://www.cnblogs.com/ginvip/p/6376049.html)
---
title: Shiro 学习（三）
date: 2019-11-20 17:18:59
tags:
 - Java
 - 框架
categories:
 - Java
 - 框架
---

### Web 集成

Shiro 提供了与 Web 集成的支持，其通过一个 ShiroFilter 入口来拦截需要安全控制的 URL，然后进行相应的控制，ShiroFilter 类似于如 Strut2/SpringMVC 这种 web 框架的前端控制器，其是安全控制的入口点，其负责读取配置（如 ini 配置文件），然后判断 URL 是否需要登录 / 权限等工作。

1. 创建 webapp 应用

   此处我们使用了 jetty-maven-plugin 插件；这样可以直接使用 “mvn jetty:run”直接运行 webapp 了

2. 依赖

   ```xml
           <dependency>
               <groupId>org.apache.shiro</groupId>
               <artifactId>shiro-web</artifactId>
               <version>1.2.5</version>
           </dependency>
           <dependency>
               <groupId>javax.servlet</groupId>
               <artifactId>javax.servlet-api</artifactId>
               <version>3.0.1</version>
               <scope>provided</scope>
           </dependency>
   ```

#### ShiroFilter 入口

1. Shiro 1.1 及以前版本配置方式

   ```xml
   <filter>
       <filter-name>iniShiroFilter</filter-name>
       <filter-class>org.apache.shiro.web.servlet.IniShiroFilter</filter-class>
       <init-param>
           <param-name>configPath</param-name>
           <param-value>classpath:shiro.ini</param-value>
       </init-param>
   </filter>
   <filter-mapping>
       <filter-name>iniShiroFilter</filter-name>
       <url-pattern>/*</url-pattern>
   </filter-mapping>
   ```

   1. 使用 IniShiroFilter 作为 Shiro 安全控制的入口点，通过 url-pattern 指定需要安全的 URL；
   2. 通过 configPath 指定 ini 配置文件位置，默认是先从 /WEB-INF/shiro.ini 加载，如果没有就默认加载 classpath:shiro.ini，即默认相对于 web 应用上下文根路径；
   3. 也可以通过如下方式直接内嵌 ini 配置文件内容到 web.xml。

   ```xml
   <init-param>
       <param-name>config</param-name>
       <param-value>
           ini配置文件贴在这
       </param-value>
   </init-param>
   ```

2. Shiro 1.2 及以后版本的配置方式

   从 Shiro 1.2 开始引入了 Environment/WebEnvironment 的概念，即由它们的实现提供相应的 SecurityManager 及其相应的依赖。ShiroFilter 会自动找到 Environment 然后获取相应的依赖。

   ```
   <listener>
      <listener-class>org.apache.shiro.web.env.EnvironmentLoaderListener</listener-class>
   </listener>
   ```

   通过 EnvironmentLoaderListener 来创建相应的 WebEnvironment，并自动绑定到 ServletContext，默认使用 IniWebEnvironment 实现。

   可以通过如下配置修改默认实现及其加载的配置文件位置：

   ```xml
   <context-param>
      <param-name>shiroEnvironmentClass</param-name>
      <param-value>org.apache.shiro.web.env.IniWebEnvironment</param-value>
   </context-param>
       <context-param>
           <param-name>shiroConfigLocations</param-name>
           <param-value>classpath:shiro.ini</param-value>
       </context-param>
   ```

   shiroConfigLocations 默认是 “/WEB-INF/shiro.ini”，IniWebEnvironment 默认是先从 / WEB-INF/shiro.ini 加载，如果没有就默认加载 classpath:shiro.ini。

代码：<https://github.com/hanyunpeng0521/java-framework/tree/master/learn-shiro/cha06>

### 拦截器机制

Shiro 使用了与 Servlet 一样的 Filter 接口进行扩展

下图是 Shiro 拦截器的基础类图：

![G9UBDI.png](https://s1.ax1x.com/2020/03/26/G9UBDI.png)

1. NameableFilter
   NameableFilter 给 Filter 起个名字，如果没有设置默认就是 FilterName；还记得之前的如 authc 吗？当我们组装拦截器链时会根据这个名字找到相应的拦截器实例；

2. OncePerRequestFilter
   OncePerRequestFilter 用于防止多次执行 Filter 的；也就是说一次请求只会走一次拦截器链；另外提供 enabled 属性，表示是否开启该拦截器实例，默认 enabled=true 表示开启，如果不想让某个拦截器工作，可以设置为 false 即可。

3. ShiroFilter
   ShiroFilter 是整个 Shiro 的入口点，用于拦截需要安全控制的请求进行处理，这个之前已经用过了。

4. AdviceFilter
   AdviceFilter 提供了 AOP 风格的支持，类似于 SpringMVC 中的 Interceptor：

   ```java
   boolean preHandle(ServletRequest request, ServletResponse response) throws Exception
   void postHandle(ServletRequest request, ServletResponse response) throws Exception
   void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception;
   ```

   - preHandler：类似于 AOP 中的前置增强；在拦截器链执行之前执行；如果返回 true 则继续拦截器链；否则中断后续的拦截器链的执行直接返回；进行预处理（如基于表单的身份验证、授权）
   - postHandle：类似于 AOP 中的后置返回增强；在拦截器链执行完成后执行；进行后处理（如记录执行时间之类的）；
   - afterCompletion：类似于 AOP 中的后置最终增强；即不管有没有异常都会执行；可以进行清理资源（如接触 Subject 与线程的绑定之类的）；

5. PathMatchingFilter

   PathMatchingFilter 提供了基于 Ant 风格的请求路径匹配功能及拦截器参数解析的功能，如“roles[admin,user]”自动根据“，”分割解析到一个路径参数配置并绑定到相应的路径：

   ```java
   boolean pathsMatch(String path, ServletRequest request)
   boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception
   ```

   pathsMatch：该方法用于 path 与请求路径进行匹配的方法；如果匹配返回 true；
   onPreHandle：在 preHandle 中，当 pathsMatch 匹配一个路径后，会调用 opPreHandler 方法并将路径绑定参数配置传给 mappedValue；然后可以在这个方法中进行一些验证（如角色授权），如果验证失败可以返回 false 中断流程；默认返回 true；也就是说子类可以只实现 onPreHandle 即可，无须实现 preHandle。如果没有 path 与请求路径匹配，默认是通过的（即 preHandle 返回 true）。

6. AccessControlFilterAccessControlFilter 提供了访问控制的基础功能；比如是否允许访问/当访问拒绝时如何处理等：

   ```java
   abstract boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;
   boolean onAccessDenied(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;
   abstract boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception; 
   ```

   isAccessAllowed：表示是否允许访问；mappedValue 就是[urls]配置中拦截器参数部分，如果允许访问返回 true，否则 false；

   onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回 true 表示需要继续处理；如果返回 false 表示该拦截器实例已经处理了，将直接返回即可。

   onPreHandle 会自动调用这两个方法决定是否继续处理：

   ```java
   boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {
       return isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue);
   } 
   ```

   另外 AccessControlFilter 还提供了如下方法用于处理如登录成功后/重定向到上一个请求：

   ```java
   void setLoginUrl(String loginUrl) //身份验证时使用，默认/login.jsp
   String getLoginUrl()
   Subject getSubject(ServletRequest request, ServletResponse response) //获取Subject 实例
   boolean isLoginRequest(ServletRequest request, ServletResponse response)//当前请求是否是登录请求
   void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response) throws IOException //将当前请求保存起来并重定向到登录页面
   void saveRequest(ServletRequest request) //将请求保存起来，如登录成功后再重定向回该请求
   void redirectToLogin(ServletRequest request, ServletResponse response) //重定向到登录页面 
   ```

   比如基于表单的身份验证就需要使用这些功能。

到此基本的拦截器就完事了，如果我们想进行访问访问的控制就可以继承 AccessControlFilter；如果我们要添加一些通用数据我们可以直接继承 PathMatchingFilter。

#### 拦截器链

Shiro 对 Servlet 容器的 FilterChain 进行了代理，即 ShiroFilter 在继续 Servlet 容器的 Filter 链的执行之前，通过 ProxiedFilterChain 对 Servlet 容器的 FilterChain 进行了代理；即先走 Shiro 自己的 Filter 体系，然后才会委托给 Servlet 容器的 FilterChain 进行 Servlet 容器级别的 Filter 链执行；Shiro 的 ProxiedFilterChain 执行流程：

1. 先执行 Shiro 自己的 Filter 链；
2. 再执行 Servlet 容器的 Filter 链（即原始的 Filter）。

而 ProxiedFilterChain 是通过 FilterChainResolver 根据配置文件中[urls]部分是否与请求的 URL 是否匹配解析得到的。

```
FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain);
```

即传入原始的 chain 得到一个代理的 chain。

Shiro 内部提供了一个路径匹配的 FilterChainResolver 实现：PathMatchingFilterChainResolver，其根据[urls]中配置的 url 模式（默认 Ant 风格）=拦截器链和请求的 url 是否匹配来解析得到配置的拦截器链的；而 PathMatchingFilterChainResolver 内部通过 FilterChainManager 维护着拦截器链，比如 DefaultFilterChainManager 实现维护着 url 模式与拦截器链的关系。因此我们可以通过 FilterChainManager 进行动态动态增加 url 模式与拦截器链的关系。

DefaultFilterChainManager 会默认添加 org.apache.shiro.web.filter.mgt.DefaultFilter 中声明的拦截器：

```java
public enum DefaultFilter {
    anon(AnonymousFilter.class),
    authc(FormAuthenticationFilter.class),
    authcBasic(BasicHttpAuthenticationFilter.class),
    logout(LogoutFilter.class),
    noSessionCreation(NoSessionCreationFilter.class),
    perms(PermissionsAuthorizationFilter.class),
    port(PortFilter.class),
    rest(HttpMethodPermissionFilter.class),
    roles(RolesAuthorizationFilter.class),
    ssl(SslFilter.class),
    user(UserFilter.class);
}
```

如果要注册自定义拦截器，IniSecurityManagerFactory/WebIniSecurityManagerFactory 在启动时会自动扫描 ini 配置文件中的 [filters]/[main] 部分并注册这些拦截器到 DefaultFilterChainManager；且创建相应的 url 模式与其拦截器关系链。如果使用 Spring 后续章节会介绍如果注册自定义拦截器。

如果想自定义 FilterChainResolver，可以通过实现 WebEnvironment 接口完成：

```java
public class MyIniWebEnvironment extends IniWebEnvironment {
    @Override
    protected FilterChainResolver createFilterChainResolver() {
        //在此处扩展自己的FilterChainResolver
        return super.createFilterChainResolver();
    }
}
```

FilterChain 之间的关系。如果想动态实现 url -拦截器的注册，就可以通过实现此处的 FilterChainResolver 来完成，比如：

```java
//1、创建 FilterChainResolver
PathMatchingFilterChainResolver filterChainResolver =
        new PathMatchingFilterChainResolver();
//2、创建 FilterChainManager
DefaultFilterChainManager filterChainManager = new DefaultFilterChainManager();
//3、注册 Filter
for(DefaultFilter filter : DefaultFilter.values()) {
    filterChainManager.addFilter(
        filter.name(), (Filter) ClassUtils.newInstance(filter.getFilterClass()));
}
//4、注册 URL-Filter 的映射关系
filterChainManager.addToChain("/login.jsp", "authc");
filterChainManager.addToChain("/unauthorized.jsp", "anon");
filterChainManager.addToChain("/**", "authc");
filterChainManager.addToChain("/**", "roles", "admin");
//5、设置 Filter 的属性
FormAuthenticationFilter authcFilter =
         (FormAuthenticationFilter)filterChainManager.getFilter("authc");
authcFilter.setLoginUrl("/login.jsp");
RolesAuthorizationFilter rolesFilter =
          (RolesAuthorizationFilter)filterChainManager.getFilter("roles");
rolesFilter.setUnauthorizedUrl("/unauthorized.jsp");
filterChainResolver.setFilterChainManager(filterChainManager);
return filterChainResolver;
```

此处自己去实现注册 filter，及url 模式与 filter 之间的映射关系。可以通过定制 FilterChainResolver 或 FilterChainManager 来完成诸如动态 URL 匹配的实现。

然后再 web.xml 中进行如下配置 Environment：

```xml
<context-param>
<param-name>shiroEnvironmentClass</param-name> <param-value>com.hyp.learn.shiro.cha06.web.env.MyIniWebEnvironment</param-value>
</context-param>
```

#### 自定义拦截器

通过自定义自己的拦截器可以扩展一些功能，诸如动态 url -角色/权限访问控制的实现、根据 Subject 身份信息获取用户信息绑定到 Request（即设置通用数据）、验证码验证、在线用户信息的保存等等，因为其本质就是一个 Filter；所以 Filter 能做的它就能做。

1. 扩展 OncePerRequestFilter

   OncePerRequestFilter 保证一次请求只调用一次 doFilterInternal，即如内部的 forward 不会再多执行一次 doFilterInternal：

   ```java
   public class MyOncePerRequestFilter extends OncePerRequestFilter {
       @Override
       protected void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException {
           System.out.println("=========once per request filter");
           chain.doFilter(request, response);
       }
   }
   ```

   然后再 shiro.ini 配置文件中：

   ```properties
   #[main]
   #myFilter1=com.hyp.learn.shiro.cha06.web.filter.MyOncePerRequestFilter
   [filters]
   myFilter1=com.hyp.learn.shiro.cha06.web.filter.MyOncePerRequestFilter
   [urls]
   /**=myFilter1
   ```

   Filter 可以在 [main] 或 [filters] 部分注册，然后在 [urls] 部分配置 url 与 filter 的映射关系即可。

2. 扩展 AdviceFilter

   AdviceFilter 提供了 AOP 的功能，其实现和 SpringMVC 中的 Interceptor 思想一样

   ```java
   public class MyAdviceFilter extends AdviceFilter {
       @Override
       protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {
           System.out.println("====预处理/前置处理");
           return true;//返回 false 将中断后续拦截器链的执行
       }
       @Override
       protected void postHandle(ServletRequest request, ServletResponse response) throws Exception {
           System.out.println("====后处理/后置返回处理");
       }
       @Override
       public void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception {
           System.out.println("====完成处理/后置最终处理");
       }
   }
   ```

   - preHandle：进行请求的预处理，然后根据返回值决定是否继续处理（true：继续过滤器链）；可以通过它实现权限控制；
   - postHandle：执行完拦截器链之后正常返回后执行；
   - afterCompletion：不管最后有没有异常，afterCompletion 都会执行，完成如清理资源功能。

   然后在 shiro.ini 中进行如下配置：

   ```properties
   [filters]
   myFilter1=com.hyp.learn.shiro.cha06.web.filter.MyOncePerRequestFilter
   myFilter2=com.hyp.learn.shiro.cha06.web.filter.MyAdviceFilter
   [urls]
   /**=myFilter1,myFilter2
   ```

3. PathMatchingFilter

   PathMatchingFilter 继承了 AdviceFilter，提供了 url 模式过滤的功能，如果需要对指定的请求进行处理，可以扩展 PathMatchingFilter：

   ```java
   public class MyPathMatchingFilter extends PathMatchingFilter {
       @Override
       protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {
          System.out.println("url matches,config is " + Arrays.toString((String[])mappedValue));
          return true;
       }
   }
   ```

   - preHandle：会进行 url 模式与请求 url 进行匹配，如果匹配会调用 onPreHandle；如果没有配置 url 模式 / 没有 url 模式匹配，默认直接返回 true；
   - onPreHandle：如果 url 模式与请求 url 匹配，那么会执行 onPreHandle，并把该拦截器配置的参数传入。默认什么不处理直接返回 true。

   然后在 shiro.ini 中进行如下配置：

   ```properties
   [filters]
   myFilter1=com.hyp.learn.shiro.cha06.web.filter.MyOncePerRequestFilter
   myFilter2=com.hyp.learn.shiro.cha06.web.filter.MyAdviceFilter
   myFilter3=com.hyp.learn.shiro.cha06.web.filter.MyPathMatchingFilter
   [urls]
   /**=myFilter1,myFilter2,myFilter3[config]
   ```

4. 扩展 AccessControlFilterAccessControlFilter 继承了 PathMatchingFilter，并扩展了了两个方法：

   ```java
   public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {
       return isAccessAllowed(request, response, mappedValue)
        || onAccessDenied(request, response, mappedValue);
   }
   ```

   isAccessAllowed：即是否允许访问，返回 true 表示允许；
   onAccessDenied：表示访问拒绝时是否自己处理，如果返回 true 表示自己不处理且继续拦截器链执行，返回 false 表示自己已经处理了（比如重定向到另一个页面）。

   ```java
   public class MyAccessControlFilter extends AccessControlFilter {
       protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {
           System.out.println("access allowed");
           return true;
       }
       protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {
           System.out.println("访问拒绝也不自己处理，继续拦截器链的执行");
           return true;
       }
   }
   ```

   然后在 shiro.ini 中进行如下配置：

   ```properties
   [filters]
   myFilter1=com.hyp.learn.shiro.cha06.web.filter.MyOncePerRequestFilter
   myFilter2=com.hyp.learn.shiro.cha06.web.filter.MyAdviceFilter
   myFilter3=com.hyp.learn.shiro.cha06.web.filter.MyPathMatchingFilter
   myFilter4=com.hyp.learn.shiro.cha06.web.filter.MyAccessControlFilter
   [urls]
   /**=myFilter1,myFilter2,myFilter3[config],myFilter4
   ```

5. 基于表单登录拦截器

   之前我们已经使用过 Shiro 内置的基于表单登录的拦截器了，此处自己做一个类似的基于表单登录的拦截器。

   ```java
   public class FormLoginFilter extends PathMatchingFilter {
       private String loginUrl = "/login.jsp";
       private String successUrl = "/";
       @Override
       protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {
           if(SecurityUtils.getSubject().isAuthenticated()) {
               return true;//已经登录过
           }
           HttpServletRequest req = (HttpServletRequest) request;
           HttpServletResponse resp = (HttpServletResponse) response;
           if(isLoginRequest(req)) {
               if("post".equalsIgnoreCase(req.getMethod())) {//form表单提交
                   boolean loginSuccess = login(req); //登录
                   if(loginSuccess) {
                       return redirectToSuccessUrl(req, resp);
                   }
               }
               return true;//继续过滤器链
           } else {//保存当前地址并重定向到登录界面
               saveRequestAndRedirectToLogin(req, resp);
               return false;
           }
       }
       private boolean redirectToSuccessUrl(HttpServletRequest req, HttpServletResponse resp) throws IOException {
           WebUtils.redirectToSavedRequest(req, resp, successUrl);
           return false;
       }
       private void saveRequestAndRedirectToLogin(HttpServletRequest req, HttpServletResponse resp) throws IOException {
           WebUtils.saveRequest(req);
           WebUtils.issueRedirect(req, resp, loginUrl);
       }
       private boolean login(HttpServletRequest req) {
           String username = req.getParameter("username");
           String password = req.getParameter("password");
           try {
               SecurityUtils.getSubject().login(new UsernamePasswordToken(username, password));
           } catch (Exception e) {
               req.setAttribute("shiroLoginFailure", e.getClass());
               return false;
           }
           return true;
       }
       private boolean isLoginRequest(HttpServletRequest req) {
           return pathsMatch(loginUrl, WebUtils.getPathWithinApplication(req));
       }
   }
   ```

   onPreHandle 主要流程：

   1. 首先判断是否已经登录过了，如果已经登录过了继续拦截器链即可；
   2. 如果没有登录，看看是否是登录请求，如果是 get 方法的登录页面请求，则继续拦截器链（到请求页面），否则如果是 get 方法的其他页面请求则保存当前请求并重定向到登录页面；
   3. 如果是 post 方法的登录页面表单提交请求，则收集用户名 / 密码登录即可，如果失败了保存错误消息到 “shiroLoginFailure” 并返回到登录页面；
   4. 如果登录成功了，且之前有保存的请求，则重定向到之前的这个请求，否则到默认的成功页面。

   shiro.ini 配置

   ```properties
   [users]
   zhang=123,admin
   wang=123
   
   [roles]
   admin=user:*,menu:*
   
   [filters]
   formLogin=com.hyp.learn.shiro.cha06.web.filter.FormLoginFilter
   [urls]
   /test.jsp=formLogin
   /login.jsp=formLogin
   ```

6. 任意角色授权拦截器

   Shiro 提供 roles 拦截器，其验证用户拥有所有角色，没有提供验证用户拥有任意角色的拦截器。

   ```java
   public class AnyRolesFilter extends AccessControlFilter {
       private String unauthorizedUrl = "/unauthorized.jsp";
       private String loginUrl = "/login.jsp";
       protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {
           String[] roles = (String[])mappedValue;
           if(roles == null) {
               return true;//如果没有设置角色参数，默认成功
           }
           for(String role : roles) {
               if(getSubject(request, response).hasRole(role)) {
                   return true;
               }
           }
           return false;//跳到onAccessDenied处理
       }
       @Override
       protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {
           Subject subject = getSubject(request, response);
           if (subject.getPrincipal() == null) {//表示没有登录，重定向到登录页面
               saveRequest(request);
               WebUtils.issueRedirect(request, response, loginUrl);
           } else {
               if (StringUtils.hasText(unauthorizedUrl)) {//如果有未授权页面跳转过去
                   WebUtils.issueRedirect(request, response, unauthorizedUrl);
               } else {//否则返回401未授权状态码
                   WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED);
               }
           }
           return false;
       }
   } 
   ```

   流程：

   1. 首先判断用户有没有任意角色，如果没有返回 false，将到 onAccessDenied 进行处理；
   2. 如果用户没有角色，接着判断用户有没有登录，如果没有登录先重定向到登录；
   3. 如果用户没有角色且设置了未授权页面（unauthorizedUrl），那么重定向到未授权页面；否则直接返回 401 未授权错误码。

   shiro.ini 配置

   ```properties
   [users]
   zhang=123,admin
   wang=123
   
   [roles]
   admin=user:*,menu:*
   
   [filters]
   formLogin=com.hyp.learn.shiro.cha06.web.filter.FormLoginFilter
   anyRoles=com.hyp.learn.shiro.cha06.web.filter.AnyRolesFilter
   [urls]
   /test.jsp=formLogin,anyRoles[admin,user]
   /login.jsp=formLogin
   ```

   此处可以继承 AuthorizationFilter 实现，其提供了授权相关的基础代码。另外可以参考 Shiro 内嵌的 RolesAuthorizationFilter 的源码，只是实现 hasAllRoles 逻辑。

##### 默认拦截器

Shiro 内置了很多默认的拦截器，比如身份验证、授权等相关的。默认拦截器可以参考 org.apache.shiro.web.filter.mgt.DefaultFilter 中的枚举拦截器：

| 默认拦截器名      | 拦截器类                                                     | 说明（括号里的表示默认值）                                   |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 身份验证相关的    |                                                              |                                                              |
| authc             | org.apache.shiro.web.filter.authc.FormAuthenticationFilter   | 基于表单的拦截器；如 “`/**=authc`”，如果没有登录会跳到相应的登录页面登录；主要属性：usernameParam：表单提交的用户名参数名（ username）；  passwordParam：表单提交的密码参数名（password）； rememberMeParam：表单提交的密码参数名（rememberMe）； loginUrl：登录页面地址（/login.jsp）；successUrl：登录成功后的默认重定向地址； failureKeyAttribute：登录失败后错误信息存储 key（shiroLoginFailure）； |
| authcBasic        | org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter | Basic HTTP 身份验证拦截器，主要属性： applicationName：弹出登录框显示的信息（application）； |
| logout            | org.apache.shiro.web.filter.authc.LogoutFilter               | 退出拦截器，主要属性：redirectUrl：退出成功后重定向的地址（/）; 示例 “/logout=logout” |
| user              | org.apache.shiro.web.filter.authc.UserFilter                 | 用户拦截器，用户已经身份验证 / 记住我登录的都可；示例 “/**=user” |
| anon              | org.apache.shiro.web.filter.authc.AnonymousFilter            | 匿名拦截器，即不需要登录即可访问；一般用于静态资源过滤；示例 “/static/**=anon” |
| **授权相关的**    |                                                              |                                                              |
| roles             | org.apache.shiro.web.filter.authz.RolesAuthorizationFilter   | 角色授权拦截器，验证用户是否拥有所有角色；主要属性： loginUrl：登录页面地址（/login.jsp）；unauthorizedUrl：未授权后重定向的地址；示例 “/admin/**=roles[admin]” |
| perms             | org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter | 权限授权拦截器，验证用户是否拥有所有权限；属性和 roles 一样；示例 “/user/**=perms["user:create"]” |
| port              | org.apache.shiro.web.filter.authz.PortFilter                 | 端口拦截器，主要属性：port（80）：可以通过的端口；示例 “/test= port[80]”，如果用户访问该页面是非 80，将自动将请求端口改为 80 并重定向到该 80 端口，其他路径 / 参数等都一样 |
| rest              | org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter | rest 风格拦截器，自动根据请求方法构建权限字符串（GET=read, POST=create,PUT=update,DELETE=delete,HEAD=read,TRACE=read,OPTIONS=read, MKCOL=create）构建权限字符串；示例 “/users=rest[user]”，会自动拼出“user:read,user:create,user:update,user:delete” 权限字符串进行权限匹配（所有都得匹配，isPermittedAll）； |
| ssl               | org.apache.shiro.web.filter.authz.SslFilter                  | SSL 拦截器，只有请求协议是 https 才能通过；否则自动跳转会 https 端口（443）；其他和 port 拦截器一样； |
| **其他**          |                                                              |                                                              |
| noSessionCreation | org.apache.shiro.web.filter.session.NoSessionCreationFilter  | 不创建会话拦截器，调用 subject.getSession(false) 不会有什么问题，但是如果 subject.getSession(true) 将抛出 DisabledSessionException 异常； |

另外还提供了一个 org.apache.shiro.web.filter.authz.HostFilter，即主机拦截器，比如其提供了属性：authorizedIps：已授权的 ip 地址，deniedIps：表示拒绝的 ip 地址；不过目前还没有完全实现，不可用。

这些默认的拦截器会自动注册，可以直接在 ini 配置文件中通过 “拦截器名. 属性” 设置其属性：

```
perms.unauthorizedUrl=/unauthorized
```

另外如果某个拦截器不想使用了可以直接通过如下配置直接禁用：

```
perms.enabled=false
```

### JSP 标签

> 了解即可

Shiro 提供了 JSTL 标签用于在 JSP/GSP 页面进行权限控制，如根据登录用户显示相应的页面按钮。

#### 导入标签库

```
<%@taglib prefix="shiro" uri="http://shiro.apache.org/tags" %>
```

标签库定义在 shiro-web.jar 包下的 META-INF/shiro.tld 中定义。

guest 标签

```
<shiro:guest>
欢迎游客访问，<a href="${pageContext.request.contextPath}/login.jsp">登录</a>
</shiro:guest> 
```

用户没有身份验证时显示相应信息，即游客访问信息。

**user 标签**

```
<shiro:guest>
欢迎游客访问，<a href="${pageContext.request.contextPath}/login.jsp">登录</a>
</shiro:guest> 
```

用户已经身份验证 / 记住我登录后显示相应的信息。

**authenticated 标签**

```
<shiro:authenticated>
    用户[<shiro:principal/>]已身份验证通过
</shiro:authenticated> 
```

用户已经身份验证通过，即 Subject.login 登录成功，不是记住我登录的。

**notAuthenticated 标签**

```
<shiro:notAuthenticated>
    未身份验证（包括记住我）
</shiro:notAuthenticated> 
```

用户已经身份验证通过，即没有调用 Subject.login 进行登录，包括记住我自动登录的也属于未进行身份验证。

**principal 标签**

`<shiro: principal/>`

显示用户身份信息，默认调用 Subject.getPrincipal() 获取，即 Primary Principal。

`<shiro:principal type="java.lang.String"/>`

相当于 Subject.getPrincipals().oneByType(String.class)。

`<shiro:principal type="java.lang.String"/>`

相当于 Subject.getPrincipals().oneByType(String.class)。

`<shiro:principal property="username"/>`

相当于 ((User)Subject.getPrincipals()).getUsername()。

**hasRole 标签**

```
<shiro:hasRole name="admin">
    用户[<shiro:principal/>]拥有角色admin<br/>
</shiro:hasRole> 
```

如果当前 Subject 有角色将显示 body 体内容。

**hasAnyRoles 标签**

```
<shiro:hasAnyRoles name="admin,user">
    用户[<shiro:principal/>]拥有角色admin或user<br/>
</shiro:hasAnyRoles> 
```

如果当前 Subject 有任意一个角色（或的关系）将显示 body 体内容。

**lacksRole 标签**

```
<shiro:lacksRole name="abc">
    用户[<shiro:principal/>]没有角色abc<br/>
</shiro:lacksRole> 
```

如果当前 Subject 没有角色将显示 body 体内容。

**hasPermission 标签**

```
<shiro:hasPermission name="user:create">
    用户[<shiro:principal/>]拥有权限user:create<br/>
</shiro:hasPermission> 
```

如果当前 Subject 有权限将显示 body 体内容。

**lacksPermission 标签**

```
<shiro:lacksPermission name="org:create">
    用户[<shiro:principal/>]没有权限org:create<br/>
</shiro:lacksPermission> 
```

如果当前 Subject 没有权限将显示 body 体内容。

另外又提供了几个权限控制相关的标签：

**导入自定义标签库**

```
<%@taglib prefix="zhang" tagdir="/WEB-INF/tags" %>
```

**示例**

```
<zhang:hasAllRoles name="admin,user">
    用户[<shiro:principal/>]拥有角色admin和user<br/>
</zhang:hasAllRoles>
<zhang:hasAllPermissions name="user:create,user:update">
    用户[<shiro:principal/>]拥有权限user:create和user:update<br/>
</zhang:hasAllPermissions>
<zhang:hasAnyPermissions name="user:create,abc:update">
    用户[<shiro:principal/>]拥有权限user:create或abc:update<br/>
</zhang:hasAnyPermissions> 
```

hasAllRoles 表示拥有所有相关的角色；hasAllPermissions 表示拥有所有相关的权限；hasAnyPermissions 表示拥有任意一个相关的权限。

#### 会话管理

Shiro 提供了完整的企业级会话管理功能，不依赖于底层容器（如 web 容器 tomcat），不管 JavaSE 还是 JavaEE 环境都可以使用，提供了会话管理、会话事件监听、会话存储 / 持久化、容器无关的集群、失效 / 过期支持、对 Web 的透明支持、SSO 单点登录的支持等特性。即直接使用 Shiro 的会话管理可以直接替换如 Web 容器的会话管理。

#### 会话

所谓会话，即用户访问应用时保持的连接关系，在多次交互中应用能够识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后，网站可以记住用户，且在退出之前都可以识别当前用户是谁。

Shiro 的会话支持不仅可以在普通的 JavaSE 应用中使用，也可以在 JavaEE 应用中使用，如 web 应用。且使用方式是一致的。

```
login("classpath:shiro.ini", "zhang", "123");
Subject subject = SecurityUtils.getSubject();
Session session = subject.getSession(); 
```

登录成功后使用 Subject.getSession() 即可获取会话；其等价于 Subject.getSession(true)，即如果当前没有创建 Session 对象会创建一个；另外 Subject.getSession(false)，如果当前没有创建 Session 则返回 null（不过默认情况下如果启用会话存储功能的话在创建 Subject 时会主动创建一个 Session）。

```
session.getId();
```

获取当前会话的唯一标识。

```
session.getHost();
```

获取当前 Subject 的主机地址，该地址是通过 HostAuthenticationToken.getHost() 提供的。

```
session.getTimeout();
session.setTimeout(毫秒); 
```

获取 / 设置当前 Session 的过期时间；如果不设置默认是会话管理器的全局过期时间。

```
session.getStartTimestamp();
session.getLastAccessTime();
```

获取会话的启动时间及最后访问时间；如果是 JavaSE 应用需要自己定期调用 session.touch() 去更新最后访问时间；如果是 Web 应用，每次进入 ShiroFilter 都会自动调用 session.touch() 来更新最后访问时间。

```
session.touch();
session.stop(); 
```

更新会话最后访问时间及销毁会话；当 Subject.logout() 时会自动调用 stop 方法来销毁会话。如果在 web 中，调用 javax.servlet.http.HttpSession. invalidate() 也会自动调用 Shiro Session.stop 方法进行销毁 Shiro 的会话。

```
session.setAttribute("key", "123");
Assert.assertEquals("123", session.getAttribute("key"));
session.removeAttribute("key");
```

设置 / 获取 / 删除会话属性；在整个会话范围内都可以对这些属性进行操作。

Shiro 提供的会话可以用于 JavaSE/JavaEE 环境，不依赖于任何底层容器，可以独立使用，是完整的会话模块。

#### 会话管理器

会话管理器管理着应用中所有 Subject 的会话的创建、维护、删除、失效、验证等工作。是 Shiro 的核心组件，顶层组件 SecurityManager 直接继承了 SessionManager，且提供了SessionsSecurityManager 实现直接把会话管理委托给相应的 SessionManager，DefaultSecurityManager 及 DefaultWebSecurityManager 默认 SecurityManager 都继承了 SessionsSecurityManager。

SecurityManager 提供了如下接口：

```
Session start(SessionContext context); //启动会话
Session getSession(SessionKey key) throws SessionException; //根据会话Key获取会话 
```

另外用于 Web 环境的 WebSessionManager 又提供了如下接口：

```
boolean isServletContainerSessions();// 是否使用 Servlet 容器的会话
```

Shiro 还提供了 ValidatingSessionManager 用于验资并过期会话：

```
void validateSessions();// 验证所有会话是否过期
```

Shiro 提供了三个默认实现：

1. **DefaultSessionManager**：DefaultSecurityManager 使用的默认实现，用于 JavaSE 环境；
2. **ServletContainerSessionManager**：DefaultWebSecurityManager 使用的默认实现，用于 Web 环境，其直接使用 Servlet 容器的会话；
3. **DefaultWebSessionManager**：用于 Web 环境的实现，可以替代 ServletContainerSessionManager，自己维护着会话，直接废弃了 Servlet 容器的会话管理。

替换 SecurityManager 默认的 SessionManager 可以在 ini 中配置（shiro.ini）：

```
[main]
sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager
securityManager.sessionManager=$sessionManager
```

Web 环境下的 ini 配置 (shiro-web.ini)：

```properties
[main]
sessionManager=org.apache.shiro.web.session.mgt.ServletContainerSessionManager
securityManager.sessionManager=$sessionManager
```

另外可以设置会话的全局过期时间（毫秒为单位），默认 30 分钟：

```
sessionManager. globalSessionTimeout=1800000
```

默认情况下 globalSessionTimeout 将应用给所有 Session。可以单独设置每个 Session 的 timeout 属性来为每个 Session 设置其超时时间。

另外如果使用 ServletContainerSessionManager 进行会话管理，Session 的超时依赖于底层 Servlet 容器的超时时间，可以在 web.xml 中配置其会话的超时时间（分钟为单位）：

```
<session-config>
  <session-timeout>30</session-timeout>
</session-config>
```

在 Servlet 容器中，默认使用 JSESSIONID Cookie 维护会话，且会话默认是跟容器绑定的；在某些情况下可能需要使用自己的会话机制，此时我们可以使用 DefaultWebSessionManager 来维护会话：

```properties
sessionIdCookie=org.apache.shiro.web.servlet.SimpleCookie
sessionManager=org.apache.shiro.web.session.mgt.DefaultWebSessionManager
sessionIdCookie.name=sid
\#sessionIdCookie.domain=sishuok.com
\#sessionIdCookie.path=
sessionIdCookie.maxAge=1800
sessionIdCookie.httpOnly=true
sessionManager.sessionIdCookie=$sessionIdCookie
sessionManager.sessionIdCookieEnabled=true
securityManager.sessionManager=$sessionManager
```

- sessionIdCookie 是 sessionManager 创建会话 Cookie 的模板：
- sessionIdCookie.name：设置 Cookie 名字，默认为 JSESSIONID；
- sessionIdCookie.domain：设置 Cookie 的域名，默认空，即当前访问的域名；
- sessionIdCookie.path：设置 Cookie 的路径，默认空，即存储在域名根下；
- sessionIdCookie.maxAge：设置 Cookie 的过期时间，秒为单位，默认 - 1 表示关闭浏览器时过期 Cookie；
- sessionIdCookie.httpOnly：如果设置为 true，则客户端不会暴露给客户端脚本代码，使用 HttpOnly cookie 有助于减少某些类型的跨站点脚本攻击；此特性需要实现了 Servlet 2.5 MR6 及以上版本的规范的 Servlet 容器支持；
- sessionManager.sessionIdCookieEnabled：是否启用 / 禁用 Session Id Cookie，默认是启用的；如果禁用后将不会设置 Session Id Cookie，即默认使用了 Servlet 容器的 JSESSIONID，且通过 URL 重写（URL 中的 “;JSESSIONID=id” 部分）保存 Session Id。

另外我们可以如 “sessionManager. sessionIdCookie.name=sid” 这种方式操作 Cookie 模板。

#### 会话监听器

会话监听器用于监听会话创建、过期及停止事件：

```java
public class MySessionListener1 implements SessionListener {
    @Override
    public void onStart(Session session) {//会话创建时触发
        System.out.println("会话创建：" + session.getId());
    }
    @Override
    public void onExpiration(Session session) {//会话过期时触发
        System.out.println("会话过期：" + session.getId());
    }
    @Override
    public void onStop(Session session) {//退出/会话过期时触发
        System.out.println("会话停止：" + session.getId());
    }  
}
```

如果只想监听某一个事件，可以继承 SessionListenerAdapter 实现：

```java
public class MySessionListener2 extends SessionListenerAdapter {
    @Override
    public void onStart(Session session) {
        System.out.println("会话创建：" + session.getId());
    }
}
```

在 shiro-web.ini 配置文件中可以进行如下配置设置会话监听器：

```properties
sessionListener1=com.github.zhangkaitao.shiro.chapter10.web.listener.MySessionListener1
sessionListener2=com.github.zhangkaitao.shiro.chapter10.web.listener.MySessionListener2
sessionManager.sessionListeners=$sessionListener1,$sessionListener2
```

#### 会话存储 / 持久化

Shiro 提供 SessionDAO 用于会话的 CRUD，即 DAO（Data Access Object）模式实现：

```
//如DefaultSessionManager在创建完session后会调用该方法；如保存到关系数据库/文件系统/NoSQL数据库；即可以实现会话的持久化；返回会话ID；主要此处返回的ID.equals(session.getId())；
Serializable create(Session session);
//根据会话ID获取会话
Session readSession(Serializable sessionId) throws UnknownSessionException;
//更新会话；如更新会话最后访问时间/停止会话/设置超时时间/设置移除属性等会调用
void update(Session session) throws UnknownSessionException;
//删除会话；当会话过期/会话停止（如用户退出时）会调用
void delete(Session session);
//获取当前所有活跃用户，如果用户量多此方法影响性能
Collection<Session> getActiveSessions(); 
```

Shiro 内嵌了如下 SessionDAO 实现：

![GPyqzt.png](https://s1.ax1x.com/2020/03/27/GPyqzt.png)

AbstractSessionDAO 提供了 SessionDAO 的基础实现，如生成会话 ID 等；CachingSessionDAO 提供了对开发者透明的会话缓存的功能，只需要设置相应的 CacheManager 即可；MemorySessionDAO 直接在内存中进行会话维护；而 EnterpriseCacheSessionDAO 提供了缓存功能的会话维护，默认情况下使用 MapCache 实现，内部使用 ConcurrentHashMap 保存缓存的会话。

可以通过如下配置设置 SessionDAO：

```properties
sessionDAO=org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO
sessionManager.sessionDAO=$sessionDAO
```

Shiro 提供了使用 Ehcache 进行会话存储，Ehcache 可以配合 TerraCotta 实现容器无关的分布式集群。

首先在 pom.xml 里添加如下依赖：

```
<dependency>
    <groupId>org.apache.shiro</groupId>
    <artifactId>shiro-ehcache</artifactId>
    <version>1.2.2</version>
</dependency>
```

接着配置 shiro-web.ini 文件：

```properties
sessionDAO=org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO
sessionDAO. activeSessionsCacheName=shiro-activeSessionCache
sessionManager.sessionDAO=$sessionDAO
cacheManager = org.apache.shiro.cache.ehcache.EhCacheManager
cacheManager.cacheManagerConfigFile=classpath:ehcache.xml
securityManager.cacheManager = $cacheManager
```

- sessionDAO. activeSessionsCacheName：设置 Session 缓存名字，默认就是 shiro-activeSessionCache；
- cacheManager：缓存管理器，用于管理缓存的，此处使用 Ehcache 实现；
- cacheManager.cacheManagerConfigFile：设置 ehcache 缓存的配置文件；
- securityManager.cacheManager：设置 SecurityManager 的 cacheManager，会自动设置实现了 CacheManagerAware 接口的相应对象，如 SessionDAO 的 cacheManager；

然后配置 ehcache.xml：

```xml
<cache name="shiro-activeSessionCache"
       maxEntriesLocalHeap="10000"
       overflowToDisk="false"
       eternal="false"
       diskPersistent="false"
       timeToLiveSeconds="0"
       timeToIdleSeconds="0"
       statistics="true"/>
```

Cache 的名字为 shiro-activeSessionCache，即设置的 sessionDAO 的 activeSessionsCacheName 属性值。

另外可以通过如下 ini 配置设置会话 ID 生成器：

```properties
sessionIdGenerator=org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator
sessionDAO.sessionIdGenerator=$sessionIdGenerator
```

用于生成会话 ID，默认就是 JavaUuidSessionIdGenerator，使用 java.util.UUID 生成。

如果自定义实现 SessionDAO，继承 CachingSessionDAO 即可：

```java
public class MySessionDAO extends CachingSessionDAO {
    private JdbcTemplate jdbcTemplate = JdbcTemplateUtils.jdbcTemplate();
     protected Serializable doCreate(Session session) {
        Serializable sessionId = generateSessionId(session);
        assignSessionId(session, sessionId);
        String sql = "insert into sessions(id, session) values(?,?)";
        jdbcTemplate.update(sql, sessionId, SerializableUtils.serialize(session));
        return session.getId();
    }
protected void doUpdate(Session session) {
    if(session instanceof ValidatingSession && !((ValidatingSession)session).isValid()) {
        return; //如果会话过期/停止 没必要再更新了
    }
        String sql = "update sessions set session=? where id=?";
        jdbcTemplate.update(sql, SerializableUtils.serialize(session), session.getId());
    }
    protected void doDelete(Session session) {
        String sql = "delete from sessions where id=?";
        jdbcTemplate.update(sql, session.getId());
    }
    protected Session doReadSession(Serializable sessionId) {
        String sql = "select session from sessions where id=?";
        List<String> sessionStrList = jdbcTemplate.queryForList(sql, String.class, sessionId);
        if(sessionStrList.size() == 0) return null;
        return SerializableUtils.deserialize(sessionStrList.get(0));
    }
}
```

doCreate/doUpdate/doDelete/doReadSession 分别代表创建 / 修改 / 删除 / 读取会话；此处通过把会话序列化后存储到数据库实现；接着在 shiro-web.ini 中配置：

```
sessionDAO=com.github.zhangkaitao.shiro.chapter10.session.dao.MySessionDAO
```

其他设置和之前一样，因为继承了 CachingSessionDAO；所有在读取时会先查缓存中是否存在，如果找不到才到数据库中查找。

#### 会话验证

Shiro 提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话；出于性能考虑，一般情况下都是获取会话时来验证会话是否过期并停止会话的；但是如在 web 环境中，如果用户不主动退出是不知道会话是否过期的，因此需要定期的检测会话是否过期，Shiro 提供了会话验证调度器 SessionValidationScheduler 来做这件事情。

可以通过如下 ini 配置开启会话验证：

```
sessionValidationScheduler=org.apache.shiro.session.mgt.ExecutorServiceSessionValidationScheduler
sessionValidationScheduler.interval = 3600000
sessionValidationScheduler.sessionManager=$sessionManager
sessionManager.globalSessionTimeout=1800000
sessionManager.sessionValidationSchedulerEnabled=true
sessionManager.sessionValidationScheduler=$sessionValidationScheduler 
```

- sessionValidationScheduler：会话验证调度器，sessionManager 默认就是使用 ExecutorServiceSessionValidationScheduler，其使用 JDK 的 ScheduledExecutorService 进行定期调度并验证会话是否过期；
- sessionValidationScheduler.interval：设置调度时间间隔，单位毫秒，默认就是 1 小时；
- sessionValidationScheduler.sessionManager：设置会话验证调度器进行会话验证时的会话管理器；
- sessionManager.globalSessionTimeout：设置全局会话超时时间，默认 30 分钟，即如果 30 分钟内没有访问会话将过期；
- sessionManager.sessionValidationSchedulerEnabled：是否开启会话验证器，默认是开启的；
- sessionManager.sessionValidationScheduler：设置会话验证调度器，默认就是使用 ExecutorServiceSessionValidationScheduler。

Shiro 也提供了使用 Quartz 会话验证调度器：

```
sessionValidationScheduler=org.apache.shiro.session.mgt.quartz.QuartzSessionValidationScheduler
sessionValidationScheduler.sessionValidationInterval = 3600000
sessionValidationScheduler.sessionManager=$sessionManager 
```

使用时需要导入 shiro-quartz 依赖：

```
<dependency>
     <groupId>org.apache.shiro</groupId>
     <artifactId>shiro-quartz</artifactId>
     <version>1.2.2</version>
</dependency>
```

如上会话验证调度器实现都是直接调用 AbstractValidatingSessionManager 的 validateSessions 方法进行验证，其直接调用 SessionDAO 的 getActiveSessions 方法获取所有会话进行验证，如果会话比较多，会影响性能；可以考虑如分页获取会话并进行验证，如 com.github.zhangkaitao.shiro.chapter10.session.scheduler.MySessionValidationScheduler：

```
//分页获取会话并验证
String sql = "select session from sessions limit ?,?";
int start = 0; //起始记录
int size = 20; //每页大小
List<String> sessionList = jdbcTemplate.queryForList(sql, String.class, start, size);
while(sessionList.size() > 0) {
  for(String sessionStr : sessionList) {
    try {
      Session session = SerializableUtils.deserialize(sessionStr);
      Method validateMethod = 
        ReflectionUtils.findMethod(AbstractValidatingSessionManager.class, 
            "validate", Session.class, SessionKey.class);
      validateMethod.setAccessible(true);
      ReflectionUtils.invokeMethod(validateMethod, 
        sessionManager, session, new DefaultSessionKey(session.getId()));
    } catch (Exception e) {
        //ignore
    }
  }
 start = start + size;
  sessionList = jdbcTemplate.queryForList(sql, String.class, start, size);
} 
```

其直接改造自 ExecutorServiceSessionValidationScheduler，如上代码是验证的核心代码，可以根据自己的需求改造此验证调度器器；ini 的配置和之前的类似。

如果在会话过期时不想删除过期的会话，可以通过如下 ini 配置进行设置：

```
sessionManager.deleteInvalidSessions=false
```

默认是开启的，在会话过期后会调用 SessionDAO 的 delete 方法删除会话：如会话时持久化存储的，可以调用此方法进行删除。

如果是在获取会话时验证了会话已过期，将抛出 InvalidSessionException；因此需要捕获这个异常并跳转到相应的页面告诉用户会话已过期，让其重新登录，如可以在 web.xml 配置相应的错误页面：

```
<error-page>
    <exception-type>org.apache.shiro.session.InvalidSessionException</exception-type>
    <location>/invalidSession.jsp</location>
</error-page>
```

#### sessionFactory

sessionFactory 是创建会话的工厂，根据相应的 Subject 上下文信息来创建会话；默认提供了 SimpleSessionFactory 用来创建 SimpleSession 会话。

首先自定义一个 Session：

```
public class OnlineSession extends SimpleSession {
    public static enum OnlineStatus {
        on_line("在线"), hidden("隐身"), force_logout("强制退出");
        private final String info;
        private OnlineStatus(String info) {
            this.info = info;
        }
        public String getInfo() {
            return info;
        }
    }
    private String userAgent; //用户浏览器类型
    private OnlineStatus status = OnlineStatus.on_line; //在线状态
    private String systemHost; //用户登录时系统IP
    //省略其他
} 
```

OnlineSession 用于保存当前登录用户的在线状态，支持如离线等状态的控制。

接着自定义 SessionFactory：

```
public class OnlineSessionFactory implements SessionFactory {
    @Override
    public Session createSession(SessionContext initData) {
        OnlineSession session = new OnlineSession();
        if (initData != null && initData instanceof WebSessionContext) {
            WebSessionContext sessionContext = (WebSessionContext) initData;
            HttpServletRequest request = (HttpServletRequest) sessionContext.getServletRequest();
            if (request != null) {
                session.setHost(IpUtils.getIpAddr(request));
                session.setUserAgent(request.getHeader("User-Agent"));
                session.setSystemHost(request.getLocalAddr() + ":" + request.getLocalPort());
            }
        }
        return session;
    }
} 
```

根据会话上下文创建相应的 OnlineSession。

最后在 shiro-web.ini 配置文件中配置：

```
sessionFactory=org.apache.shiro.session.mgt.OnlineSessionFactory
sessionManager.sessionFactory=$sessionFactory
```

#### 缓存机制

Shiro 提供了类似于 Spring 的 Cache 抽象，即 Shiro 本身不实现 Cache，但是对 Cache 进行了又抽象，方便更换不同的底层 Cache 实现。

**Shiro 提供的 Cache 接口**：

```java
public interface Cache<K, V> {
    //根据Key获取缓存中的值
    public V get(K key) throws CacheException;
    //往缓存中放入key-value，返回缓存中之前的值
    public V put(K key, V value) throws CacheException; 
    //移除缓存中key对应的值，返回该值
    public V remove(K key) throws CacheException;
    //清空整个缓存
    public void clear() throws CacheException;
    //返回缓存大小
    public int size();
    //获取缓存中所有的key
    public Set<K> keys();
    //获取缓存中所有的value
    public Collection<V> values();
}
```

**Shiro 提供的 CacheManager 接口**：

```java
public interface CacheManager {
    //根据缓存名字获取一个Cache
    public <K, V> Cache<K, V> getCache(String name) throws CacheException;
}
```

**Shiro 还提供了 CacheManagerAware 用于注入 CacheManager**：

```java
public interface CacheManagerAware {
    //注入CacheManager
    void setCacheManager(CacheManager cacheManager);
}
```

Shiro 内部相应的组件（DefaultSecurityManager）会自动检测相应的对象（如 Realm）是否实现了 CacheManagerAware 并自动注入相应的 CacheManager。

#### Realm 缓存

Shiro 提供了 CachingRealm，其实现了 CacheManagerAware 接口，提供了缓存的一些基础实现；另外 AuthenticatingRealm 及 AuthorizingRealm 分别提供了对 AuthenticationInfo 和 AuthorizationInfo 信息的缓存。

**ini 配置**

```properties
userRealm=com.github.zhangkaitao.shiro.chapter11.realm.UserRealm
userRealm.credentialsMatcher=$credentialsMatcher
userRealm.cachingEnabled=true
userRealm.authenticationCachingEnabled=true
userRealm.authenticationCacheName=authenticationCache
userRealm.authorizationCachingEnabled=true
userRealm.authorizationCacheName=authorizationCache
securityManager.realms=$userRealm
cacheManager=org.apache.shiro.cache.ehcache.EhCacheManager
cacheManager.cacheManagerConfigFile=classpath:shiro-ehcache.xml
securityManager.cacheManager=$cacheManager
```

- userRealm.cachingEnabled：启用缓存，默认 false；
- userRealm.authenticationCachingEnabled：启用身份验证缓存，即缓存 AuthenticationInfo 信息，默认 false；
- userRealm.authenticationCacheName：缓存 AuthenticationInfo 信息的缓存名称；
- userRealm. authorizationCachingEnabled：启用授权缓存，即缓存 AuthorizationInfo 信息，默认 false；
- userRealm. authorizationCacheName：缓存 AuthorizationInfo 信息的缓存名称；
- cacheManager：缓存管理器，此处使用 EhCacheManager，即 Ehcache 实现，需要导入相应的 Ehcache 依赖，请参考 pom.xml；

因为测试用例的关系，需要将 Ehcache 的 CacheManager 改为使用 VM 单例模式： this.manager = new net.sf.ehcache.CacheManager(getCacheManagerConfigFileInputStream())； 改为 this.manager = net.sf.ehcache.CacheManager.create(getCacheManagerConfigFileInputStream())；

**测试用例**

```java
@Test
public void testClearCachedAuthenticationInfo() {
    login(u1.getUsername(), password);
    userService.changePassword(u1.getId(), password + "1");
    RealmSecurityManager securityManager =
     (RealmSecurityManager) SecurityUtils.getSecurityManager();
    UserRealm userRealm = (UserRealm) securityManager.getRealms().iterator().next();   userRealm.clearCachedAuthenticationInfo(subject().getPrincipals());
    login(u1.getUsername(), password + "1");
}
```

首先登录成功（此时会缓存相应的 AuthenticationInfo），然后修改密码；此时密码就变了；接着需要调用 Realm 的 clearCachedAuthenticationInfo 方法清空之前缓存的 AuthenticationInfo；否则下次登录时还会获取到修改密码之前的那个 AuthenticationInfo；

```java
@Test
public void testClearCachedAuthorizationInfo() {
    login(u1.getUsername(), password);
    subject().checkRole(r1.getRole());
    userService.correlationRoles(u1.getId(), r2.getId());
    RealmSecurityManager securityManager =
      (RealmSecurityManager) SecurityUtils.getSecurityManager();
    UserRealm userRealm = (UserRealm)securityManager.getRealms().iterator().next();   userRealm.clearCachedAuthorizationInfo(subject().getPrincipals());
    subject().checkRole(r2.getRole());
}
```

和之前的用例差不多；此处调用 Realm 的 clearCachedAuthorizationInfo 清空之前缓存的 AuthorizationInfo；

另外还有 clearCache，其同时调用 clearCachedAuthenticationInfo 和 clearCachedAuthorizationInfo，清空 AuthenticationInfo 和 AuthorizationInfo。

UserRealm 还提供了 clearAllCachedAuthorizationInfo、clearAllCachedAuthenticationInfo、clearAllCache，用于清空整个缓存。

在某些清空下这种方式可能不是最好的选择，可以考虑直接废弃 Shiro 的缓存，然后自己通过如 AOP 机制实现自己的缓存；

另外如果和 Spring 集成时可以考虑直接使用 Spring 的 Cache 抽象，可以考虑使用 SpringCacheManagerWrapper，其对 Spring Cache 进行了包装，转换为 Shiro 的 CacheManager 实现

#### Session 缓存

当我们设置了 SecurityManager 的 CacheManager 时，如：

```
securityManager.cacheManager=$cacheManager
```

当我们设置 SessionManager 时：

```
sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager
securityManager.sessionManager=$sessionManager
```

如 securityManager 实现了 SessionsSecurityManager，其会自动判断 SessionManager 是否实现了 CacheManagerAware 接口，如果实现了会把 CacheManager 设置给它。然后 sessionManager 会判断相应的 sessionDAO（如继承自 CachingSessionDAO）是否实现了 CacheManagerAware，如果实现了会把 CacheManager 设置给它；如第九章的 MySessionDAO 就是带缓存的 SessionDAO；其会先查缓存，如果找不到才查数据库。

对于 CachingSessionDAO，可以通过如下配置设置缓存的名称：

```
sessionDAO=com.github.zhangkaitao.shiro.chapter11.session.dao.MySessionDAO
sessionDAO.activeSessionsCacheName=shiro-activeSessionCache
```

activeSessionsCacheName 默认就是 shiro-activeSessionCache。


---
title: 剑指offer（一）
date: 2019-05-25 23:18:59
tags:
 - 算法
categories:
 - 算法
---

练习网站：<https://www.nowcoder.com/ta/coding-interviews>

语言：java 8

<!--more-->

#### 二维数组中的查找

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

1. 把每一行看成有序递增的数组，利用二分查找，通过遍历每一行得到答案，时间复杂度是nlogn

   ```java
   public static boolean Find(int target, int[][] array) {
           if (null == array || array.length == 0 || array[0].length == 0) {
               return false;
           }
           for (int[] ints : array) {
               int low = 0;
               int high = ints.length;
               while (low <= high) {
                   int mid = (low + high) / 2;
                   if (target == ints[mid]) {
                       return true;
                   } else if (target > ints[mid]) {
                       low = mid + 1;
                   } else {
                       high = mid - 1;
                   }
   
               }
           }
   
           return false;
       }
   ```

2. 利用二维数组由上到下，由左到右递增的规律，那么选取**右上角或者左下角**的元素`a[row][col]`与target进行比较。

   使用**右上角**开始，当target小于元素`a[row][col]`时，那么target必定在元素a所在行的左边,即col--；当target大于元素`a[row][col]`时，那么target必定在元素a所在列的下边,即row++；

   使用**左上角**开始，当target小于元素`a[row][col]`时，那么target必定在元素a所在行的上边边,即row--；当target大于元素`a[row][col]`时，那么target必定在元素a所在列的左边,即col++；

   越界，说明没有找到。

   ```java
   // 使用**右上角**开始
   public static boolean Find(int target, int[][] array) {
           if (null == array || array.length == 0 || array[0].length == 0) {
               return false;
           }
           int len = array.length - 1;
           int i = 0;
           while ((len >= 0) && (i < array[0].length)) {
               if (array[len][i] > target) {
                   len--;
               } else if (array[len][i] < target) {
                   i++;
               } else {
                   return true;
               }
           }
           return false;
       }
   ```

#### 替换空格

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

思考：

- 问题1：替换字符串，是在原来的字符串上做替换，还是新开辟一个字符串做替换！
- 问题2：在当前字符串替换，怎么替换才更有效率（不考虑java里现有的replace方法）。
        从前往后替换，后面的字符要不断往后移动，要多次移动，所以效率低下
        从后往前，先计算需要多少空间，然后从后往前移动，则每个字符只为移动一次，这样效率更高一点。

```java
//这里采用从后往前，使用原来的StringBuffer对象进行操作
 public static String replaceSpace(StringBuffer str) {
        if (null == str || str.length() == 0) {
            return "";
        }

        int spacenum = 0;//spacenum为计算空格数
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == ' ')
                spacenum++;
        }
        int indexold = str.length() - 1; //indexold为为替换前的str下标
        int newlength = str.length() + spacenum * 2;//计算空格转换成%20之后的str长度
        int indexnew = newlength - 1;//indexnew为把空格替换为%20后的str下标
        str.setLength(newlength);//使str的长度扩大到转换成%20之后的长度,防止下标越界
        for (; indexold >= 0 && indexold < newlength; --indexold) {
            //如果newlength==indexold，则说明空格完全转换成替换字符，不需要循环
            //如果indexold<0，则说明以及替换全部字符串。
            if (str.charAt(indexold) == ' ') {  //如果遇到空格
                str.setCharAt(indexnew--, '0');
                str.setCharAt(indexnew--, '2');
                str.setCharAt(indexnew--, '%');
            } else {//如果遇到普通字符
                str.setCharAt(indexnew--, str.charAt(indexold));
            }
        }
        return str.toString();
    }
```

#### 从头到尾打印链表

输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

节点结构：

```java
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
```

解决方法

1. 递归超简洁版本（递归的本质还是使用了堆栈结构） 

   ```java
   public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
           ArrayList<Integer> list=new ArrayList<Integer>();
           
           ListNode pNode=listNode;
           if(pNode!=null){
               if(pNode.next!=null){
                   list=printListFromTailToHead(pNode.next);
               }
               list.add(pNode.val);
           }
           
           return list;
       }
   ```

2. 借助堆栈的“后进先出”实现 

   ```java
   public  ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
           ArrayList<Integer> result = new ArrayList<Integer>();
           if (null == listNode) {
               return result;
           }
           Stack<Integer> stack = new Stack();
           ListNode node = listNode;
           while (node != null) {
               stack.push(node.val);
               node = node.next;
           }
           int l = stack.size();
           for (int i = 0; i < l; i++) {
               result.add(stack.pop());
           }
   
           return result;
       }
   ```

3. 使用数组翻转

   ```java
   public  ArrayList<Integer> printListFromTailToHead4(ListNode listNode) {
           ArrayList<Integer> result = new ArrayList<Integer>();
           if (null == listNode) {
               return result;
           }
           Stack<Integer> stack = new Stack();
           ListNode node = listNode;
           while (node != null) {
               result.add(node.val);
               node = node.next;
           }
           Collections.reverse(result);
           return result;
       }
   ```

#### 重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

二叉树节点定义：

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }

}
```

先序遍历特点：第一个值是根节点
中序遍历特点：根节点左边都是左子树，右边都是右子

**步骤**：

1. 先求出根节点（前序序列第一个元素）。
2. 将根节点带入到中序遍历序列中求出左右子树的中序遍历序列。
3. 通过左右子树的中序序列元素集合带入前序遍历序列可以求出左右子树的前序序列。
4. 左右子树的前序序列第一个元素分别是根节点的左右儿子
5. 求出了左右子树的4种序列可以递归上述步骤 

**方法**：

因为是树的结构，一般都是用递归来实现。

```java
 public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        return reConBTree(pre,0,pre.length-1,in,0,in.length-1);
    }
    public TreeNode reConBTree(int [] pre,int preleft,int preright,int [] in,int inleft,int inright){
        if(preleft > preright || inleft> inright)//当到达边界条件时候返回null
            return null;
        //新建一个TreeNode
        TreeNode root = new TreeNode(pre[preleft]);
        //对中序数组进行输入边界的遍历
        for(int i = inleft; i<= inright; i++){
            if(pre[preleft] == in[i]){
                //重构左子树，注意边界条件
                root.left = reConBTree(pre,preleft+1,preleft+i-inleft,in,inleft,i-1);
                //重构右子树，注意边界条件
                root.right = reConBTree(pre,preleft+i+1-inleft,preright,in,i+1,inright);
            }
        }
        return root;
    }
```

使用到Arrays.copyOfRange的方法：

```java
public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        //数组长度为0的时候要处理
        if(pre.length == 0){
            return null;
        }
 
        int rootVal = pre[0];
 
        //数组长度仅为1的时候就要处理
        if(pre.length == 1){
            return new TreeNode(rootVal);
        }
 
        //我们先找到root所在的位置，确定好前序和中序中左子树和右子树序列的范围
        TreeNode root = new TreeNode(rootVal);
        int rootIndex = 0;
        for(int i=0;i<in.length;i++){
            if(rootVal == in[i]){
                rootIndex = i;
                break;
            }
        }
 
        //递归，假设root的左右子树都已经构建完毕，那么只要将左右子树安到root左右即可
        //这里注意Arrays.copyOfRange(int[],start,end)是[)的区间
        root.left = reConstructBinaryTree(Arrays.copyOfRange(pre,1,rootIndex+1),Arrays.copyOfRange(in,0,rootIndex));
        root.right = reConstructBinaryTree(Arrays.copyOfRange(pre,rootIndex+1,pre.length),Arrays.copyOfRange(in,rootIndex+1,in.length));
 
        return root;
    }
```

#### 使用两个栈实现队列

用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

1. 方法一

    入队：判断栈B是否为空，如果为不为空，则将栈B中所有元素pop，并push进栈A，最后将元素进栈A；若为空，直接将元素进栈A。

   出队：判断栈A是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；如果不为空，栈B直接出栈。 

   ```java
   import java.util.Stack;
   
   public class Solution {
       Stack<Integer> stack1 = new Stack<Integer>();
       Stack<Integer> stack2 = new Stack<Integer>();
       
       public void push(int node) {
           while (!stack2.empty())
           {
               stack1.push(stack2.pop());
           }
           stack1.push(node);
       }
   
       public int pop() {
           while (!stack1.empty())
           {
               stack2.push(stack1.pop());
           }
           return stack2.pop();
       }
   }
   ```

2. 方法二

   有两个栈，栈1和栈2.当入栈的时候，我们将它全放进栈1中，当需要出栈的时候，我们将栈1出栈到栈2中，然后再将栈2依次出栈。所以入栈的时候，思路很简单，注意到要将int类型转为Integer类型，我们使用了new Integer(int);当需要出栈的时候，我们用API提供的方法while(stack1.isEmpty())来将所有栈1的元素压入栈2中，然后将栈2弹出就可以。这里又涉及到将Integer的类型转为int类型的方法Integer.intValue();  

   ```java
      public void push(int node) {
           stack1.push(node);
       }
   
   
       public int pop() {
   
           while(!stack2.isEmpty())
           {
               return stack2.pop();
           }
   
           while(!stack1.isEmpty())
           {
               stack2.push(stack1.pop());
           }
   
           return stack2.pop();
       }
   ```

#### 旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

旋转之后的数组实际上可以划分成两个有序的子数组：前面子数组的大小都大于后面子数组中的元素

注意到实际上最小的元素就是两个子数组的分界线。本题目给出的数组一定程度上是排序的，因此我们试着用二分查找法寻找这个最小的元素。

**思路：**

- 我们用两个指针left,right分别指向数组的第一个元素和最后一个元素。按照题目的旋转的规则，第一个元素应该是大于最后一个元素的（没有重复的元素）。

  但是如果不是旋转，第一个元素肯定小于最后一个元素。

- 找到数组的中间元素。

  中间元素大于第一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素。

  移动之后，第一个指针仍然位于前面的递增数组中。

  中间元素小于第一个元素，则中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面。我们可以让第二个指针right指向中间元素。

  移动之后，第二个指针仍然位于后面的递增数组中。

  这样可以缩小寻找的范围。

- 按照以上思路，第一个指针left总是指向前面递增数组的元素，第二个指针right总是指向后面递增的数组元素。

  最终第一个指针将指向前面数组的最后一个元素，第二个指针指向后面数组中的第一个元素。

  也就是说他们将指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环的结束条件。

  到目前为止以上思路很耗的解决了没有重复数字的情况，这一道题目添加上了这一要求，有了重复数字。

  因此这一道题目比上一道题目多了些特殊情况：

  我们看一组例子：｛1，0，1，**1，1**｝ 和 ｛**1，1**， 1，0，1｝ 都可以看成是递增排序数组｛0，1，1，1，1｝的旋转。

  这种情况下我们无法继续用上一道题目的解法，去解决这道题目。因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。

  第一种情况下，中间数字位于后面的子数组，第二种情况，中间数字位于前面的子数组。

  因此当两个指针指向的数字和中间数字相同的时候，我们无法确定中间数字1是属于前面的子数组（第一个后两个），还是属于后面的子数组（第二个前两个）。

  也就无法移动指针来缩小查找的范围。 

1. 最笨的一种

   遍历整个数组，找出其中最小的数。这样肯定拿不到offer

2. 稍微优化

   ```java
       public int minNumberInRotateArray(int[] array) {
           if (null == array || array.length == 0) {
               return 0;
           }
           int result = array[0];
           for (int i = 1, j = array.length; i < j; i++) {
               if (result > array[i]) {
                   result = array[i];
                   break;
               }
   
           }
           return result;
       }
   ```

3. 二分法

   采用二分法解答这个问题，

   ```
   mid = low + (high - low)/2
   ```

   需要考虑三种情况：

   - `array[mid] > array[high]:`
     出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。

     ```
     low = mid + 1
     ```

   - `array[mid] == array[high]:`
     出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边
     还是右边,这时只好一个一个试 ，

     ```
     high = high - 1
     ```

   - `array[mid] < array[high]:`
     出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左
     边。因为右边必然都是递增的。

     ```
     high = mid
     ```

   注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字

   比如 `array = [4,6]`

   ```
   array[low] = 4 ;
   array[mid] = 4 ;
   array[high] = 6 ;
   ```

   如果`high = mid - 1`，就会产生错误， 因此`high = mid`

   但情形(1)中`low = mid + 1`就不会错误 

   ```java
   public int minNumberInRotateArray(int[] array) {
       if (null==array||array.length==0)
           {
               return 0;
           }
           int low = 0;
           int high = array.length - 1;
           while (low < high) {
               int mid = low + (high - low) / 2;
               if (array[mid] > array[high]) {
                   low = mid + 1;
               } else if (array[mid] == array[high]) {
                   high = high - 1;
               } else {
                   high = mid;
               }
           }
           return array[low];
       }
   
   ```

   或者

   ```java
       public int minNumberInRotateArray(int[] array) {
           if (null == array || array.length == 0) {
               return 0;
           }
           int l = 0, r = array.length - 1;
           int m = 0;
           //确保旋转
           while (array[l] >= array[r]) {
               // 分界点
               if (r - l == 1) {
                   m = r;
                   break;
               }
               m = l + (r - l) / 2;
               //三者相等
               // 无法确定中间元素是属于前面还是后面的递增子数组
               // 只能顺序查找
               if (array[l] == array[r] && array[l] == array[m]) {
                   return minOrMax(array, l, r);
               }
               //中间元素位于前面的递增子数组
               //此时最小元素位于中间元素的后面
               if (array[m] >= array[l]) {
                   l = m;
               }
               // 中间元素位于后面的递增子数组
               // 此时最小元素位于中间元素的前面
               else {
                   r = m;
               }
           }
           return array[m];
       }
   
       // 顺序寻找最小值
       public int minOrMax(int[] arr, int l, int r) {
           int result = arr[l];
           for (int i = l + 1; i < r; i++) {
               if (arr[i] < result) {
                   result = arr[i];
                   break;
               }
           }
           return result;
       }
   ```

#### 斐波那契数列

大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 `n<=39` 

```
F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）
```

1. 递归

   ```java
       public int Fibonacci(int n) {
   
           if (n == 0)
               return 0;
           else if (n == 1 || n == 2)
               return 1;
           else if (n == 3)
               return 2;
           else
               return 3 * Fibonacci3(n - 3) + 2 * Fibonacci3(n - 4);
       }
   ```

2. 非递归

   ```java
   /*
   整体思路：考虑负数，大数，算法的复杂度，空间的浪费
   */
    
   public class Solution {
       public int Fibonacci(int n) {
           //方法1：用递归，系统会让一个超大的n来让Stack Overflow，所以
           //递归就不考虑了
            
           //使用迭代法，用fn1和fn2保存计算过程中的结果，并复用起来
           int fn1 = 1;
           int fn2 = 1;
            
           //考虑出错情况
           if (n <= 0) {
               return 0;
           }
           //第一和第二个数直接返回
           if (n == 1 || n == 2) {
               return 1;
           }
    
           //当n>=3时，走这里，用迭代法算出结果
           //这里也说明了，要用三个数操作的情况，其实也可以简化为两
           //个数，从而节省内存空间
           while (n-- > 2) {
               fn1 += fn2;
               fn2 = fn1 - fn2;
           }
           return fn1;
       }
        public int Fibonacci2(int n) {
           if (n <= 0) {
               return 0;
           } else if (n == 1 || n == 2) {
               return 1;
           } else {
               int a = 1, b = 1, c = 0;
               for (int i = 3; i <= n; i++) {
                   c = a + b;
                   b = a;
                   a = c;
               }
               return c;
           }
       }
   }
   ```

3. 动态规划

   ```java
       public int Fibonacci(int n) {
   
           int f = 0, g = 1;
           while (n-- != 0) {
               g += f;
               f = g - f;
           }
           return f;
       }
       public int Fibonacci4(int n) {
           if (n <= 1) {
               return n;
           }
           int[] record = new int[n + 1];
           record[0] = 0;
           record[1] = 1;
           for (int i = 2; i <= n; i++) {
               record[i] = record[i - 1] + record[i - 2];
           }
          return record[n];
       }
   ```

#### 跳台阶

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

**思路：**

对于本题,前提只有 一次 1阶或者2阶的跳法。

- 如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);

- 假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)

- 由a\b假设可以得出总跳法为: `f(n) = f(n-1) + f(n-2)` 

- 然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2

- 可以发现最终得出的是一个斐波那契数列：

          ```
        		| 1, (n=1)
    f(n) =    | 2, (n=2)
              | f(n-1)+f(n-2) ,(n>2,n为整数)
    
    ```
    
    ```

参照上题做出更改即可。

```java
public class Solution {
    public int JumpFloor(int target) {
         if (target <= 0) {
            return 0;
        } else if (target == 1) {
            return 1;
        } else if (target == 2) {
            return 2;
        } else {
            int a = 1, b = 2, c = 0;
            for (int i = 3; i <= target; i++) {
                c = a + b;
                a = b;
                b = c;
            }
            return c;
        }
    }
}
```

#### 变态跳台阶

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

**思路：**

关于本题，前提是n个台阶会有一次n阶的跳法。分析如下:

```
f(1) = 1

f(2) = f(2-1) + f(2-2)         //f(2-2) 表示2阶一次跳2阶的次数。

f(3) = f(3-1) + f(3-2) + f(3-3) 

...

f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n) 
```

说明： 

- 这里的f(n) 代表的是n个台阶有一次1,2,...n阶的 跳法数。

- n = 1时，只有1种跳法，f(1) = 1

- n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2) 

- n = 3时，会有三种跳得方式，1阶、2阶、3阶，

  那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3)

  因此结论是f(3) = f(3-1)+f(3-2)+f(3-3)

- n = n时，会有n中跳的方式，1阶、2阶...n阶，得出结论：

    f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) => f(0) + f(1) + f(2) + f(3) + ... + f(n-1)

- 由以上已经是一种结论，但是为了简单，我们可以继续简化：

    f(n-1) = f(0) + f(1)+f(2)+f(3) + ... + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2)
    
    f(n) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) + f(n-1) = f(n-1) + f(n-1)

可以得出：

```
f(n) = 2*f(n-1)
```

- 得出最终结论,在n阶台阶，一次有1、2、...n阶的跳的方式时，总得跳法为：

              			| 1       ,(n=0 ) 
        f(n) =    | 1       ,(n=1 )
                  | 2*f(n-1),(n>=2)

代码：

```java
public class Solution {
    public int JumpFloorII(int target) {
        if (target<=1)
        {
            return 1;
        }else {
            int a=1;
            return a<<(target-1);
        }
    }
}
```

#### 矩形覆盖

我们可以用`2*1`的小矩形横着或者竖着去覆盖更大的矩形。请问用n个`2*1`的小矩形无重叠地覆盖一个`2*n`的大矩形，总共有多少种方法？

**思路**

`2*n`的大矩形，和n个`2*1`的小矩形
其中`target*2`为大矩阵的大小
有以下几种情形：

- target <= 0 大矩形为<= `2*0`,直接return 1；
- target = 1大矩形为`2*1`，只有一种摆放方法，return 1；
- target = 2 大矩形为`2*2`，有两种摆放方法，return 2；
- target = n 分为两步考虑： 
  - 第一次摆放一块 2*1 的小矩阵，则摆放方法总共为f(target - 1)  
  - 第一次摆放一块1*2的小矩阵，则摆放方法总共为f(target-2) 

```
          | 1       ,(n<1 ) 
f(n) =    | 2       ,(n=2 )
          | f(n-1)+f(n-2) ,(n>=2)
```

1. 递归法

   ```java
   public int RectCover(int target) {
         if(target  <= 1){
               return 1;
           }
           if(target*2 == 2){
               return 1;
           }else if(target*2 == 4){
               return 2;
           }else{
               return RectCover((target-1))+RectCover(target-2);
           }
       }
   ```

2. 非递归法

   ```java
   public int RectCover(int target) {
           if(target==0)
           {
               return 0;
           }else if (target<=1)
           {
               return 1;
           }else if (target==2)
           {
               return 2;
           }else {
               int a=1,b=2,c=0;
               for (int i = 2; i < target; i++) {
                   c=a+b;
                   a=b;
                   b=c;
               }
               return c;
           }
   
       }
   ```

#### 二进制中1的个数

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

1. 正解

   用1（1自身左移运算，其实后来就不是1了）和n的每位进行位与，来判断1的个数

   ```java
       public int NumberOf(int n) {
           int count = 0;
           int flag = 1;
           while (flag != 0) {
               if ((n & flag) != 0) {
                   count++;
               }
               flag = flag << 1;
           }
           return count;
       }
   ```

2. 最优解

   如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。

   举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。

   ```java
   public int NumberOf(int n) {
           int count = 0;
           while (n != 0) {
               ++count;
               n = (n - 1) & n;
           }
           return count;
       }
   ```

#### 数值的整数次方

给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

```java
    /**
     * 1.全面考察指数的正负、底数是否为零等情况。
     * 2.写出指数的二进制表达，例如13表达为二进制1101。
     * 3.举例:10^1101 = 10^0001*10^0100*10^1000。
     * 4.通过&1和>>1来逐位读取1101，为1时将该位代表的乘数累乘到最终结果。
     */
    public double Power(double base, int exponent) {

        double res = 1,curr = base;
        int n;
        if(exponent>0){
            n = exponent;
        }else if(exponent<0){
            if(base==0)
                throw new RuntimeException("分母不能为0");
            n = -exponent;
        }else{// n==0
            return 1;// 0的0次方
        }
        while(n!=0){
            if((n&1)==1)
                res*=curr;
            curr*=curr;// 翻倍
            n>>=1;// 右移一位
        }
        return exponent>=0?res:(1/res);
    }
```

#### 调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

  **相对位置不变--->保持稳定性；奇数位于前面，偶数位于后面 --->存在判断，挪动元素位置；**  

  这些都和内部排序算法相似，考虑到具有稳定性的排序算法不多，例如插入排序，归并排序等；这里采用插入排序的思想实现。 

```java
 /**
     * 1.要想保证原有次序，则只能顺次移动或相邻交换。
     * 2.i从左向右遍历，找到第一个偶数。
     * 3.j从i+1开始向后找，直到找到第一个奇数。
     * 4.将[i,...,j-1]的元素整体后移一位，最后将找到的奇数放入i位置，然后i++。
     * 5.終止條件：j向後遍歷查找失敗。
     */
    public void reOrderArray(int[] a) {
        if (null == a || a.length == 0) {
            return;
        }
        int i = 0, j;
        while (i < a.length) {
            while (i < a.length && !isEven(a[i]))
                i++;
            j = i + 1;
            while (j < a.length && isEven(a[j]))
                j++;
            if (j < a.length) {
                int tmp = a[j];
                for (int j2 = j - 1; j2 >= i; j2--) {
                    a[j2 + 1] = a[j2];
                }
                a[i++] = tmp;
            } else {// 查找失敗
                break;
            }
        }

    }

    boolean isEven(int n) {
        if (n % 2 == 0)
            return true;
        return false;
    }
    public void reOrderArray2(int [] array) {
        //相对位置不变，稳定性
        //插入排序的思想
        int m = array.length;
        int k = 0;//记录已经摆好位置的奇数的个数
        for (int i = 0; i < m; i++) {
            if (array[i] % 2 == 1) {
                int j = i;
                while (j > k) {//j >= k+1
                    int tmp = array[j];
                    array[j] = array[j-1];
                    array[j-1] = tmp;
                    j--;
                }
                k++;
            }
        }
    }
```

#### 链表中倒数第k个结点

输入一个链表，输出该链表中倒数第k个结点。

1. 使用长度为k的链表

```java
    public ListNode FindKthToTail(ListNode head,int k) {
        if (k<=0)
        {
            return null;
        }
        Queue<ListNode> q=new LinkedList<ListNode>();
        ListNode p=head;
        while (null!=p)
        {
            if (q.size()==k)
            {
                q.poll();
            }
            q.offer(p);
            p=p.next;
        }
        if (q.size()>0&&q.size()==k)
        {
            return q.poll();
        }
        return null;
    }
```

2. 两个指针，先让第一个指针和第二个指针都指向头结点，然后再让第一个指正走(k-1)步，到达第k个节点。然后两个指针同时往后移动，当第一个结点到达末尾的时候，第二个结点所在位置就是倒数第k个节点了

   ```java
   public ListNode FindKthToTail(ListNode head,int k) {
           if(head==null||k<=0){
               return null;
           }
           ListNode pre=head;
           ListNode last=head;
           for(int i=1;i<k;i++){
               if(pre.next!=null){
                   pre=pre.next;
               }else{
                   return null;
               }
           }
           while(pre.next!=null){
               pre = pre.next;
               last=last.next;
           }
           return last;
       }
   ```

#### 反转链表

输入一个链表，反转链表后，输出新链表的表头。

```java
    public ListNode ReverseList(ListNode head) {

        if (head == null)
            return null;
        //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null；
        ListNode pre = null;
        ListNode next = null;
        //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点
        //需要pre和next的目的是让当前节点从pre->head->next1->next2变成pre<-head next1->next2
        //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了
        //所以需要用到pre和next两个节点
        //1->2->3->4->5
        //1<-2<-3 4->5
        while (head != null) {
            //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre
            //如此就可以做到反转链表的效果
            //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂
            next = head.next;
            //保存完next，就可以让head从指向next变成指向pre了，代码如下
            head.next = pre;
            //head指向pre后，就继续依次反转下一个节点
            //让pre，head，next依次向后移动一个节点，继续下一次的指针反转
            pre = head;
            head = next;
        }
        //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点
        //直接输出pre就是我们想要得到的反转后的链表
        return pre;
    }
```

#### 合并两个排序的链表

输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

1. 递归

   ```java
   /*
   public class ListNode {
       int val;
       ListNode next = null;
   
       ListNode(int val) {
           this.val = val;
       }
   }*/
   public class Solution {
       public ListNode Merge(ListNode list1,ListNode list2) {
           if(list1==null)
               return list2;
           if(list2==null)
               return list1;
           ListNode res = null;
           if(list1.val<list2.val){
               res = list1;
               res.next = Merge(list1.next, list2);
           }else{
               res = list2;
               res.next = Merge(list1, list2.next);
           }
           return res;
       }
   }
   ```

2. 非递归

   ```java
   public class Solution {
       public ListNode Merge(ListNode list1,ListNode list2) {
           //新建一个头节点，用来存合并的链表。
           ListNode head=new ListNode(-1);
           head.next=null;
           ListNode root=head;
           while(list1!=null&&list2!=null){
               if(list1.val<list2.val){
                   head.next=list1;
                   head=list1;
                   list1=list1.next;
               }else{
                   head.next=list2;
                   head=list2;
                   list2=list2.next;
               }
           }
           //把未结束的链表连接到合并后的链表尾部
           if(list1!=null){
               head.next=list1;
           }
           if(list2!=null){
               head.next=list2;
           }
           return root.next;
       }
   }
   ```

#### 树的子结构

输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

思路：对A树DFS，如果B的根节点与A中某个节点值相同，那么以B为树根进行DFS，判断即可

时间复杂度为O(n * m) 

```java
public class Solution {
    public static boolean HasSubtree(TreeNode root1, TreeNode root2) {
        boolean result = false;
        //当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false
        if (root2 != null && root1 != null) {
            //如果找到了对应Tree2的根节点的点
            if(root1.val == root2.val){
                //以这个根节点为为起点判断是否包含Tree2
                result = doesTree1HaveTree2(root1,root2);
            }
            //如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2
            if (!result) {
                result = HasSubtree(root1.left,root2);
            }
             
            //如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2
            if (!result) {
                result = HasSubtree(root1.right,root2);
               }
            }
            //返回结果
        return result;
    }
 
    public static boolean doesTree1HaveTree2(TreeNode node1, TreeNode node2) {
        //如果Tree2已经遍历完了都能对应的上，返回true
        if (node2 == null) {
            return true;
        }
        //如果Tree2还没有遍历完，Tree1却遍历完了。返回false
        if (node1 == null) {
            return false;
        }
        //如果其中有一个点没有对应上，返回false
        if (node1.val != node2.val) {  
                return false;
        }
         
        //如果根节点对应的上，那么就分别去子节点里面匹配
        return doesTree1HaveTree2(node1.left,node2.left) && doesTree1HaveTree2(node1.right,node2.right);
    }
}
```

使用短路方式：

```java
    public boolean HasSubtree(TreeNode root1, TreeNode root2) {
        if (root1 == null || root2 == null) {
            return false;
        }
        return isSubtree(root1, root1) ||
                HasSubtree(root1.left, root2) ||
                HasSubtree(root1.right, root2);
    }


    private boolean isSubtree(TreeNode pRootA, TreeNode pRootB) {
        if (pRootB == null) return true;
        if (pRootA == null) return false;
        if (pRootB.val == pRootA.val) {
            return isSubtree(pRootA.left, pRootB.left)
                    && isSubtree(pRootA.right, pRootB.right);
        } else return false;
    }
```

#### 二叉树的镜像

操作给定的二叉树，将其变换为源二叉树的镜像。

```
二叉树的镜像定义：源二叉树 
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5
```

1. 递归

   ```java
   /* 先前序遍历这棵树的每个结点，如果遍历到的结点有子结点，就交换它的两个子节点，
   当交换完所有的非叶子结点的左右子结点之后，就得到了树的镜像 */
   /**
   public class TreeNode {
       int val = 0;
       TreeNode left = null;
       TreeNode right = null;
   
       public TreeNode(int val) {
           this.val = val;
   
       }
   
   }
   */
   public class Solution {
       public void Mirror(TreeNode root) {
            TreeNode tmp=null;
   		 if(root == null)
               return;
            if(root.left == null && root.right == null)
               return;
              tmp=root.left;
              root.left=root.right;
              root.right=tmp;
              if (root.left!=null)
              {
                  Mirror(root.left);
              }
              if (root.right!=null)
              {
                  Mirror(root.right);
              }
       }
   }
   ```

2. 非递归

   ```java
   import java.util.Stack;
   public class Solution {
      public void Mirror(TreeNode root) {
           if (root == null || (root.left == null && root.right == null))
               return;
           Stack<TreeNode> stack = new Stack<>();
           stack.push(root);
           while (!stack.empty()) {
               TreeNode node = stack.pop();
               if (null != node.left || null != node.right) {
                   TreeNode tmp = node.left;
                   node.left = node.right;
                   node.right = tmp;
               }
               if (null != node.left) {
                   stack.push(node.left);
               }
               if (null != node.right) {
                   stack.push(node.right);
               }
           }
       }
   }
   ```

#### 顺时针打印矩阵

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 

```
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16 
```

则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

```java
/*
解题思路：顺时针打印就是按圈数循环打印，一圈包含两行或者两列，在打印的时候会出现某一圈中只包含一行，
要判断从左向右打印和从右向左打印的时候是否会出现重复打印，同样只包含一列时，
要判断从上向下打印和从下向上打印的时候是否会出现重复打印的情况
*/
  public ArrayList<Integer> printMatrix(int[][] array) {
        ArrayList<Integer> result = new ArrayList<Integer>();
        if (array.length == 0) 
            return result;

        int n = array.length,//行数
                m = array[0].length;//列数

        if (m == 0) return result;

        int layers = (Math.min(n, m) - 1) / 2 + 1; //这个是层数

        for (int i = 0; i < layers; i++) {
            
            for (int k = i; k < m - i; k++) 
                result.add(array[i][k]);//左至右
            for (int j = i + 1; j < n - i; j++) 
                result.add(array[j][m - i - 1]);//右上至右下
            for (int k = m - i - 2; (k >= i) && (n - i - 1 != i); k--) 
                result.add(array[n - i - 1][k]);//右至左
            for (int j = n - i - 2; (j > i) && (m - i - 1 != i); j--)
                result.add(array[j][i]);//左下至左上
        }
        return result;
    }
```

#### 包含min函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。

  每入栈一次，就与辅助栈顶比较大小，如果小就入栈，如果大就入栈当前的辅助栈顶 

  当出栈时，辅助栈也要出栈 

```java
import java.util.Stack;

public class Solution {
 
    //数据
    private Stack<Integer> s1=new Stack<>();
    //最小值
    private Stack<Integer> s2=new Stack<>();
    
    public void push(int node) {
        if (s2.empty())
        {
            s2.push(node);
        }else {
            if (s2.peek()>node)
            {
                s2.push(node);
            }
        }
        s1.push(node);
    }

    public void pop() {
        if (s1.empty())
        {
            return;
        }
        if (s1.peek().equals(s2.peek()))
        {
            s2.pop();
        }
        s1.pop();
    }

    public int top() {
        return s1.peek();
    }

    public int min() {
        return s2.peek();
    }
}
```

#### 栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

```java
public boolean IsPopOrder(int[] pushA, int[] popA) {
        if (pushA.length == 0) return false;
        Stack<Integer> stack = new Stack<>();
        for (int i = 0, j = 0; i < pushA.length; ) {
            stack.push(pushA[i++]);
            while (j < popA.length && stack.peek() == popA[j]) {
                stack.pop();
                j++;
            }
        }
        return stack.empty();
    }
```

#### 从上往下打印二叉树

从上往下打印出二叉树的每个节点，同层节点从左至右打印。（层序遍历）

```java
public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        ArrayList<Integer> list = new ArrayList<Integer>();

        if (null != root) {
            Queue<TreeNode> s = new LinkedList<>();
            TreeNode tmp = root;
            s.offer(root);
            while (s.size() != 0) {
                tmp = s.poll();
                list.add(tmp.val);
                if (tmp.left != null) {
                    s.offer(tmp.left);
                }
                if (tmp.right != null) {
                    s.offer(tmp.right);
                }
            }
        }

        return list;
    }
```

#### 二叉搜索树的后序遍历序列

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

思路：  BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x   （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。完美的递归定义   : ) 。

```java
//已知条件：后序序列最后一个值为root；二叉搜索树左子树值都比root小，右子树值都比root大。
//1、确定root；
//2、遍历序列（除去root结点），找到第一个大于root的位置，则该位置左边为左子树，右边为右子树；
//3、遍历右子树，若发现有小于root的值，则直接返回false；
//4、分别判断左子树和右子树是否仍是二叉搜索树（即递归步骤1、2、3）。
    public boolean VerifySquenceOfBST(int [] sequence) {

        if ( sequence==null || sequence.length<=0 ) return false;
        return VerifySquenceOfBST(sequence, 0, sequence.length-1);
    }

    private boolean VerifySquenceOfBST(int [] sequence, int start, int end){
        if ( start>=end )
            return true;

        int root = sequence[end];

        int i=start;
        while( sequence[i] < root ){
            i++;
        }

        int j=i;
        while( j<end ){
            if ( sequence[j]<root ) {
                return false;
            }
            j++;
        }

        boolean left = VerifySquenceOfBST(sequence, start, i-1);
        boolean right = VerifySquenceOfBST(sequence, i, end-1);
        return left && right;
    }
```

#### 二叉树中和为某一值的路径

输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)

```java
 ArrayList<ArrayList<Integer>> listAll = new ArrayList<ArrayList<Integer>>();
    ArrayList<Integer> list = new ArrayList<Integer>();

    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root, int target) {


        if (root == null) return listAll;
        list.add(root.val);
        target -= root.val;
        if (target == 0 && root.left == null && root.right == null)
            listAll.add(new ArrayList<Integer>(list));
        FindPath(root.left, target);
        FindPath(root.right, target);
        list.remove(list.size() - 1);
        return listAll;
    }
```

#### 复杂链表的复制

输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

```java
/*
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}
*/
public class Solution {
    public RandomListNode Clone(RandomListNode pHead)
    {
          if (pHead == null) {
            return null;
        }

        RandomListNode currentNode = pHead;
        //1、复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；
        while (currentNode != null) {
            RandomListNode cloneNode = new RandomListNode(currentNode.label);
            RandomListNode nextNode = currentNode.next;
            currentNode.next = cloneNode;
            cloneNode.next = nextNode;
            currentNode = nextNode;
        }

        currentNode = pHead;
        //2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;
        while (currentNode != null) {
            currentNode.next.random = currentNode.random == null ? null : currentNode.random.next;
            currentNode = currentNode.next.next;
        }

        //3、拆分链表，将链表拆分为原链表和复制后的链表
        currentNode = pHead;
        RandomListNode pCloneHead = pHead.next;
        while (currentNode != null) {
            RandomListNode cloneNode = currentNode.next;
            currentNode.next = cloneNode.next;
            cloneNode.next = cloneNode.next == null ? null : cloneNode.next.next;
            currentNode = currentNode.next;
        }

        return pCloneHead;
    }
}
```

#### 二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

1. 非递归版

   解题思路：

   - 核心是中序遍历的非递归算法。
   - 修改当前遍历节点与前一遍历节点的指针指向。

   ```java
     import java.util.Stack;
   
       public TreeNode ConvertBSTToBiList(TreeNode root) {
           if(root==null)
               return null;
           Stack<TreeNode> stack = new Stack<TreeNode>();
           TreeNode p = root;
           TreeNode pre = null;// 用于保存中序遍历序列的上一节点
           boolean isFirst = true;
           while(p!=null||!stack.isEmpty()){
               while(p!=null){
                   stack.push(p);
                   p = p.left;
               }
               p = stack.pop();
               if(isFirst){
                   root = p;// 将中序遍历序列中的第一个节点记为root
                   pre = root;
                   isFirst = false;
               }else{
                   pre.right = p;
                   p.left = pre;
                   pre = p;
               }      
               p = p.right;
           }
           return root;
       }
   ```

2. 递归版

   解题思路：

   - 将左子树构造成双链表，并返回链表头节点。
   - 定位至左子树双链表最后一个节点。
   - 如果左子树链表不为空的话，将当前root追加到左子树链表。
   - 将右子树构造成双链表，并返回链表头节点。
   - 如果右子树链表不为空的话，将该链表追加到root节点之后。
   - 根据左子树链表是否为空确定返回的节点。

   ```java
     public TreeNode Convert(TreeNode root) {
           if(root==null)
               return null;
           if(root.left==null&&root.right==null)
               return root;
           // 1.将左子树构造成双链表，并返回链表头节点
           TreeNode left = Convert(root.left);
           TreeNode p = left;
           // 2.定位至左子树双链表最后一个节点
           while(p!=null&&p.right!=null){
               p = p.right;
           }
           // 3.如果左子树链表不为空的话，将当前root追加到左子树链表
           if(left!=null){
               p.right = root;
               root.left = p;
           }
           // 4.将右子树构造成双链表，并返回链表头节点
           TreeNode right = Convert(root.right);
           // 5.如果右子树链表不为空的话，将该链表追加到root节点之后
           if(right!=null){
               right.left = root;
               root.right = right;
           }
           return left!=null?left:root;       
       }
   ```

3. 改进递归版

   解题思路：

   思路与方法二中的递归版一致，仅对第2点中的定位作了修改，新增一个全局变量记录左子树的最后一个节点。

   ```java
       // 记录子树链表的最后一个节点，终结点只可能为只含左子树的非叶节点与叶节点
       protected TreeNode leftLast = null;
       public TreeNode Convert(TreeNode root) {
           if(root==null)
               return null;
           if(root.left==null&&root.right==null){
               leftLast = root;// 最后的一个节点可能为最右侧的叶节点
               return root;
           }
           // 1.将左子树构造成双链表，并返回链表头节点
           TreeNode left = Convert(root.left);
           // 3.如果左子树链表不为空的话，将当前root追加到左子树链表
           if(left!=null){
               leftLast.right = root;
               root.left = leftLast;
           }
           leftLast = root;// 当根节点只含左子树时，则该根节点为最后一个节点
           // 4.将右子树构造成双链表，并返回链表头节点
           TreeNode right = Convert(root.right);
           // 5.如果右子树链表不为空的话，将该链表追加到root节点之后
           if(right!=null){
               right.left = root;
               root.right = right;
           }
           return left!=null?left:root;       
       }
   ```

#### 字符串的排列

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

输入描述:输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。

1. 递归

   ```java
   /**
        * 1、递归算法
        *
        * 解析：http://www.cnblogs.com/cxjchen/p/3932949.html  (感谢该文作者！)
        *
        * 对于无重复值的情况
        *
        * 固定第一个字符，递归取得首位后面的各种字符串组合；
        * 再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合； *递归的出口，就是只剩一个字符的时候，递归的循环过程，就是从每个子串的第二个字符开始依次与第一个字符交换，然后继续处理子串。
        *
        * 假如有重复值呢？
        * *由于全排列就是从第一个数字起，每个数分别与它后面的数字交换，我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这两个数就不交换了。
        * 例如abb，第一个数与后面两个数交换得bab，bba。然后abb中第二个数和第三个数相同，就不用交换了。
        * 但是对bab，第二个数和第三个数不 同，则需要交换，得到bba。
        * 由于这里的bba和开始第一个数与第三个数交换的结果相同了，因此这个方法不行。
        *
        * 换种思维，对abb，第一个数a与第二个数b交换得到bab，然后考虑第一个数与第三个数交换，此时由于第三个数等于第二个数，
        * 所以第一个数就不再用与第三个数交换了。再考虑bab，它的第二个数与第三个数交换可以解决bba。此时全排列生成完毕！
        */
    
   public ArrayList<String> Permutation(String str){
    
           ArrayList<String> list = new ArrayList<String>();
           if(str!=null && str.length()>0){
               PermutationHelper(str.toCharArray(),0,list);
               Collections.sort(list);
           }
           return list;
       }
   
       private void PermutationHelper(char[] chars,int i,ArrayList<String> list){
           if(i == chars.length-1){
               list.add(String.valueOf(chars));
           }else{
               Set<Character> charSet = new HashSet<Character>();
               for(int j=i;j<chars.length;++j){
                   if(j==i || !charSet.contains(chars[j])){
                       charSet.add(chars[j]);
                       swap(chars,i,j);
                       PermutationHelper(chars,i+1,list);
                       swap(chars,j,i);
                   }
               }
           }
       }
    
       private void swap(char[] cs,int i,int j){
           char temp = cs[i];
           cs[i] = cs[j];
           cs[j] = temp;
       }
   ```

2. 非递归

   ```java
    
   /**
        * 2、字典序排列算法
        *
        * 可参考解析： http://www.cnblogs.com/pmars/archive/2013/12/04/3458289.html  （感谢作者）
        *
        * 一个全排列可看做一个字符串，字符串可有前缀、后缀。
        * 生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。
        * 这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。
        *
        * [例]839647521是1--9的排列。1—9的排列最前面的是123456789，最后面的987654321，
        * 从右向左扫描若都是增的，就到了987654321，也就没有下一个了。否则找出第一次出现下降的位置。
        *
        * 【例】 如何得到346987521的下一个
        * 1，从尾部往前找第一个P(i-1) < P(i)的位置
        * 3 4 6 <- 9 <- 8 <- 7 <- 5 <- 2 <- 1
        * 最终找到6是第一个变小的数字，记录下6的位置i-1
        *
        * 2，从i位置往后找到最后一个大于6的数
        * 3 4 6 -> 9 -> 8 -> 7 5 2 1
        * 最终找到7的位置，记录位置为m
        *
        * 3，交换位置i-1和m的值
        * 3 4 7 9 8 6 5 2 1
        * 4，倒序i位置后的所有数据
        * 3 4 7 1 2 5 6 8 9
        * 则347125689为346987521的下一个排列
        *
        * @param str
        * @return
        */
    
   public ArrayList<String> Permutation2(String str){
           ArrayList<String> list = new ArrayList<String>();
           if(str==null || str.length()==0){
               return list;
           }
           char[] chars = str.toCharArray();
           Arrays.sort(chars);
           list.add(String.valueOf(chars));
           int len = chars.length;
           while(true){
               int lIndex = len-1;
               int rIndex;
               while(lIndex>=1 && chars[lIndex-1]>=chars[lIndex]){
                   lIndex--;
               }
               if(lIndex == 0)
                   break;
               rIndex = lIndex;
               while(rIndex<len && chars[rIndex]>chars[lIndex-1]){
                   rIndex++;
               }
               swap(chars,lIndex-1,rIndex-1);
               reverse(chars,lIndex);
    
               list.add(String.valueOf(chars));
           }
    
           return list;
       }
       private void reverse(char[] chars,int k){
           if(chars==null || chars.length<=k)
               return;
           int len = chars.length;
           for(int i=0;i<(len-k)/2;i++){
               int m = k+i;
               int n = len-1-i;
               if(m<=n){
                   swap(chars,m,n);
               }
           }
    
       }
   ```

#### 组中出现次数超过一半的数字

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

1. 方法一

   采用用户“分形叶”思路（注意到目标数超过数组长度的一半，对数组同时去掉两个不同的数字，到最后剩下的一个数就是该数字。如果剩下两个，那么这两个也是一样的，就是结果），在其基础上把最后剩下的一个数字或者两个回到原来数组中，将数组遍历一遍统计一下数字出现次数进行最终判断。

   ```java
   public class Solution {
       public int MoreThanHalfNum_Solution(int [] array) {
           int length=array.length;
               if(array==null||length<=0){
                   return 0;
               }
               
               if(length==1){
                   return array[1];
               }
               
               int[] tempArray=new int[length];
               for(int i=0;i<length;i++){
                   tempArray[i]=array[i];
               }
               
               for(int i=0;i<length;i++){
                   //后面需要用零来代表抹除数字，所以对0时做特殊处理
                   if(tempArray[i]==0){
                       continue;
                   }
                   
                   for(int j=i+1;j<length;j++){
                       if(tempArray[i]!=tempArray[j]&&tempArray[j]!=0){
                           tempArray[i]=0;//此处用0代表抹去该数字
                           tempArray[j]=0;
                           break;
                       }
                       
                   }
               }
               
               //找出未被抹去的数字
               int result=0;
               for(int i=0;i<length;i++){
                   if(tempArray[i]!=0){
                       result=tempArray[i];
                       break;
                   }
               }
               
               int times=0;
               for(int i=0;i<length;i++){
                   if(result==array[i]){
                       
                       times++;
                   }
               }
               
               if(times*2<length){
                   result=0;
               }
               return result;
       }
   }
   ```

2. 方法二

   ```java
    public int MoreThanHalfNum_Solution(int [] array) {
           HashMap<Integer,Integer> map=new HashMap<>();
           if (null==array||array.length==0)
           {
               return 0;
           }
           for (int key : array) {
               if (map.containsKey(key))
               {
                   Integer count = map.get(key);
                   count++;
                   map.put(key,count);
               }else {
                   map.put(key,1);
               }
           }
           int s=(int)array.length/2;
           for (Integer key : map.keySet()) {
   
               if (map.get(key)>s)
               {
                   return key;
               }
           }
           return 0;
   
       }
   ```

3. 方法三，时间复杂度是O(n)

   ```java
       public int MoreThanHalfNum_Solution(int[] array) {
           if (array == null || array.length <= 0) {
               return 0;
           }
           int length = array.length;
           int result = array[0];
           int times = 1;
           for (int i = 1; i < length; i++) {
               if (times == 0) {
                   result = array[i];
                   times = 1;
               } else {
                   if (array[i] == result) {
                       times++;
                   } else {
                       times--;
                   }
               }
           }
   
           times = 0;
           for (int i = 0; i < length; i++) {
               if (result == array[i]) {
                   times++;
               }
           }
   
           if (times * 2 < length) {
               result = 0;
           }
           return result;
       }
   
   ```

#### 最小的K个数

输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。

1.   用最大堆保存这k个数，每次只和堆顶比，如果比堆顶小，删除堆顶，新数入堆，java中的优先队列是基于堆实现的。时间复杂度为O(nlogk)

   ```java
   public ArrayList<Integer> GetLeastNumbers_Solution(int[] input, int k) {
           ArrayList<Integer> result = new ArrayList<Integer>();
           int length = input.length;
           if (k > length || k == 0) {
               return result;
           }
           PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(k, new Comparator<Integer>() {
   
               @Override
               public int compare(Integer o1, Integer o2) {
                   return o2.compareTo(o1);
               }
           });
           for (int i = 0; i < length; i++) {
               if (maxHeap.size() != k) {
                   maxHeap.offer(input[i]);
               } else if (maxHeap.peek() > input[i]) {
                   Integer temp = maxHeap.poll();
                   temp = null;
                   maxHeap.offer(input[i]);
               }
           }
           for (Integer integer : maxHeap) {
               result.add(integer);
           }
           return result;
       }
   ```

2. 快速排序，时间复杂度为O(nlogn)；

3. 冒泡排序，时间复杂度为O(n*k)

#### 连续子数组的最大和

HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)

```java

//    F（i）：以array[i]为末尾元素的子数组的和的最大值，子数组的元素的相对位置不变
//    F（i）=max（F（i-1）+array[i] ， array[i]）
//    res：所有子数组的和的最大值
//            res=max（res，F（i））

//    如数组[6, -3, -2, 7, -15, 1, 2, 2]
//    初始状态：
//    F（0）=6
//    res=6
//    i=1：
//    F（1）=max（F（0）-3，-3）=max（6-3，3）=3
//    res=max（F（1），res）=max（3，6）=6
//    i=2：
//    F（2）=max（F（1）-2，-2）=max（3-2，-2）=1
//    res=max（F（2），res）=max（1，6）=6
//    i=3：
//    F（3）=max（F（2）+7，7）=max（1+7，7）=8
//    res=max（F（2），res）=max（8，6）=8
//    i=4：
//    F（4）=max（F（3）-15，-15）=max（8-15，-15）=-7
//    res=max（F（4），res）=max（-7，8）=8
//    以此类推
//            最终res的值为8
    public int FindGreatestSumOfSubArray(int[] array) {
        int res = array[0]; //记录当前所有子数组的和的最大值
        int max=array[0];   //包含array[i]的连续数组最大值
        for (int i = 1; i < array.length; i++) {
            max=Math.max(max+array[i], array[i]);
            res=Math.max(max, res);
        }
        return res;
    }
```


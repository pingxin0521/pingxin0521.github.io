---
title: 算法入门
date: 2019-05-24 23:18:59
tags:
 - 算法
categories:
 - 算法
---

算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。

**算法可视化：**<https://visualgo.net/zh>

<!--more-->

#### 特性

一个算法应该具有以下五个重要的特征：

- 有穷性（Finiteness）：算法的有穷性是指算法必须能在执行有限个步骤之后终止；
- 确切性(Definiteness)：算法的每一步骤必须有确切的定义；
- 输入项(Input)：一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；
- 输出项(Output)：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；
- 可行性(Effectiveness)：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成（也称之为有效性）。

#### 评定

同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。一个算法的评价主要从时间复杂度和空间复杂度来考虑。

- 时间复杂度

  算法的时间复杂度是指执行算法所需要的计算工作量。一般来说，计算机算法是问题规模n 的函数f(n)，算法的时间复杂度也因此记做。

  ```
  T(n)=Ο(f(n))
  ```

  因此，问题的规模n 越大，算法执行的时间的增长率与f(n) 的增长率正相关，称作渐进时间复杂度（Asymptotic Time Complexity）。

- 空间复杂度算法的空间复杂度是指算法需要消耗的内存空间。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。

- 正确性：算法的正确性是评价一个算法优劣的最重要的标准。

- 可读性：算法的可读性是指一个算法可供人们阅读的容易程度。
- 健壮性 ：健壮性是指一个算法对不合理数据输入的反应能力和处理能力，也称为容错性。

#### 时间复杂度

![](https://i.loli.net/2019/06/29/5d175cd209db541292.png)

**推导方法**

1. 用常数1取代运行时间中的所有加法常数。

2. 在修改后的运行次数函数中，只保留最高阶项。

3. 如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。

**示例**

1. 常数O（1）

    首先顺序结构的时间复杂度。下面这个算法，是利用高斯定理计算1，2，……n个数的和。

   ```c++
   int sum = 0, n = 100;       /*执行一次*/
   sum = (1 + n) * n / 2;      /*执行一次*/
   printf("%d",sum);           /*执行一次*/
   ```

    这个算法的运行次数函数是f (n)  =3。 根据我们推导大0阶的方法，第一步就是把常数项3 改为1。在保留最高阶项时发现，它根本没有最高阶项，所以这个算法的时间复杂度为0(1)。

   另外，我们试想一下，如果这个算法当中的语句 sum = (1+n)*n/2; 有10 句，则与示例给出的代码就是3次和12次的差异。这种与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O(1)的时间复杂度，又叫常数阶。对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着n 的变大而发生变化，所以**单纯的分支结构(不包含在循环结构中)，其时间复杂度也是0(1)**。

2. 线性阶

   线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行的次数。因此，我们要分析算法的复杂度，关键就是要分析循环结构的运行情况。

    下面这段代码，它的循环的时间复杂度为**O(n)**， 因为循环体中的代码须要执行n次

   ```c++
   int i;      
   for(i = 0; i < n; i++){
       /*时间复杂度为O(1)的程序步骤序列*/
   }
   ```

3. 对数阶

   ```c++
   int count = 1;      
   while (count < n){
      count = count * 2;
     /*时间复杂度为O(1)的程序步骤序列*/
   }
   ```

   由于每次count乘以2之后，就距离n更近了一分。 也就是说，有多少个2相乘后大于n，则会退出循环。 由2^x=n 得到x=logn。 所以这个循环的时间复杂度为**O(logn)**。

4. 平方阶

   下面例子是一个循环嵌套，它的内循环刚才我们已经分析过，时间复杂度为O(n)。

   ```c++
   int i, j;      
   for(i = 0; i < n; i++){
       for(j = 0; j < n; j++){
           /*时间复杂度为O(1)的程序步骤序列*/
       }
   }
   ```

   而对于外层的循环，不过是内部这个时间复杂度为O(n)的语句，再循环n次。 所以这段代码的时间复杂度为O(n^2)。

   如果外循环的循环次数改为了m，时间复杂度就变为O(mXn)。

   所以我们可以总结得出，循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。
   那么下面这个循环嵌套，它的时间复杂度是多少呢

   ```c++
   int i, j;      
   for(i = 0; i < n; i++){
       for(j = i; j < n; j++){   /*注意j = i而不是0*/
           /*时间复杂度为O(1)的程序步骤序列*/
       }
   }
   ```

   由于当i=0时，内循环执行了n次，当i = 1时，执行了n-1次，……当i=n-1时，执行了1次。所以总的执行次数为:n*(n+1)/2

   用我们推导大O阶的方法，第一条，没有加法常数不予考虑；第二条，只保留最高阶项，因此保留时(n^2)/2; 第三条，去除这个项相乘的常数，也就是去除1/2，最终这段代码的时间复杂度为O(n2)。

   从这个例子，我们也可以得到一个经验，其实理解大0推导不算难，难的是**对数列的一些相关运算，这更多的是考察你的数学知识和能力。**

5. 立方阶

   下面例子是一个三重循环嵌套

   ```java
   int i, j;      
   for(i = 1; i < n; i++)
       for(j = 1; j < n; j++)
           for(j = 1; j < n; j++){
               /*时间复杂度为O(1)的程序步骤序列*/
    
           }
   ```

   这里循环了(1^2+2^2+3^2+……+n^2) = n(n+1)(2n+1)/6次，按照上述大O阶推导方法，时间复杂度为O(n^3)。

6. 指数阶

   ```c++
   for(j = 1; j < pow(2,n); j++){
   /*时间复杂度为O(1)的程序步骤序列*/
   
   }
   ```

7. 阶乘阶

   ```c++
   for(j = 1; j <=factorial(n); j++){
   /*时间复杂度为O(1)的程序步骤序列*/
   
   }
   ```

**常见的时间复杂度**

常见的时问复杂度如表所示。

| 执行次数函数  | 阶       | 非正式术语 |
| ------------- | -------- | ---------- |
| 12            | O(1)     | 常数阶     |
| 2n+3          | O(n)     | 线性阶     |
| 3n²+2n+1      | O(n²)    | 平方阶     |
| 5log2n+20     | O(logn)  | 对数阶     |
| 2n+3nlog2n+19 | O(nlogn) | nlogn阶    |
| 6n³+2n²+3n+4  | O(n³)    | 立方阶     |
| 2^n           | O(2^n)   | 指数阶     |

常用的时间复杂度所耗费的时间从小到大依次是：

```
O(1)<O(logn)<O(n)<O(nlogn)<O(n²)<O(n³)<O(2^n)<O(n!)<O(n^n)
```

我们前面已经谈到了。O(1)常数阶、O(logn)对数阶、O(n)线性阶、 O(n^2)平方阶等，像O(n^3)，过大的n都会使得结果变得不现实。同样指数阶O(2^n)和阶乘阶O(n!)等除非是很小的n值，否则哪怕n 只是100，都是噩梦般的运行时间。所以这种不切实际的算法时间复杂度，一般我们都不去讨论。

**常见数据结构的时间复杂度和空间复杂度**

![](https://i.loli.net/2019/06/29/5d175ac24c78687902.png)

**常见排序方法的时间复杂度和空间复杂度**

![2019-06-29 20-33-10 的屏幕截图.png](https://i.loli.net/2019/06/29/5d175ac2592cc43046.png)

中文版：

![4.png](https://i.loli.net/2019/06/29/5d1756ebe586d36746.png)

**一些计算的规则**

1. 加法规则

     T(n,m) = T1(n) + T2(m) = O(max{f(n), g(m)})
2. 乘法规则

     T(n,m) = T1(n) * T2(m) = O(max{f(n)*g(m)})
3. 一个经验

     复杂度与时间效率的关系：
    c(常数) < logn < n < n*logn < n^2 < n^3 < 2^n < 3^n < n!
    l------------------------------l--------------------------l--------------l
                   较好                          一般                    较差
#### 主定理（Master Theorem）

在算法分析中，主定理（英语：master theorem）提供了用渐近符号（大O符号）表示许多由分治法得到的**递推关系式**的方法。

```
T(n) = a T(n/b) + f(n) where a >= 1 and b > 1
```

Case 1:

![2019-06-29 20-28-26 的屏幕截图.png](https://i.loli.net/2019/06/29/5d175998a524968219.png)

Case 2:

![2019-06-29 20-28-33 的屏幕截图.png](https://i.loli.net/2019/06/29/5d175998b2a0428162.png)

Case 3:

![2019-06-29 20-28-38 的屏幕截图.png](https://i.loli.net/2019/06/29/5d175998be22e46993.png)

推导：<https://www.jianshu.com/p/ca2cc9c5703b>

![](https://i.loli.net/2019/06/29/5d175ea78734e95019.png)


---
title: Spring Security 认证的常用方法
date: 2019-10-07 18:18:59
tags:
 - Java
 - 框架
categories:
 - Java
 - 框架
---

### 认证(Authentication)

#### 示例

<!--more-->

1. 引入spring-boot-starter-security依赖

   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-security</artifactId>
   </dependency>
   
   ```

2. 一个简单的测试Controller

   ```java
   @RestController
   public class ExampleController {
   
       @GetMapping("helloworld")
       public List<String> helloworld() {
           return Arrays.asList("Spring Security simple demo");
       }
   }
   
   ```

3. 开始验证

   - 启动应用程序，控制台会打印一个生成的密码，如"Using generated security password: 4dd8384a-bc9e-4df0-9124-6686c9a813fa"，该密码每次启动应用程序都会改变
   - 访问 <http://localhost:8081/helloworld>
   - 系统会自动重定向到 <http://localhost:8081/login> （注意：这个登录页面不是自己写的，是Spring Security默认的登录页面）
   - 输入用户名和密码，用户名为"user", 密码就是控制台生成的"4dd8384a-bc9e-4df0-9124-6686c9a813fa"
     系统会自动重定向到 <http://localhost:8081/helloworld> ，从而能够访问到接口

##### 示例分析

下面是Spring Security认证的重要流程，自己可以打断点看一下程序是怎么执行的。

过程一：从访问的目标接口重定向到登录页面

```
http://localhost:8080/helloworld
| AnonymousAuthenticationFilter#doFilter	检查安全上下文SecurityContextHolder中是否有认证信息，如果没有就设置为匿名认证令牌AnonymousAuthenticationToken
| FilterSecurityInterceptor extends AbstractSecurityInterceptor#doFilter
	| FilterSecurityInterceptor#invoke
		| AbstractSecurityInterceptor#beforeInvocation
			 | AffirmativeBased extends AbstractAccessDecisionManager#decide 访问决定管理器: 决定一个url是否有权限访问，具体决定操作由投票器决定
				| WebExpressionVoter#vote() 投票器: 对url是否有权限访问进行投票，是否允许访问，允许则投"通过"，不允许则投"拒绝"
					| ExpressionUtils#evaluateAsBoolean
						|SpelExpression#getValue(org.springframework.expression.EvaluationContext, java.lang.Class<T>)
							| PropertyOrFieldReference#getValueInternal()
								| PropertyOrFieldReference#readProperty
									| ReflectivePropertyAccessor.OptimalPropertyAccessor#read
										| SecurityExpressionRoot#isAuthenticated() 投票的最终结果(拒绝)
			 	| 如果投票结果是拒绝则抛出访问拒绝异常new AccessDeniedException("Access is denied")
| ExceptionTranslationFilter#doFilter 异常转换过滤器：用于捕获过滤器抛出的异常，并作出适当的处理
	| catch(Exception ex)
		| handleSpringSecurityException(request, response, chain, ase)
			| sendStartAuthentication()	
				| DelegatingAuthenticationEntryPoint#commence
					| LoginUrlAuthenticationEntryPoint#commence
						| DefaultRedirectStrategy#sendRedirect(request, response, redirectUrl); 重定向登录路径redirectUrl="http://localhost:8081/login"
							| response.sendRedirect(redirectUrl)							
| DefaultLoginPageGeneratingFilter#doFilter 拦截登录路径"/login", 如果没有指定登录页面就会生成默认的登录页面
	| generateLoginPageHtml()
	| response.setContentType("text/html;charset=UTF-8")
	| response.getWriter().write(loginPageHtml)

```

过程二：从登录页面重定向到目标接口

```
| 输入用户名、密码登录	
| UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter#doFilter
	| Authentication authResult = attemptAuthentication(request, response) 尝试认证
		| authRequest = new UsernamePasswordAuthenticationToken(username, password)
		| ProviderManager.authenticate(authRequest)
			| DaoAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider#authenticate
				| retrieveUser(username, authentication) 
					| UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username)
						| InMemoryUserDetailsManager#loadUserByUsername 如果用户名错误会抛异常 UsernameNotFoundException
				| additionalAuthenticationChecks(user, authentication)
					| passwordEncoder.matches(presentedPassword, userDetails.getPassword()) 检查密码，如果密码不匹配则抛出异常BadCredentialsException
	| successfulAuthentication(request, response, chain, authResult) 处理认证成功操作
		| SavedRequestAwareAuthenticationSuccessHandler#onAuthenticationSuccess
			| SimpleUrlAuthenticationSuccessHandler#onAuthenticationSuccess
				| handle(request, response, authentication)
					| DefaultRedirectStrategy#sendRedirect(request, response, targetUrl) 
						| response.sendRedirect(redirectUrl) 重定向到"http://localhost:8080/helloworld"

```

首先我们要知道Spring Security的基本原理就是用一堆过滤器来实现的，就是一个请求过来会经过很多个过滤器的拦截，如果所有过滤器都通过就能访问，如果不满足条件就抛异常，终止访问。

##### 过程一源码分析

1. 启动应用程序，访问接口http://localhost:8080/helloworld

2. "/helloworld"路径首先会被AnonymousAuthenticationFilter进行拦截，该拦截器会检查认证上下文SecurityContextHolder中是否有认证信息，如果没有就给一个匿名认证信息

   ```java
   public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) {
   
   		if (SecurityContextHolder.getContext().getAuthentication() == null) {
   			Authentication authentication = createAuthentication((HttpServletRequest) req);
   			SecurityContextHolder.getContext().setAuthentication(authentication);
   			chain.doFilter(req, res);
   		}
   }
   
   protected Authentication createAuthentication(HttpServletRequest request) {
   		AnonymousAuthenticationToken auth = new AnonymousAuthenticationToken("12676a06-df4a-475b-bb7c-4d3ec4bd1c9b",
   				"anonymousUser", Arrays.asList("ROLE_ANONYMOUS"));
   		auth.setDetails(authenticationDetailsSource.buildDetails(request));
   		return auth;
   }
   
   ```

3. FilterSecurityInterceptor是Spring Security过滤器链中的最后一个过滤器，负责来决定请求是否最终有权限来访问。在该过滤器方法调用中链中AbstractAccessDecisionManager#decide和WebExpressionVoter#vote是需要注意的两个方法，WebExpressionVoter是一种投票器，可以对访问的url进行投票，可以投"通过"，也可以投"拒绝"。 SecurityExpressionRoot#isAuthenticated()方法会返回最终的投票的结果。Spring Security默认所有的请求都需要登录认证，因我们访问"/helloworld"接口没有登录，所以投票器会投"拒绝"票(AccessDecisionVoter.ACCESS_DENIED)

   ```java
   public class AffirmativeBased extends AbstractAccessDecisionManager {
   	public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) throws AccessDeniedException {
   		int deny = 0;
   
   		for (AccessDecisionVoter voter : getDecisionVoters()) {
   			int result = voter.vote(authentication, object, configAttributes);
   
   			if (logger.isDebugEnabled()) {
   				logger.debug("Voter: " + voter + ", returned: " + result);
   			}
   
   			switch (result) {
   				case AccessDecisionVoter.ACCESS_GRANTED:
   					return;
   	
   				case AccessDecisionVoter.ACCESS_DENIED:
   					deny++;
   	
   					break;
   	
   				default:
   					break;
   			}
   		}
   
   		// 如果有"拒绝"票，则抛出访问拒绝异常
   		if (deny > 0) {
   			throw new AccessDeniedException(messages.getMessage("AbstractAccessDecisionManager.accessDenied", "Access is denied"));
   		}
   
   		checkAllowIfAllAbstainDecisions();
   	}
   }
   
   ```

4. ExceptionTranslationFilter是倒数第二个过滤器，它会捕获FilterSecurityInterceptor抛出的异常并对异常进行逻辑处理。如果访问拒绝(认证失败)就会重定向到登录地址"/login"

   ```java
   
   public class ExceptionTranslationFilter extends GenericFilterBean {
   	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
   		try {
   			chain.doFilter(request, response);
   		} catch (Exception ex) {
   			handleSpringSecurityException(request, response, chain, ase);
   		}
   
   	}
   	
   	private void handleSpringSecurityException(HttpServletRequest request, HttpServletResponse response, FilterChain chain, RuntimeException exception)throws IOException, ServletException {
   		if (exception instanceof AccessDeniedException) {
   			Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
   			if (authenticationTrustResolver.isAnonymous(authentication) || authenticationTrustResolver.isRememberMe(authentication)) {
   				sendStartAuthentication(request, response, chain, new InsufficientAuthenticationException(messages.getMessage("ExceptionTranslationFilter.insufficientAuthentication", "Full authentication is required to access this resource")));
   			}
   	}
   }
   
       
   public class DefaultRedirectStrategy implements RedirectStrategy {
   	public void sendRedirect(HttpServletRequest request, HttpServletResponse response,
   			String url) throws IOException {
   		String redirectUrl = calculateRedirectUrl(request.getContextPath(), url);
   		// http://localhost:8080/login
   		redirectUrl = response.encodeRedirectURL(redirectUrl);
   
   		if (logger.isDebugEnabled()) {
   			logger.debug("Redirecting to '" + redirectUrl + "'");
   		}
   
   		response.sendRedirect(redirectUrl);
   	}
   }
   
   ```

5. 当系统访问"/login"路径时会被默认的登录页面生成过滤器DefaultLoginPageGeneratingFilter所拦截，系统会判断自己有没有指定登录页面，如果没有指定系统就会生成一个默认的登录页面

   ```java
   public class DefaultLoginPageGeneratingFilter extends GenericFilterBean {
   	public static final String DEFAULT_LOGIN_PAGE_URL = "/login";
   	
   	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
   		HttpServletRequest request = (HttpServletRequest) req;
   		HttpServletResponse response = (HttpServletResponse) res;
   
   		boolean loginError = isErrorPage(request);
   		boolean logoutSuccess = isLogoutSuccess(request);
   		if (isLoginUrlRequest(request) || loginError || logoutSuccess) {
   			// 生成登录页面
   			String loginPageHtml = generateLoginPageHtml(request, loginError, logoutSuccess);
   			response.setContentType("text/html;charset=UTF-8");
   			response.setContentLength(loginPageHtml.getBytes(StandardCharsets.UTF_8).length);
   			response.getWriter().write(loginPageHtml);
   
   			return;
   		}
   
   		chain.doFilter(request, response);
   	}
   }	
   
   ```

##### 过程二源码分析

1. 用户在登录页面输入用户名和密码点击登录

2. 登录时被用户名密码认证过滤器UsernamePasswordAuthenticationFilter所拦截，去校验用户名和密码是否正确。检查用户名是在DaoAuthenticationProvider#retrieveUser(username, authentication) 方法中检查，检查密码是在DaoAuthenticationProvider#additionalAuthenticationChecks(user, authentication)中检查。如果用户名和密码都是正确的，则重定向到上次访问的路径上，即我们第一次访问的"http://localhost:8080/helloworld"路径上。

   ```java
   public class DaoAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider {
   
   	protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {
   		prepareTimingAttackProtection();
   		try {
   			UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username);
   			if (loadedUser == null) {
   				throw new InternalAuthenticationServiceException(
   						"UserDetailsService returned null, which is an interface contract violation");
   			}
   			return loadedUser;
   		}
   		catch (UsernameNotFoundException ex) {
   			mitigateAgainstTimingAttack(authentication);
   			throw ex;
   		}
   		catch (InternalAuthenticationServiceException ex) {
   			throw ex;
   		}
   		catch (Exception ex) {
   			throw new InternalAuthenticationServiceException(ex.getMessage(), ex);
   		}
   	}
   	
   	
   	protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {
   		if (authentication.getCredentials() == null) {
   			logger.debug("Authentication failed: no credentials provided");
   
   			throw new BadCredentialsException(messages.getMessage(
   					"AbstractUserDetailsAuthenticationProvider.badCredentials",
   					"Bad credentials"));
   		}
   
   		String presentedPassword = authentication.getCredentials().toString();
   		
   		// 检查密码是否正确
   		if (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) {
   			logger.debug("Authentication failed: password does not match stored value");
   
   			throw new BadCredentialsException(messages.getMessage(
   					"AbstractUserDetailsAuthenticationProvider.badCredentials",
   					"Bad credentials"));
   		}
   	}
   }
   
   
   public class InMemoryUserDetailsManager implements UserDetailsManager, UserDetailsPasswordService {
   	public UserDetails loadUserByUsername(String username)
   			throws UsernameNotFoundException {
   		UserDetails user = users.get(username.toLowerCase());
   
   		// 检查用户名是否正确
   		if (user == null) {
   			throw new UsernameNotFoundException(username);
   		}
   
   		return new User(user.getUsername(), user.getPassword(), user.isEnabled(),
   				user.isAccountNonExpired(), user.isCredentialsNonExpired(),
   				user.isAccountNonLocked(), user.getAuthorities());
   	}
   }		
   
   ```

##### Spring  Security 默认的配置

Spring Security中可以通过配置来配置一些参数，比如哪些路径需要认证，登录页面相关的配置(如登录的路径、登录成功时要跳转的路径、登录成功时的处理器、登录失败时要跳转的路径、登录失败时的处理器、登出的路径等)、在过滤器链中添加自己的过滤器(addFilterBefore)等，可以配置很多。如果没有显式配置Spring Security会提供一套默认的值，默认的配置大致如下配置：

```java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable()
                // 配置需要认证的请求
                .authorizeRequests()
                    .anyRequest()
                    .authenticated()
                    .and()
                // 登录表单相关配置
                .formLogin()
                    .usernameParameter("username")
                    .passwordParameter("password")
                    .failureUrl("/login?error")
                    .permitAll()
                    .and()
                // 登出相关配置
                .logout()
                    .permitAll();

    }
}

```

##### Spring Security过滤器链

Spring Security主要用于认证Authentication(登录)和授权Authorize(api是否有权访问)，实现这些功能的基本原理就是过滤器链，即当访问一个url时会被过滤器链中的每个过滤器所拦截，如果每个过滤器都没有抛异常则表示当前用户允许访问该url，则重定向到用户需要访问的url上，如果有一个过滤器抛出异常了则表示当前用户没有权限访问该url，此时可以报错。

Spring Security使用到的过滤器：

- WebAsyncManagerIntegrationFilter
- SecurityContextPersistenceFilter
- HeaderWriterFilter
- CsrfFilter
- LogoutFilter
- BasicAuthenticationFilter
- UsernamePasswordAuthenticationFilter
- RememberMeAuthenticationFilter
- SocialAuthenticationFilter
- DefaultLoginPageGeneratingFilter
- DefaultLogoutPageGeneratingFilter
- RequestCacheAwareFilter
- SecurityContextHolderAwareRequestFilter
- SessionManagementFilter
- AnonymousAuthenticationFilter
- ExceptionTranslationFilter
- FilterSecurityInterceptor

#### 用户名密码登录

1. pom.xml

   thymeleaf-extras-springsecurity5是springsecurity针对thymeleaf模板引擎而开发的一套标签库，可以在thymeleaf中引入该标签库，然后就可以在thymeleaf中使用springsecurity提供的标签了。

   注意：Spring Boot 2.x 要用thymeleaf-extras-springsecurity5； Spring Boot 1.x用thymeleaf-extras-springsecurity4

   ```xml
    <dependencies>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-security</artifactId>
           </dependency>
           <dependency>
               <groupId>org.thymeleaf.extras</groupId>
               <artifactId>thymeleaf-extras-springsecurity5</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-thymeleaf</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-web</artifactId>
           </dependency>
           <dependency>
               <groupId>org.projectlombok</groupId>
               <artifactId>lombok</artifactId>
               <version>1.18.6</version>
           </dependency>
   
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-test</artifactId>
               <scope>test</scope>
           </dependency>
       </dependencies>
   ```

2. html

   位于resources/templates/文件夹下：

   ```html
   <!-- login.html-->
   <!DOCTYPE html>
   <html lang="en"
         xmlns="http://www.w3.org/1999/xhtml"
         xmlns:th="http://www.thymeleaf.org">
   <head>
       <meta charset="utf-8">
       <title>登录</title>
   </head>
   <body>
   <form method="post" action="/login">
       <h2 class="form-signin-heading">登录</h2>
       <span th:if="${param.error}" th:text="${session.SPRING_SECURITY_LAST_EXCEPTION.message}"></span>
       <p>
           <label for="username">用户名</label>
           <input type="text" id="username" name="username" required autofocus>
       </p>
       <p>
           <label for="password">密码</label>
           <input type="password" id="password" name="password" required>
       </p>
   
       <button type="submit">登录</button>
   </form>
   </body>
   </html>
   ```

   index.html

   引入标签库`xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity4"`，引入标签库这里使用thymeleaf-extras-springsecurity4，标签库就是对应于org.springframework.security.access.expression.SecurityExpressionRoot这个类。

   常用的标签库

   - sec:authorize 权限
   - sec:authentication 认证
   - sec:authorize-url : 不能直接使用还需额外的配置 (也不建议使用该标签，因为该标签不支持restful风格)

   SecurityExpressionRoot常用的表达式

   - boolean hasAuthority(String authority)
   - boolean hasAnyAuthority(String… authorities)
   - boolean hasRole(String role)
   - hasAnyRole(String… roles)
   - Authentication getAuthentication()
   - Object getPrincipal()
   - boolean isAnonymous()
   - boolean isAuthenticated()
   - boolean isRememberMe()

   ```html
   <!DOCTYPE html>
   <html xmlns="http://www.w3.org/1999/xhtml"
         xmlns:th="http://www.thymeleaf.org"
         xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity4">
   <head>
       <meta charset="utf-8">
   </head>
   <body>
   <div sec:authorize="isAuthenticated()">
       <p>登录名：<span sec:authentication="name"></span></p>
       <p>角色：<span sec:authentication="principal.authorities"></span></p>
       <p>Username：<span sec:authentication="principal.username"></span></p>
   
       <div sec:authorize="hasAuthority('ROLE_user:view:GET')">用户列表</div>
       <div sec:authorize="hasRole('user:add:POST')">添加用户</div>
       <div sec:authorize="hasAuthority('ROLE_user:update:PUT')">修改用户</div>
       <div sec:authorize="hasAuthority('ROLE_user:delete:DELETE')">删除用户</div>
   </div>
   </body>
   </html>
   
   <!-- userList.html -->
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="utf-8">
   </head>
   <body>
   用户列表
   </body>
   </html>
   
   <!--orderList.html -->
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="utf-8">
   </head>
   <body>
   订单列表
   </body>
   </html>
   ```

3. WebMvcConfiguration

   ```java
   @Configuration
   public class WebMvcConfiguration implements WebMvcConfigurer {
   
       @Override
       public void addViewControllers(ViewControllerRegistry registry) {
           registry.addViewController("/login").setViewName("login");
           registry.addViewController("/index").setViewName("index");
           registry.addViewController("/getUserList").setViewName("userList");
           registry.addViewController("/getOrderList").setViewName("orderList");
       }
   }
   
   ```

4. model:权限实体实现GrantedAuthority接口，重写getAuthority方法，该方法唯一标识一个权限

   ```java
   @Data
   @ToString
   @AllArgsConstructor
   @RequiredArgsConstructor
   public class SysPermission implements GrantedAuthority {
       private Long id;
       private String name;
       private String code;
       private String url;
       private String method;
   
       @Override
       public String getAuthority() {
           return "ROLE_" + this.code + ":" + this.method.toUpperCase();
       }
   }
   
   @Data
   @ToString
   @AllArgsConstructor
   @RequiredArgsConstructor
   public class SysUser {
       private Long id;
       private String username;
       private String password;
   
       private List<SysPermission> sysPermissions;
   }
   
   ```

5. UserDetailsService:从数据库中获取用户的信息和权限列表

   ```java
   @Component
   public class MyUserDetailsService implements UserDetailsService {
       @Override
       public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
           // 模拟根据用户名查询用户信息和权限
           SysUser user = new SysUser(1L, "admin", "$2a$10$nm5H9QvnoWao.l7NbxQGZeZoR0Cn.VqCpsl3E/FhglPa954Zg9ccm", Arrays.asList(
                   new SysPermission(1L, "用户列表", "user:view", "/getUserList", "GET"),
                   new SysPermission(2L, "添加用户", "user:add", "/addUser", "POST"),
                   new SysPermission(3L, "修改用户", "user:update", "/updateUser", "PUT")
           ));
           if (user == null) {
               throw new UsernameNotFoundException(username);
           }
   
           return new User(user.getUsername(), user.getPassword(), user.getSysPermissions());
       }
   
       public static void main(String[] args) {
           System.out.println(new BCryptPasswordEncoder().encode("123456"));
       }
   }
   
   ```

   登录成功后处理的逻辑，默认是重定向到上一个url，也可以在这里自定义自己的逻辑。

   ```java
   @Slf4j
   @Component
   public class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler {
   
       @Autowired
       private ObjectMapper objectMapper;
   
       @Override
       public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
           log.info("login sucesssful {}", objectMapper.writeValueAsString(authentication));
   
           response.sendRedirect("/index");
       }
   }
   
   ```

   Spring Security的核心配置，注意BCryptPasswordEncoder是用于加密解密密码的，每次加密的密文都不一样。

   ```java
   @Configuration
   @EnableWebSecurity
   public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
   
       @Autowired
       private MyUserDetailsService myUserDetailsService;
   
       @Autowired
       private MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;
   
       @Override
       protected void configure(HttpSecurity http) throws Exception {
           http.csrf().disable()
                   // 配置需要认证的请求
                   .authorizeRequests()
                       .anyRequest()
                       .authenticated()
                       .and()
                   // 登录表单相关配置
                   .formLogin()
                       .loginPage("/login")
                       .usernameParameter("username")
                       .passwordParameter("password")
                       .successHandler(myAuthenticationSuccessHandler)
                       .failureUrl("/login?error")
                       .permitAll()
                       .and()
                   // 登出相关配置
                   .logout()
                       .permitAll();
   
       }
   
       @Override
       public void configure(AuthenticationManagerBuilder auth) throws Exception {
           auth.userDetailsService(myUserDetailsService).passwordEncoder(passwordEncoder());
       }
   
       @Override
       public void configure(WebSecurity web) {
           web.ignoring().antMatchers("/static/**");
       }
   
       @Bean
       public PasswordEncoder passwordEncoder() {
           return new BCryptPasswordEncoder();
       }
   }
   
   ```

6. 运行结果

   - 访问<http://localhost:8080/getUserList>跳转到登录页面<http://localhost:8080/login>
   - 输入用户名(admin)密码(123456)登录成功后跳转到首页index.html(登录成功后的逻辑是在AuthenticationSuccessHandler中处理的)，因admin用户只有用户列表、添加用户、修改用户 所以在页面上只能看到这三个按钮没有删除用户的按钮。
   - 访问<http://localhost:8080/getOrderList>可以看到订单页面，虽然用户的权限列表中并没有订单相关的权限，但是仍然能访问。此问题属于权限校验，在后面解决这个问题。

#### 图片验证码登录

Spring Security实现的基本原理就是一堆过滤器，每个需要认证的请求都需要经过每个拦截器的拦截，如果所有拦截器都不报错就表示该用户有权限访问访问该接口，如果没有权限就抛异常。Spring Security登录时会经过UsernamePasswordAuthenticationFilter过滤器来校验用户名和密码，Spring Security并没有提供用于校验验证码的过滤器，所以实现验证码登录只需要定义一个图片验证码的过滤器，然后将图片验证码过滤器添加到Spring Security过滤器链中，一般是将图片验证码过滤器添加到UsernamePasswordAuthenticationFilter过滤器签名，先校验图片验证码是否正确，正确再校验用户名和密码是否正确。

该示例代码需要基于前面文章的代码之上

1. pom.xml
   spring-social-web 这里使用到该依赖的HttpSessionSessionStrategy类，一个Session管理的工具类

   ```xml
   <dependency>
       <groupId>org.springframework.social</groupId>
       <artifactId>spring-social-web</artifactId>
       <version>1.1.4.RELEASE</version>
   </dependency>
   
   ```

2. login.html

   登录页面增加图片验证码域，页面加载时``会请求接口，接口返回一个验证码图片

   ```html
   <!DOCTYPE html>
   <html lang="en"
         xmlns="http://www.w3.org/1999/xhtml"
         xmlns:th="http://www.thymeleaf.org">
   <head>
       <meta charset="utf-8">
       <title>登录</title>
   </head>
   <body>
   <form method="post" action="/login">
       <h2 class="form-signin-heading">登录</h2>
       <span th:if="${param.error}" th:text="${session.SPRING_SECURITY_LAST_EXCEPTION.message}"></span>
       <p>
           <label for="username">用户名</label>
           <input type="text" id="username" name="username" required autofocus>
       </p>
       <p>
           <label for="password">密码</label>
           <input type="password" id="password" name="password" required>
       </p>
       <p>
           <label for="imageCode">图形验证码</label>
           <input type="input" id="imageCode" name="imageCode" required>
           <img src="/code/image"/>
       </p>
       <input type="checkbox" name="remember-me"/>记住我<br>
       <button type="submit">登录</button>
   </form>
   </body>
   </html>
   
   ```

3. 验证码控制器

   获取验证码时将验证码保存到Session中，以便于登录时从Session获取到该验证码用于比较。

   ```java
   @Data
   @ToString
   @AllArgsConstructor
   @RequiredArgsConstructor
   public class ImageCode {
   
       private BufferedImage image;
       private String code;
       private LocalDateTime expireTime;
   
       public ImageCode(BufferedImage image, String code, int expireIn) {
           this.image = image;
           this.code = code;
           this.expireTime = LocalDateTime.now().plusSeconds(expireIn);
       }
   
       public boolean isExpried() {
           return LocalDateTime.now().isAfter(expireTime);
       }
   }
   
   
   @RestController
   public class ValidateCodeController {
   
       private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy();
   
       public static final String SESSION_KEY = "SESSION_KEY_IMAGE_CODE";
   
       @GetMapping("/code/image")
       public void createCode(HttpServletRequest request, HttpServletResponse response) throws IOException {
           ImageCode imageCode = createImageCode(request);
           sessionStrategy.setAttribute(new ServletWebRequest(request), SESSION_KEY, imageCode);
           ImageIO.write(imageCode.getImage(), "JPEG", response.getOutputStream());
       }
   
       private ImageCode createImageCode(HttpServletRequest request) {
           int width = 67;
           int height = 23;
           BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
   
           Graphics g = image.getGraphics();
   
           Random random = new Random();
   
           g.setColor(getRandColor(200, 250));
           g.fillRect(0, 0, width, height);
           g.setFont(new Font("Times New Roman", Font.ITALIC, 20));
           g.setColor(getRandColor(160, 200));
           for (int i = 0; i < 155; i++) {
               int x = random.nextInt(width);
               int y = random.nextInt(height);
               int xl = random.nextInt(12);
               int yl = random.nextInt(12);
               g.drawLine(x, y, x + xl, y + yl);
           }
   
           String sRand = "";
           for (int i = 0; i < 4; i++) {
               String rand = String.valueOf(random.nextInt(10));
               sRand += rand;
               g.setColor(new Color(20 + random.nextInt(110), 20 + random.nextInt(110), 20 + random.nextInt(110)));
               g.drawString(rand, 13 * i + 6, 16);
           }
   
           g.dispose();
   
           return new ImageCode(image, sRand, 60);
       }
   
       /**
        * 生成随机背景条纹
        *
        * @param fc
        * @param bc
        * @return
        */
       private Color getRandColor(int fc, int bc) {
           Random random = new Random();
           if (fc > 255) {
               fc = 255;
           }
           if (bc > 255) {
               bc = 255;
           }
           int r = fc + random.nextInt(bc - fc);
           int g = fc + random.nextInt(bc - fc);
           int b = fc + random.nextInt(bc - fc);
           return new Color(r, g, b);
       }
   }
   
   ```

4. 图片验证码过滤器
   该过滤器只拦截登录页面，主要用于校验验证码是否正确，如果校验失败就使用认证失败处理器处理, 这里的认证失败处理就是将错误信息返回给前端(这里只是简单的做法)

   ```java
   public class ValidateCodeException extends AuthenticationException {
   
       public ValidateCodeException(String message) {
           super(message);
       }
   }
   
   @Slf4j
   @Component
   public class MyAuthenticationFailureHandler implements AuthenticationFailureHandler {
       @Override
       public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
         log.info("认证失败");
         response.setContentType("text/html;charset=utf-8");
         response.getWriter().write(exception.getMessage());
       }
   }
   
   
   public class ImageValidateCodeFilter extends OncePerRequestFilter {
   
       @Autowired
       private AuthenticationFailureHandler authenticationFailureHandler;
   
       // spring-social-web
       private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy();
   
       @Override
       protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
           if ("/login".equals(request.getRequestURI()) && "POST".equals(request.getMethod())) {
               try {
                   validate(new ServletWebRequest(request));
               } catch (ValidateCodeException e) {
                   authenticationFailureHandler.onAuthenticationFailure(request, response, e);
                   return;
               }
           }
   
           filterChain.doFilter(request, response);
       }
   
       private void validate(ServletWebRequest request) throws ServletRequestBindingException {
           ImageCode codeInSession = (ImageCode) sessionStrategy.getAttribute(request, ValidateCodeController.SESSION_KEY);
           String codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(), "imageCode");
   
           if (StringUtils.isEmpty(codeInRequest)) {
               throw new ValidateCodeException("验证码不能为空");
           }
   
           if (codeInSession == null) {
               throw new ValidateCodeException("验证码不存在");
           }
   
           if (codeInSession.isExpried()) {
               sessionStrategy.removeAttribute(request, ValidateCodeController.SESSION_KEY);
               throw new ValidateCodeException("验证码已过期");
           }
   
           if (!codeInRequest.equals(codeInSession.getCode())) {
               throw new ValidateCodeException("验证码不匹配");
           }
   
           sessionStrategy.removeAttribute(request, ValidateCodeController.SESSION_KEY);
       }
   
       public AuthenticationFailureHandler getAuthenticationFailureHandler() {
           return authenticationFailureHandler;
       }
   
       public void setAuthenticationFailureHandler(AuthenticationFailureHandler authenticationFailureHandler) {
           this.authenticationFailureHandler = authenticationFailureHandler;
       }
   }
   
   ```

5. Spring Security Configuration
   将图片验证码过滤器添加到Spring Security过滤器链中来，并且将图片验证码过滤器添加到UsernamePasswordAuthenticationFilter前面(addFilterBefore), 这里也需要将"/code/image"配置为不需要认证。

   ```java
   @Configuration
   @EnableWebSecurity
   public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
   
       @Autowired
       private MyUserDetailsService myUserDetailsService;
   
       @Autowired
       private MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;
   
       @Autowired
       private MyAuthenticationFailureHandler myAuthenticationFailureHandler;
   
   
       @Override
       protected void configure(HttpSecurity http) throws Exception {
           ImageValidateCodeFilter imageValidateCodeFilter = new ImageValidateCodeFilter();
   
           imageValidateCodeFilter.setAuthenticationFailureHandler(myAuthenticationFailureHandler);
   
           http.csrf().disable()
                   // 配置需要认证的请求
                   .authorizeRequests()
                   .antMatchers("/login", "/code/image").permitAll()
                   .anyRequest()
                   .authenticated()
                   .and()
                   // 登录表单相关配置
                   .addFilterBefore(imageValidateCodeFilter, UsernamePasswordAuthenticationFilter.class)
                   .formLogin()
                   .loginPage("/login")
                   .usernameParameter("username")
                   .passwordParameter("password")
                   .successHandler(myAuthenticationSuccessHandler)
                   .failureUrl("/login?error")
                   .permitAll()
                   .and()
                   // 登出相关配置
                   .logout()
                   .permitAll();
   
       }
   
       @Override
       public void configure(AuthenticationManagerBuilder auth) throws Exception {
           auth.userDetailsService(myUserDetailsService).passwordEncoder(passwordEncoder());
       }
   
       @Override
       public void configure(WebSecurity web) {
           web.ignoring().antMatchers("/static/**");
       }
   
       @Bean
       public PasswordEncoder passwordEncoder() {
           return new BCryptPasswordEncoder();
       }
   
   }
   ```

#### 记住我

登录页面一般都会有记住我(或者是保持登录)这样的一个选项，用于在某段时间范围内退出浏览器不用再重新登录，仍旧保持登录的状态。

1. pom.xml

   增加mybatis和h2依赖

   ```xml
           <!--mybatis-->
           <dependency>
               <groupId>org.mybatis.spring.boot</groupId>
               <artifactId>mybatis-spring-boot-starter</artifactId>
               <version>2.1.1</version>
           </dependency>
   
           <dependency>
               <groupId>com.h2database</groupId>
               <artifactId>h2</artifactId>
           </dependency>
   ```

2. application.yml

   ```yml
   #debug=true
   # 数据源配置
   spring:
     datasource:
       url: jdbc:h2:mem:security
       driver-class-name: org.h2.Driver
       username: root
       password: 123456
   ```

3. schema-all.sql

   ```sql
   -- 此表Spring Security中会使用到，用于持久化用户登录的信息。
   create table IF NOT EXISTS persistent_logins (
   	username varchar(64) not null, 
   	series varchar(64) primary key, 
   	token varchar(64) not null, 
   	last_used timestamp not null
   );
   
   ```

4. login.html

   增加记住我复选框，注意name必须为"remember-me"

   ```html
   <!DOCTYPE html>
   <html lang="en"
         xmlns="http://www.w3.org/1999/xhtml"
         xmlns:th="http://www.thymeleaf.org">
   <head>
       <meta charset="utf-8">
       <title>登录</title>
   </head>
   <body>
   <form method="post" action="/login">
       <h2 class="form-signin-heading">登录</h2>
       <span th:if="${param.error}" th:text="${session.SPRING_SECURITY_LAST_EXCEPTION.message}"></span>
       <p>
           <label for="username">用户名</label>
           <input type="text" id="username" name="username" required autofocus>
       </p>
       <p>
           <label for="password">密码</label>
           <input type="password" id="password" name="password" required>
       </p>
       <p>
           <label for="imageCode">图形验证码</label>
           <input type="input" id="imageCode" name="imageCode" required>
           <img src="/code/image"/>
       </p>
       <input type="checkbox" name="remember-me"/>记住我<br>
       <button type="submit">登录</button>
   </form>
   </body>
   </html>
   
   ```

5. SecurityConfiguration

   增加rememberMe配置：

   - tokenRepository 令牌仓库
   - tokenValiditySeconds token保存时间，单位秒

   ```java
   @Configuration
   @EnableWebSecurity
   public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
   
       @Autowired
       private MyUserDetailsService myUserDetailsService;
   
       @Autowired
       private MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;
   
       @Autowired
       private MyAuthenticationFailureHandler myAuthenticationFailureHandler;
   
       @Autowired
       private DataSource dataSource;
   
   
       @Override
       protected void configure(HttpSecurity http) throws Exception {
           ImageValidateCodeFilter imageValidateCodeFilter = new ImageValidateCodeFilter();
   
           imageValidateCodeFilter.setAuthenticationFailureHandler(myAuthenticationFailureHandler);
   
           http.csrf().disable()
                   // 配置需要认证的请求
                   .authorizeRequests()
                   .antMatchers("/login", "/code/image").permitAll()
                   .anyRequest()
                   .authenticated()
                   .and()
                   // 登录表单相关配置
                   .addFilterBefore(imageValidateCodeFilter, UsernamePasswordAuthenticationFilter.class)
                   .formLogin()
                   .loginPage("/login")
                   .usernameParameter("username")
                   .passwordParameter("password")
                   .successHandler(myAuthenticationSuccessHandler)
                   .failureUrl("/login?error")
                   .permitAll()
                   .and()
                   //记住我
                   .rememberMe()
                   .userDetailsService(myUserDetailsService)
                   .tokenRepository(persistentTokenRepository())
                   .tokenValiditySeconds(60 * 60 * 60 * 30)
                   .and()
                   // 登出相关配置
                   .logout()
                   .permitAll();
   
       }
   
       @Override
       public void configure(AuthenticationManagerBuilder auth) throws Exception {
           auth.userDetailsService(myUserDetailsService).passwordEncoder(passwordEncoder());
       }
   
       @Override
       public void configure(WebSecurity web) {
           web.ignoring().antMatchers("/static/**");
       }
   
       @Bean
       public PasswordEncoder passwordEncoder() {
           return new BCryptPasswordEncoder();
       }
   
       @Bean
       public PersistentTokenRepository persistentTokenRepository() {
           JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl();
           tokenRepository.setDataSource(dataSource);
   
           return tokenRepository;
       }
   
   }
   ```

6. 测试

   登录成功后查看浏览器cookie或者数据库，可以关闭浏览器后打开<127.0.0.1:8080>

7. 源码分析

   ![llGRht.png](https://s2.ax1x.com/2019/12/30/llGRht.png)

   过程一

   ```
   | 用户输入用户名密码并选中"记住我"，点击登录
   	| UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter#doFilter
   		| successfulAuthentication(request, response, chain, authResult)
   			| AbstractRememberMeServices#loginSuccess(request, response, authResult)
   				| onLoginSuccess(request, response, successfulAuthentication)
   					| PersistentTokenBasedRememberMeServices#onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication)
   						| PersistentRememberMeToken persistentToken = new PersistentRememberMeToken(username, generateSeriesData(), generateTokenData(), new Date())
   						| tokenRepository.createNewToken(persistentToken)
   							| JdbcTokenRepositoryImpl#createNewToken(persistentToken)
   								| public static final String DEF_INSERT_TOKEN_SQL = "insert into persistent_logins (username, series, token, last_used) values(?,?,?,?)"
   								| private String insertTokenSql = DEF_INSERT_TOKEN_SQL
   								| getJdbcTemplate().update(insertTokenSql, token.getUsername(), token.getSeries(), token.getTokenValue(), token.getDate())
   						| addCookie(persistentToken, request, response)
   							| AbstractRememberMeServices#setCookie(new String[] { token.getSeries(), token.getTokenValue() }, getTokenValiditySeconds(), request, response)
   								| response.addCookie(cookie)
   								
   
   ```

   - 用户输入用户名密码并选中"记住我"，点击登录
   - 登录被UsernamePasswordAuthenticationFilter过滤器拦截，进行认证，认证成功(successfulAuthentication)后会调用AbstractRememberMeServices#loginSuccess()
   - AbstractRememberMeServices#loginSuccess()会调用PersistentTokenBasedRememberMeServices#onLoginSuccess()
   - onLoginSuccess()方法首先会创建PersistentRememberMeToken对象，会生成series、token: generateSeriesData()、generateTokenData()
   - 接下来调用JdbcTokenRepositoryImpl#createNewToken(persistentToken)像persistent_logins表插入一条数据
   - 接下来调用addCookie(persistentToken, request, response)像reponse对象中添加Cookie, response.addCookie(cookie)

   **过程二**

   ```
   | 关闭服务器再重新启动，然后访问任意一个接口
   	| RememberMeAuthenticationFilter#doFilter
   		| Authentication rememberMeAuth = AbstractRememberMeServices#autoLogin(request, response)
   			| String rememberMeCookie = extractRememberMeCookie(request)
   			| String[] cookieTokens = decodeCookie(rememberMeCookie)
   			| UserDetails user = PersistentTokenBasedRememberMeServices#processAutoLoginCookie(cookieTokens, request, response)
   				| final String presentedSeries = cookieTokens[0]
   				| PersistentRememberMeToken token = tokenRepository.getTokenForSeries(presentedSeries)
   				| PersistentRememberMeToken newToken = new PersistentRememberMeToken(token.getUsername(), token.getSeries(), generateTokenData(), new Date())
   				| tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(), newToken.getDate());
   				| addCookie(newToken, request, response)
   				| getUserDetailsService().loadUserByUsername(token.getUsername())
   			| AbstractRememberMeServices#createSuccessfulAuthentication(request, user)
   				| RememberMeAuthenticationToken auth = new RememberMeAuthenticationToken(key, user, authoritiesMapper.mapAuthorities(user.getAuthorities()));
   					| public RememberMeAuthenticationToken(String key, Object principal, Collection<? extends GrantedAuthority> authorities) {
   						 this.keyHash = key.hashCode();
   						 setAuthenticated(true);
   					  }
   				| auth.setDetails(authenticationDetailsSource.buildDetails(request));	
   		| rememberMeAuth = ProviderManager#authenticate(rememberMeAuth)
   			| RememberMeAuthenticationProvider#authenticate(authentication)
   				| if (this.key.hashCode() != ((RememberMeAuthenticationToken) authentication).getKeyHash()) {
   					throw new BadCredentialsException(messages.getMessage("RememberMeAuthenticationProvider.incorrectKey", "The presented RememberMeAuthenticationToken does not contain the expected key"));
   				  }
   				  
   
   ```

   访问任意一个请求都会被RememberMeAuthenticationFilter过滤器拦截，通过remember-me Cookie可以解析出series和username字段，通过series去更新这条记录，通过用户名获取用户信息，然后创建成功认证的token(RememberMeAuthenticationToken), 最终调RememberMeAuthenticationProvider#authenticate(authentication)来认证，记住我认证逻辑只判断key是否一致，如果一致就认证通过，如果不一致就抛异常。记住我认证和用户名密码认证完全不一样，记住我认证只判断key是否一致，不会判断用户名和密码是否正确。


#### 短信验证码登录

有些登录是输入手机号然后获取短信验证码进行登录的。短信验证码和图片验证码原理一样，都是自定义一个过滤器用于校验验证码是否正确。

1. login.html

   ```html
   <p>
       <label for="imageCode">短信验证码</label>
       <input type="input" id="smsCode" name="smsCode" required>
       <button onclick="getSmsCode()">获取验证码</button>
   </p>
   
   <script>
   function getSmsCode() {
       var ajax = new XMLHttpRequest();
       ajax.open('get','/code/sms');
       ajax.send();
   }
   </script>
   
   ```

2. controller

   ```java
   @Data
   @ToString
   @AllArgsConstructor
   @RequiredArgsConstructor
   public class SmsCode {
       private String code;
       private LocalDateTime expireTime;
   
   
       public SmsCode(String code, int expireIn) {
           this.code = code;
           this.expireTime = LocalDateTime.now().plusSeconds(expireIn);
       }
   
       public boolean isExpried() {
           return LocalDateTime.now().isAfter(expireTime);
       }
   }
   
   @RestController
   public class SmsValidateCodeController {
   
       private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy();
       public static final String SESSION_KEY = "SESSION_KEY_SMS_CODE";
   
       @GetMapping("/code/sms")
       public void createCode(HttpServletRequest request) {
           SmsCode smsCode = createSmsCode();
           System.out.println("验证码发送成功：" + smsCode);
           sessionStrategy.setAttribute(new ServletWebRequest(request), SESSION_KEY, smsCode);
       }
   
       private SmsCode createSmsCode() {
           String code = (int) ((Math.random() * 9 + 1) * 100000) + "";
           return new SmsCode(code, 600);
       }
   }
   
   ```

3. filter

   ```java
   public class SmsValidateCodeFilter extends OncePerRequestFilter {
   
       @Autowired
       private AuthenticationFailureHandler authenticationFailureHandler;
   
       // spring-social-web
       private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy();
   
       @Override
       protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
           if ("/login".equals(request.getRequestURI()) && "POST".equals(request.getMethod())) {
               try {
                   validate(new ServletWebRequest(request));
               } catch (ValidateCodeException e) {
                   authenticationFailureHandler.onAuthenticationFailure(request, response, e);
                   return;
               }
           }
   
           filterChain.doFilter(request, response);
       }
   
       private void validate(ServletWebRequest request) throws ServletRequestBindingException {
           SmsCode codeInSession = (SmsCode) sessionStrategy.getAttribute(request, SmsValidateCodeController.SESSION_KEY);
           String codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(), "smsCode");
   
           if (StringUtils.isEmpty(codeInRequest)) {
               throw new ValidateCodeException("验证码不能为空");
           }
   
           if (codeInSession == null) {
               throw new ValidateCodeException("验证码不存在");
           }
   
           if (codeInSession.isExpried()) {
               sessionStrategy.removeAttribute(request, SmsValidateCodeController.SESSION_KEY);
               throw new ValidateCodeException("验证码已过期");
           }
   
           if (!codeInRequest.equals(codeInSession.getCode())) {
               throw new ValidateCodeException("验证码不匹配");
           }
   
           sessionStrategy.removeAttribute(request, SmsValidateCodeController.SESSION_KEY);
       }
   
       public AuthenticationFailureHandler getAuthenticationFailureHandler() {
           return authenticationFailureHandler;
       }
   
       public void setAuthenticationFailureHandler(AuthenticationFailureHandler authenticationFailureHandler) {
           this.authenticationFailureHandler = authenticationFailureHandler;
       }
   }
   
   ```

4. configuration

   ```java
   @Configuration
   @EnableWebSecurity
   public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
   
       @Autowired
       private MyUserDetailsService myUserDetailsService;
   
       @Autowired
       private MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;
   
       @Autowired
       private MyAuthenticationFailureHandler myAuthenticationFailureHandler;
   
   
       @Override
       protected void configure(HttpSecurity http) throws Exception {
   
           SmsValidateCodeFilter smsValidateCodeFilter = new SmsValidateCodeFilter();
           smsValidateCodeFilter.setAuthenticationFailureHandler(myAuthenticationFailureHandler);
   
           http.csrf().disable()
                   // 配置需要认证的请求
                   .authorizeRequests()
                   .antMatchers("/login", "/code/image", "/code/sms").permitAll()
                   .anyRequest()
                       .authenticated()
                       .and()
                   // 登录表单相关配置
                   .addFilterBefore(smsValidateCodeFilter, UsernamePasswordAuthenticationFilter.class)
                   .formLogin()
                       .loginPage("/login")
                       .usernameParameter("username")
                       .passwordParameter("password")
                       .successHandler(myAuthenticationSuccessHandler)
                       .failureUrl("/login?error")
                       .permitAll()
                       .and()
                   // 登出相关配置
                   .logout()
                       .permitAll();
   
       }
   
       @Override
       public void configure(AuthenticationManagerBuilder auth) throws Exception {
           auth.userDetailsService(myUserDetailsService).passwordEncoder(passwordEncoder());
       }
   
       @Override
       public void configure(WebSecurity web) {
           web.ignoring().antMatchers("/static/**");
       }
   
       @Bean
       public PasswordEncoder passwordEncoder() {
           return new BCryptPasswordEncoder();
       }
   }
   
   
   ```

5. 测试

   点击发送信息验证码后，从命令行获取验证码

#### Web社交登录(Social)-QQ

1. 成为个人开发者

   在QQ互联(https://connect.qq.com)上称为个人开发者，填上一些基本信息

   - 名称： 自己的身份证上的姓名
   - 联系地址：自己实际居住的地址
   - 手机号码：自己的手机号
   - 电子邮箱：自己的邮箱，申请开发者时会收到一封确认邮件"腾讯开放平台-开发者注册认证",点击一下链接就可以了
   - 身份证号码：自己的身份证号码
   - 照片：自己拿着身份证，并且身份证中的照片要在人的右边

2. 创建网站应用

   创建网站应用时需要一个已经备过案的域名，可以通过IPC备案查询网站(http://icp.chinaz.com/) 查询域名的具体信息。如果自己没有备过案的域名，可以暂时使用公司的域名，这好像对公司没啥影响。如果没有公司域名，那就在网上随意找个域名，然后在IPC备案查询网站中查询一下该网站的具体信息，用别人的域名。如果用公司的或者别人的域名自己开发好功能了，删除掉应用，避免影响到别的公司，其实也没啥影响。

   - 基本信息
     - 网站名称 ：通过 IPC备案查询网站查询的域名上会有网站名称，填写查询出来的名称
     - 网站类别 ：自己访问以下那个备案的网站，看一下该网站是什么类型的，然后选择一下
     - 网站简介：随便写一下该网站的功能
     - 网站logo：去网站上应该能找到相应的图片，下载下来，然后修改图片的大小100X100

   - 平台信息
     - 网站地址 ：备案的域名，如http://www.example.com/
     - 网站回调域: 备案域名的子路径，如http://www.example.com/social/callback 这个地址在第三方
     - 登录时会使用到，可以随便写，后面也可以随意修改
     - 主办单位名称：在IPC备案查询网站中输入备案的域名可以查询出来
     - 网站备案号：在IPC备案查询网站中输入备案的域名可以查询出来

3. 社交登录原理

   ![lldWVO.png](https://s2.ax1x.com/2019/12/30/lldWVO.png)

   ![lldfaD.png](https://s2.ax1x.com/2019/12/30/lldfaD.png)

##### 示例

代码参看：<https://github.com/hanyunpeng0521/learn-sercurity/tree/master/security-social>

1. pom.xml

   ```xml
   <dependencies>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-security</artifactId>
           </dependency>
           <dependency>
               <groupId>org.thymeleaf.extras</groupId>
               <artifactId>thymeleaf-extras-springsecurity5</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-thymeleaf</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-web</artifactId>
           </dependency>
   
           <dependency>
               <groupId>org.springframework.social</groupId>
               <artifactId>spring-social-web</artifactId>
               <version>1.1.4.RELEASE</version>
           </dependency>
           <dependency>
               <groupId>org.springframework.social</groupId>
               <artifactId>spring-social-core</artifactId>
               <version>1.1.4.RELEASE</version>
           </dependency>
           <dependency>
               <groupId>org.springframework.social</groupId>
               <artifactId>spring-social-config</artifactId>
               <version>1.1.4.RELEASE</version>
           </dependency>
           <dependency>
               <groupId>org.springframework.social</groupId>
               <artifactId>spring-social-security</artifactId>
               <version>1.1.4.RELEASE</version>
           </dependency>
   
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-autoconfigure</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.security.oauth</groupId>
               <artifactId>spring-security-oauth2</artifactId>
               <version>2.0.14.RELEASE</version>
           </dependency>
   
           <dependency>
               <groupId>org.mybatis.spring.boot</groupId>
               <artifactId>mybatis-spring-boot-starter</artifactId>
               <version>1.3.2</version>
           </dependency>
   
           <dependency>
               <groupId>mysql</groupId>
               <artifactId>mysql-connector-java</artifactId>
               <scope>runtime</scope>
           </dependency>
           <dependency>
               <groupId>org.projectlombok</groupId>
               <artifactId>lombok</artifactId>
               <version>1.18.6</version>
           </dependency>
           <dependency>
               <groupId>com.alibaba</groupId>
               <artifactId>fastjson</artifactId>
               <version>1.2.51</version>
           </dependency>
   
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-test</artifactId>
               <scope>test</scope>
           </dependency>
       </dependencies>
   ```

2. AbstractOAuth2ApiBinding：调用QQ第三方的api获取用户的信息

   ```java
   public interface QQ {
       QQUserInfo getUserInfo();
   }
   
   @Data
   @ToString
   @RequiredArgsConstructor
   public class QQUserInfo {
       /**
        * 	返回码
        */
       private String ret;
       /**
        * 如果ret<0，会有相应的错误信息提示，返回数据全部用UTF-8编码。
        */
       private String msg;
       /**
        *
        */
       private String openId;
       /**
        * 不知道什么东西，文档上没写，但是实际api返回里有。
        */
       private String is_lost;
       /**
        * 省(直辖市)
        */
       private String province;
       /**
        * 市(直辖市区)
        */
       private String city;
       /**
        * 出生年月
        */
       private String year;
       /**
        * 	用户在QQ空间的昵称。
        */
       private String nickname;
       /**
        * 	大小为30×30像素的QQ空间头像URL。
        */
       private String figureurl;
       /**
        * 	大小为50×50像素的QQ空间头像URL。
        */
       private String figureurl_1;
       /**
        * 	大小为100×100像素的QQ空间头像URL。
        */
       private String figureurl_2;
       /**
        * 	大小为40×40像素的QQ头像URL。
        */
       private String figureurl_qq_1;
       /**
        * 	大小为100×100像素的QQ头像URL。需要注意，不是所有的用户都拥有QQ的100×100的头像，但40×40像素则是一定会有。
        */
       private String figureurl_qq_2;
       /**
        * 	性别。 如果获取不到则默认返回”男”
        */
       private String gender;
       /**
        * 	标识用户是否为黄钻用户（0：不是；1：是）。
        */
       private String is_yellow_vip;
       /**
        * 	标识用户是否为黄钻用户（0：不是；1：是）
        */
       private String vip;
       /**
        * 	黄钻等级
        */
       private String yellow_vip_level;
       /**
        * 	黄钻等级
        */
       private String level;
       /**
        * 标识是否为年费黄钻用户（0：不是； 1：是）
        */
       private String is_yellow_year_vip;
   }
   
   public class QQImpl extends AbstractOAuth2ApiBinding implements QQ {
   
       private static final String URL_GET_OPENID = "https://graph.qq.com/oauth2.0/me?access_token=%s";
       private static final String URL_GET_USERINFO = "https://graph.qq.com/user/get_user_info?oauth_consumer_key=%s&openid=%s";
   
       private String appId;
       private String openId;
   
       private ObjectMapper objectMapper = new ObjectMapper();
   
       public QQImpl(String accessToken, String appId) {
           super(accessToken, TokenStrategy.ACCESS_TOKEN_PARAMETER);
           this.appId = appId;
   
           String url = String.format(URL_GET_OPENID, accessToken);
           // callback( {"client_id":"xxx","openid":"xxxx"} );
           String result = getRestTemplate().getForObject(url, String.class);
           System.out.println(result);
           String[] items = result.split("openid");
           String openid = items[1].substring(3, items[1].length() - 6);
           this.openId = openid;
       }
       /**
        * QQ 互联
        * https://connect.qq.com/ 文档资料 Api文档/Api列表/访问用户资料(get_user_info)
        * @return
        */
       public QQUserInfo getUserInfo() {
           String url = String.format(URL_GET_USERINFO, appId, openId);
           String result = getRestTemplate().getForObject(url, String.class);
           System.out.println(result);
           QQUserInfo userInfo = JSONObject.parseObject(result, QQUserInfo.class);
           userInfo.setOpenId(openId);
   
           return userInfo;
       }
   }
   
   
   ```

3. OAuth2Template：调用api发送请求的模板

   ```java
   public class QQOAuth2Template extends OAuth2Template {
   
       public QQOAuth2Template(String clientId, String clientSecret, String authorizeUrl, String accessTokenUrl) {
           super(clientId, clientSecret, authorizeUrl, accessTokenUrl);
           setUseParametersForClientAuthentication(true);
       }
   
       @Override
       protected RestTemplate createRestTemplate() {
           RestTemplate restTemplate = super.createRestTemplate();
           restTemplate.getMessageConverters().add(new StringHttpMessageConverter(Charset.forName("UTF-8")));
           return restTemplate;
       }
   
       @Override
       protected AccessGrant postForAccessGrant(String accessTokenUrl, MultiValueMap<String, String> parameters) {
           // access_token=xxx&expires_in=7776000&refresh_token=xxx
           String responseString = getRestTemplate().postForObject(accessTokenUrl, parameters, String.class);
           String[] items = responseString.split("&");
           String accessToken = items[0].split("=")[1];
           Long expiresIn = new Long(items[1].split("=")[1]);
           String refreshToen = items[2].split("=")[1];
   
   
           return new AccessGrant(accessToken, null, refreshToen, expiresIn);
       }
   }
   
   ```

4. ApiAdapter

   ```java
   public class QQAdapter implements ApiAdapter<QQ> {
       @Override
       public boolean test(QQ qq) {
           return true;
       }
   
       @Override
       public void setConnectionValues(QQ qq, ConnectionValues values) {
           QQUserInfo userInfo = qq.getUserInfo();
           values.setDisplayName(userInfo.getNickname());
           values.setImageUrl(userInfo.getFigureurl_qq_1());
           values.setProfileUrl(null);
           values.setProviderUserId(userInfo.getOpenId());
       }
   
       @Override
       public UserProfile fetchUserProfile(QQ qq) {
           return null;
       }
   
       @Override
       public void updateStatus(QQ qq, String s) {
   
       }
   }
   
   ```

5. QQServiceProvider

   ```java
   public class QQServiceProvider extends AbstractOAuth2ServiceProvider<QQ> {
   
       private String appId;
   
       private static final String URL_AUTHORIZE = "https://graph.qq.com/oauth2.0/authorize";
       private static final String URL_ACCESS_TOKEN = "https://graph.qq.com/oauth2.0/token";
   
       public QQServiceProvider(String appId, String appSecret) {
           super(new QQOAuth2Template(appId, appSecret, URL_AUTHORIZE, URL_ACCESS_TOKEN));
           this.appId = appId;
       }
   
       @Override
       public QQ getApi(String accessToken) {
           return new QQImpl(accessToken, appId);
       }
   }
   
   ```

6. OAuth2ConnectionFactory

   ```java
   public class QQConnectionFactory extends OAuth2ConnectionFactory<QQ> {
       public QQConnectionFactory(String providerId, String appId, String appSecret) {
           super(providerId, new QQServiceProvider(appId, appSecret), new QQAdapter());
       }
   }
   
   ```

7.  SocialConfiguration

   ```java
   @Data
   @ConfigurationProperties(prefix = "social.qq")
   public class QQProperties {
       private String filterProcessesUrl = "/auth";
       private String providerId = "qq";
       private String appId;
       private String appSecret;
       private String signupUrl;
   }
   
   ```

   application.yml

   注意：

   - appId和appSecret要使用自己创建的应用对应的值。
   - filterProcessesUrl和providerId 要和创建应用时网站回调域的子路径保持一致，即 如果网站回调域为http://www.example.com/qqLogin/callback.do，那么filterProcessesUrl为/qqLogin，而providerId为callback.do，关于网站回调域的子路径可以任意修改，修改这个值不需要QQ互联重新审核。

   ```yml
   server:
     port: 8080
   
   spring:
     datasource:
       url: jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf8
       driver-class-name: com.mysql.cj.jdbc.Driver
       username: root
       password: root123
   
   social:
     qq:
       appId: xxx
       appSecret: xxx
       filterProcessesUrl: /qqLogin
       providerId: callback.do
       signupUrl: /signup
   
   ```

   ConnectionSignUp： 当第三方登录授权成功后跳转到signup页面，用于走注册流程或者完善账号信息流程(如手机号等信息)

   ```java
   @Component
   public class MyConnecitonSignUp implements ConnectionSignUp {
       @Override
       public String execute(Connection<?> connection) {
           // 根据社交用于信息默认创建用户并返回用户的唯一标识
           return connection.getDisplayName();
       }
   }
   
   public class MySpringSocialConfigurer extends SpringSocialConfigurer {
   
       private String filterProcessesUrl;
   
       public MySpringSocialConfigurer(String filterProcessesUrl) {
           this.filterProcessesUrl = filterProcessesUrl;
       }
   
       @Override
       protected <T> T postProcess(T object) {
           SocialAuthenticationFilter filter = (SocialAuthenticationFilter) super.postProcess(object);
           filter.setFilterProcessesUrl(filterProcessesUrl);
           return (T) filter;
       }
   }
   
   ```

   注意：需要手动的先建好表，建表sql在 spring-social-core-1.1.4.RELEASE.jar/org/springframework/social/connect/jdbc/JdbcUsersConnectionRepository.sql

   ```java
   @Configuration
   @EnableSocial
   public class SocialConfiguration extends SocialConfigurerAdapter {
   
       @Autowired
       private DataSource dataSource;
   
       @Autowired
       private QQProperties properties;
   
       @Autowired
       private MyConnecitonSignUp myConnecitonSignUp;
   
       /**
        * 建表 spring-social-core-1.1.4.RELEASE.jar/org/springframework/social/connect/jdbc/JdbcUsersConnectionRepository.sql
        *
        * create table UserConnection (userId varchar(255) not null,
        * 	providerId varchar(255) not null,
        * 	providerUserId varchar(255),
        * 	rank int not null,
        * 	displayName varchar(255),
        * 	profileUrl varchar(512),
        * 	imageUrl varchar(512),
        * 	accessToken varchar(512) not null,
        * 	secret varchar(512),
        * 	refreshToken varchar(512),
        * 	expireTime bigint,
        * 	primary key (userId, providerId, providerUserId));
        * create unique index UserConnectionRank on UserConnection(userId, providerId, rank);
        * @param connectionFactoryLocator
        * @return
        */
       @Override
       public UsersConnectionRepository getUsersConnectionRepository(ConnectionFactoryLocator connectionFactoryLocator) {
           // Encryptors.noOpText() 对数据不加密
           JdbcUsersConnectionRepository jdbcUsersConnectionRepository = new JdbcUsersConnectionRepository(dataSource, connectionFactoryLocator, Encryptors.noOpText());
           // 只能设置表前缀，但是不能修改表名
           jdbcUsersConnectionRepository.setTablePrefix("");
           if (myConnecitonSignUp != null) {
               jdbcUsersConnectionRepository.setConnectionSignUp(myConnecitonSignUp);
           }
           return jdbcUsersConnectionRepository;
       }
   
       @Bean
       public MySpringSocialConfigurer mySpringSocialConfigurer() {
           MySpringSocialConfigurer springSocialConfigurer = new MySpringSocialConfigurer(properties.getFilterProcessesUrl());
           springSocialConfigurer.userIdSource(getUserIdSource());
           springSocialConfigurer.signupUrl(properties.getSignupUrl());
           return springSocialConfigurer;
       }
   
       @Override
       public UserIdSource getUserIdSource() {
           return new AuthenticationNameUserIdSource();
       }
   
       @Bean
       public ProviderSignInUtils providerSignInUtils(ConnectionFactoryLocator connectionFactoryLocator) {
           return new ProviderSignInUtils(connectionFactoryLocator, getUsersConnectionRepository(connectionFactoryLocator));
       }
   }
   
   @Configuration
   @ConditionalOnProperty(prefix = "social.qq", name = "appId")
   @EnableConfigurationProperties(QQProperties.class)
   public class QQAutoConfig extends SocialConfigurerAdapter {
   
       @Autowired
       private QQProperties properties;
   
       protected ConnectionFactory<?> createConnectionFactory() {
           return new QQConnectionFactory(properties.getProviderId(), properties.getAppId(), properties.getAppSecret());
       }
   
       @Override
       public void addConnectionFactories(ConnectionFactoryConfigurer configurer, Environment environment) {
           configurer.addConnectionFactory(this.createConnectionFactory());
       }
   
       @Override
       public UsersConnectionRepository getUsersConnectionRepository(ConnectionFactoryLocator connectionFactoryLocator) {
           return null;
       }
   }
   
   ```

8. UserDetailsService

   ```java
   @Data
   @ToString
   @AllArgsConstructor
   @RequiredArgsConstructor
   public class SysPermission implements GrantedAuthority {
       private Long id;
       private String name;
       private String code;
       private String url;
       private String method;
   
       /**
        * 次方法很重要，用于唯一标识一个权限
        * @return
        */
       @Override
       public String getAuthority() {
           return "ROLE_" + this.code + ":" + this.method.toUpperCase();
       }
   }
   
   @Data
   @ToString
   @AllArgsConstructor
   @RequiredArgsConstructor
   public class SysUser {
       private Long id;
       private String username;
       private String password;
   
       private List<SysPermission> sysPermissions;
   }
   
   @Component
   public class MyUserDetailsService implements UserDetailsService, SocialUserDetailsService {
       @Override
       public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
           // 根据用户名查询用户信息和权限
           SysUser user = queryUserInfo(username, null);
           if (user == null) {
               throw new UsernameNotFoundException(username);
           }
   
           return new User(user.getUsername(), user.getPassword(), user.getSysPermissions());
       }
   
       @Override
       public SocialUserDetails loadUserByUserId(String userId) throws UsernameNotFoundException {
           // 根据用户名查询用户信息和权限
           SysUser user = queryUserInfo(null, userId);
           if (user == null) {
               throw new UsernameNotFoundException(userId);
           }
   
           return new SocialUser(userId, user.getPassword(), true, true, true, true, user.getSysPermissions());
       }
       
       public SysUser queryUserInfo(String username, String userId) {
           SysUser user = new SysUser(1L, "admin", "$2a$10$nm5H9QvnoWao.l7NbxQGZeZoR0Cn.VqCpsl3E/FhglPa954Zg9ccm", Arrays.asList(
                   new SysPermission(1L, "用户列表", "user:view", "/getUserList", "GET"),
                   new SysPermission(2L, "添加用户", "user:add", "/addUser", "POST"),
                   new SysPermission(3L, "修改用户", "user:update", "/updateUser", "PUT")
           ));
           
           return user;
       }
   
       public static void main(String[] args) {
           System.out.println(new BCryptPasswordEncoder().encode("123456"));
       }
   }
   
   
   
   ```

9. SecurityConfiguration

   ```java
   @Slf4j
   @Component
   public class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler {
   
       @Autowired
       private ObjectMapper objectMapper;
   
       @Override
       public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
           log.info("login sucesssful {}", objectMapper.writeValueAsString(authentication));
   
           response.sendRedirect("/index");
       }
   }
   
   @Slf4j
   @Component
   public class MyAuthenticationFailureHandler implements AuthenticationFailureHandler {
       @Override
       public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
         log.info("认证失败");
         response.setContentType("text/html;charset=utf-8");
         response.getWriter().write(exception.getMessage());
       }
   }
   
   @Configuration
   @EnableWebSecurity
   public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
   
       @Autowired
       private MyUserDetailsService myUserDetailsService;
   
       @Autowired
       private MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;
   
       @Autowired
       private MyAuthenticationFailureHandler myAuthenticationFailureHandler;
   
       @Autowired
       private MySpringSocialConfigurer mySpringSocialConfigurer;
   
   
       @Override
       protected void configure(HttpSecurity http) throws Exception {
           http.csrf().disable()
                   .apply(mySpringSocialConfigurer).and()
                   // 配置需要认证的请求
                   .authorizeRequests()
                   .antMatchers("/login", "/signup", "/user/regist").permitAll()
                   .anyRequest()
                       .authenticated()
                       .and()
                   .formLogin()
                       .loginPage("/login")
                       .usernameParameter("username")
                       .passwordParameter("password")
                       .successHandler(myAuthenticationSuccessHandler)
                       .failureHandler(myAuthenticationFailureHandler)
                       .failureUrl("/login?error")
                       .permitAll()
                       .and()
                   .logout()
                       .permitAll();
   
       }
   
       @Override
       public void configure(AuthenticationManagerBuilder auth) throws Exception {
           auth.userDetailsService(myUserDetailsService).passwordEncoder(passwordEncoder());
       }
   
       @Bean
       public PasswordEncoder passwordEncoder() {
           return new BCryptPasswordEncoder();
       }
   
   }
   
   ```

10. UserController

    ```java
    @Data
    public class SocialUserInfo {
        private String providerId;
        private String providerUserId;
        private String nickname;
        private String headimg;
    }
    @RestController
    public class UserController {
    
        @Autowired
        private ProviderSignInUtils providerSignInUtils;
    
        @GetMapping("/user/me")
        public String me() {
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            return auth.toString();
        }
    
        @GetMapping("/social/user")
        public SocialUserInfo getSocialUserInfo(HttpServletRequest request) {
            SocialUserInfo userInfo = new SocialUserInfo();
            Connection<?> connection = providerSignInUtils.getConnectionFromSession(new ServletWebRequest(request));
            userInfo.setProviderId(connection.getKey().getProviderId());
            userInfo.setNickname(connection.getDisplayName());
            userInfo.setHeadimg(connection.getImageUrl());
            return userInfo;
        }
    
        @PostMapping("/user/regist")
        public void regist(SysUser user, HttpServletRequest request) {
            String userId = user.getUsername();
            providerSignInUtils.doPostSignUp(userId, new ServletWebRequest(request));
        }
    }
    
    @Configuration
    public class WebMvcConfiguration implements WebMvcConfigurer {
    
        @Override
        public void addViewControllers(ViewControllerRegistry registry) {
            registry.addViewController("/login").setViewName("login");
            registry.addViewController("/signup").setViewName("signup");
            registry.addViewController("/index").setViewName("index");
        }
    }
    
    
    ```

11. html

    login.html

    注意：`<a href="/qqLogin/callback.do">QQ登录</a>`QQ登录的href地址为application.yml中的flterProcessesUrl和providerId的值的拼接在一起的子路径。

    ```html
    <!DOCTYPE html>
    <html lang="en"
          xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="utf-8">
        <title>登录</title>
    </head>
    <body>
    <a href="/qqLogin/callback.do">QQ登录</a>
    </body>
    </html>
    
    ```

    signup.html

    ```html
    <!DOCTYPE html>
    <html lang="en"
          xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="utf-8">
        <title>注册</title>
    </head>
    <body>
    <form method="post" action="/user/regist">
        <h2 class="form-signin-heading">注册</h2>
        <p>
            <label for="username">用户名</label>
            <input type="text" id="username" name="username" required autofocus>
        </p>
        <p>
            <label for="password">密码</label>
            <input type="password" id="password" name="password" required>
        </p>
        <button type="submit" name="type" value="regist">注册</button>
        <button type="submit" name="type" value="binding">绑定</button>
    </form>
    </body>
    </html>
    
    ```

    index.html

    ```html
    <!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml"
          xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity4">
    <head>
        <meta charset="utf-8">
    </head>
    <body>
    <h1>首页</h1>
    登录名：<span sec:authentication="name"></span>
    </body>
    </html>
    
    ```

##### 服务器配置

1. 配置hosts文件

   ```
   vi /etc/hosts
   
   # 这里的www.example.com为创建应用是填的网站地址对应的域名
   127.0.0.1 www.example.com
   
   ```

2. nginx配置

   主要是server配置，将80端口映射到8080端口上。QQ认证是会有个回调地址redirect_uri，这个地址默认会使用80端口，而我们的应用程序一般为其它端口，所以需要将80端口映射成8080端口。

   注意在启用nginx时看一下80端口是否被占用了，像mac开机就会启动apache httpd就是用的80端口，需要将其停掉。查找80端口是否被占用命令 sudo lsof -n -P | grep :80

   ```shell
   # 启动nginx
   $ sudo nginx -c /usr/local/etc/nginx/nginx.conf
   
   $ vim nginx.conf
   user root root;
   worker_processes  1;
   
   #error_log  logs/error.log;
   #error_log  logs/error.log  notice;
   #error_log  logs/error.log  info;
   
   pid        logs/nginx.pid;
   
   
   events {
       worker_connections  1024;
   }
   
   
   http {
       include       mime.types;
       default_type  application/octet-stream;
   
       log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                         '$status $body_bytes_sent "$http_referer" '
                         '"$http_user_agent" "$http_x_forwarded_for"';
   
       access_log  /usr/local/etc/nginx/logs/host.access.log  main;
   
       sendfile        on;
       #tcp_nopush     on;
   
       #keepalive_timeout  0;
       keepalive_timeout  65;
   
       gzip  on;
   
       server {
           listen       80;
           server_name  www.example.com;
   
           set $doc_root /usr/local/var/www;
   
           location / {
               proxy_pass http://www.example.com:8080;
           }
   
           location ^~ /images/ {
               root $doc_root;
           }
   
           location ~ .(gif|jpg|jpeg|png|bmp|ico|swf|css|js)$ {
              root $doc_root/img;
           }
        }
   
   
       include servers/*;
   }
   ```

   访问登录页面使用域名来访问，如 <http://www.example.com/login>，登录成功进入到index.html

   注意创建应用时的网站回调域的值要必须和QQ认证页面中的<https://graph.qq.com/oauth2.0/show?redirect_uri=http://www.examole.com:8080/qqLogin/callback.do>中的redirect_uri值要完全一致，这里不知道为什么redirect_uri中域名把8080端口给我带出来了，为了保持一致，我在配置网站回调域的时候也要把端口8080加上，这样才能保持完全一致。即网站回调域配置为<http://www.examole.com:8080/qqLogin/callback.do>

### 会话管理(Session)

Spring Security可以与Spring Session库配合使用，只需要做一些简单的配置就可以实现一些功能，如(会话过期、一个账号只能同时在线一个、集群session等)

#### 会话超时

1. application.yml

   配置session会话超时时间，默认为30秒，但是Spring Boot中的会话超时时间至少为60秒

   ```
   server:
     session:
       timeout: 60
   ```

2. security configuration

   配置session超时后地址

   ```java
   http.csrf().disable()
   	.antMatchers("/login", "/session/invalid").permitAll()
   	.sessionManagement()
             .invalidSessionUrl("/session/invalid")
   
       //SessionController
    @RestController
   public class SessionController {
   
       @GetMapping("/session/invalid")
       @ResponseStatus(code = HttpStatus.UNAUTHORIZED)
       public String sessionInvalid() {
           return "session失效";
       }
   }
   
   @RestController
   @RequestMapping("/user")
   public class UserController {
       @GetMapping("/me")
       public String me() {
           Authentication auth = SecurityContextHolder.getContext().getAuthentication();
           return JSON.toJSONString(auth);
       }
   }
   ```

3. 测试

   先登录/login，随意访问一个地址如"/user/me"获取用户的信息
   等待一分钟，然后重新访问/user/me，结果是跳转到"/session/invalid"地址上了

#### 同一个账号同时在线个数

同一个账号同时在线个数如果设置为1表示，该账号在同一时间内只能有一个有效的登录，如果同一个账号又在其它地方登录，那么就将上次登录的会话过期，即后面的登录会踢掉前面的登录

为了演示该功能我们调整会话超时未1个小时，以便有足够的时间来操作。

1. application.yml

   ```
   server:
     session:
       timeout: 600
   ```

2. security configuration

   - maximumSessions：最大会话数量，设置为1表示一个用户只能有一个会话
   - expiredSessionStrategy：会话过期策略

   ```java
   http.csrf().disable()
   	.antMatchers("/login", "/session/invalid").permitAll()
   	.sessionManagement()
             .invalidSessionUrl("/session/invalid")
             .maximumSessions(1)
             .expiredSessionStrategy(new MyExpiredSessionStrategy())
   
   public class MyExpiredSessionStrategy implements SessionInformationExpiredStrategy {
   
       @Override
       public void onExpiredSessionDetected(SessionInformationExpiredEvent event) throws IOException, ServletException {
           HttpServletResponse response = event.getResponse();
           response.setContentType("application/json;charset=UTF-8");
           response.getWriter().write("并发登录");
       }
   }
   
   ```

3. 测试

   1. 使用chrome浏览器，先登录，再访问/user/me
   2. 使用Firefox浏览器，再登录，再访问/user/me
   3. 使用chrome浏览器，重新访问/user/me，会执行expiredSessionStrategy，页面上显示”并发登录“

4. 阻止用户第二次登录

   sessionManagement也可以配置 maxSessionsPreventsLogin：boolean值，当达到maximumSessions设置的最大会话个数时阻止登录。

   ```java
   http.csrf().disable()
   	.antMatchers("/login", "/session/invalid").permitAll()
   	.sessionManagement()
             .invalidSessionUrl("/session/invalid")
             .maximumSessions(1)
             .expiredSessionStrategy(new MyExpiredSessionStrategy())
             .maxSessionsPreventsLogin(true)
             .and().and()     
   	.logout().permitAll();
   
   ```

#### 集群session

![llcwaq.png](https://s2.ax1x.com/2019/12/31/llcwaq.png)

实际场景中一个服务会至少有两台服务器在提供服务，在服务器前面会有一个nginx做负载均衡，用户访问nginx，nginx再决定去访问哪一台服务器。当一台服务宕机了之后，另一台服务器也可以继续提供服务，保证服务不中断。如果我们将session保存在Web容器(比如tomcat)中，如果一个用户第一次访问被分配到服务器1上面需要登录，当某些访问突然被分配到服务器二上，因为服务器二上没有用户在服务器一上登录的会话session信息，服务器二还会再次让用户登录，用户已经登录了还让登录就感觉不正常了。解决这个问题的思路是用户登录的会话信息不能再保存到Web服务器中，而是保存到一个单独的库(redis、mongodb、jdbc等)中，所有服务器都访问同一个库，都从同一个库来获取用户的session信息，如用户在服务器一上登录，将会话信息保存到库中，用户的下次请求被分配到服务器二，服务器二从库中检查session是否已经存在，如果存在就不用再登录了，可以直接访问服务了。

1. 引入spring session依赖

   ```xml
   <dependency>
       <groupId>org.springframework.session</groupId>
       <artifactId>spring-session-data-redis</artifactId>
       <version>2.1.5.RELEASE</version>
   </dependency>
   <dependency>
       <groupId>redis.clients</groupId>
       <artifactId>jedis</artifactId>
       <version>2.9.0</version>
   </dependency>
   
   ```

2. application.properties

   ```java
   spring:
     session:
       store-type: redis
     redis:
       host: localhost
       port: 6379
   
   server:
     port: 8080
     session:
        timeout: 600
   
   ```

3. 启动两个应用

   用两个不同的端口分别启动应用

   ```shell
   mvn clean install
   java -jar security-source-0.0.1-SNAPSHOT.jar --server.port=8080
   java -jar security-source-0.
   0.1-SNAPSHOT.jar --server.port=8081
   
   ```

4. 测试

   1. 使用其中一个服务去登录 http://localhost:8080/login
   2. 使用另一个服务访问任意接口 http://localhost:8081/user/me 不需要再重新登录就可以直接访问

   注意：session是有过期时间的，当session过期了，redis中的key也就会被自动删除。

#### 登出Logout

Spring Security默认退出处理逻辑

- 使当前session失效
- 清楚与当前用户相关的remember-me记录
- 清空当前的SecurityContext
- 重定向到登录页

Spring Security 登出配置:

spring security登出配置sping给出了一套默认值，如果不使用默认值，可以配置自己的值

- logoutUrl：登出对应的地址
- logoutSuccessHandler：登出成功后可以在这里处理自己的登出逻辑
- deleteCookies：登出成功后删除指定的Cookie

```java
    @Autowired
    private MyLogoutSuccessHandler myLogoutSuccessHandler;

protected void configure(HttpSecurity http) throws Exception {
	http.csrf().disable()
	.antMatchers("/login", "/session/invalid", "/logout", "/signOut").permitAll()
	.logout()
	    .logoutUrl("/logout")
	    .logoutSuccessHandler(myLogoutSuccessHandler)
	    .deleteCookies("JSESSIONID")
	    .permitAll();
}    

@Slf4j
@Component
public class MyLogoutSuccessHandler implements LogoutSuccessHandler {
    @Override
    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        log.info("退出成功");

        response.sendRedirect("/signOut");
    }
}

```

**登出页面**

路径与视图的简单映射

```java
@Configuration
public class WebMvcConfiguration implements WebMvcConfigurer {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/login").setViewName("login");
        registry.addViewController("/signOut").setViewName("signOut");
        registry.addViewController("/index").setViewName("index");
    }
}


```

signOut.html 登出页面

```html
<!DOCTYPE html>
<html lang="en"
      xmlns="http://www.w3.org/1999/xhtml"
      xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8">
    <title>退出</title>
</head>
<body>
退出成功
</body>
</html>

```



### 参考

1. https://blog.csdn.net/vbirdbest/category_8899577.html
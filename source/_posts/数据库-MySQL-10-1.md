---
title: MySQL SQL 锁(九)
date: 2019-05-17 13:08:59
tags:
 - 数据库
 - MySQL
 - SQL
categories:
 - 数据库
 - MySQL
---

### MariaDB/MySQL中的锁

锁和事务的实现是存储引擎内的组件管理的，而MariaDB/MySQL是插件式的存储引擎实现方式，所以不同的存储引擎可以支持不同级别的锁和事务。

<!--more-->

**不同存储引擎支持的锁级别**

MariaDB/MySQL相比其他数据产品来说，支持的锁比较简单。

1. MyISAM、Aria(MariaDB中对myisam的改进版本)和memory存储引擎只支持表级别的锁。

2. innodb支持行级别的锁和表级别的锁，默认情况下在允许使用行级别锁的时候都会使用行级别的锁。

3. DBD存储引擎支持页级别和表级别的锁。

**锁类型**

1. 共享/排它锁(Shared and Exclusive Locks)

   共享锁和排他锁是InnoDB引擎实现的标准行级别锁。

   拿共享锁是为了让当前事务去读一行数据。

   拿排他锁是为了让当前事务去修改或删除某一行数据。。

   设置共享锁：`select * from user where id = 1 LOCK IN SHARE MODE;`

   设置排他锁：`select * from user where id = 1 FOR UPDATE;`

2. 意向锁(Intention Locks)

   意向锁存在的意义在于，使得行锁和表锁能够共存。

   意向锁是表级别的锁，用来说明事务稍后会对表中的数据行加哪种类型的锁(共享锁或独占锁)。

   当一个事务对表加了意向排他锁时，另外一个事务在加锁前就会通过该表的意向排他锁知道前面已经有事务在对该表进行独占操作，从而等待。

3. 记录锁(Record Locks)

   记录锁是索引记录上的锁，例如：SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;会阻止其他事务对c1=10的数据行进行插入、更新、删除等操作。

   记录锁总是锁定索引记录。如果一个表没有定义索引，那么就会去锁定隐式的“聚集索引”。

4. 间隙锁(Gap Locks)

   间隙锁是一个在索引记录之间的间隙上的锁。

   一个间隙可能跨越单个索引值、多个索引值，甚至为空。

   对于使用唯一索引 来搜索唯一行的语句，只加记录锁不加间隙锁(这并不包括组合唯一索引）。

5. 临键锁(Next-key Locks)

   Next-Key Locks是行锁与间隙锁的组合。当InnoDB扫描索引记录的时候，会首先对选中的索引记录加上记录锁（Record Lock），然后再对索引记录两边的间隙加上间隙锁（Gap Lock）。

6. 插入意向锁(Insert Intention Locks)

   插入意向锁是在数据行插入之前通过插入操作设置的间隙锁定类型。

   如果多个事务插入到相同的索引间隙中，如果它们不在间隙中的相同位置插入，则无需等待其他事务。例如：在4和7的索引间隙之间两个事务分别插入5和6，则两个事务不会发冲突阻塞。 

7. 自增锁(Auto-inc Locks)

   自增锁是事务插入到有自增列的表中而获得的一种特殊的表级锁。如果一个事务正在向表中插入值，那么任何其他事务都必须等待，保证第一个事务插入的行是连续的自增值。

在MariaDB/MySQL中只有简单的几种锁类型：

1. 共享锁(S)：即读锁，不涉及修改数据，在检索数据时才申请的锁。

2. 独占锁(X)：增、删、改等涉及修改操作的时候，都会申请独占锁。

以上是支持表锁的存储引擎都会有的锁类型。以下两种是支持行锁或页锁才会有的锁类型，也就是说myisam没有下面的锁，而innodb有。

1. 意向共享锁(IS)：获取低级别共享锁的同时，在高级别上也获取特殊的共享锁，这种特殊的共享锁是意向共享锁。

2. 意向独占锁(IX)：获取低级别独占锁的同时，在高级别上也获取特殊的独占锁，这种特殊的独占锁是意向独占锁。

低级别锁表示的是行锁或页锁，意向锁可能是多条记录组成的范围锁，也可能直接就是表意向锁。

**锁兼容性**

![8AQbqJ.png](https://s2.ax1x.com/2020/03/11/8AQbqJ.png)

独占锁和所有的锁都冲突，意向共享锁和共享锁兼容(这是肯定的)，还和意向独占锁兼容。所以加了意向共享锁的时候，可以修改行级非共享锁的记录。同理，加了意向独占锁的时候，可以检索这些加了独占锁的记录。

#### 锁的实现方式

**InnoDB行锁是通过给索引加锁来实现的，如果没有索引，InnoDB会通过隐藏的聚簇索引来对记录进行加锁（全表扫描，也就是表锁）。**

但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会放锁，最终持有的，是满足条件的记录上的锁。但是不满足条件的记录上的加锁/放锁动作是不会省略的。**所以在没有索引时，不满足条件的数据行会有加锁又放锁的耗时过程。**

索引分为主键索引和非主键索引两种。如果一条sql语句操作了主键索引，MySQL就会锁定对应主键索引；如果一条语句操作了非主键索引，MySQL会先锁定非主键索引，再锁定对应的主键索引。

**mysql锁在4种事务隔离级别里的应用**

事务的四种隔离级别有：

- 读未提交(Read Uncommitted)

  此时select语句不加任何锁。此时并发最高，但会产生脏读。

- 读提交(Read Committed, RC)

  普通select语句是快照读

  update语句、delete语句、显示加锁的select语句（select … in share mode 或者 select … for update） 等，除了在外键约束检查和重复键检查时会封锁区间，其他情况都只使用记录锁；

- 可重复读(Repeated Read, RR)

  普通select语句也是快照读

  update语句、delete语句、显示加锁的select语句（select … in share mode 或者 select … for update）则要分情况：

  - 在唯一索引上使用唯一的查询条件，则使用记录锁。如: select * from user where id = 1;其中id建立了唯一索引
  - 在唯一索引上使用 范围查询条件，则使用间隙锁与临键锁。如: select * from user where id >20;

- 串行化(Serializable)

  此时所有select语句都会被隐式加锁：select … in share mode.

#### 快照读、当前读

要理解前面四种隔离级别的加锁方式，对于MVCC、快照读、当前读 都是必须要理解的。

MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。

快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。

当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。

##### MVCC

MVCC定义：多版并发控制系统。可认为是行级锁的一个变种，它能够避免更多情况下的加锁操作。

作用：避免一些加锁操作，提升并发性能。

实现：通过在每行记录的后面保存行的创建时间和过期时间或删除时间（它们是隐藏的），这两个时间实际都是系统的版本号。每开始一个新的事务，版本号都会自动增加。

具体原理

- select：innoDB查询时会检查以下两个条件：一个是数据行的版本号早于当前事务的版本号；另一个是行的删除版本号，要么没有，要么大于当前事务的版本号。
- insert/delete：innoDB将当前的系统版本号作为新插入(删除)的数据行的版本号。
- update：先新插入一行数据，并将当前系统版本号作为行的版本号，同时将当前系统版本号作为原来行的删除版本号。更新主键时，聚集索引和普通索引都会产生两个版本；而更新非主键时，只要普通索引会产生两个版本。

注意：MVCC只在read committed和repeatable read两个隔离级别下工作。

##### 快照读

一个正常的select…语句就是快照读。

快照读，使得在RR（repeatable read）级别下一个普通select...语句也能做到可重复读。即前面MVCC里提到的利用可见版本来保证数据的一致性。

##### 当前读

insert语句、update语句、delete语句、显示加锁的select语句（select… LOCK IN SHARE MODE、select… FOR UPDATE）是当前读。

为什么insert、update、delete语句都属于当前读？

这是因为这些语句在执行时，都会执行一个读取当前数据最新版本的过程。

当前读的SQL语句，InnoDB是逐条与MySQL Server交互的。即先对一条满足条件的记录加锁后，再返回给MySQL Server，当MySQL Server做完DML操作后，再对下一条数据加锁并处理。

##### 查看行级锁争用情况

```
show status like 'InnoDB_row_lock%';
```

如果发现锁争用比较严重，还可以通过设置InnoDB Monitors 来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。如：

设置监视器：mysql> create table InnoDB_monitor(a INT) engine=InnoDB;

查看：mysql> show engine InnoDB status;

停止查看：mysql> drop table InnoDB_monitor;

具体参考：[InnoDB Monitor](https://blog.csdn.net/zyz511919766/article/details/50147283)

#### 死锁

什么是死锁：一般是由于两个事务同时操作两个表，但加锁的顺序是不一致出现的。比如A事务先锁a表，B事务先锁b表；当A去锁b表的时候发现b表被B事务锁住了，要等待；当B事务去锁a表的时候发现a表被A锁住了。于是出现了死锁

如何发现死锁： 在InnoDB的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在，一般像一些运维系统是能发现的

解决办法：回滚较小的那个事务


在REPEATABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT…FOR UPDATE加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可避免问题。


如何判断事务大小：事务各自插入、更新或者删除的数据量

注意：

当产生死锁的场景中涉及到不止InnoDB存储引擎的时候，InnoDB是没办法检测到该死锁的，这时候就只能通过锁定超时限制参数`InnoDB_lock_wait_timeout`来解决。

#### 表级锁

Mysql有三种级别的锁定：表级锁定、页级锁定、行级锁定

每次锁定的是一张表的锁机制就是表级别锁定(table-level)。它是MySQL各存储引擎中粒度最大的锁定机制。

1. 优点
   - 实现逻辑简单，开销小。
   - 获取锁和释放锁的速度快。
   - 由于表级锁一次会将整个表锁定，所以能很好的避免死锁问题。

2. 缺点
   - 由于锁粒度最大，因此出现争用被锁定资源的概率也会最高，致使并发度十分低下。

**支持存储引擎**

使用表级锁定的主要有MyISAM，MEMORY，CSV等一些非事务性存储引擎

Innodb存储引擎也支持

**表级锁类型**

MySQL的表级锁有两种类型：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。

锁模式的兼容性：

- 对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写操作；
- 对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；

MyISAM表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。

##### 如何加表锁

- 在执行查询语句（select）前，会自动给涉及的所有表加读锁
- 在执行更新操作（update、delete、insert等）前，会自动给涉及的表加写锁。这个过程并不需要用户干预，因此不需要直接用lock table命令给MyISAM表显式加锁。

显示加写锁：

```
// 当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。
// 其他线程的读、写操作都会等待，直到锁被释放为止。
// test表将会被锁住，另一个线程执行select * from test where id = 3;将会一直等待，直到test表解锁
LOCK TABLE test WRITE; 
```

显示加读锁

```
// test表将会被锁住，另一个线程执行select * from test where id = 3;不会等待
// 执行UPDATE test set name='peter' WHERE id = 4;将会一直等侍，直到test表解锁
LOCK table test READ;
```

显示释放锁：

```
UNLOCK TABLES;
```

需要**注意**的是，在`同一个SQL session`里，如果已经获取了一个表的锁定，则对没有锁的表不能进行任何操作，否则会报错。

```
// 锁定test表
LOCK table test WRITE;

// 操作锁定表没问题
SELECT * from test where id = 4;

// 操作没有锁的表会报错
SELECT * from bas_farm where id =1356
```

报错：`[Err] 1100 - Table 'bas_farm' was not locked with LOCK TABLES。`这是因为MyISAM希望一次获得sql语句所需要的全部锁。这也正是myisam表不会出现死锁的原因。

当然，你也不必担心，MyISAM引擎的默认方式是会给同一个session里的所有表都加上锁的，不会麻烦你自己显示操作的。

**查看表级锁争用情况**

执行：`show status like ‘table%’;`

Table_locks_immediate：产生表级锁定的次数；
Table_locks_waited：出现表级锁定争用而发生等待的次数；
如果Table_locks_waited状态值比较高，那么说明系统中表级锁定争用现象比较严重，就需要进一步分析为什么会有较多的锁定资源争用了。

##### 优化表级锁定

优化表级锁时的最大问题是：提高并发度

1. 通过减少查询时间缩短锁定时间

  缩短锁定时间的总体原则是：让Query执行时间尽可能的短。

  - 尽量减少大的、复杂的Query，将复杂Query分拆成几个小的Query分步执行；
  - 尽可能的建立足够高效的索引，让数据检索更迅速；
  - 尽量让MyISAM存储引擎的表只存放必要的信息，控制字段类型；
  - 利用合适的机会优化MyISAM表数据文件。

2. 设置可并发插入：concurrent_insert=2

   MyISAM的表锁虽是读写互相阻塞的，但依然能够实现并行操作。MyISAM存储引擎有一个控制是否打开Concurrent Insert（并发插入）功能的参数选项：concurrent_insert，取值范围为0，1，2。

   - concurrent_insert=0，不允许并发插入。

   - concurrent_insert=1，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个线程读表的同时，另一个线程从表尾插入记录。这是MySQL的默认设置；

   - concurrent_insert=2，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录；

   所以，我们可通过设置concurrent_insert=2，同时定期在系统空闲时段执行optimize table tableName语句来整理空间碎片，收回因删除记录而没有真正释放的空间，从而提高并发。

   optimize参考：[mysql中OPTIMIZE TABLE的作用及使用](https://www.cnblogs.com/jimmy-muyuan/p/5874410.html)

3. 合理设置读写优先级
   MyISAM存储引擎默认是**写优先级大于读优先级**。即使是写请求后到，写锁也会插到读锁请求之前。

   但是，有时像修改文章点击数 操作是不那么重要的，我们希望的是读更快，此时我们可以这样：

   ```
   UPDATE  LOW_PRIORITY  article SET click_num=134 WHERE id = 823
   ```

   LOW_PRIORITY使得系统认为update操作优化级比读操作低，如果同时出现读操作和上面的更新操作，则优先执行读操作。

MySQL提供了几个语句调节符，允许你修改它的调度策略：

- LOW_PRIORITY关键字应用于：DELETE、INSERT、LOAD DATA、REPLACE和UPDATE。
- HIGH_PRIORITY关键字应用于：SELECT、INSERT语句。
- delayed(延迟)关键字应用于：INSERT、REPLACE语句。

如果你希望所有支持LOW_PRIORITY选项的语句都默认地按照低优先级来处理，那么可能使用**low-priority-updates**选项来启动服务器。然后可通过使用insert HIGH_PRIORITY table.....来把个别我们希望的INSERT语句提高到正常的写入优先级。

#### 行级锁

每次锁定的是一行数据的锁机制就是行级别锁定(row-level)。行级锁定不是MySQL自己实现的锁定方式，而是由其他存储引擎自己所实现的

1. 优点

   由于锁粒度小，争用率低，并发高。

2. 缺点

   实现复杂，开销大。
   加锁慢、容易出现死锁

**支持存储引擎**

使用行级锁定的主要有InnoDB存储引擎，以及MySQL的分布式存储引擎NDBCluster

**行级锁类型**

InnoDB的行级锁定同样分为两种类型：共享锁和排他锁，而在锁定机制的实现过程中为了让行级锁定和表级锁定共存，InnoDB也同样使用了**意向锁（表级锁定）**的概念，也就有了意向共享锁和意向排他锁这两种。

意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。

意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。所以，可以说InnoDB的锁定模式实际上可以分为四种：共享锁（S），排他锁（X），意向共享锁（IS）和意向排他锁（IX）

锁模式的兼容性：

![8AQbqJ.png](https://s2.ax1x.com/2020/03/11/8AQbqJ.png)

##### 行级锁定实现方式

InnoDB行锁是通过给索引上的索引项加锁来实现的。所以，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。其他注意事项：

- 在不通过索引条件查询的时候，InnoDB使用的是表锁，而不是行锁。
- 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以即使是访问不同行的记录，如果使用了相同的索引键，也是会出现锁冲突的。
- 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。
- 即便在条件中使用了索引字段，但具体是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。

1. 隐式加锁：
   - InnoDB自动加意向锁。
   - 对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；
   - 对于普通SELECT语句，InnoDB不会加任何锁；

2. 显示加锁：
   - 共享锁（S）：`SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE`
   - 排他锁（X) ：`SELECT * FROM table_name WHERE ... FOR UPDATE`
   - 用`SELECT … IN SHARE MODE`获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。

但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用`SELECT… FOR UPDATE`方式获得排他锁。

**InnoDB如何加表锁**

在用 LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0，否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁。

```
SET AUTOCOMMIT=0;
LOCK TABLES t1 WRITE, t2 READ, ...;
[do something with tables t1 and t2 here];
COMMIT;
UNLOCK TABLES;
```

##### 间隙锁（Next-Key锁）

1. 间隙锁定义：
  Innodb的锁定规则是通过在指向数据记录的第一个索引键之前和最后一个索引键之后的空域空间上标记锁定信息而实现的。 Innodb的这种锁定实现方式被称为“ NEXT-KEY locking” （间隙锁），因为Query执行过程中通过范围查找的话，它会锁定整个范围内所有的索引键值，即使这个键值并不存在。例：假如emp表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：

  ```
  mysql> select * from emp where empid > 100 for update;
  ```

  是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。

2. 间隙锁的缺点

   - 间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害
   - 当Query无法利用索引的时候， Innodb会放弃使用行级别锁定而改用表级别的锁定，造成并发性能的降低；
   - 当Quuery使用的索引并不包含所有过滤条件的时候，数据检索使用到的索引键所指向的数据可能有部分并不属于该Query的结果集的行列，但是也会被锁定，因为间隙锁锁定的是一个范围，而不是具体的索引键；
   - 当Query在使用索引定位数据的时候，如果使用的索引键一样但访问的数据行不同的时候（索引只是过滤条件的一部分），一样会被锁定

3. 间隙锁的作用

   - 防止幻读，以满足相关隔离级别的要求。
   - 为了数据恢复和复制的需要

4. 注意

   - 在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。
   - InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁。

##### 查看行级锁争用情况

执行SQL:`mysql> show status like 'InnoDB_row_lock%';`

如果发现锁争用比较严重，还可以通过设置InnoDB Monitors 来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。如：

设置监视器：`mysql> create table InnoDB_monitor(a INT) engine=InnoDB;`

查看：`mysql> show engine InnoDB status;`

停止查看：`mysql> drop table InnoDB_monitor;`


##### 优化行级锁定

1. 要想合理利用InnoDB的行级锁定，做到扬长避短，我们必须做好以下工作： 

   - 尽可能让所有的数据检索都通过索引来完成，从而避免InnoDB因为无法通过索引键加锁而升级为表级锁定； 
   - 合理设计索引，让InnoDB在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他Query的执行； 
   - 尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录； 
   - 尽量控制事务的大小，减少锁定的资源量和锁定时间长度； 
   - 在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少MySQL因为实现事务隔离级别所带来的附加成本。

2. 由于InnoDB的行级锁定和事务性，所以肯定会产生死锁，下面是一些比较常用的减少死锁产生概率的小建议：
   - 类似业务模块中，尽可能按照相同的访问顺序来访问，防止产生死锁； 
   - 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率； 
   - 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。

**查看SQL语句的锁信息**

1. 查看事务的隔离级别：

   通过`show global variables like “tx_isolation”;` 命令查看。
   可通过执行`set session transaction isolation level repeatable read;`更改成我们想要隔离级别，隔离级别取值如下：
   read uncommitted、read committed、repeatable read、serializable
   保证事务为手动提交：

2. 通过`show global variables like “autocommit”;`查看。
   如果为ON，则通过执行`set session autocommit=0;`改为手动提交。
   保证间隙锁开启：

3. 通过`show global variables like “innodb_locks%”;`查看
   OFF时表示开启。默认是OFF

#### 意向锁

![8AQbqJ.png](https://s2.ax1x.com/2020/03/11/8AQbqJ.png)

InnoDB为了让表锁和行锁共存而使用了意向锁。如果没有意 向锁的话，表锁和行锁不能共存

##### 为什么没有意向锁的话，表锁和行锁不能共存？

举个粟子（此时假设行锁和表锁能共存）： 事务A锁住表中的一行（写锁）。事务B锁住整个表（写锁）。

但你就会发现一个很明显的问题，事务A既然锁住了某一行，其他事务就不可能修改这一行。这与”事务B锁住整个表就能修改表中的任意一行“形成了冲突。所以，没有意向锁的时候，行锁与表锁共存就会存在问题！

##### 意向锁是如何让表锁和行锁共存的？

有了意向锁之后，前面例子中的事务A在申请行锁（写锁）之前，数据库会自动先给事务A申请表的意向排他锁。当事务B去申请表的写锁时就会失败，因为表上有意向排他锁之后事务B申请表的写锁时会被阻塞。

所以，意向锁的作用就是：

当一个事务在需要获取资源的锁定时，如果该资源已经被排他锁占用，则数据库会自动给该事务申请一个该表的意向锁。如果自己需要一个共享锁定，就申请一个意向共享锁。如果需要的是某行（或者某些行）的排他锁定，则申请一个意向排他锁。

 说明：**意向锁之间都是兼容的**

参考：https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-intention-locks

##### 意向锁是表锁还是行锁？

首先可以肯定的是，意向锁是表级别锁。意向锁是表锁是有原因的。

当我们需要给一个加表锁的时候，我们需要根据意向锁去判断表中有没有数据行被锁定，以确定是否能加成功。如果意向锁是行锁，那么我们就得遍历表中所有数据行来判断。如果意向锁是表锁，则我们直接判断一次就知道表中是否有数据行被锁定了。

#### MVCC

MVCC使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读，从而大大提高数据库系统的并发性能。

##### 重要字段

Mysql Innodb中行记录的存储格式，除了最基本的行信息外，还会有一些额外的字段，这里主要介绍和MVCC有关的字段：DATA_TRX_ID和DATA_ROLL_PTR。

**DATA_TRX_ID**：用来标识最近一次对本行记录做修改(insert|update)的事务的标识符, 即最后一次修改(insert|update)本行记录的事务id。

**DATA_ROLL_PTR**：指写入回滚段(rollback segment)的 undo log record (撤销日志记录记录)。如果一行记录被更新, 则 undo log record 包含 '重建该行记录被更新之前内容' 所必须的信息。

![8A3eKS.png](https://s2.ax1x.com/2020/03/11/8A3eKS.png)

当插入的是一条新数据时，记录上对应的回滚段指针为NULL

![8A3GvT.png](https://s2.ax1x.com/2020/03/11/8A3GvT.png)

DB_TRX_ID记录了行的创建的时间,删除的时间在每个事件发生的时候，每行存储版本号，而不是存储事件实际发生的时间。每次事物的开始这个版本号都会增加。自记录时间开始，每个事物都会保存记录的系统版本号。依照事物的版本来检查每行的版本号。

- 在insert操作时， “创建时间”=DB_TRX_ID，这时，“删除时间”是未定义的；
- 在update操作时，复制新增行的“创建时间”=DB_TRX_ID，删除时间未定义，旧数据行“创建时间”不变，删除时间=该事务DB_TRX_ID；
- 在delete操作时，相应数据行的“创建时间”不变，删除时间=该事务的DB_ROW_ID；
- 在select操作时，对两者都不修改，只读相应的数据。

##### 原理

InnoDB的MVCC，是通过在每行纪录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间（或删除时间），当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行纪录的版本号进行比较。在REPEATABLE READ隔离级别下，MVCC具体的操作如下：

SELECT
 InnoDB会根据以下两个条件检查每行纪录：

- InnoDB只查找版本早于当前事务版本的数据行，即，行的系统版本号小于或等于事务的系统版本号，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
- 行的删除版本，要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除。
   只有符合上述两个条件的纪录，才能作为查询结果返回。

INSERT

- InnoDB为插入的每一行保存当前系统版本号作为行版本号。

DELETE

- InnoDB为删除的每一行保存当前系统版本号作为行删除标识。

UPDATE

- InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时，保存当前系统版本号到原来的行作为行删除标识。

优点：
 保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好。

缺点：
 每行纪录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。

读到这里，也许会有一个疑问，考虑如下执行序列：

![8A34PI.png](https://s2.ax1x.com/2020/03/11/8A34PI.png)

按照之前的Select规则，会话B 的事务是在 会话A的后面开启的，那么B的事务版本号大于A的事务版本号。这样在A中插入的数据在未提交的情况下，B可以读到A修改的数据，这不就自相矛盾了么？其实不然，InnoDB每个事务在开始的时候，会将当前系统中的活跃事务列表（trx_sys->trx_list）创建一个副本（read view），然后一致性读去比较记录的tx id的时候，并不是根据当前事务的tx id，而是根据read view最早一个事务的tx id（read view->up_limit_id）来做比较的，这样就能确保在事务B之前没有提交的所有事务的变更，B事务都是看不到的。如下图所示：

![8A89MT.png](https://s2.ax1x.com/2020/03/11/8A89MT.png)

##### 版本链

我们先来理解一下版本链的概念。在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列：

- **trx_id**这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。
- **roll_pointer**每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)

![8AtzKP.png](https://s2.ax1x.com/2020/03/11/8AtzKP.png)

比如现在有个事务id是60的执行的这条记录的修改语句

![8ANPUg.png](https://s2.ax1x.com/2020/03/11/8ANPUg.png)

此时在undo日志中就存在版本链

![8ANkCj.png](https://s2.ax1x.com/2020/03/11/8ANkCj.png)

##### ReadView

说了版本链我们再来看看ReadView。**已提交读和可重复读的区别就在于它们生成ReadView的策略不同**。

ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。假设当前列表里的事务id为[80,100]。

- 如果你要访问的记录版本的事务id为50，比当前列表最小的id80小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。
- 如果你要访问的记录版本的事务id为70,发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。
- 如果你要访问的记录版本的事务id为110，那比事务列表最大id100都大，那说明这个版本是在ReadView生成之后才发生的，所以不能被访问。这些记录都是去版本链里面找的，先找最近记录，如果最近这一条记录事务id不符合条件，不可见的话，再去找上一个版本再比较当前事务的id和这个版本事务id看能不能访问，以此类推直到返回可见的版本或者结束。

举个例子 ，在已提交读隔离级别下：

比如此时有一个事务id为100的事务，修改了name,使得的name等于小明2，但是事务还没提交。则此时的版本链是

![8AN4iQ.png](https://s2.ax1x.com/2020/03/11/8AN4iQ.png)

那此时另一个事务发起了select 语句要查询id为1的记录，那此时生成的ReadView 列表只有[100]。那就去版本链去找了，首先肯定找最近的一条，发现trx_id是100,也就是name为小明2的那条记录，发现在列表内，所以不能访问。

这时候就通过指针继续找下一条，name为小明1的记录，发现trx_id是60，小于列表中的最小id,所以可以访问，直接访问结果为小明1。

那这时候我们把事务id为100的事务提交了，并且新建了一个事务id为110也修改id为1的记录，并且不提交事务

![8ANbLV.png](https://s2.ax1x.com/2020/03/11/8ANbLV.png)

这时候版本链就是

![8AUFeK.png](https://s2.ax1x.com/2020/03/11/8AUFeK.png)

这时候之前那个select事务又执行了一次查询,要查询id为1的记录。

**这个时候关键的地方来了**

如果你是**已提交读隔离级别，这时候你会重新一个ReadView**，那你的活动事务列表中的值就变了，变成了[110]。

按照上的说法，你去版本链通过trx_id对比查找到合适的结果就是小明2。

如果你是**可重复读隔离级别，这时候你的ReadView还是第一次select时候生成的ReadView,**也就是列表的值还是[100]。所以select的结果是小明1。所以第二次select结果和第一次一样，所以叫可重复读！

**也就是说已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。**

这就是Mysql的MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同实现不同的隔离级别。
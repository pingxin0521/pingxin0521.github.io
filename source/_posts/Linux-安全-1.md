---
title: 密码学与加密算法
date: 2019-03-19 23:18:59
tags:
 - 密码学
 - 安全
categories:
 - Linux
 - 安全  
---

### 前言

1. 首先，我们需要知道什么才是密码学。

```
密码学是研究编制密码和破译密码的技术科学。研究密码变化的客观规律，
应用于编制密码以保守通信秘密的，称为编码学；应用于破译密码以获取通信情报的，
称为破译学，总称密码学。
```

2. 其次，我们要了解为什么密码学会存在。

   <!--more-->

​	专家们认为密码学的发展经历了这三个阶段：

​	公元前~1949年，古典密码学。

​	1949~二十世纪70年代，近代密码学。

​	二十世纪70年代~至今，基于数据块的加密技术。

​	主要用于战争、商业，现在更多地应用于人们的生活。以前密码学只是研究如何对信息进行加密，而如今还应该考虑完整性、可认证性、真实性等特性。



### 古典密码

古典密码编码方法归根结底主要有两种，即置换和代换。

把明文中的字母重新排列，字母本身不变，但其位置改变了，这样编成的密码称为置换密码。最简单的置换密码是把明文中的字母顺序倒过来，然后截成固定长度的字母组作为密文。

代换密码则是将明文中的字符替代成其他字符。

### 现代密码学

现代的密码学根据加解密时使用的原理不同，将算法大致分为：对称算法、非对称算法。对称算法使用同一个秘钥进行加解密，算法较简单，主要有DES、3DES、AES等；非对称算法使用公钥进行加密，使用私钥进行解密，安全性更高，主要有ASR等。

#### DES算法

DES算法为密码体制中的对称密码体制，又被称为美国数据加密标准，是1972年美国IBM公司研制的对称密码体制加密算法。DES算法具有极高安全性，到目前为止，除了用穷举搜索法对DES算法进行攻击外，还没有发现更有效的办法（已经可以被破解）。

其入口参数有三个：key、data、mode。key为加密解密使用的密钥，data为加密解密的数据，mode为其工作模式。当模式为加密模式时，明文按照64位进行分组，形成明文组，key用于对数据加密，当模式为解密模式时，key用于对数据解密。实际运用中，密钥只用到了64位中的56位，其中8位用于错误检测，这样才具有高的安全性。具有分组比较短、密钥太短、密码生命周期短、运算速度较慢等特点。

#### 3DES算法

3DES又称Triple DES，是DES加密算法的一种模式，它使用3条56位的密钥对3DES数据进行三次加密。数据加密标准(DES)是美国的一种由来已久的加密标准，它使用对称密钥加密法，并于1981年被ANSI组织规范为ANSI X.3.92。DES使用56位密钥和密码块的方法，而在密码块的方法中，文本被分成64位大小的文本块然后再进行加密。比起最初的DES，3DES更为安全。
　　3DES(即Triple DES)是DES向AES过渡的加密算法(1999年，NIST将3-DES指定为过渡的加密标准)，加密算法，其具体实现如下:设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，P代表明文，C代表密文，这样:
　　3DES加密过程为:C=Ek3(Dk2(Ek1(P)))
　　3DES解密过程为:P=Dk1(EK2(Dk3(C)))

3DES（即TripleDES）是DES向AES过度的加密算法，她使用三条56位的密钥对数据进行三次加密。是DES的一个更安全的变形。它是以DES为基本模块，通过组合分组方法设计出分组的加码算法。比起最初的DES，3DES更为安全。

#### AES算法

　AES（The Advanced Encryption Standard）是美国国家标准与技术研究所用于加密电子数据的规范。它被预期能成为人们公认的加密包括金融、电信和政府数字信息的方法。该算法为比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，以Rijndael之命名之，投稿高级加密标准的甄选流程。Rijdael的发音近于 "Rhinedoll，两位设计者的名字，参考荷兰语原发音可译为尤安•达蒙、文森特•莱蒙。(Joan不能译为女性化的名字"琼"。另外，西欧的姓名很多是有相同拉丁文或希腊文源头的，故译成中文是可能相同)
　　AES 是一个新的可以用于保护电子数据的加密算法。明确地说，AES 是一个迭代的、对称密钥分组的密码，它可以使用128、192 和 256 位密钥，并且用 128 位（16字节）分组加密和解密数据。与公共密钥密码使用密钥对不同，对称密钥密码使用相同的密钥加密和解密数据。通过分组密码返回的加密数据的位数与输入数据相同。迭代加密使用一个循环结构，在该循环中重复置换（permutations ）和替换(substitutions）输入数据。

Rijndael是由Daemen和Rijmen早期所设计的Square改良而来;而Square则是由SHARK发展而来。不同于它的前任标准DES，Rijndael使用的是代换-置换网络，而非Feistel架构。AES在软件及硬件上都能快速地加解密，相对来说较易于实作，且只需要很少的存储器。作为一个新的加密标准，目前正被部署应用到更广大的范围。

对称密码体制的发展趋势将以分组密码为重点。分组密码算法通常由密钥扩展算法和加密（解密）算法两部分组成。密钥扩展算法将b字节用户主密钥扩展成r个子密钥。加密算法由一个密码学上的弱函数f与r个子密钥迭代r次组成。混乱和密钥扩散是分组密码算法设计的基本原则。抵御已知明文的差分和线性攻击，可变长密钥和分组是该体制的设计要点。
　　AES 是一个新的可以用于保护电子数据的加密算法。明确地说，AES 是一个迭代的、对称密钥分组的密码，它可以使用128、192 和 256 位密钥，并且用 128 位（16字节）分组加密和解密数据。与公共密钥密码使用密钥对不同，对称密钥密码使用相同的密钥加密和解密数据。通过分组密码返回的加密数据的位数与输入数据相同。迭代加密使用一个循环结构，在该循环中重复置换（permutations ）和替换(substitutions）输入数据。
　　在应用方面，尽管DES在安全上是脆弱的，但由于快速DES芯片的大量生产，使得DES仍能暂时继续使用，为提高安全强度，通常使用独立密钥的三级DES。但是DES迟早要被AES代替。流密码体制较之分组密码在理论上成熟且安全，但未被列入下一代加密标准。
　　AES加密数据块分组长度必须为128比特，密钥长度可以是128比特、192比特、256比特中的任意一个（如果 数据块及密钥长度不足时，会补齐）。AES加密有很多轮的重复和变换。大致步骤如下：
　　密钥扩展（KeyExpansion）、初始轮 （Initial Round）、重复轮（Rounds），每一轮又包括：SubBytes、ShiftRows、MixColumns、AddRoundKey， 最终轮（Final Round）：最终轮没有MixColumns。

#### MD5算法

**1.原理**

对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。
    　　在MD5算法中，首先需要对信息进行填充，使其位长对512求余的结果等于448。因此，信息的位长（Bits Length）将被扩展至N*512+448，N为一个非负整数，N可以是零。填充的方法如下，在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。然后，在这个结果后面附加一个以64位二进制表示的填充前信息长度。经过这两步的处理，信息的位长=N*512+448+64= (N+1)*512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求。表示第i个分组，每次的运算都由前一轮的128位结果值和第i块512bit值进行运算。初始的128位值为初试链接变量，这些参数用于第一轮的运算，以大端字节序来表示，他们分别为：A=0x01234567，B=0x89ABCDEF，C=0xFEDCBA98，D=0x76543210。

**2.发展历史**
　　MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已由MD5实现。
　　将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。
　　MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被"压缩"成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。
　　除了MD5以外，其中比较有名的还有sha-1、RIPEMD以及Haval等

**3. MD4简介**
　　为了加强算法的安全性，Rivest在1990年又开发出MD4算法。MD4算法同样需要填补信息以确保信息的比特位长度减去448后能被512整除（信息比特位长度mod 512 = 448）。然后，一个以64位二进制表 示的信息的最初长度被添加进来。信息被处理成512位damg?rd/merkle迭代结构的区块，而且每个区块要通过三个不同步骤的处理。Den boer和Bosselaers以及其他人很快的发现了攻击MD4版本中第一步和第三步的漏洞。Dobbertin向大家演示了如何利用一部普通的个人电脑在几分钟内找到MD4完整版本中的冲突（这个冲突实际上是一种漏洞，它将导致对不同的内容进行加密却可能得到相同的加密后结果）。毫无疑问，MD4就此被淘汰掉了。
　　尽管MD4算法在安全上有个这么大的漏洞，但它对在其后才被开发出来的好几种信息安全加密算法的出现却有着不可忽视的引导作用。

**4. MD5的应用**
　　**（1）一致性验证**
　　MD5的典型应用是对一段信息（Message）产生信息摘要（Message-Digest），以防止被篡改。比如，在Unix下有很多软件在下载的时候都有一个文件名相同，文件扩展名为.md5的文件，在这个文件中通常只有一行文本，大致结构如：
MD5 (tanajiya.tar.gz) = 0ca175b9c0f726a831d895e269332461
这就是tanajiya.tar.gz文件的数字签名。MD5将整个文件当作一个大文本信息，通过其不可逆的字符串变换算法，产生了这个唯一的MD5信息摘要。为了让读者朋友对MD5的应用有个直观的认识，笔者以一个比方和一个实例来简要描述一下其工作过程：
　　大家都知道，地球上任何人都有自己独一无二的指纹，这常常成为司法机关鉴别罪犯身份最值得信赖的方法；与之类似，MD5就可以为任何文件（不管其大小、格式、数量）产生一个同样独一无二的“数字指纹”，如果任何人对文件做了任何改动，其MD5值也就是对应的“数字指纹”都会发生变化。
　　我们常常在某些软件下载站点的某软件信息中看到其MD5值，它的作用就在于我们可以在下载该软件后，对下载回来的文件用专门的软件（如Windows MD5 Check等）做一次MD5校验，以确保我们获得的文件与该站点提供的文件为同一文件。利用MD5算法来进行文件校验的方案被大量应用到软件下载站、论坛数据库、系统文件安全等方面。
　　**（2）数字证书**
　　MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹）， 以防止被“篡改”。举个例子，你将一段话写在一个叫 readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内 容，你对这个文件重新计算MD5时就会发现（两个MD5值不相同）。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的 数字签名应用。
　　**（3）安全访问认证**
　　MD5还广泛用于操作系统的登陆认证上，如Unix、各类BSD系统登录密码、数字签名等 诸多方面。如在Unix系统中用户的密码是以MD5（或其它类似的算法）经Hash运算后存储在文件系统中。当用户登录的时候，系统把用户输入的密码进行 MD5 Hash运算，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可 以确定用户登录系统的合法性。这可以避免用户的密码被具有系统管理员权限的用户知道。MD5将任意长度的“字节串”映射为一个128bit的大整数，并且 是通过该128bit反推原始字符串是困难的，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。所以，要遇到了md5密码的问题，比较好的办法是：你可以用这个系统中的md5（）函数 重新设一个密码，如admin，把生成的一串密码的Hash值覆盖原来的Hash值就行了。
　　正是因为这个原因，现在被黑客使用最多的一种破译密码的方法就是一种被称为"跑字典"的方法。有两种方法得到字典，一种是日常搜集的用做密码的字符串表，另一种是用排列组合方法生成的，先用MD5程序计算出这些字典项的MD5值，然后再用目标的MD5值在这个字典中检索。我们假设密码的最大长度为8位字节（8 Bytes），同时密码只能是字母和数字，共26+26+10=62个字符，排列组合出的字典的项数则是 P（62,1）+P（62,2）….+P（62,8），那也已经是一个很天文的数字了，存储这个字典就需要TB级的磁盘阵列，而且这种方法还有一个前提，就是能获得目标账户的密码MD5值的情况下才可以。这种加密技术被广泛的应用于Unix系统中，这也是为什么Unix系统比一般操作系统更为坚固一个重要原因。

#### SHA算法

SHA (Secure Hash Algorithm，译作安全散列算法) 是美国国家安全局 (NSA) 设计，美国国家标准与技术研究院 (NIST) 发布的一系列密码散列函数。正式名称为 SHA 的家族第一个成员发布于 1993年。然而现在的人们给它取了一个非正式的名称 SHA-0 以避免与它的后继者混淆。两年之后， SHA-1，第一个 SHA 的后继者发布了。 另外还有四种变体，曾经发布以提升输出的范围和变更一些细微设计: SHA-224, SHA-256, SHA-384 和 SHA-512 (这些有时候也被称做 SHA-2)。
　　最初载明的算法于 1993年发布，称做安全散列标准 (Secure Hash Standard)，FIPS PUB 180。这个版本现在常被称为 "SHA-0"。它在发布之后很快就被 NSA 撤回，并且以 1995年发布的修订版本 FIPS PUB 180-1 (通常称为 "SHA-1") 取代。根据 NSA 的说法，它修正了一个在原始算法中会降低密码安全性的错误。然而 NSA 并没有提供任何进一步的解释或证明该错误已被修正。1998年，在一次对 SHA-0 的攻击中发现这次攻击并不能适用于 SHA-1， 我们不知道这是否就是 NSA 所发现的错误，但这或许暗示我们这次修正已经提升了安全性。SHA-1 已经被公众密码社群做了非常严密的检验而还没发现到有不安全的地方，它现在被认为是安全的。
　　SHA-0 和 SHA-1 会从一个最大 264 位元的讯息中产生一串 160 位元的摘要然后以设计 MD4 及 MD5 讯息摘要算法的 MIT 教授 Ronald L. Rivest 类似的原理为基础来加密。
　　在 CRYPTO 98 上，两位法国研究者展示了一次对 SHA-0 的攻击 (Chabaud and Joux, 1998): 散列碰撞可以复杂到 261 时被发现；小于 280 是理想的相同大小散列函数。2004年时，Biham 和 Chen 发现了 SHA-0 的近似碰撞 — 两个讯息可以散列出相同的数值；在这种情况之下，142 和 160 位元是一样的。他们也发现了 SHA-0 在 80 次之后减少到 62 位元的完整碰撞。2004年8月12日，Joux, Carribault, Lemuet 和 Jalby 宣布了完整 SHA-0 算法的散列碰撞。这是归纳 Chabaud 和 Joux 的攻击所完成的结果。发现这个碰撞要复杂到 251 并且用一台有 256 颗 Itanium2 处理器的超级电脑耗时大约 80,000 CPU 工作时 。2004年8月17日，在 CRYPTO 2004 的 Rump 会议上，Wang, Feng, Lai, 和 Yu 宣布了攻击 MD5、SHA-0 和其他散列函数的初步结果。他们对 SHA-0 攻击复杂到 240 位元，这意谓的他们攻击的成果比 Joux 还有其他人所做的更好。请参见 MD5 安全性。该次 Rump 会议的简短摘要可以在 这里找到，而他们在 sci.crypt 的讨论，例如： 这些结果建议计划使用 SHA-1 作为新的密码系统的人需要重新考虑。
　　NIST 发布了三个额外的 SHA 变体，每个都有更长的讯息摘要。以它们的摘要长度 (以位元计算) 加在原名后面来命名："SHA-256", "SHA-384" 和 "SHA-512"。它们发布于 2001年的 FIPS PUB 180-2 草稿中，随即通过审查和评论。包含 SHA-1 的 FIPS PUB 180-2，于 2002年以官方标准发布。这些新的散列函数并没有接受像 SHA-1 一样的公众密码社群做详细的检验，所以它们的密码安全性还不被大家广泛的信任。2004年2月，发布了一次 FIPS PUB 180-2 的变更通知，加入了一个额外的变种 "SHA-224"，定义了符合双密钥 3DES 所需的密钥长度。Gilbert 和 Handschuh (2003) 研究了新的变种并且没有发现弱点
　　

#### RSA算法

RSA公开密钥密码体制。所谓的公开密钥密码体制就是使用不同的加密密钥与解密密钥，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。非常好用。
　　在公开密钥密码体制中，加密密钥（即公开密钥）PK是公开信息，而解密密钥（即秘密密钥）SK是需要保密的。加密算法E和解密算法D也都是公开的。虽然秘密密钥SK是由公开密钥PK决定的，但却不能根据PK计算出SK。正是基于这种理论，1978年出现了著名的RSA算法，它通常是先生成一对RSA 密钥，其中之一是保密密钥，由用户保存；另一个为公开密钥，可对外公开，甚至可在网络服务器中注册。为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位。这就使加密的计算量很大。为减少计算量，在传送信息时，常采用传统加密方法与公开密钥加密方法相结合的方式，即信息采用改进的DES或IDEA对话密钥加密，然后使用RSA密钥加密对话密钥和信息摘要。对方收到信息后，用不同的密钥解密并可核对信息摘要。
　　RSA算法是第一个能同时用于加密和数字签名的算法，也易于理解和操作。RSA是被研究得最广泛的公钥算法，从提出到现在的三十多年里，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。

**RSA算法安全性**
　　RSA的安全性依赖于大数分解，但是否等同于大数分解一直未能得到理论上的证明，因为没有证明破解 RSA就一定需要作大数分解。假设存在一种无须分解大数的算法，那它肯定可以修改成为大数分解算法。目前，RSA 的一些变种算法已被证明等价于大数分解。不管怎样，分解n是最显然的攻击方法。现在，人们已能分解多个十进制位的大素数。因此，模数n 必须选大一些，因具体适用情况而定

#### DSA算法

**数字签名**
　　数字签名的文件的完整性是很容易验证的（不需要骑缝章，骑缝签名，也不需要笔迹专家），而且数字签名具有不可抵赖性（不需要笔迹专家来验证）。
　　简单地说,所谓数字签名就是附加在数据单元上的一些数据,或是对数据单元所作的密码变换。这种数据或变换允许数据单元的接收者用以确认数据单元的来源和数据单元的完整性并保护数据,防止被人(例如接收者)进行伪造。它是对电子形式的消息进行签名的一种方法,一个签名消息能在一个通信网络中传输。基于公钥密码体制和私钥密码体制都可以获得数字签名,主要是基于公钥密码体制的数字签名。包括普通数字签名和特殊数字签名。普通数字签名算法有RSA、ElGamal、Fiat-Shamir、Guillou- Quisquarter、Schnorr、Ong-Schnorr-Shamir数字签名算法、Des/DSA,椭圆曲线数字签名算法和有限自动机数字签名算法等。特殊数字签名有盲签名、代理签名、群签名、不可否认签名、公平盲签名、门限签名、具有消息恢复功能的签名等,它与具体应用环境密切相关。显然,数字签名的应用涉及到法律问题,美国联邦政府基于有限域上的离散对数问题制定了自己的数字签名标准(DSS)。

**DSA算法原理**
　　数字签名是数据在公开行信道中传输的安全保障，能够实现数据公开、公正、不可抵赖等特点的方法，只能公开的密钥、密码签名算法。国际公认的公开密钥签字算法主要有RSA算法、EIGAMAL算法或者其变形的签名算法。DSA（Digite Signature Arithmotic）是Schnore和ElGamal算法的变型。
　　美国国家标准局（NIST）1994年5月19日公布了数字签名标准的（DSS），标准采用的是算法便是DSA，密钥长度为512-1024位。密钥长度俞长，签名速度愈慢，制约运算速度的主要因素是大数的模指数预算。

**DSA签名中的参数**
　　参数描述：Digital Signature Algorithm（DSA）是Schnorr和EIGamal签名算法的变种，被美国NIST作为DSS（Digital Signature Standard）。算法中应用了下述参数：
　　p：L bits长的素数。L是64的倍数，范围是512到1024；
　　q：p - 1的160bits的素因子；
　　g：g = h^((p-1)/q) mod p，h满足h < p - 1, h^((p-1)/q) mod p > 1；
　　x：x < q，x为私钥 ；
　　y：y = g^x mod p ，( p, q, g, y )为公钥；
　　H( x )：One-Way Hash函数。DSS中选用SHA( Secure Hash Algorithm )。
　　
　　p, q, g可由一组用户共享，但在实际应用中，使用公共模数可能会带来一定的威胁。签名及验证协议如下：

  1. P产生随机数k，k < q；

  2. P计算 r = ( g^k mod p ) mod q
       s = ( k^(-1) (H(m) + xr)) mod q
       　　签名结果是( m, r, s )。

  3. 验证时计算 w = s^(-1)mod q
       u1 = ( H( m )  *w ) mod q　　u2 = ( r*  w ) mod q

       v = (( g^u1 * y^u2 ) mod p ) mod q
       　　若v = r，则认为签名有效。
       　　DSA是基于整数有限域离散对数难题的，其安全性与RSA相比差不多。DSA的一个重要特点是两个素数公开，这样，当使用别人的p和q时，即使不知道私钥，你也能确认它们是否是随机产生的，还是作了手脚。RSA算法却作不到。

以上便是在生活中常用的加密算法，根据需求不同来选择适当的算法，当然，现实中的算法不至这几个，请大家从他处进行学习。
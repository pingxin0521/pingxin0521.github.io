---
title: 微服务组件--分布式追踪系统
date: 2019-10-27 12:18:59
tags:
 - Java 
 - 框架
 - Spring Cloud
categories:
 - Java
 - Spring Cloud
---

随着微服务架构的流行，一些微服务架构下的问题也会越来越突出，比如一个请求会涉及多个服务，而服务本身可能也会依赖其他服务，整个请求路径就构成了一个网状的调用链，而在整个调用链中一旦某个节点发生异常，整个调用链的稳定性就会受到影响，所以会深深的感受到 “银弹” 这个词是不存在的，每种架构都有其优缺点 。

<!--more-->

一次用户的请求会经过多个系统,不同服务之间的调用关系十分复杂,任何一个系统出错都可能影响整个请求的处理结果。以往的监控系统往往只能知道单个系统的健康状况、一次请求的成功失败,无法快速定位失败的根本原因。

![tevCcD.png](https://s1.ax1x.com/2020/05/28/tevCcD.png)

除此之外,复杂的分布式系统也面临这下面这些问题:

- 性能分析:一个服务依赖很多服务,被依赖的服务也依赖了其他服务。如果某个接口耗时突然变长了,那未必是直接调用的下游服务慢了,也可能是下游的下游慢了造成的,如何快速定位耗时变长的根本原因呢?
- 链路梳理:需求迭代很快,系统之间调用关系变化频繁,靠人工很难梳理清楚系统链路拓扑 (系统之间的调用关系)。

面对以上情况， 我们就需要一些可以帮助理解系统行为、用于分析性能问题的工具，以便发生故障的时候，能够快速定位和解决问题，这时候 APM（应用性能管理）工具就该闪亮登场了。

> APM (Application Performance Management) 即应用性能管理系统,是对企业系统即时监控以实现对应用程序性能管理和故障管理的系统化的解决方案。应用性能管理,主要指对企业的关键业务应用进行监测、优化,提高企业应用的可靠性和质量,保证用户得到良好的服务,降低IT总拥有成本。
>
> APM系统是可以帮助理解系统行为、用于分析性能问题的工具,以便发生故障的时候,能够快速定位和解决问题。

目前主要的一些 APM 工具有: Cat、Zipkin、Pinpoint、SkyWalking

首先需要了解OpenTracing

### OpenTracing

分布式链路跟踪最先由Google在Dapper论文中提出,而[OpenTracing](http://opentracing.io/)通过提供平台无关、厂商无关的API,使得开发人员能够方便的添加(或更换)追踪系统的实现。

下图是一个分布式调用的例子,客户端发起请求,请求首先到达负载均衡器,接着经过认证服务,订单服务,然后请求资源,最后返回结果。

![tevJNq.png](https://s1.ax1x.com/2020/05/28/tevJNq.png)

虽然这种图对于看清各组件的组合关系是很有用的,但是存在下面两个问题:

- 它不能很好显示组件的调用时间,是串行调用还是并行调用,如果展现更复杂的调用关系,会更加复杂,甚至无法画出这样的图。
- 这种图也无法显示调用间的时间间隔以及是否通过定时调用来启动调用。

一种更有效的展现一个调用过程的图:

![tev0u4.png](https://s1.ax1x.com/2020/05/28/tev0u4.png)

基于 OpenTracing我们就可以很轻松的构建出上面这幅图。

#### 关于Metrics、Tracing和Logging

监控、链路追踪及日志作为实时监测系统运行监控状况，在这三个领域都有对应的工具和解决方案，它们除负责各自的职责(prometheus、jaeger、ELK)在某些情况下可能会重叠。我们可以用维恩图的形式，描绘出各个领域之间的可观测性

![tmSe41.png](https://s1.ax1x.com/2020/05/28/tmSe41.png)

- **Metrics** 监控指标的定义特征是它们是可聚合的：它们是在一段时间内组成单个逻辑指标、计数器或直方图的原子。例如：队列的当前深度可以建模为一个规范，其更新聚合为最后一个writer win语义；传入的http请求的数量可以建模为一个计数器，其更新聚合为简单的加法；观察到的请求持续时间可以建模为一种直方图，其更新聚合为时间段并产生统计摘要
- **Logging** 日志的定义特征是它处理离散事件。例如：应用程序调试或错误消息通过一个轮转的文件描述符通过syslog发送到elasticsearch(OK log, nudge nudge); 审计跟踪事件通过kafka推送到数据湖bigtable；或者从服务调用中提取特定于请求的元数据并发送到错误追踪服务(如NewRelic)
- **Tracing** 它定义特征是它处理请求范围内的信息--任何可以绑定到系统中单个事务对象的生命周期的数据或元数据。例如：远程服务的出站rpc的持续时间；发送到数据库的实际sql查询的文本；或入站http请求的相关ID

通过上述定义，我们可以标记重叠部分为下图所示

![tmSY4I.png](https://s1.ax1x.com/2020/05/28/tmSY4I.png)

在云原生应用程序所特有的许多工具最终都是请求范围(request-scoped)内的，因此，讨论进行追踪上下文是有意义的。我们可以看到，并非所有的工具都绑定到请求生命周期：例如，逻辑组件诊断信息或流程生命周期详细信息将与任何离散请求正交。因此，举例来说，并非所有的监控项或日志都可以被强制放入跟踪系统，或者，我们可能会意识到，直接在应用程序中检测监控值会给我们带来更多好处，比如一种灵活的表达式语言，进行实时评估；相反，将监控值强制放入日志管道可能会迫使我们丢弃其中的一些好处

在这三个领域中，监控指标往往需要最少的资源来管理，因为从本质上来说，它们“压缩”得相当好。相反，日志记录往往是压倒性的超过它所报告的生产流量。我们可以画出一个volume开销梯度，从**监控**(低)到**日志**(高)-我们观察到**tracing**可能位于中间的某个地方

我们可以将现有系统分类。例如，prometheus最初只是作为一个监控系统启动的，随着时间的推移，它可能会向跟踪方向发展，从而进入请求范围(request-scope)内的监控，但很可能不会深入到日志空间。ELK提供日志记录和汇总功能，使其成为可聚合的事件空间，但似乎在metrics和tracing领域不断积累更多的功能，意图将它推向中心

![tmSagf.png](https://s1.ax1x.com/2020/05/28/tmSagf.png)

以上韦恩图根据Metrics、Tracing和Logging定义的划分，可能不是那么准确，但有助于理解这三个领域之间的关系

#### OpenTracing API

分布式追踪，也称为分布式请求追踪，是一种用于分析和监视应用程序的方法，特别是那些使用微服务体系结构构建的应用程序，IT和DevOps团队可以使用分布式追踪来监视应用程序; 分布式追踪有助于查明故障发生的位置以及导致性能低下的原因，开发人员可以使用分布式跟踪来帮助调试和优化他们的代码

大多数分布式追踪系统的思想模型都来自Google's Dapper论文，**OpenTracing**也使用相似的**术语**

1. **Trace** 事物在分布式系统中移动时的描述
2. **Span** 一种命名的、定时的操作，表示工作流的一部分。Spans接受key:value标签以及附加到特定Span实例的细粒度、带时间戳的结构化日志
3. **Span Contenxt** 携带分布式事务的跟踪信息，包括当它通过网络或消息总线将服务传递给服务时。SPAN上下文包含Trace标识符、SPAN标识符和跟踪系统需要传播到下游服务的任何其他数据

对现代软件系统中的**组件**可以分为**三类**

- 应用程序和业务逻辑 您的代码
- 广泛的共享库 其他人的代码
- 广泛共享的服务 其他人的基础设施

这三类组件有着不同的需求，**驱动着监控应用程序的分布式追踪系统的设计**。最终的设计产生了四个重要的部分

- 追踪监测API 修饰应用程序代码
- 有线协议 在RPC请求中与应用程序数据一起发送内容
- 数据协议 异步(带外)发送到分析系统的内容
- 分析系统 用于处理追踪数据的数据库和交互式用户界面

OpenTracing API提供了一个标准的、与供应商无关的框架，这意味着如果开发者想要尝试一种不同的分布式追踪系统，开发者只需要简单地修改Tracer配置即可，而不需要替换整个分布式追踪系统

*OpenTracing由API规范(描述了语言无关的数据模型和Opentracing API指南)、实现该规范的框架和库以及项目文档组成，OpenTracing不是一个标准，OpenTracing API项目正致力于为分布式跟踪创建更加标准化的API和工具*

**OpenTracing 数据模型**

OpenTracing 中的 **Trace**（调用链）通过归属于此调用链的 **Span** 来隐性的定义。
特别说明，一条 **Trace**（调用链）可以被认为是一个由多个 **Span** 组成的有向无环图（DAG图），**Span** 与 **Span** 的关系被命名为 **References**。

例如：下面的示例 **Trace** 就是由8个 **Span** 组成：

```
单个 Trace 中，span 间的因果关系


        [Span A]  ←←←(the root span)
            |
     +------+------+
     |             |
 [Span B]      [Span C] ←←←(Span C 是 Span A 的孩子节点, ChildOf)
     |             |
 [Span D]      +---+-------+
               |           |
           [Span E]    [Span F] >>> [Span G] >>> [Span H]
                                       ↑
                                       ↑
                                       ↑
                         (Span G 在 Span F 后被调用, FollowsFrom)
```

有些时候，使用下面这种，基于时间轴的时序图可以更好的展现 **Trace**（调用链）：

```
单个 Trace 中，span 间的时间关系


––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–> time

 [Span A···················································]
   [Span B··············································]
      [Span D··········································]
    [Span C········································]
         [Span E·······]        [Span F··] [Span G··] [Span H··]
```

每个 **Span** 包含以下的状态:（译者注：由于这些状态会反映在 OpenTracing API 中，所以会保留部分英文说明）

- An operation name，操作名称
- A start timestamp，起始时间
- A finish timestamp，结束时间
- **Span Tag**，一组键值对构成的 Span 标签集合。键值对中，键必须为 string，值可以是字符串，布尔，或者数字类型。
- **Span Log**，一组 span 的日志集合。
  每次 log 操作包含一个键值对，以及一个时间戳。

键值对中，键必须为 string，值可以是任意类型。
但是需要注意，不是所有的支持 OpenTracing 的 Tracer，都需要支持所有的值类型。

- **SpanContext**，Span 上下文对象 (下面会详细说明)
- **References**(Span间关系)，相关的零个或者多个 Span（**Span** 间通过 **SpanContext** 建立这种关系）

每一个 **SpanContext** 包含以下状态：

- 任何一个 OpenTracing 的实现，都需要将当前调用链的状态（例如：trace 和 span 的 id），依赖一个独特的 Span 去跨进程边界传输
- **Baggage Items**，Trace 的随行数据，是一个键值对集合，它存在于 trace 中，也需要跨进程边界传输

更多关于 OpenTracing 数据模型的知识，请参考 [OpenTracing语义标准](https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fgithub.com%2Fopentracing-contrib%2Fopentracing-specification-zh%2Fblob%2Fmaster%2Fspecification.md)。

#### 追踪示例

端到端注入和提取追踪数据流程

1. 一个客户端进程有一个SpanContext实例，它将在一个HTTP协议之上生成一个RPC
2. 客户端进程调用Tracer.Inject(...)，传递活动的SpanContext实例、Text Map格式的标识符和Text Map Carrier作为参数
3. Inject已经在Carrier中填充了Text Map，客户端应用程序在其自制的http协议（例如，作为头）中对该映射进行编码
4. 发起HTTP请求，数据跨越进程边界
5. 现在在服务器进程中，应用程序代码从自制的http协议中解码Text Map并使用它初始化Text Map Carrier
6. 服务进程调用Tracer.Extract(...)，抽取从上面传入所需的操作名、Text Map的格式标识符和Carrier
7. 在没有数据损坏或其他错误的情况下，服务器现在有一个SpanContext实例，它与客户机中的实例属于同一个Trace

### 主流的开源APM产品

**PinPoint**

Pinpoint是由一个韩国团队实现并开源,针对Java编写的大规模分布式系统设计,通过JavaAgent的机制做字节代码植入,实现加入traceid和获取性能数据的目的,对应用代码零侵入。

- 官方网站:
  https://github.com/naver/pinpoint

![tevjKg.png](https://s1.ax1x.com/2020/05/28/tevjKg.png)

**SkyWalking**

SkyWalking是apache基金会下面的一个开源APM项目,为微服务架构和云原生架构系统设计。它通过探针自动收集所需的指标,并进行分布式追踪。通过这些调用链路以及指标,Skywalking APM会感知应用间关系和服务间关系,并进行相应的指标统计。Skywalking支持链路追踪和监控应用组件基本涵盖主流框架和容器,如国产RPC Dubbo和motan等,国际化的spring boot,spring cloud。

- 官方网站:
  http://skywalking.apache.org/

**Zipkin**

Zipkin是由Twitter开源,是分布式链路调用监控系统,聚合各业务系统调用延迟数据,达到链路调用监控跟踪。Zipkin基于Google的Dapper论文实现,主要完成数据的收集、存储、搜索与界面展示。

- 官方网站:
  https://zipkin.io/

![tex95q.png](https://s1.ax1x.com/2020/05/28/tex95q.png)

**CAT**

CAT是由大众点评开源的项目,基于Java开发的实时应用监控平台,包括实时应用监控,业务监控,可以提供十几张报表展示。

- 官方网站:
  https://github.com/dianping/cat

### 参考

1. [OpenTracing:开放式分布式追踪规范](https://www.jianshu.com/p/d2b11c079af0)
2. [分布式追踪系统 -- Opentracing](https://zhuanlan.zhihu.com/p/83654617)
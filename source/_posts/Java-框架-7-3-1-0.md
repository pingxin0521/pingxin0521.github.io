---
title: Spring Data 概述
date: 2019-07-06 16:18:59
tags:
 - Java
 - 框架
 - DAO
 - Spring Data
categories:
 - Java
 - 框架
---

#### 持久层开发的问题

随着互联网技术的发展,现在的企业开发中用到的用于数据存储的产品,不再仅仅是关系型数据库,而是要根据场景需要选择不同的存储技术,比如用于缓存热点数据的redis,用于存储文档数据的mongodb,用于支持强大搜索功能的elasticsearch等等。

<!--more-->

![1B2Pcd.png](https://s2.ax1x.com/2020/02/04/1B2Pcd.png)

在Java中,对于上面所说的产品都提供了优秀的访问技术。比如针对关系型数据库的mybatis、jpa等技术,针对于redis的jedis技术等等..... 这些技术虽然可以很好的针对各个存储产品进行访问操作,但同时也带来了新的问题,那就是不同的持久层技术的API是不一样的。

这样一来,开发人员就必须同时掌握多种数据访问技术,这无疑增加了开发成本。那么我们会想,有没有这样一种技术,它可以使用一套API支持各个不同的存储的访问呢?就在这样的需求下,SpringData产生了。

![1B2knI.png](https://s2.ax1x.com/2020/02/04/1B2knI.png)

#### SpringData 简介

**什么是SpringData**

SpringData是一个用来简化dao层开发的框架。它在保证了各个底层存储特性的同时,提供了一套统一的数据访问API。它可以很好的支持常用的关系型数据库和非关系型数据库。

使用SpringData作为dao层开发技术,将大大简化代码量,而且其API比各个技术的原生API更加简单易用。

**SpringData的主要模块**

SpringData支持的持久层技术非常多,我们只介绍几个常见的:

- Spring Data common :SpringData 的核心模块,定义了SpringData的核心功能
- Spring Data JDBC: 对JDBC的Spring Data存储库支持
- Spring Data JPA: 对JPA的Spring Data存储库支持
- Spring Data MongoDB: 对MongoDB的基于Spring对象文档的存储库支持
- Spring Data Redis: 封装Jedis技术,对redis实现访问操作
- Spring Data Elasticsearch: 对Elasticsearch实现访问操作

#### JPA回顾

##### JPA 基础

JPA 的全称是 Java Persistence API,即 Java 持久化 API,是 SUN 公司推出的一套基于 ORM 的规范,注意不是 ORM 框架——因为 JPA 并未提供 ORM 实现,它只是提供了一些编程的 API 接口。

![1B21un.png](https://s2.ax1x.com/2020/02/04/1B21un.png)

##### JPA 实战

**目标**

本章节我们是实现的功能是搭建Jpa环境,并实现一条数据的增删改查。

注：使用数据库为MySQL 8.0

**准备数据库环境**

```sql
-- 准备数据库,创建一张文章表备用
CREATE TABLE `article` (
`aid` int(11) NOT NULL auto_increment COMMENT '主键',
`author` varchar(255) default NULL COMMENT '作者',
`createTime` datetime default NULL COMMENT '创建时间',
`title` varchar(255) default NULL COMMENT '标题',
PRIMARY KEY
(`aid`)
);

insert into `article` values(1,'平心','2020-01-01','论永动机的可行性');
```

**创建 java工程,导入坐标**

```xml
    <dependencies>
        <!--Jpa的支撑框架hibernate-->
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-entitymanager</artifactId>
        </dependency>
        <!--mysql-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
        <!-- 日志 -->
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
        </dependency>
        <!-- 单元测试 -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
        </dependency>
        <!--注解开发-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
    </dependencies>
```

**创建实体类**

```java
@Data
public class Article implements Serializable {
private Integer aid;
private String title;
private String author;
private Date createTime;
}
```

**在实体类中配置映射关系**

```java
@Data
@Entity//表示这是一个实体类
@Table(name = "article") //建立实体类和表的映射关系
public class Article implements Serializable {
    @Id//声明当前私有属性为主键
    @GeneratedValue(strategy = GenerationType.IDENTITY) //配置主键的生成策略
    private Integer aid;
    //声明类的属性跟数据表字段的对应关系,如果属性名称和字段名称一致,可省略
    @Column(name = "title")
    private String title;
    private String author;
    private Date createTime;
}
```

**加入 JPA 的核心配置文件**

在maven工程的resources路径下创建一个名为META-INF的文件夹,在文件夹下创建一个名为persistence.xml的配置文件。注意: META-INF文件夹名称不能修改,persistence.xml文件名称不能改。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/persistence
http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd" version="2.0">
    <!--持久化单元-->
    <persistence-unit name="springdata" transaction-type="RESOURCE_LOCAL">
        <!--配置 JPA 规范的服务提供商 -->
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
        <properties>
            <!-- 数据库驱动 -->
            <property name="javax.persistence.jdbc.driver"
                      value="com.mysql.cj.jdbc.Driver"/>
            <!-- 数据库地址 -->
            <property name="javax.persistence.jdbc.url"
                      value="jdbc:mysql:///test"/>
            <!-- 数据库用户名 -->
            <property name="javax.persistence.jdbc.user" value="root"/>
            <!-- 数据库密码 -->
            <property name="javax.persistence.jdbc.password"
                      value="123456"/>
            <!--jpa的核心配置中兼容hibernate的配置-->
            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.format_sql" value="true"/>
            <property name="hibernate.hbm2ddl.auto" value="update"/>
        </properties>
    </persistence-unit>
</persistence>
```

**测试**

```java
public class JpaTest {

    @Test
    public void testSave() {
        //1 创建持久化管理器工厂
        String persistenceUnitName = "springdata";
        EntityManagerFactory factory = Persistence.createEntityManagerFactory(persistenceUnitName);

        //2 创建持久化管理器
        EntityManager entityManager = factory.createEntityManager();

        //3 获取事务
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        //4 操作
        Article article = new Article();
        article.setTitle("测试文章标题");
        article.setAuthor("px");
        article.setCreateTime(new Date());
        entityManager.persist(article);

        //5 事务提交
        transaction.commit();

        //6 关闭资源
        entityManager.close();
    }

    @Test
    public void testFindByAid() {
        EntityManagerFactory factory = Persistence.createEntityManagerFactory("springdata");
        EntityManager entityManager = factory.createEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        Article article = entityManager.find(Article.class, 1);
        System.out.println(article);

        transaction.commit();
        entityManager.close();
    }

    @Test
    public void testUpdate() {
        EntityManagerFactory factory = Persistence.createEntityManagerFactory("springdata");
        EntityManager entityManager = factory.createEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        Article article = entityManager.find(Article.class, 1);
        //修改
        article.setAuthor("平心");
        entityManager.merge(article);
        transaction.commit();
        entityManager.close();
    }

    @Test
    public void testDelete() {
        EntityManagerFactory factory = Persistence.createEntityManagerFactory("springdata");
        EntityManager entityManager = factory.createEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        Article article = entityManager.find(Article.class, 1);
        //删除
        entityManager.remove(article);

        transaction.commit();
        entityManager.close();
    }
}
```

##### JPA 的重要API介绍

```
EntityManagerFactory接口主要用来创建EntityManager实例
EntityManagerFactory是一个线程安全的对象,并且其创建极其浪费资源,所以编程的时候要保持它是单例的。
```

EntityManager:

```
在JPA规范中,EntityManager是操作数据库的重要API,他是线程不安全的,需要保持线程独有。
重要方法说明:
    getTransaction: 获取事务对象
    persist:保存操作
    merge:更新操作
    remove:删除操作
    find/getReference:根据id查询
```

#### SpringData JPA

SpringData JPA是Spring Data家族的一个成员,是Spring Data对JPA封装之后的产物,目的在于简化基于JPA的数据访问技术。使用SpringData JPA技术之后,开发者只需要声明Dao层的接口,不必再写实现类或其它代码,剩下的一切交给SpringData JPA来搞定

**准备数据环境**

```
--下面的操作让JPA自动生成表结构
```

**创建 java工程,导入坐标**

```xml
        <!-- 日志 -->
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
        </dependency>

        <!-- Spring框架相关jar包 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.2.3.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-test</artifactId>
            <version>5.2.3.RELEASE</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-orm</artifactId>
            <version>5.2.3.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.8.7</version>
        </dependency>
        <!--jpa-->
        <dependency>
            <groupId>org.springframework.data</groupId>
            <artifactId>spring-data-jpa</artifactId>
            <version>2.1.8.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-core</artifactId>
        </dependency>

        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.1.21</version>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
```

**创建实体类**

```java
@Data
@Entity//表示这是一个实体类
@Table(name = "article") //建立实体类和表的映射关系
public class Article implements Serializable {
    @Id//声明当前私有属性为主键
    @GeneratedValue(strategy = GenerationType.IDENTITY) //配置主键的生成策略
    private Integer aid;
    //声明类的属性跟数据表字段的对应关系,如果属性名称和字段名称一致,可省略
    @Column(name = "title")
    private String title;
    private String author;
    private Date createTime;
}

```

**dao接口**

```java
/**
 * JpaRepository<实体类类型,主键类型>:用来完成基本 CRUD 操作
 * JpaSpecificationExecutor<实体类类型>:用于复杂查询(分页等查询操作)
 */
public interface ArticleDao extends JpaRepository<Article, Integer>,
        JpaSpecificationExecutor<Article> {
}
```

**添加 Spring整合Jpa的配置文件**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:jdbc="http://www.springframework.org/schema/jdbc"
       xmlns:jpa="http://www.springframework.org/schema/data/jpa"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		 
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
		http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd
		 
		http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd">

    <!--配置包扫描-->
    <context:component-scan base-package="com.hyp.learn.sdjpa"/>

    <!--配置一个数据源-->
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql:///springdata"/>
        <property name="username" value="root"/>
        <property name="password" value="adminadmin"/>
    </bean>

    <!--配置EntityManagerFactory 可以产生entityManger-->
    <bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
        <!--配置一个数据源-->
        <property name="dataSource" ref="dataSource"/>

        <!--指定实体类-->
        <property name="packagesToScan" value="com.hyp.learn.sdjpa.domain"/>

        <!--配置服务的提供商-->
        <property name="persistenceProvider">
            <bean class="org.hibernate.jpa.HibernatePersistenceProvider"/>
        </property>

        <!--SpringData Jpa 兼容Hibernate使用-->
        <property name="jpaVendorAdapter">
            <bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter">
                <!--配置数据库名称-->
                <property name="database" value="MYSQL"/>
                <!--是否自动建表  true 自动建表  false 不会自动建表-->
                <property name="generateDdl" value="true"/>
                <!--是否显示SQL-->
                <property name="showSql" value="true"/>
            </bean>
        </property>
    </bean>

    <!--声明事务管理器-->
    <bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>


    <!--做一个jpa:repository的配置-->
    <!--base-package 配置dao包的包名 它会为这个包先所有的接口动态产生代理对象-->
    <jpa:repositories base-package="com.hyp.learn.sdjpa.jpa"
                      entity-manager-factory-ref="entityManagerFactory"
                      transaction-manager-ref="transactionManager"
    />

</beans>
```

**测试**

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext-jpa.xml")
public class SpringDataJpaTest {

    @Autowired
    private ArticleDao articleDao;

    //保存
    @Test
    public void testSave() {
        Article article = new Article();
        article.setTitle("平心1的个人自述");
        article.setAuthor("平心2");
        article.setCreateTime(new Date());

        articleDao.save(article);
    }


    //查询主键
    @Test
    public void testFindByAid() {
        Optional<Article> optional = articleDao.findById(1);
        System.out.println(optional.get());
    }

    //查询所有
    @Test
    public void testFindAll() {
        List<Article> articles = articleDao.findAll();
        for (Article article : articles) {
            System.out.println(article);
        }
    }

    //修改
    @Test
    public void testUpdate() {
        Article article = new Article();
        article.setAuthor("黑马3");
        article.setAid(2);

        //Spingdata Jpa的保存和修改使用的都是save方法
        //关键来看传入的实体是否有主键
        //---如果有主键,代表要修改
        //---如果没有主键,代表要保存
        articleDao.save(article);
    }

    //删除
    @Test
    public void testDelete() {
        articleDao.deleteById(2);
    }
}

```

##### SpringData中的几个重要接口

```
自定义的接口继承了两个接口,方法肯定来自里面,追踪关系得到下面的继承关系

Repository 标记接口:继承了此接口后会被Spring识别,进而可以在接口中声明一些满足规范的方法
|
|
CrudRepository 实现了基本增删改查方法
|
|
PagingAndSortingRepository 实现了分页和排序的方法
|
|
JpaRepository 重写了几个查找和删除的方法
|
|
ArticleDao

通过上面的继承关系,我们可以看到我们自定义的接口ArticleDao继承了一系列的Repository接口,而每一个接口都会给我们提供一部分的功能,这样继承下来,我们的ArticleDao不用任何的方法声明就拥有了很多的功能了。
```

##### SpringData Jpa 底层运行原理

思考一个问题:我们找到了定义方法的接口,但并没有看到实现类,没有实现来就无法创建对象,那么真正干活的实现类到底在哪,它又是如何产生对象的呢?

1.  在运行时,Spring会使用JdkDynamicAopProxy为dao接口生成一个代理对象

   ![1B7Ko9.png](https://s2.ax1x.com/2020/02/04/1B7Ko9.png)

2. 那么这个代理对象是根据那个类代理出来的呢?点击进入JdkDynamicAopProxy源码查看invoke方法,发现targetSource代理的是SimpleJpaRepository类

   ![1B71Rx.png](https://s2.ax1x.com/2020/02/04/1B71Rx.png)

3. 通过对SimpleJpaRepository中代码的分析,我们看到最终执行保存的是EntityManager对象

   ![1B7YLD.png](https://s2.ax1x.com/2020/02/04/1B7YLD.png)

总结:使用 SpringData JPA开发底层还是用的JPA的API,SpringData JPA只是对标准 JPA 操作进行了进一步封装,已达到简化了Dao层代码开发的目的。

##### SpringData Jpa 与 Jpa 及 Hibernate的关系

![1B7aod.png](https://s2.ax1x.com/2020/02/04/1B7aod.png)



##### 多种查询方法

1. 父接口方法查询

   我们自定义的Dao接口可以使用它的父接口提供的方法,可以使用的方法如下图所示。

   ![1DpQFf.png](https://s2.ax1x.com/2020/02/04/1DpQFf.png)

   ```java
   @RunWith(SpringJUnit4ClassRunner.class)
   @ContextConfiguration("classpath:applicationContext-jpa.xml")
   public class Query1Test {
   
       @Autowired
       private ArticleDao articleDao;
   
       //根据主键查询
       @Test
       public void testFindById() {
           //根据一个主键查询
           Optional<Article> optional = articleDao.findById(21);
           System.out.println(optional.get());
   
           //根据多个主键查询
           List<Integer> list = new ArrayList<>();
           list.add(21);
           list.add(23);
           list.add(25);
           List<Article> articles = articleDao.findAllById(list);
           for (Article article : articles) {
               System.out.println(article);
           }
       }
   
   
       //查询所有
       @Test
       public void testFindAll() {
           List<Article> articles = articleDao.findAll();
           for (Article article : articles) {
               System.out.println(article);
           }
       }
   
       //查询所有--排序
       @Test
       public void testFindAllWithSort() {
           //按照aid倒序排列
           Sort sort = Sort.by(Sort.Order.desc("aid"));
           List<Article> articles = articleDao.findAll(sort);
           for (Article article : articles) {
               System.out.println(article);
           }
       }
   
   
       //查询所有--分页
       @Test
       public void testFindAllWithPage() {
           //处理分页条件
           //page   当前是第几页(从0开始)    size  每页大小
           Pageable pageable = PageRequest.of(0, 2);
           Page<Article> page = articleDao.findAll(pageable);
   
           //总记录数  总页数  每页多少
           System.out.println("总记录数:" + page.getTotalElements());
           System.out.println("总页数:" + page.getTotalPages());
           System.out.println("每页多少:" + page.getSize());
           //当前页的元素
           List<Article> content = page.getContent();
           for (Article article : content) {
               System.out.println(article);
           }
       }
   
   
       //查询所有--分页+排序
       @Test
       public void testFindAllWithPageAndPage() {
           //按照aid倒序排列
           Sort sort = Sort.by(Sort.Order.desc("aid"));
   
           //处理分页条件
           //page   当前是第几页(从0开始)    size  每页大小
           Pageable pageable = PageRequest.of(0, 2, sort);
           Page<Article> page = articleDao.findAll(pageable);
   
           //总记录数  总页数  每页多少
           System.out.println("总记录数:" + page.getTotalElements());
           System.out.println("总页数:" + page.getTotalPages());
           System.out.println("每页多少:" + page.getSize());
           //当前页的元素
           List<Article> content = page.getContent();
           for (Article article : content) {
               System.out.println(article);
           }
       }
   
   }
   ```

2. 方法命名规则查询

   顾名思义,方法命名规则查询就是根据方法的名字,就能创建查询。只需要按照SpringData JPA提供的
   方法命名规则定义方法的名称,就可以完成查询工作。

   SpringData JPA在程序执行的时候会根据方法名称进行解析,并自动生成查询语句进行查询

   按照SpringData JPA定义的规则,查询方法以findBy开头,涉及条件查询时,条件的属性用条件关键字连接,要注意的是:条件属性首字母需大写。框架在进行方法名解析时,会先把方法名多余的前缀截取掉,然后对剩下部分进行解析。

   ```java
   @Repository
   public interface ArticleDao extends JpaRepository<Article, Integer>,
           JpaSpecificationExecutor<Article> {
   
       //根据标题查询
       List<Article> findByTitle(String title);
   
       //根据标题模糊查询
       List<Article> findByTitleLike(String title);
   
       //根据标题和作者查询
       List<Article> findByTitleAndAuthor(String title, String author);
   
       //根据ID范围查询 > < between in
       List<Article> findByAidIsLessThan(Integer aid);
   
       List<Article> findByAidBetween(Integer startAid, Integer endAid);
   
       List<Article> findByAidIn(List<Integer> aids);
   
       //根据创建时间之后查询
       List<Article> findByCreateTimeAfter(Date createTime);
       }
   
   ```

3. JPQL 查询

   使用SpringData JPA提供的查询方法已经可以解决大部分的应用场景,但是对于某些业务来说,我们还需要灵活的构造查询条件,这时就可以使用@Query注解,结合JPQL的语句方式完成查询。

   JPQL,全称是Java Persistence Query Language。JPQL语句是JPA中定义的一种查询语言,此种语言的用意是让开发者忽略数据库表和表中的字段,而关注实体类及实体类中的属性。

   它的写法十分类似于SQL语句的写法,但是要把查询的表名换成实体类名称,把表中的字段名换成实体类的属性名称。

   ```java
       //JPQL:类似于SQL语句,但是要使用实体类名代替表名,使用属性名代替字段名[面向对象查询]
       //展示位置参数绑定[按照title和author查询]
       //占位符从1开始
       @Query("from Article a where a.title = ?1 and a.author =?2")
       List<Article> findByCondition1(String title, String author);
   
       //展示名字参数绑定
       @Query("from Article a where a.title = :title and a.author = :authors")
       List<Article> findByCondition2(@Param("title") String title, @Param("authors") String author);
   
       //展示like模糊查询
       @Query("from Article a where a.title like %:title%")
       List<Article> findByCondition3(@Param("title") String title);
   
       //展示排序查询
       @Query("from Article a where a.title like %:title% order by a.aid desc ")
       List<Article> findByCondition4(@Param("title") String title);
   
       //展示分页查询
       @Query("from Article a where a.title like %:title%")
       List<Article> findByCondition5(Pageable pageable, @Param("title") String title);
   
       //展示传入集合参数查询
       @Query("from Article a where a.aid in :aids")
       List<Article> findByCondition6(@Param("aids") List<Integer> aids);
   
       //展示传入Bean进行查询（SPEL表达式查询）
       @Query("from Article a where a.title = :#{#article.title} and a.author = :#{#article.author}")
       List<Article> findByCondition7(@Param("article") Article article);
   
   ```

4. 本地 SQL查询

   ```java
   //本地SQL查询
       @Query(value = "select * from article a where a.title = ?1 and a.author =?2", nativeQuery = true)
       List<Article> findByCondition8(String title, String author);
   ```

5. Specifications 动态查询

   有时我们在查询某个实体的时候,给定的条件是不固定的,这时就需要动态构建相应的查询语句,在 Spring Data JPA 中可以通过 JpaSpecificationExecutor 接口查询。相比 JPQL,其优势是类型安全,更加的面向对象,缺点是书写比较麻烦。

   ```java
   @RunWith(SpringJUnit4ClassRunner.class)
   @ContextConfiguration("classpath:applicationContext-jpa.xml")
   public class Query4Test {
   
       @Autowired
       private ArticleDao articleDao;
   
   
       //按照标题和作者进行查询,以不为空的属性作为查询条件
       @Test
       public void testFindAll() {
   
           //就模拟从从外边传入的变量
           String title = "平心程序员3";
           String author = "平心3";
   
           List<Article> articles = articleDao.findAll(new Specification<Article>() {
   
               /**
                * @param root  代表实体对象,我们可以通过它获取属性值
                * @param cq    用于生成SQL语句
                * @param cb    用于拼接查询条件
                * @return
                */
               @Override
               public Predicate toPredicate(Root<Article> root, CriteriaQuery<?> cq, CriteriaBuilder cb) {
   
                   List<Predicate> list = new ArrayList<>();
                   if (!StringUtils.isEmpty(title)) {
                       //拼接作为查询条件
                       Predicate predicate = cb.equal(root.get("title").as(String.class), title);
                       list.add(predicate);
                   }
                   if (!StringUtils.isEmpty(author)) {
                       //拼接作为查询条件
                       Predicate predicate = cb.equal(root.get("author").as(String.class), author);
                       list.add(predicate);
                   }
   
                   return cb.and(list.toArray(new Predicate[]{}));
               }
           });
   
           for (Article article : articles) {
               System.out.println(article);
           }
       }
   
   
       @Test
       public void testFindAllWithPage() {
   
           //就模拟从从外边传入的变量
           String title = "";
           String author = "";
   
           //分页
           Pageable pageable = PageRequest.of(0, 3);
   
           Page<Article> page = articleDao.findAll(new Specification<Article>() {
   
               /**
                * @param root  代表实体对象,我们可以通过它获取属性值
                * @param cq    用于生成SQL语句
                * @param cb    用于拼接查询条件
                * @return
                */
               @Override
               public Predicate toPredicate(Root<Article> root, CriteriaQuery<?> cq, CriteriaBuilder cb) {
   
                   List<Predicate> list = new ArrayList<>();
                   if (!StringUtils.isEmpty(title)) {
                       //拼接作为查询条件
                       Predicate predicate = cb.equal(root.get("title").as(String.class), title);
                       list.add(predicate);
                   }
                   if (!StringUtils.isEmpty(author)) {
                       //拼接作为查询条件
                       Predicate predicate = cb.equal(root.get("author").as(String.class), author);
                       list.add(predicate);
                   }
   
                   return cb.and(list.toArray(new Predicate[]{}));
               }
           }, pageable);
   
           for (Article article : page.getContent()) {
               System.out.println(article);
           }
       }
   
   
       @Test
       public void testFindAllWithPageAndSort() {
   
           //就模拟从从外边传入的变量
           String title = "";
           String author = "";
   
           //分页
           Pageable pageable = PageRequest.of(0, 3, Sort.by(Sort.Order.desc("aid")));
   
           Page<Article> page = articleDao.findAll(new Specification<Article>() {
   
               /**
                * @param root  代表实体对象,我们可以通过它获取属性值
                * @param cq    用于生成SQL语句
                * @param cb    用于拼接查询条件
                * @return
                */
               @Override
               public Predicate toPredicate(Root<Article> root, CriteriaQuery<?> cq, CriteriaBuilder cb) {
   
                   List<Predicate> list = new ArrayList<>();
                   if (!StringUtils.isEmpty(title)) {
                       //拼接作为查询条件
                       Predicate predicate = cb.equal(root.get("title").as(String.class), title);
                       list.add(predicate);
                   }
                   if (!StringUtils.isEmpty(author)) {
                       //拼接作为查询条件
                       Predicate predicate = cb.equal(root.get("author").as(String.class), author);
                       list.add(predicate);
                   }
   
                   return cb.and(list.toArray(new Predicate[]{}));
               }
           }, pageable);
   
           for (Article article : page.getContent()) {
               System.out.println(article);
           }
       }
   
   
   }
   ```

##### SpringData JPA实现多表操作

多表关系分析:数据库中多表之间存在着三种关系,如图所示。

![1Dpsl4.png](https://s2.ax1x.com/2020/02/04/1Dpsl4.png)

注意:一对多关系可以看为两种: 即一对多,多对一。所以说四种更精确。

在实际开发中,我们数据库的表难免会有相互的关联关系,在操作表的时候就有可能会涉及到多张表的操作。而在这种实现了ORM思想的框架中(如 JPA),可以让我们通过操作实体类就实现对数据库表的操作。所以今天我们的学习重点是:掌握配置实体之间的关联关系

- 第一步:首先确定两张表之间的关系
- 第二步:在实体类中描述出两个实体的关系
- 第三步:配置出实体类和数据库表的关系映射(重点)

**案例表间关系**

![1DpgmR.png](https://s2.ax1x.com/2020/02/04/1DpgmR.png)

1. 一对一关系

   ![1DphtK.png](https://s2.ax1x.com/2020/02/04/1DphtK.png)

   ```java
   @Data
   @Entity//表示这是一个实体类
   @Table(name = "article") //建立实体类和表的映射关系
   public class Article implements Serializable {
       @Id//声明当前私有属性为主键
       @GeneratedValue(strategy = GenerationType.IDENTITY) //配置主键的生成策略
       private Integer aid;
       //声明类的属性跟数据表字段的对应关系,如果属性名称和字段名称一致,可省略
       @Column(name = "title")
       private String title;
       private String author;
       private Date createTime;
   
       //1 声明类间关系
       //声明主动放弃关系维护 mappedBy="当前类在对方类中的属性名"
       //当保存Article的时候,同时保存ArticleData
       @OneToOne(mappedBy = "article", cascade = CascadeType.PERSIST)
       private ArticleData articleData;
   
       //2 在类中使用注解再声明表间关系
       // --书写注解
       // --明确谁来维护关系(在多的一方维护关系)
       //  ----在维护的一方主动声明维护策略,在不维护的一方声明主动放弃
   
   }
   
   @Data
   @Entity
   @Table(name = "article_data")
   public class ArticleData implements Serializable {
   
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Integer id;
   
       private String content;
   
   
       //让这个实体维护关系
       //name                    当前表中的外键名
       //referencedColumnName    指向的对方表中的主键名
       @OneToOne
       @JoinColumn(name = "articleId", referencedColumnName = "aid", unique = true)
       private Article article;
   }
   
   ```

   测试

   ```java
   @RunWith(SpringJUnit4ClassRunner.class)
   @ContextConfiguration("classpath:applicationContext-jpa.xml")
   public class One2OneTest {
   
       @Autowired
       private ArticleDao articleDao;
   
   
       //保存
       @Test
       public void testSave() {
           //创建文章对象
           Article article = new Article();
           article.setTitle("黑马好文章");
           article.setAuthor("黑马");
           article.setCreateTime(new Date());
   
           //创建文章内容对象
           ArticleData articleData = new ArticleData();
           articleData.setContent("真是一篇好文章");
   
   
           //建立两个对象间的关系
           article.setArticleData(articleData);
           articleData.setArticle(article);
   
           //保存操作
           articleDao.save(article);
       }
   }
   ```

2. 一对多关系

   ![1D97CT.png](https://s2.ax1x.com/2020/02/04/1D97CT.png)

   ```java
       @OneToMany(mappedBy = "article")
       private Set<Comment> comments = new HashSet<>(0);
   @Data
   @Entity
   @Table(name = "comment")
   public class Comment implements Serializable {
   
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Integer cid;
   
       private String comment;
   
   
       @ManyToOne()
       @JoinColumn(name = "aid", referencedColumnName = "aid")
       private Article article;
   }
   
   ```

   测试

   ```java
   @RunWith(SpringJUnit4ClassRunner.class)
   @ContextConfiguration("classpath:applicationContext-jpa.xml")
   public class One2ManyTest {
   
       @Autowired
       private ArticleDao articleDao;
       @Autowired
       private CommentDao commentDao;
   
       //保存
       @Test
       public void testSave() {
           //创建文章对象
           Article article = new Article();
           article.setTitle("黑马好文章");
           article.setAuthor("黑马");
           article.setCreateTime(new Date());
   
           //创建文章评论对象
           Comment comment1 = new Comment();
           comment1.setComment("真不错");
           Comment comment2 = new Comment();
           comment2.setComment("挺好的");
   
           //建立两个对象间的关系
           comment1.setArticle(article);
           comment2.setArticle(article);
   
           Set<Comment> comments = new HashSet<>();
           comments.add(comment1);
           comments.add(comment2);
           article.setComments(comments);
   
   
           //保存操作
           articleDao.save(article);
           commentDao.save(comment1);
           commentDao.save(comment2);
   
       }
   }
   
   ```

3. 多对多关系

   ![1DCmIP.png](https://s2.ax1x.com/2020/02/04/1DCmIP.png)

   ```java
       @ManyToMany(mappedBy = "articles")
       private Set<Type> types = new HashSet<>(0);
       
   @Data
   @Entity
   @Table(name = "type")
   public class Type implements Serializable {
   
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Integer tid;
   
       private String name;
   
       @ManyToMany
       @JoinTable(
               //代表中间表名称
               name = "article_type",
               //中间表的外键对应到当前表的主键名称
               joinColumns = {@JoinColumn(name = "tid", referencedColumnName = "tid")},
               //中间表的外键对应到对方表的主键名称
               inverseJoinColumns = {@JoinColumn(name = "aid", referencedColumnName = "aid")}
       )
       private Set<Article> articles = new HashSet<>(0);
   }
   
   ```

   测试

   ```java
   @RunWith(SpringJUnit4ClassRunner.class)
   @ContextConfiguration("classpath:applicationContext-jpa.xml")
   public class Many2ManyTest {
   
       @Autowired
       private ArticleDao articleDao;
       @Autowired
       private TypeDao typeDao;
   
       //保存
       @Test
       public void testSave() {
           //创建文章对象
           Article article1 = new Article();
           article1.setTitle("黑马好文章11");
           article1.setAuthor("黑马11");
           article1.setCreateTime(new Date());
   
           Article article2 = new Article();
           article2.setTitle("黑马好文章22");
           article2.setAuthor("黑马22");
           article2.setCreateTime(new Date());
   
   
           //创建文章类型对象
           Type type1 = new Type();
           type1.setName("军事");
           Type type2 = new Type();
           type2.setName("民政");
   
   
           //建立两个对象间的关系
           Set<Type> types = new HashSet<>();
           types.add(type1);
           types.add(type2);
           article1.setTypes(types);
           article2.setTypes(types);
   
           Set<Article> articles = new HashSet<>();
           articles.add(article1);
           articles.add(article2);
           type1.setArticles(articles);
           type2.setArticles(articles);
   
   
           //保存操作
           articleDao.save(article1);
           articleDao.save(article2);
           typeDao.save(type1);
           typeDao.save(type2);
       }
   }
   ```

#### SpringData Redis

Redis是一个基于内存的数据结构存储系统,它可以用作数据库或者缓存。它支持多种类型的数据结构,这些数据结构类型分别为String(字符串)、List(列表)、Set(集合)、Hash(散列)和Zset(有序集合)。

SpringData Redis的作用是通过一段简单的配置即可访问redis服务,它的底层是对java提供的redis开发包(比如jedis等)进行了高度封装,主要提供了如下功能:

- 连接池自动管理,提供了一个高度封装的 RedisTemplate类,基于这个类的对象可以对redis进行各种操作
- 针对 jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口
  - ValueOperations :简单字符串类型数据操作
  - SetOperations :set类型数据操作
  - ZSetOperations :zset类型数据操作
  - HashOperations :map类型的数据操作
  - ListOperations :list类型的数据操作

依赖

```xml
        <!--jedis-->
        <dependency>
            <groupId>redis.clients</groupId>
            <artifactId>jedis</artifactId>
            <version>2.9.3</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.data</groupId>
            <artifactId>spring-data-redis</artifactId>
            <version>2.2.4.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-test</artifactId>
            <version>5.1.6.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.9.8</version>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
```

配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--配置Jedis连接池参数-->
    <bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig">
        <!--最大连接数-->
        <property name="maxTotal" value="30"/>
        <!--最大空闲连接数-->
        <property name="maxIdle" value="20"/>
        <!--最小空闲连接数-->
        <property name="minIdle" value="10"/>
    </bean>

    <!--配置Jedis连接工厂-->
    <bean id="jedisConnectionFactory"
          class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"
          p:hostName="127.0.0.1" p:port="6379" p:poolConfig-ref="jedisPoolConfig"
    />


    <!--配置Redis的模板-->
    <bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate">
        <!--配置jedis的连接工厂,目的是为了获取jedis连接-->
        <property name="connectionFactory" ref="jedisConnectionFactory"/>

        <!--配置非hash类型的序列化器-->
        <!--        <property name="keySerializer">
                    <bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/>
                </property>
                <property name="valueSerializer">
                    <bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/>
                </property>-->
    </bean>

</beans>
```

测试

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext-redis.xml")
public class RedisTest {

    @Autowired
    private RedisTemplate redisTemplate;

    //测试:向redis保存一条数据
    @Test
    public void testSave() {
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new StringRedisSerializer());

        //获取操作简单字符串类型数据的数据句柄
        ValueOperations valueOperations = redisTemplate.opsForValue();
        valueOperations.append("name11", " very good");
    }

    @Test
    public void testSave2() {
        //获取操作简单字符串类型数据的数据句柄
        ValueOperations operations = redisTemplate.opsForValue();
        operations.set("name3", "heima3");
    }
}
```

**SpringData Redis 的序列化器**

通过Redis提供的客户端查看入门案例中存入redis的数据，这时候会发现,存入的数据并不是简单的字符串,而是一些类似于二进制的数据,这是怎么回事呢?

原来,SpringData Redis在保存数据的时候,底层有一个序列化器在工作,它会将要保存的数据(键和值)按照一定的规则进行序列化操作后再进行存储。spring-data-redis提供如下几种序列化器:

- StringRedisSerializer: 简单的字符串序列化
- GenericToStringSerializer: 可以将任何对象泛化为字符串并序列化
- Jackson2JsonRedisSerializer: 序列化对象为json字符串
- GenericJackson2JsonRedisSerializer: 功能同上,但是更容易反序列化
- OxmSerializer: 序列化对象为xml字符串
- JdkSerializationRedisSerializer: 序列化对象为二进制数据

RedisTemplate默认使用的是JdkSerializationRedisSerializer对数据进行序列化。

```xml
    <!--配置Redis的模板-->
    <bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate">
        <!--配置jedis的连接工厂,目的是为了获取jedis连接-->
        <property name="connectionFactory" ref="jedisConnectionFactory"/>

        <!--配置非hash类型的序列化器-->
        <!--        <property name="keySerializer">
                    <bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/>
                </property>
                <property name="valueSerializer">
                    <bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/>
                </property>-->
    </bean>
```

##### 运行原理分析

我们从入门案例中已经知道SpringData Redis操作Redis服务器只要是通过RestTemplate实现的,那么RestTemplate底层到底是如何操作redis的呢,下面我们通过源码追踪的形式看一看。

1. 首先看配置文件中关于RestTemplate的bean的配置,可以看到在RedisTemplate的bean声明中注入了一个JedisConnectionFactory实例,顾名思义,这个连接工厂是用来获取Jedis连接的,那么通过这种方式RedisTemplate就可以拿到操作Redis服务器的句柄了。

   ![1Di9je.png](https://s2.ax1x.com/2020/02/04/1Di9je.png)

2. 使用debug运行入门案例,观察创建好的RestTemplate实例,可以看到里面主要有序列化器和redis的连接信息,基于这些,我们就可以对redis进行操作了

   ![1DiPnH.png](https://s2.ax1x.com/2020/02/04/1DiPnH.png)

3. 跟踪进入set方法,我们可以看到set方法中使用了一个connection来进行操作,这个connection的类型是JedisConnetion,而这个connection肯定是通过配置文件配置的JedisConnectionFactory产生的,也就是底层开始调用jedis的api了。

   ![1Di3En.png](https://s2.ax1x.com/2020/02/04/1Di3En.png)

4. 继续之宗set方法,可以看到底层已经获取到了jedis的实例,再调用set方法已经在调jedis的set了

   ![1DiG40.png](https://s2.ax1x.com/2020/02/04/1DiG40.png)

5. 再追踪一步,就会发现,底层最终调用的是jedis的原生API,setCommand方法,这个方法就是jedis提供的对redis的各种操作命令了。

   ![1DiNgU.png](https://s2.ax1x.com/2020/02/04/1DiNgU.png)

SpringData提供redisTemplate就是在原生的Jedis或者其他操作redis的技术上做的一层封装,它屏蔽掉了这些原生技术的实现细节,统一了调用接口,使得我们的操作更加简单明了。

##### 常见操作

在Redis中有五种常见类型,SpringData Redis对每一种数据类型都提供了一个xxxOperations的API,他们
分别是:

- ValueOperations : 用来操作字符串类型数据
- HashOperations: 用来操作hash类型数据
- ListOperations: 用来操作list类型数据

- SetOperations: 用来操作set类型数据
- ZSetOperations: 用来操作zset类型数

#### Repository和Template的选用

经过前面的章节,我们学习了SpringData家族中jpa和redis的使用,在感受到SpringData技术使用方便的同时,也隐隐约约感觉有点问题,那就是jpa和redis的使用思路好像不是很一致。

我们使用SpringDataJpa的时候,采用了继承SpringData提供的一个接口的形式,即 `public interface ArticleDao extends JpaRepository<Article,Integer>,JpaSpecificationExecutor<Article>` ,但是使用SpingData Redis的时候,却是使用了在实现类中注入一个 redisTemplate 的方式,那么这两种方式到底有什么关系,用哪个更好呢?

其实这两种方式都可以完成我们对持久层的操作,但是对比两种方式的使用,就会发现:

- 第一种方式,直接继承xxxRepository接口,可以不必自己去写实现类,而轻松实现简单的增删改查、分页、排序操作,但是对于非常复杂的查询,用起来就比较的费力了;
- 第二种方式,直接使用xxxTemplate,就需要自己写实现类,但是这样增删改查可以自己控制,对于复杂查询来说,用起来更加得心应手。

所以,两种方式在企业开发中都可能用到,甚至有的项目开发中会同时使用两种方式:对于简单的操作,直接继承Repository接口,对于复杂操作,使用Template完成。所以我们用的时候也要根据实际场景进行灵活选用。

#### SpringData ElasticSearch

Elasticsearch是一个实时的分布式搜索和分析引擎。它底层封装了Lucene框架,可以提供分布式多用户的全文搜索服务。

Spring Data ElasticSearch是SpringData技术对ElasticSearch原生API封装之后的产物,它通过对原生API的封装,使得程序员可以简单的对ElasticSearch进行各种操作。

##### ElasticSearch 基础知识回顾

**核心概念**

1. 索引 index
   一个索引就是一个拥有几分相似特征的文档的集合。索引就类似于关系型数据库中的库的概念。
2. 类型 type
   一个类型是索引中的一个逻辑上的分类/分区。类型就类似于关系型数据库中的数据表的概念。
3. 映射 mapping
   映射是对类型中的字段的限制。映射就类似于关系型数据库中的数据表结构的概念。
4. 文档 document
   一个文档是一个可被索引的基础信息单元。文档就类似于关系型数据库中的行的概念。

```
ElasticSearch跟关系型数据库中概念的对比:
Relational DB -> Databases -> Tables -> Rows -> Columns
Elasticsearch -> Indices -> Types -> Documents -> Fields
```

![1DFRJ0.png](https://s2.ax1x.com/2020/02/04/1DFRJ0.png)

##### 入门案例

1. 依赖

   ```xml
           <!--elasticsearch, 需要跟你的es版本相同-->
           <dependency>
               <groupId>org.elasticsearch</groupId>
               <artifactId>elasticsearch</artifactId>
               <version>5.6.12</version>
           </dependency>
           <dependency>
               <groupId>org.elasticsearch.client</groupId>
               <artifactId>transport</artifactId>
               <version>5.6.12</version>
           </dependency>
   
           <!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-elasticsearch -->
           <dependency>
               <groupId>org.springframework.data</groupId>
               <artifactId>spring-data-elasticsearch</artifactId>
               <version>3.2.4.RELEASE</version>
           </dependency>
   
           <!--单元测试-->
           <dependency>
               <groupId>junit</groupId>
               <artifactId>junit</artifactId>
               <version>4.12</version>
               <scope>test</scope>
           </dependency>
           <dependency>
               <groupId>org.springframework</groupId>
               <artifactId>spring-test</artifactId>
               <version>5.1.6.RELEASE</version>
               <scope>test</scope>
           </dependency>
   ```

2. 配置文件

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:elasticsearch="http://www.springframework.org/schema/data/elasticsearch"
          xsi:schemaLocation="http://www.springframework.org/schema/data/elasticsearch
           http://www.springframework.org/schema/data/elasticsearch/spring-elasticsearch.xsd
           http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd">
   
       <!-- 扫描dao包 -->
       <elasticsearch:repositories base-package="com.hyp.learn.es.dao"/>
   
   
       <!-- 配置Client -->
       <elasticsearch:transport-client id="client" cluster-nodes="127.0.0.1:9200"/>
   
   
       <!-- 配置搜索模板 -->
       <bean id="elasticsearchTemplate"
             class="org.springframework.data.elasticsearch.core.ElasticsearchTemplate">
           <constructor-arg name="client" ref="client"/>
       </bean>
   
   </beans>
   ```

3. 实体类

   ```java
   //indexName指定索引名称   type  指定类型名称
   @Document(indexName = "heima-sd", type = "article")
   public class Article {
   
       @Id
       @Field(index = false, type = FieldType.Integer)
       private Integer id;
   
       /**
        * index：是否设置分词  默认是true
        * analyzer：存储时使用的分词器
        * searchAnalyze：搜索时使用的分词器
        * store：是否存储 默认是false
        * type: 数据类型 默认值是FieldType.Auto
        */
       @Field(analyzer = "ik_smart", searchAnalyzer = "ik_smart", store = true, type = FieldType.Text)
       private String title;
   
       @Field(analyzer = "ik_smart", searchAnalyzer = "ik_smart", store = true, type = FieldType.Text)
       private String context;
   
       @Field(store = true, type = FieldType.Integer)
       private Integer hits;
   
       public Integer getHits() {
           return hits;
       }
   
       public void setHits(Integer hits) {
           this.hits = hits;
       }
   
       public Integer getId() {
           return id;
       }
   
       public void setId(Integer id) {
           this.id = id;
       }
   
       public String getTitle() {
           return title;
       }
   
       public void setTitle(String title) {
           this.title = title;
       }
   
       public String getContext() {
           return context;
       }
   
       public void setContext(String context) {
           this.context = context;
       }
   
       @Override
       public String toString() {
           return "Article{" +
                   "id=" + id +
                   ", title='" + title + '\'' +
                   ", context='" + context + '\'' +
                   ", hits=" + hits +
                   '}';
       }
   }
   
   ```

4. dao接口

   ```java
   @Repository
   //自定义的接口需要继承ElasticsearchRepository<实体类型,主键类型>  基本的crud 分页
   public interface ArticleDao extends ElasticsearchRepository<Article, Integer> {
   
       //根据标题查询
       List<Article> findByTitle(String title);
   
       //根据标题或内容查询
       List<Article> findByTitleOrContext(String title, String context);
   
       //根据标题或内容查询(含分页)
       List<Article> findByTitleOrContext(String title, String context, Pageable pageable);
   
   
   }
   ```

5. 测试类

   ```java
   @RunWith(SpringJUnit4ClassRunner.class)
   @ContextConfiguration("classpath:applicationContext-es.xml")
   public class AppTest 
   {
       @Autowired
       private ElasticsearchTemplate template;
   
       @Autowired
       private ArticleDao articleDao;
   
       //通过SpringData ES技术向ElasticSearch数据库存储一条数据
       @Test
       public void testSave() {
           //创建索引
           template.createIndex(Article.class);
   
           //创建映射
           template.putMapping(Article.class);
   
           //创建文档
           Article article = new Article();
           article.setId(1);
           article.setTitle("sd-平心程序员");
           article.setContext("sd-平心程序员很棒");
   
           //保存文档
           articleDao.save(article);
       }
   
       //修改
       @Test
       public void testUpdate() {
   
           //判断数据库中是否有你指定的id的文档,如果没有,就进行保存,如果有,就进行更新
           Article article = new Article();
           article.setId(1);
           article.setTitle("sd-平心程序员1");
           article.setContext("sd-平心程序员很棒1");
   
           articleDao.save(article);
       }
   
       //删除
       @Test
       public void testDelete() {
           //根据主键删除
           articleDao.deleteById(1);
       }
   
       //重新构建数据
       @Test
       public void makeData() {
           //创建索引
           template.createIndex(Article.class);
   
           //创建映射
           template.putMapping(Article.class);
   
           for (int i = 1; i <= 10; i++) {
               //创建文档
               Article article = new Article();
               article.setId(i);
               article.setTitle("sd-平心程序员" + i);
               article.setContext("sd-平心程序员很棒" + i);
               article.setHits(100 + i);
               //保存文档
               articleDao.save(article);
           }
       }
   
       //查询所有
       @Test
       public void testFindAll() {
           Iterable<Article> all = articleDao.findAll();
           for (Article article : all) {
               System.out.println(article);
           }
       }
   
       //主键查询
       @Test
       public void testFindById() {
           Optional<Article> opt = articleDao.findById(1);
           System.out.println(opt.get());
       }
   
       //分页查询
       @Test
       public void testFindAllWithPage() {
           //设置分页条件
           Pageable pageable = PageRequest.of(1, 3);//page代表的页码,从0开始
   
           Page<Article> page = articleDao.findAll(pageable);
   
           for (Article article : page.getContent()) {
               System.out.println(article);
           }
       }
   
       //排序查询
       @Test
       public void testFindAllWithSort() {
           //设置排序条件
           Sort sort = Sort.by(Sort.Order.desc("hits"));
   
           Iterable<Article> all = articleDao.findAll(sort);
           for (Article article : all) {
               System.out.println(article);
           }
       }
   
       //分页+排序查询
       @Test
       public void testFindAllWithPageAndSort() {
           //设置排序条件
           Sort sort = Sort.by(Sort.Order.desc("hits"));
   
           //设置分页条件
           Pageable pageable = PageRequest.of(1, 3, sort);//page代表的页码,从0开始
   
           Page<Article> page = articleDao.findAll(pageable);
   
           for (Article article : page.getContent()) {
               System.out.println(article);
           }
       }
   
       //根据标题查询
       @Test
       public void testFindByTitle() {
           List<Article> articles = articleDao.findByTitle("员");
           for (Article article : articles) {
               System.out.println(article);
           }
       }
   
   
       //根据标题查询
       @Test
       public void testFindByTitleOrContext() {
           List<Article> articles = articleDao.findByTitleOrContext("程序员", "程序员");
           for (Article article : articles) {
               System.out.println(article);
           }
       }
   
       //根据标题查询
       @Test
       public void testFindByTitleOrContextWithPage() {
   
           //设置排序条件
           Sort sort = Sort.by(Sort.Order.desc("hits"));
   
           //设置分页条件
           Pageable pageable = PageRequest.of(1, 3, sort);//page代表的页码,从0开始
   
           List<Article> articles = articleDao.findByTitleOrContext("程序员", "程序员", pageable);
           for (Article article : articles) {
               System.out.println(article);
           }
       }
   }
   ```

#### SpringData MongoDB

MongoDB 是一个跨平台的,面向文档的数据库,是非关系数据库当中功能最丰富,最像关系数据库的产品。它支持的数据结构非常松散,是类似 JSON 的一种格式,因此可以存储比较复杂的数据类型。

MongoDB主要由文档(document)、集合(collection)、数据库(database)三部分组成

- 文档( document)就相当于关系数据库中的一行记录
- 多个文档组成一个集合( collection),相当于关系数据库的表
- 多个集合组织在一起,就是数据库( database),一个 MongoDB 实例支持多个数据库

![1siGCt.png](https://s2.ax1x.com/2020/02/05/1siGCt.png)

SpringData MongoDB是SpringData技术封装了mongodb-driver技术之后的产物,它可以用更加简单的方式操作MongoDB。

##### 示例

1. 依赖

   ```xml
           <!--spring-data-mongodb-->
           <dependency>
               <groupId>org.springframework.data</groupId>
               <artifactId>spring-data-mongodb</artifactId>
               <version>2.2.3.RELEASE</version>
           </dependency>
   
           <!--测试-->
           <dependency>
               <groupId>junit</groupId>
               <artifactId>junit</artifactId>
               <version>4.12</version>
               <scope>test</scope>
           </dependency>
           <dependency>
               <groupId>org.springframework</groupId>
               <artifactId>spring-test</artifactId>
               <version>5.1.6.RELEASE</version>
               <scope>test</scope>
           </dependency>
   ```

2. 配置文件

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:mongo="http://www.springframework.org/schema/data/mongo"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
           http://www.springframework.org/schema/data/mongo
           http://www.springframework.org/schema/data/mongo/spring-mongo.xsd">
   
       <!--包扫描-->
       <mongo:repositories base-package="com.hyp.learn.mongo"/>
   
   
       <!-- spring连接mongodb数据库的配置 -->
       <!--
           host="127.0.0.1" 指定mongodb服务所在主机地址
           port="27017"  指定mongodb服务所在主机端口号
           dbname="pingxin"  数据名称
       -->
       <mongo:mongo-client host="127.0.0.1" port="27017" id="mongo">
           <mongo:client-options write-concern="SAFE"/>
       </mongo:mongo-client>
       <mongo:db-factory id="mongoDbFactory" dbname="pingxin" mongo-ref="mongo"/>
   
   
       <!--mongoTemplate-->
       <bean id="mongoTemplate" class="org.springframework.data.mongodb.core.MongoTemplate">
           <constructor-arg name="mongoDbFactory" ref="mongoDbFactory"/>
       </bean>
   </beans>
   ```

3. 实体类

   ```java
   
   
   /**
    * @author hyp
    * Project name is spring-data-learn
    * Include in com.hyp.learn.domain
    * hyp create at 20-2-4
    **/
   //使用@Document建立的是实体类和collection的关系
   @Document("article")
   public class Article implements Serializable {
   
       @Id//用来标识主键
       private Integer id;
   
       //使用@Field建立实体类中属性跟collection中字段的映射关系,如果省略,代表两个名称一致
       //@Field
       private String name;
       private String content;
       private Integer hits;
   
       public Integer getId() {
           return id;
       }
   
       public void setId(Integer id) {
           this.id = id;
       }
   
       public String getName() {
           return name;
       }
   
       public void setName(String name) {
           this.name = name;
       }
   
       public String getContent() {
           return content;
       }
   
       public void setContent(String content) {
           this.content = content;
       }
   
       public Integer getHits() {
           return hits;
       }
   
       public void setHits(Integer hits) {
           this.hits = hits;
       }
   
       @Override
       public String toString() {
           return "Article{" +
                   "id=" + id +
                   ", name='" + name + '\'' +
                   ", content='" + content + '\'' +
                   ", hits=" + hits +
                   '}';
       }
   }
   ```

4. dao接口

   ```java
   @Repository
   //自定义的接口需要继承ElasticsearchRepository<实体类型,主键类型>  基本的crud 分页
   public interface ArticleDao extends MongoRepository<Article, Integer> {
   
       //根据标题查询
       List<Article> findByNameLike(String name);
   
       //根据点击量查询
       List<Article> findByHitsGreaterThan(Integer hits);
   
   
   }
   ```

5. 测试

   ```java
   
   @RunWith(SpringJUnit4ClassRunner.class)
   @ContextConfiguration("classpath:applicationContext.xml")
   public class AppTest {
       @Autowired
       private ArticleDao articleDao;
   
   
       //保存
       @Test
       public void testSave() {
           Article article = new Article();
           article.setId(1);
           article.setName("平心");
           article.setContent("平心很低调");
           article.setHits(100);
   
           articleDao.save(article);
       }
   
   
       //修改
       @Test
       public void testUpdate() {
           Article article = new Article();
           article.setId(1);
           article.setName("平心2");
           article.setContent("平心很低调2");
           article.setHits(200);
   
           articleDao.save(article);
       }
   
       //修改
       @Test
       public void testDelete() {
           articleDao.deleteById(1);
       }
   
   
       //做数据
       @Test
       public void makeData() {
           for (int i = 1; i <= 10; i++) {
               Article article = new Article();
               article.setId(i);
               article.setName("平心" + i);
               article.setContent("平心很低调" + i);
               article.setHits(100 + i);
   
               articleDao.save(article);
           }
       }
   
   
       //查询所有
       @Test
       public void testFindAll() {
           List<Article> articles = articleDao.findAll();
           for (Article article : articles) {
               System.out.println(article);
           }
       }
   
       //主键查询
       @Test
       public void testFindById() {
           Optional<Article> opt = articleDao.findById(1);
           System.out.println(opt.get());
       }
   
       //分页和排序
       @Test
       public void testFindAllWithPageAndSort() {
   
           //设置排序条件
           Sort sort = Sort.by(Sort.Order.desc("hits"));
   
           //设置分页条件
           Pageable pageable = PageRequest.of(1, 3, sort);
   
           Page<Article> page = articleDao.findAll(pageable);
           for (Article article : page.getContent()) {
               System.out.println(article);
           }
       }
   
   
       //根据标题查询
       @Test
       public void testFindByName() {
           List<Article> articles = articleDao.findByNameLike("平心1");
           for (Article article : articles) {
               System.out.println(article);
           }
       }
   
       //根据标题查询
       @Test
       public void testFindByHitsGreaterThan() {
           List<Article> articles = articleDao.findByHitsGreaterThan(105);
           for (Article article : articles) {
               System.out.println(article);
           }
       }
   
   }
   
   ```

#### 综合案例

通过一个【文章】案例来综合使用SpringData技术,案例中将涉及到jpa、redis、es、mongo的使用,可以很好的将前面章节所学知识点加以练习巩固。

**涉及技术分析**

案例以常见网站中的文章管理和查询为背景,涉及到文章内容、最新文章列表、文章评论、文章检索等功能,下面具体分析:

- 文章内容分为文章基础和文章详情两部分,分别存储在 mysql的文章表和文章详情表中
- 最新文章列表展示的是热点数据,访问量比较大,采用 redis存储
- 文章评论数据量大,数据价值较低,存放在 mongodb中
- 全文检索使用 ES实现,本次直接向ES中插入测试数据测试,后期可以考虑使用logstash从数据库同步

![1sFsdH.png](https://s2.ax1x.com/2020/02/05/1sFsdH.png)

**数据后台管理**

![1sFbYn.png](https://s2.ax1x.com/2020/02/05/1sFbYn.png)

**数据查询功能**

![1sFOS0.png](https://s2.ax1x.com/2020/02/05/1sFOS0.png)

代码参考：<https://github.com/hanyunpeng0521/spring-data-learn/tree/master/07-case>

### 参考

1. http://blog.csdn.net/pdw2009/article/details/51115044
2. http://blog.csdn.net/w_x_z_/article/details/53174308
3. [Java Persistence/What is JPA?](https://en.wikibooks.org/wiki/Java_Persistence/What_is_JPA%3F)
4. [Spring Data JPA - Reference Documentation](http://docs.spring.io/spring-data/jpa/docs/2.0.0.M1/reference/html/)
5. [Querydsl Reference Guide](http://www.querydsl.com/static/querydsl/latest/reference/html_single/)
6. [Spring Boot JPA - 基本使用 ](https://lufficc.com/blog/spring-boot-jpa-basic)
7. [Spring Data JPA - Reference Documentation](http://docs.spring.io/spring-data/jpa/docs/current/reference/html/)
8. [Spring Data JPA——参考文档 中文版](https://www.gitbook.com/book/ityouknow/spring-data-jpa-reference-documentation/details)